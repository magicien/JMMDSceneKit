module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 18);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 116);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

//import CGPoint from '../CoreGraphics/CGPoint'
//import CGRect from '../CoreGraphics/CGRect'

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ClassList2 = __webpack_require__(37);

var _ClassList3 = _interopRequireDefault(_ClassList2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*global Buffer*/

/**
 * The root class of most Objective-C class hierarchies, from which subclasses inherit a basic interface to the runtime system and the ability to behave as Objective-C objects.
 * @access public
 * @see https://developer.apple.com/documentation/objectivec/nsobject
 */
var NSObject = function () {
  _createClass(NSObject, null, [{
    key: 'initialize',


    // Initializing a Class

    /**
     * Initializes the class before it receives its first message.
     * @access public
     * @returns {void}
     * @desc The runtime sends initialize() to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.The runtime sends the initialize() message to classes in a thread-safe manner. That is, initialize() is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until initialize() completes.The superclass implementation may be called multiple times if subclasses do not implement initialize()—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:+ (void)initialize {
    if (self == [ClassName self]) {
      // ... do the initialization ...
    }
    }
    Because initialize() is called in a blocking manner, it’s important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes in their initialize() methods is liable to lead to deadlocks. Therefore, you should not rely on initialize() for complex initialization, and should instead limit it to straightforward, class local initialization.Special Considerationsinitialize() is invoked only once per class. If you want to perform independent initialization for the class and for categories of the class, you should implement load() methods.+ (void)initialize {
    if (self == [ClassName self]) {
      // ... do the initialization ...
    }
    }
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1418639-initialize
     */
    value: function initialize() {}

    /**
     * Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.
     * @access public
     * @returns {void}
     * @desc The load() message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.The order of initialization is as follows:All initializers in any framework you link to.All +load methods in your image.All C++ static initializers and C/C++ __attribute__(constructor) functions in your image.All initializers in frameworks that link to you.In addition:A class’s +load method is called after all of its superclasses’ +load methods.A category +load method is called after the class’s own +load method.In a custom implementation of load() you can therefore safely message other unrelated classes from the same image, but any load() methods implemented by those classes may not have run yet.ImportantCustom implementations of the load method for Swift classes bridged to Objective-C are not called automatically.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418815-load
     */

  }, {
    key: 'load',
    value: function load() {}

    // Creating, Copying, and Deallocating Objects

    /**
     * Implemented by subclasses to initialize a new object (the receiver) immediately after memory for it has been allocated.
     * @access public
     * @constructor
     * @desc An init() message is coupled with an alloc (or allocWithZone:) message in the same line of code:SomeClass *object = [[SomeClass alloc] init];
    An object isn’t ready to be used until it has been initialized.The init() method defined in the NSObject class does no initialization; it simply returns self. In terms of nullability, callers can assume that the NSObject implemetation of init() does not return nil.In a custom implementation of this method, you must invoke super’s Initialization then initialize and return the new object. If the new object can’t be initialized, the method should return nil. For example, a hypothetical BuiltInCamera class might return nil from its init method if run on a device that has no camera.- (instancetype)init {
      self = [super init];
      if (self) {
          // Initialize self
      }
      return self;
    }
    In some cases, a custom implementation of the init() method might return a substitute object. You must therefore always use the object returned by init(), and not the one returned by alloc or allocWithZone:, in subsequent code.SomeClass *object = [[SomeClass alloc] init];
    - (instancetype)init {
      self = [super init];
      if (self) {
          // Initialize self
      }
      return self;
    }
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1418641-init
     */

  }, {
    key: '_propTypes',

    /**
     * @access private
     * @type {Object}
     */
    get: function get() {
      return {};
    }
  }]);

  function NSObject() {
    _classCallCheck(this, NSObject);

    // Discardable Content Proxy Support

    this._autoContentAccessingProxy = null;

    // Archiving

    this._classForArchiver = null;
    this._classForCoder = null;
    this._classForKeyedArchiver = null;

    // Working with Class Descriptions

    this._attributeKeys = null;
    this._classDescription = null;
    this._toManyRelationshipKeys = null;
    this._toOneRelationshipKeys = null;

    // Scripting

    /**
     * An NSString-keyed dictionary of the receiver's scriptable properties.
     * @type {?Map<string, Object>}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1417254-scriptingproperties
     */
    this.scriptingProperties = null;

    this._classCode = 0;

    // Instance Properties

    /**
     * Returns a pointer that identifies information about all of the observers that are registered with the observed object.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1414009-observationinfo
     */
    this.observationInfo = null;

    /**
     * The activation point for the accessibility element, in screen coordinates.
     * @type {CGPoint}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615179-accessibilityactivationpoint
     */
    this.accessibilityActivationPoint = null;

    /**
     * An array of custom actions to display along with the built-in actions.
     * @type {?UIAccessibilityCustomAction[]}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615150-accessibilitycustomactions
     */
    this.accessibilityCustomActions = null;

    /**
     * 
     * @type {?UIAccessibilityCustomRotor[]}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1649788-accessibilitycustomrotors
     */
    this.accessibilityCustomRotors = null;

    /**
     * An array of the accessibility elements in the container. 
     * @type {?Object[]}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615147-accessibilityelements
     */
    this.accessibilityElements = null;

    /**
     * A Boolean value indicating whether the accessibility elements contained within this accessibility element are hidden.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615080-accessibilityelementshidden
     */
    this.accessibilityElementsHidden = false;

    /**
     * The frame of the accessibility element, in screen coordinates.
     * @type {CGRect}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615111-accessibilityframe
     */
    this.accessibilityFrame = null;

    /**
     * 
     * @type {?Object[]}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1627578-accessibilityheaderelements
     */
    this.accessibilityHeaderElements = null;

    /**
     * A brief description of the result of performing an action on the accessibility element, in a localized string.
     * @type {?string}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615093-accessibilityhint
     */
    this.accessibilityHint = null;

    /**
     * A succinct label that identifies the accessibility element, in a localized string.
     * @type {?string}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615181-accessibilitylabel
     */
    this.accessibilityLabel = null;

    /**
     * The language in which to speak the accessibility element's label, value, and hint.
     * @type {?string}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615192-accessibilitylanguage
     */
    this.accessibilityLanguage = null;

    /**
     * The navigation style to apply to the object and its elements.
     * @type {UIAccessibilityNavigationStyle}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615200-accessibilitynavigationstyle
     */
    this.accessibilityNavigationStyle = null;

    /**
     * The path of the element, in screen coordinates.
     * @type {?UIBezierPath}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615159-accessibilitypath
     */
    this.accessibilityPath = null;

    /**
     * The combination of accessibility traits that best characterize the accessibility element. 
     * @type {UIAccessibilityTraits}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615202-accessibilitytraits
     */
    this.accessibilityTraits = null;

    /**
     * The value of the accessibility element, in a localized string.
     * @type {?string}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615117-accessibilityvalue
     */
    this.accessibilityValue = null;

    /**
     * A Boolean value indicating whether VoiceOver should ignore the elements within views that are siblings of the receiver.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615089-accessibilityviewismodal
     */
    this.accessibilityViewIsModal = false;

    /**
     * A Boolean value indicating whether the receiver is an accessibility element that an assistive application can access.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615141-isaccessibilityelement
     */
    this.isAccessibilityElement = false;

    /**
     * A Boolean value indicating whether VoiceOver should group together the elements that are children of the receiver, regardless of their positions on the screen.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615143-shouldgroupaccessibilitychildren
     */
    this.shouldGroupAccessibilityChildren = false;

    this._hashValue = 0;
    this._accessibilityFocusedUIElement = null;
    this._accessibilityNotifiesWhenDestroyed = false;
    this._exposedBindings = null;
    this._objectForWebScript = null;
    this._objectSpecifier = null;
    this._webFrame = null;
    this._webPlugInContainerSelectionColor = null;
    this._isSelectable = false;

    /**
     * @access private
     * @type {boolean}
     */
    this._destroyed = false;
  }

  /**
   * Returns the object returned by copy(with:).
   * @access public
   * @returns {Object} - 
   * @desc This is a convenience method for classes that adopt the NSCopying protocol. An exception is raised if there is no implementation for copy(with:).NSObject does not itself support the NSCopying protocol. Subclasses must support the protocol and implement the copy(with:) method. A subclass version of the copy(with:) method should send the message to super first, to incorporate its implementation, unless the subclass descends directly from NSObject.
   * @see https://developer.apple.com/documentation/objectivec/nsobject/1418807-copy
   */


  _createClass(NSObject, [{
    key: 'copy',
    value: function copy() {
      var obj = new this.constructor();
      // TODO: copy variables
      return obj;
    }

    /**
     * Returns the object returned by mutableCopy(with:) where the zone is nil.
     * @access public
     * @returns {Object} - 
     * @desc This is a convenience method for classes that adopt the NSMutableCopying protocol. An exception is raised if there is no implementation for mutableCopy(with:).
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418978-mutablecopy
     */

  }, {
    key: 'mutableCopy',
    value: function mutableCopy() {
      return null;
    }

    // Identifying Classes

    /**
     * Returns the class object for the receiver’s superclass.
     * @access public
     * @returns {?Object} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418803-superclass
     */

  }, {
    key: 'isInstanceOf',


    /**
     * @access public
     * @param {Object} aClass - A class object.
     * @returns {boolean} -
     */
    value: function isInstanceOf(aClass) {
      return this.constructor.isSubclassOf(aClass);
    }

    // Testing Class Functionality

    /**
     * Returns a Boolean value that indicates whether instances of the receiver are capable of responding to a given selector.
     * @access public
     * @param {!function} aSelector - A Selector.
     * @returns {boolean} - 
     * @desc If aSelector messages are forwarded to other objects, instances of the class are able to receive those messages without error even though this method returns false.To ask the class whether it, rather than its instances, can respond to a particular message, send to the class instead the  NSObject protocol instance method responds(to:).
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418555-instancesrespond
     */

  }, {
    key: 'methodFor',


    // Obtaining Information About Methods

    /**
     * Locates and returns the address of the receiver’s implementation of a method so it can be called as a function.
     * @access public
     * @param {!function} aSelector - A Selector that identifies the method for which to return the implementation address. The selector must be a valid and non-NULL. If in doubt, use the responds(to:) method to check before passing the selector to method(for:).
     * @returns {!function} - 
     * @desc If the receiver is an instance, aSelector should refer to an instance method; if the receiver is a class, it should refer to a class method.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418863-method
     */
    value: function methodFor(aSelector) {
      return null;
    }

    /**
     * Locates and returns the address of the implementation of the instance method identified by a given selector.
     * @access public
     * @param {!function} aSelector - A Selector that identifies the method for which to return the implementation address. The selector must be non-NULL and valid for the receiver. If in doubt, use the responds(to:) method to check before passing the selector to method(for:).
     * @returns {!function} - 
     * @desc An error is generated if instances of the receiver can’t respond to aSelector messages.Use this method to ask the class object for the implementation of instance methods only. To ask the class for the implementation of a class method, send the method(for:) instance method to the class instead.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418713-instancemethod
     */

  }, {
    key: 'performWithAfterDelay',


    // Sending Messages

    /**
     * Invokes a method of the receiver on the current thread using the default mode after a delay.
     * @access public
     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
     * @param {?Object} anArgument - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument. 
     * @param {number} delay - The minimum time before which the message is sent. Specifying a delay of 0 does not necessarily cause the selector to be performed immediately. The selector is still queued on the thread’s run loop and performed as soon as possible.
     * @returns {void}
     * @desc This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode. If you want the message to be dequeued when the run loop is in a mode other than the default mode, use the perform(_:with:afterDelay:inModes:) method instead. If you are not sure whether the current thread is the main thread, you can use the performSelector(onMainThread:with:waitUntilDone:) or performSelector(onMainThread:with:waitUntilDone:modes:) method to guarantee that your selector executes on the main thread. To cancel a queued message, use the cancelPreviousPerformRequests(withTarget:) or cancelPreviousPerformRequests(withTarget:selector:object:) method. Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1416176-perform
     */
    value: function performWithAfterDelay(aSelector, anArgument, delay) {}

    /**
     * Invokes a method of the receiver on the current thread using the specified modes after a delay.
     * @access public
     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
     * @param {?Object} anArgument - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument. 
     * @param {number} delay - The minimum time before which the message is sent. Specifying a delay of 0 does not necessarily cause the selector to be performed immediately. The selector is still queued on the thread’s run loop and performed as soon as possible.
     * @param {RunLoopMode[]} modes - An array of strings that identify the modes to associate with the timer that performs the selector. This array must contain at least one string. If you specify nil or an empty array for this parameter, this method returns without performing the specified selector. For information about run loop modes, see Run Loops in Threading Programming Guide.
     * @returns {void}
     * @desc This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the modes specified by the modes parameter. When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in one of the specified modes; otherwise, the timer waits until the run loop is in one of those modes. If you want the message to be dequeued when the run loop is in a mode other than the default mode, use the perform(_:with:afterDelay:inModes:) method instead. If you are not sure whether the current thread is the main thread, you can use the performSelector(onMainThread:with:waitUntilDone:) or performSelector(onMainThread:with:waitUntilDone:modes:) method to guarantee that your selector executes on the main thread. To cancel a queued message, use the cancelPreviousPerformRequests(withTarget:) or cancelPreviousPerformRequests(withTarget:selector:object:) method. Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1415652-perform
     */

  }, {
    key: 'performWithAfterDelayInModes',
    value: function performWithAfterDelayInModes(aSelector, anArgument, delay, modes) {}

    /**
     * Invokes a method of the receiver on the main thread using the default mode.
     * @access public
     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
     * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the main thread. Specify true to block this thread; otherwise, specify false to have this method return immediately.If the current thread is also the main thread, and you specify true for this parameter, the message is delivered and processed immediately. 
     * @returns {void}
     * @desc You can use this method to deliver messages to the main thread of your application. The main thread encompasses the application’s main run loop, and is where the NSApplication object receives events. The message in this case is a method of the current object that you want to execute on the thread. This method queues the message on the run loop of the main thread using the common run loop modes—that is, the modes associated with the commonModes constant. As part of its normal run loop processing, the main thread dequeues the message (assuming it is running in one of the common run loop modes) and invokes the desired method. Multiple calls to this method from the same thread cause the corresponding selectors to be queued and performed in the same same order in which the calls were made.You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method.Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1414900-performselector
     */

  }, {
    key: 'performSelectorOnMainThreadWithWaitUntilDone',
    value: function performSelectorOnMainThreadWithWaitUntilDone(aSelector, arg, wait) {}

    /**
     * Invokes a method of the receiver on the main thread using the specified modes.
     * @access public
     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
     * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the main thread. Specify true to block this thread; otherwise, specify false to have this method return immediately.If the current thread is also the main thread, and you pass true, the message is performed immediately, otherwise the perform is queued to run the next time through the run loop.
     * @param {?string[]} array - An array of strings that identifies the modes in which it is permissible to perform the specified selector. This array must contain at least one string. If you specify nil or an empty array for this parameter, this method returns without performing the specified selector. For information about run loop modes, see Run Loops in Threading Programming Guide.
     * @returns {void}
     * @desc You can use this method to deliver messages to the main thread of your application. The main thread encompasses the application’s mai run loop, and is where the NSApplication object receives events. The message in this case is a method of the current object that you want to execute on the thread. This method queues the message on the run loop of the main thread using the run loop modes specified in the array parameter. As part of its normal run loop processing, the main thread dequeues the message (assuming it is running in one of the specified modes) and invokes the desired method. Multiple calls to this method from the same thread cause the corresponding selectors to be queued and performed in the same same order in which the calls were made, assuming the associated run loop modes for each selector are the same. If you specify different modes for each selector, any selectors whose associated mode does not match the current run loop mode are skipped until the run loop subsequently executes in that mode.You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method.Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411637-performselector
     */

  }, {
    key: 'performSelectorOnMainThreadWithWaitUntilDoneModes',
    value: function performSelectorOnMainThreadWithWaitUntilDoneModes(aSelector, arg, wait, array) {}

    /**
     * Invokes a method of the receiver on the specified thread using the default mode.
     * @access public
     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
     * @param {Thread} thr - 
     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
     * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the specified thread. Specify true to block this thread; otherwise, specify false to have this method return immediately.If the current thread and target thread are the same, and you specify true for this parameter, the selector is performed immediately on the current thread. If you specify false, this method queues the message on the thread’s run loop and returns, just like it does for other threads. The current thread must then dequeue and process the message when it has an opportunity to do so.
     * @returns {void}
     * @desc You can use this method to deliver messages to other threads in your application. The message in this case is a method of the current object that you want to execute on the target thread. This method queues the message on the run loop of the target thread using the default run loop modes—that is, the modes associated with the commonModes constant. As part of its normal run loop processing, the target thread dequeues the message (assuming it is running in one of the default run loop modes) and invokes the desired method.You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method.Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1414476-perform
     */

  }, {
    key: 'performOnWithWaitUntilDone',
    value: function performOnWithWaitUntilDone(aSelector, thr, arg, wait) {}

    /**
     * Invokes a method of the receiver on the specified thread using the specified modes.
     * @access public
     * @param {function} aSelector - A Selector that identifies the method to invoke. It should not have a significant return value and should take a single argument of type id, or no arguments.
     * @param {Thread} thr - 
     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
     * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the specified thread. Specify true to block this thread; otherwise, specify false to have this method return immediately. If the current thread and target thread are the same, and you specify true for this parameter, the selector is performed immediately. If you specify false, this method queues the message and returns immediately, regardless of whether the threads are the same or different.
     * @param {?string[]} array - An array of strings that identifies the modes in which it is permissible to perform the specified selector. This array must contain at least one string. If you specify nil or an empty array for this parameter, this method returns without performing the specified selector. For information about run loop modes, see Run Loops in Threading Programming Guide.
     * @returns {void}
     * @desc You can use this method to deliver messages to other threads in your application. The message in this case is a method of the current object that you want to execute on the target thread. This method queues the message on the run loop of the target thread using the run loop modes specified in the array parameter. As part of its normal run loop processing, the target thread dequeues the message (assuming it is running in one of the specified modes) and invokes the desired method. You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method instead. Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1417922-perform
     */

  }, {
    key: 'performOnWithWaitUntilDoneModes',
    value: function performOnWithWaitUntilDoneModes(aSelector, thr, arg, wait, array) {}

    /**
     * Invokes a method of the receiver on a new background thread.
     * @access public
     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
     * @returns {void}
     * @desc This method creates a new thread in your application, putting your application into multithreaded mode if it was not already. The method represented by aSelector must set up the thread environment just as you would for any other new thread in your program. For more information about how to configure and run threads, see Threading Programming Guide. 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1412390-performselector
     */

  }, {
    key: 'performSelectorInBackgroundWith',
    value: function performSelectorInBackgroundWith(aSelector, arg) {}

    /**
     * Cancels perform requests previously registered with the perform(_:with:afterDelay:) instance method.
     * @access public
     * @param {Object} aTarget - The target for requests previously registered with the perform(_:with:afterDelay:) instance method.
     * @returns {void}
     * @desc All perform requests having the same target aTarget are canceled. This method removes perform requests only in the current run loop, not all run loops.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1417611-cancelpreviousperformrequests
     */

  }, {
    key: 'forwardingTargetFor',


    // Forwarding Messages

    /**
     * Returns the object to which unrecognized messages should first be directed.
     * @access public
     * @param {!function} aSelector - A Selector for a method that the receiver does not implement.
     * @returns {?Object} - 
     * @desc If an object implements (or inherits) this method, and returns a non-nil (and non-self) result, that returned object is used as the new receiver object and the message dispatch resumes to that new object. (Obviously if you return self from this method, the code would just fall into an infinite loop.)If you implement this method in a non-root class, if your class has nothing to return for the given selector then you should return the result of invoking super’s implementation. This method gives an object a chance to redirect an unknown message sent to it before the much more expensive forwardInvocation: machinery takes over. This is useful when you simply want to redirect messages to another object and can be an order of magnitude faster than regular forwarding. It is not useful where the goal of the forwarding is to capture the NSInvocation, or manipulate the arguments or return value during the forwarding.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418855-forwardingtarget
     */
    value: function forwardingTargetFor(aSelector) {
      return null;
    }

    // Dynamically Resolving Methods

    /**
     * Dynamically provides an implementation for a given selector for a class method.
     * @access public
     * @param {!function} sel - 
     * @returns {boolean} - 
     * @desc This method allows you to dynamically provide an implementation for a given selector. See resolveInstanceMethod(_:) for further discussion.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418889-resolveclassmethod
     */

  }, {
    key: 'doesNotRecognizeSelector',


    // Error Handling

    /**
     * Handles messages the receiver doesn’t recognize.
     * @access public
     * @param {!function} aSelector - A Selector that identifies a method not implemented or recognized by the receiver.
     * @returns {void}
     * @desc The runtime system invokes this method whenever an object receives an aSelector message it can’t respond to or forward. This method, in turn, raises an NSInvalidArgumentException, and generates an error message. Any doesNotRecognizeSelector(_:) messages are generally sent only by the runtime system. However, they can be used in program code to prevent a method from being inherited. For example, an NSObject subclass might renounce the copy() or init() method by re-implementing it to include a doesNotRecognizeSelector(_:) message as follows:- (id)copy
    {
      [self doesNotRecognizeSelector:_cmd];
    }
    The _cmd variable is a hidden argument passed to every method that is the current selector; in this example, it identifies the selector for the copy method. This code prevents instances of the subclass from responding to copy messages or superclasses from forwarding copy messages—although responds(to:) will still report that the receiver has access to a copy method.If you override this method, you must call super or raise an invalidArgumentException exception at the end of your implementation. In other words, this method must not return normally; it must always result in an exception being thrown. - (id)copy
    {
      [self doesNotRecognizeSelector:_cmd];
    }
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1418637-doesnotrecognizeselector
     */
    value: function doesNotRecognizeSelector(aSelector) {}

    // Archiving

    /**
     * Overridden by subclasses to substitute another object in place of the object that was decoded and subsequently received this message.
     * @access public
     * @param {NSCoder} aDecoder - The decoder used to decode the receiver.
     * @returns {?Object} - 
     * @desc You can use this method to eliminate redundant objects created by the coder. For example, if after decoding an object you discover that an equivalent object already exists, you can return the existing object. If a replacement is returned, your overriding method is responsible for releasing the receiver. This method is invoked by NSCoder. NSObject’s implementation simply returns self.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1417074-awakeafter
     */

  }, {
    key: 'awakeAfterUsing',
    value: function awakeAfterUsing(aDecoder) {
      return null;
    }

    /**
     * Overridden to return the names of classes that can be used to decode objects if their class is unavailable.
     * @access public
     * @returns {string[]} - 
     * @desc NSKeyedArchiver calls this method and stores the result inside the archive. If the actual class of an object doesn’t exist at the time of unarchiving, NSKeyedUnarchiver goes through the stored list of classes and uses the first one that does exists as a substitute class for decoding the object. The default implementation of this method returns nil.You can use this method if you introduce a new class into your application to provide some backwards compatibility in case the archive will be read on a system that does not have that class. Sometimes there may be another class which may work nearly as well as a substitute for the new class, and the archive keys and archived state for the new class can be carefully chosen (or compatibility written out) so that the object can be unarchived as the substitute class if necessary.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411048-classfallbacksforkeyedarchiver
     */

  }, {
    key: 'replacementObjectFor',


    /**
     * Overridden by subclasses to substitute another object for itself during encoding.
     * @access public
     * @param {NSCoder} aCoder - The coder encoding the receiver.
     * @returns {?Object} - 
     * @desc An object might encode itself into an archive, but encode a proxy for itself if it’s being encoded for distribution. This method is invoked by NSCoder. NSObject’s implementation returns self.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1416843-replacementobject
     */
    value: function replacementObjectFor(aCoder) {
      return null;
    }

    /**
     * Sets the receiver's version number.
     * @access public
     * @param {number} aVersion - The version number for the receiver.
     * @returns {void}
     * @desc The version number is helpful when instances of the class are to be archived and reused later. The default version is 0.Special ConsiderationsThe version number applies to NSArchiver/NSUnarchiver, but not to NSKeyedArchiver/NSKeyedUnarchiver.  A keyed archiver does not encode class version numbers.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1416538-setversion
     */

  }, {
    key: 'inverseForRelationshipKey',


    // Working with Class Descriptions

    /**
     * For a given key that defines the name of the relationship from the receiver’s class to another class, returns the name of the relationship from the other class to the receiver’s class.
     * @access public
     * @param {string} relationshipKey - The name of the relationship from the receiver’s class to another class.
     * @returns {?string} - 
     * @desc NSObject’s implementation of inverseForRelationshipKey: simply invokes [[self classDescription] inverseForRelationshipKey:relationshipKey].  To make use of the default implementation, you must therefore implement and register a suitable class description—see NSClassDescription.For example, suppose an Employee class has a relationship named department to a Department class, and that Department has a relationship called employees to Employee. The statement:employee inverseForRelationshipKey:@"department"];
    returns the string employees.employee inverseForRelationshipKey:@"department"];
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1411046-inverse
     */
    value: function inverseForRelationshipKey(relationshipKey) {
      return null;
    }
    /**
     * An array of NSString objects containing the names of immutable values that instances of the receiver's class contain.
     * @type {string[]}
     * @desc NSObject’s implementation of attributeKeys simply calls [[self classDescription] attributeKeys]. To make use of the default implementation, you must therefore implement and register a suitable class description—see NSClassDescription. 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1415656-attributekeys
     */

  }, {
    key: 'copyScriptingValueForKeyWithProperties',


    // Scripting

    /**
     * Creates and returns one or more scripting objects to be inserted into the specified relationship by copying the passed-in value and setting the properties in the copied object or objects.
     * @access public
     * @param {Object} value - An object or objects to be copied. The type must match the type of the property identified by key. (See also the Discussion section.)For example, if the property is a to-many relationship, value will always be an array of objects to be copied, and this method must therefore return an array of objects.
     * @param {string} key - A key that identifies the relationship into which to insert the copied object or objects.
     * @param {Map<string, Object>} properties - The properties to be set in the copied object or objects.  Derived from the "with properties" parameter of a duplicate command. (See also the Discussion section.)
     * @returns {?Object} - 
     * @desc You can override the copyScriptingValue method to take more control when your application is sent a duplicate command. This method is invoked on the prospective container of the copied object or objects. The properties are derived from the with properties parameter of the duplicate command. The returned objects or objects are then inserted into the container using key-value coding. When this method is invoked by Cocoa, neither the value nor the properties will have yet been coerced using the NSScriptKeyValueCoding method coerceValue(_:forKey:). For sdef-declared scriptability, however, the types of the passed-in objects reliably match the relevant sdef declarations.The default implementation of this method copies scripting objects by sending copyWithZone: to the object or objects specified by value. You override this method for situations where this is not sufficient, such as in Core Data applications, in which new objects must be initialized with [NSManagedObject initWithEntity:insertIntoManagedObjectContext:].
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1410291-copyscriptingvalue
     */
    value: function copyScriptingValueForKeyWithProperties(value, key, properties) {
      return null;
    }

    /**
     * Creates and returns an instance of a scriptable class, setting its contents and properties, for insertion into the relationship identified by the key.
     * @access public
     * @param {Object} objectClass - 
     * @param {string} key - A key that identifies the relationship into which the new class object will be inserted.
     * @param {?Object} contentsValue - Specifies the contents of the object to be created. This may be nil. (See also the Discussion section.)
     * @param {Map<string, Object>} properties - The properties to be set in the new object. (See also the Discussion section.)
     * @returns {?Object} - 
     * @desc You can override the newScriptingObjectOfClass method to take more control when your application is sent a make command. This method is invoked on the prospective container of the new object. The contentsValue and properties are derived from the with contents and with properties parameters of the make command. The returned objects or objects are then inserted into the container using key-value coding.When this method is invoked by Cocoa, neither the contents value nor the properties will have yet been coerced using the NSScriptKeyValueCoding method coerceValue(_:forKey:). For sdef-declared scriptability, however, the types of the passed-in objects reliably match the relevant sdef declarations.The default implementation of this method creates new scripting objects by sending alloc to a class and init to the resulting object. You override this method for situations where this is not sufficient, such as in Core Data applications, in which new objects must be initialized with [NSManagedObject initWithEntity:insertIntoManagedObjectContext:].
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418458-newscriptingobject
     */

  }, {
    key: 'newScriptingObjectOfForValueForKeyWithContentsValue',
    value: function newScriptingObjectOfForValueForKeyWithContentsValue(objectClass, key, contentsValue, properties) {
      return null;
    }

    /**
     * Given an object specifier, returns the specified object or objects in the receiving container.
     * @access public
     * @param {NSScriptObjectSpecifier} objectSpecifier - An object specifier to be evaluated.
     * @returns {?Object} - 
     * @desc You can override this method to customize the evaluation of object specifiers without requiring that the scripting container make up indexes for contained objects that don't naturally have indexes (as can be the case if you implement indicesOfObjects(byEvaluatingObjectSpecifier:) instead).Your override of this method doesn't need to also invoke any of the NSScriptCommand error signaling methods, though it can, to record very specific information. The NSUnknownKeySpecifierError and NSInvalidIndexSpecifierError numbers are special, in that Cocoa may continue evaluating an outer specifier if they're encountered, for the convenience of scripters.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1409268-scriptingvalue
     */

  }, {
    key: 'scriptingValueFor',
    value: function scriptingValueFor(objectSpecifier) {
      return null;
    }
    /**
     * The receiver's Apple event type code, as stored in the NSScriptClassDescription object for the object’s class.
     * @type {number}
     * @desc This property is used by Cocoa’s scripting support classes.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1413991-classcode
     */

  }, {
    key: 'finalize',


    // Deprecated Methods

    /**
     * The garbage collector invokes this method on the receiver before disposing of the memory it uses.
     * @deprecated
     * @access public
     * @returns {void}
     * @desc The garbage collector invokes this method on the receiver before disposing of the memory it uses. When garbage collection is enabled, this method is invoked instead of dealloc.You can override this method to relinquish resources the receiver has obtained, as shown in the following example:- (void)finalize {
      if (log_file != NULL) {
          fclose(log_file);
          log_file = NULL;
      }
      [super finalize];
    }
    Typically, however, you are encouraged to relinquish resources prior to finalization if at all possible. For more details, see Implementing a finalize Method.Special ConsiderationsIt is an error to store self into a new or existing live object (colloquially known as “resurrection”), which implies that this method will be called only once. However, the receiver may be messaged after finalization by other objects also being finalized at this time, so your override should guard against future use of resources that have been reclaimed, as shown by the log_file = NULL statement in the example. The finalize method itself will never be invoked more than once for a given object.Importantfinalize methods must be thread-safe.- (void)finalize {
      if (log_file != NULL) {
          fclose(log_file);
          log_file = NULL;
      }
      [super finalize];
    }
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1418513-finalize
     */
    value: function finalize() {}

    // Instance Properties
    /**
     * 
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418615-hashvalue
     */

  }, {
    key: 'addObserverForKeyPath',


    // Instance Methods

    /**
     * Registers the observer object to receive KVO notifications for the key path relative to the object receiving this message.
     * @access public
     * @param {NSObject} observer - The object to register for KVO notifications. The observer must implement the key-value observing method observeValue(forKeyPath:of:change:context:).
     * @param {string} keyPath - The key path, relative to the object receiving this message, of the property to observe. This value must not be nil.
     * @param {NSKeyValueObservingOptions} [options = []] - A combination of the NSKeyValueObservingOptions values that specifies what is included in observation notifications. For possible values, see NSKeyValueObservingOptions.
     * @param {?Object} context - Arbitrary data that is passed to observer in observeValue(forKeyPath:of:change:context:).
     * @returns {void}
     * @desc Neither the object receiving this message, nor observer, are retained. An object that calls this method must also eventually call either the removeObserver(_:forKeyPath:) or removeObserver(_:forKeyPath:context:) method to unregister the observer when participating in KVO.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1412787-addobserver
     */
    value: function addObserverForKeyPath(observer, keyPath) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var context = arguments[3];
    }

    /**
     * Implemented to attempt a recovery from an error noted in an application-modal dialog.
     * @access public
     * @param {Error} error - An NSError object that describes the error, including error recovery options.
     * @param {number} recoveryOptionIndex - The index of the user selected recovery option in error's localized recovery array.
     * @returns {boolean} - 
     * @desc Invoked when an error alert is been presented to the user in an application-modal dialog, and the user has selected an error recovery option specified by error.  
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1416402-attemptrecovery
     */

  }, {
    key: 'attemptRecoveryFromErrorOptionIndex',
    value: function attemptRecoveryFromErrorOptionIndex(error, recoveryOptionIndex) {
      return false;
    }

    /**
     * Returns a dictionary containing the property values identified by each of the keys in a given array.
     * @access public
     * @param {string[]} keys - An array containing NSString objects that identify properties of the receiver.
     * @returns {Map<string, Object>} - 
     * @desc The default implementation invokes value(forKey:) for each key in keys and substitutes NSNull values in the dictionary for returned nil values.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411319-dictionarywithvalues
     */

  }, {
    key: 'dictionaryWithValuesForKeys',
    value: function dictionaryWithValuesForKeys(keys) {
      return null;
    }

    /**
     * Informs the observed object that the specified change has occurred on the indexes for a specified ordered to-many relationship.
     * @access public
     * @param {NSKeyValueChange} changeKind - 
     * @param {Set} indexes - The indexes of the to-many relationship that were affected by the change.
     * @param {string} key - The name of a property that is an ordered to-many relationship.
     * @returns {void}
     * @desc Use this method when implementing key-value-observing compliance manually.Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super. Calls to this method are always paired with a matching call to willChange(_:valuesAt:forKey:).
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1415349-didchange
     */

  }, {
    key: 'didChangeValuesAtForKey',
    value: function didChangeValuesAtForKey(changeKind, indexes, key) {}

    /**
     * Informs the observed object that the value of a given property has changed.
     * @access public
     * @param {string} key - The name of the property that changed.
     * @returns {void}
     * @desc Use this method when implementing key-value observer compliance manually to inform the observed object that the value at key has just changed. Calls to this method are always paired with a matching call to willChangeValue(forKey:).Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411809-didchangevalue
     */

  }, {
    key: 'didChangeValueForKey',
    value: function didChangeValueForKey(key) {}

    /**
     * Informs the observed object that the specified change was made to a specified unordered to-many relationship.
     * @access public
     * @param {string} key - The name of a property that is an unordered to-many relationship
     * @param {NSKeyValueSetMutationKind} mutationKind - The type of change that was made.
     * @param {Set<AnyHashable>} objects - The objects that were involved in the change (see NSKeyValueSetMutationKind).
     * @returns {void}
     * @desc Use this method when implementing key-value observer compliance manually. Calls to this method are always paired with a matching call to willChangeValue(forKey:withSetMutation:using:).Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1410539-didchangevalue
     */

  }, {
    key: 'didChangeValueForKeyWithSetMutationUsing',
    value: function didChangeValueForKeyWithSetMutationUsing(key, mutationKind, objects) {}

    /**
     * An NSFileManager object sends this message to its handler for each error it encounters when copying, moving, removing, or linking files or directories. 
     * @deprecated
     * @access public
     * @param {FileManager} fm - 
     * @param {Map<AnyHashable, Object>} errorInfo - A dictionary that contains two or three pieces of information (all NSString objects) related to the error:KeyValue@"Path"The path related to the error (usually the source path)@"Error"A description of the error@"ToPath" The destination path (not all errors)
     * @returns {boolean} - 
     * @desc An NSFileManager object, manager, sends this message for each error it encounters when copying, moving, removing, or linking files or directories. The return value is passed back to the invoker of copyPath:toPath:handler:, movePath:toPath:handler:, removeFileAtPath:handler:, or linkPath:toPath:handler:. If an error occurs and your handler has not implemented this method, the invoking method automatically returns false.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1557005-filemanager
     */

  }, {
    key: 'fileManagerShouldProceedAfterError',
    value: function fileManagerShouldProceedAfterError(fm, errorInfo) {
      return false;
    }

    /**
     * An NSFileManager object sends this message to a handler immediately before attempting to move, copy, rename, or delete, or before attempting to link to a given path.
     * @deprecated
     * @access public
     * @param {FileManager} fm - 
     * @param {string} path - The path or a file or directory that manager is about to attempt to move, copy, rename, delete, or link to.
     * @returns {void}
     * @desc You can implement this method in your handler to monitor file operations.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1557002-filemanager
     */

  }, {
    key: 'fileManagerWillProcessPath',
    value: function fileManagerWillProcessPath(fm, path) {}

    /**
     * Returns a mutable array proxy that provides read-write access to an ordered to-many relationship specified by a given key.
     * @access public
     * @param {string} key - The name of an ordered to-many relationship.
     * @returns {Array} - 
     * @desc Objects added to the mutable array become related to the receiver, and objects removed from the mutable array become unrelated. The default implementation recognizes the same simple accessor methods and array accessor methods as value(forKey:), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that value(forKey:) would return. The search pattern that mutableArrayValueForKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1416339-mutablearrayvalue
     */

  }, {
    key: 'mutableArrayValueForKey',
    value: function mutableArrayValueForKey(key) {
      return null;
    }

    /**
     * Returns a mutable array that provides read-write access to the ordered to-many relationship specified by a given key path.
     * @access public
     * @param {string} keyPath - A key path, relative to the receiver, to an ordered to-many relationship.
     * @returns {Array} - 
     * @desc See mutableArrayValue(forKey:) for additional details.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1414937-mutablearrayvalue
     */

  }, {
    key: 'mutableArrayValueForKeyPath',
    value: function mutableArrayValueForKeyPath(keyPath) {
      return null;
    }

    /**
     * Returns a mutable ordered set that provides read-write access to the uniquing ordered to-many relationship specified by a given key.
     * @access public
     * @param {string} key - The name of a uniquing ordered to-many relationship.
     * @returns {Set} - 
     * @desc Objects added to the mutable set proxy become related to the receiver, and objects removed from the mutable set become unrelated. The default implementation recognizes the same simple accessor methods and set accessor methods as value(forKey:), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that value(forKey:) would return. The search pattern that mutableOrderedSetValueForKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1415479-mutableorderedsetvalue
     */

  }, {
    key: 'mutableOrderedSetValueForKey',
    value: function mutableOrderedSetValueForKey(key) {
      return null;
    }

    /**
     * Returns a mutable ordered set that provides read-write access to the uniquing ordered to-many relationship specified by a given key path.
     * @access public
     * @param {string} keyPath - A key path, relative to the receiver, to a uniquing ordered to-many relationship represented by a set.
     * @returns {Set} - 
     * @desc See mutableOrderedSetValue(forKey:) for additional details.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1407188-mutableorderedsetvalue
     */

  }, {
    key: 'mutableOrderedSetValueForKeyPath',
    value: function mutableOrderedSetValueForKeyPath(keyPath) {
      return null;
    }

    /**
     * Returns a mutable set proxy that provides read-write access to the unordered to-many relationship specified by a given key.
     * @access public
     * @param {string} key - The name of an unordered to-many relationship.
     * @returns {Set} - 
     * @desc Objects added to the mutable set proxy become related to the receiver, and objects removed from the mutable set become unrelated. The default implementation recognizes the same simple accessor methods and set accessor methods as value(forKey:), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that value(forKey:) would return. The search pattern that mutableSetValueForKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1415105-mutablesetvalue
     */

  }, {
    key: 'mutableSetValueForKey',
    value: function mutableSetValueForKey(key) {
      return null;
    }

    /**
     * Returns a mutable set that provides read-write access to the unordered to-many relationship specified by a given key path.
     * @access public
     * @param {string} keyPath - A key path, relative to the receiver, to an unordered to-many relationship.
     * @returns {Set} - 
     * @desc See mutableSetValue(forKey:) for additional details.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1408115-mutablesetvalue
     */

  }, {
    key: 'mutableSetValueForKeyPath',
    value: function mutableSetValueForKeyPath(keyPath) {
      return null;
    }

    /**
     * Informs the observing object when the value at the specified key path relative to the observed object has changed.
     * @access public
     * @param {?string} keyPath - The key path, relative to object, to the value that has changed.
     * @param {?Object} object - The source object of the key path keyPath. 
     * @param {?Map<NSKeyValueChangeKey, Object>} change - A dictionary that describes the changes that have been made to the value of the property at the key path keyPath relative to object. Entries are described in Change Dictionary Keys.
     * @param {?Object} context - The value that was provided when the observer was registered to receive key-value observation notifications.
     * @returns {void}
     * @desc For an object to begin sending change notification messages for the value at keyPath, you send it an addObserver(_:forKeyPath:options:context:) message, naming the observing object that should receive the messages. When you are done observing, and in particular before the observing object is deallocated, you send the observed object a removeObserver(_:forKeyPath:) or removeObserver(_:forKeyPath:context:) message to unregister the observer, and stop sending change notification messages.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1416553-observevalue
     */

  }, {
    key: 'observeValueForKeyPathOf',
    value: function observeValueForKeyPathOf(keyPath, object, change, context) {}

    /**
     * Stops the observer object from receiving change notifications for the property specified by the key path relative to the object receiving this message.
     * @access public
     * @param {NSObject} observer - The object to remove as an observer.
     * @param {string} keyPath - A key-path, relative to the object receiving this message, for which observer is registered to receive KVO change notifications.
     * @returns {void}
     * @desc It is an error to call removeObserver(_:forKeyPath:) for an object that has not previously been registered as an observer.Be sure to invoke this method (or removeObserver(_:forKeyPath:context:)) before any object specified in addObserver(_:forKeyPath:options:context:) is deallocated.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1408054-removeobserver
     */

  }, {
    key: 'removeObserverForKeyPath',
    value: function removeObserverForKeyPath(observer, keyPath) {}

    /**
     * Invoked by setValue(_:forKey:) when it’s given a nil value for a scalar value (such as an int or float).
     * @access public
     * @param {string} key - The name of one of the receiver's properties.
     * @returns {void}
     * @desc Subclasses can override this method to handle the request in some other way, such as by substituting 0 or a sentinel value for nil and invoking setValue(_:forKey:) again or setting the variable directly. The default implementation raises an NSInvalidArgumentException. 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1415174-setnilvalueforkey
     */

  }, {
    key: 'setNilValueForKey',
    value: function setNilValueForKey(key) {}

    /**
     * Sets the property of the receiver specified by a given key to a given value.
     * @access public
     * @param {?Object} value - The value for the property identified by key.
     * @param {string} key - The name of one of the receiver's properties.
     * @returns {void}
     * @desc If key identifies a to-one relationship, relate the object specified by value to the receiver, unrelating the previously related object if there was one. Given a collection object and a key that identifies a to-many relationship, relate the objects contained in the collection to the receiver, unrelating previously related objects if there were any.  The search pattern that setValue:forKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.In a reference-counted environment, if the instance variable is accessed directly, value is retained.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1415969-setvalue
     */

  }, {
    key: 'setValueForKey',
    value: function setValueForKey(value, key) {
      if (typeof this[key] === 'undefined') {
        this.setValueForUndefinedKey(value, key);
      } else {
        this[key] = value;
      }
    }

    /**
     * Sets the value for the property identified by a given key path to a given value.
     * @access public
     * @param {?Object} value - The value for the property identified by keyPath.
     * @param {string} keyPath - A key path of the form relationship.property (with one or more relationships): for example “department.name” or “department.manager.lastName.” 
     * @returns {void}
     * @desc The default implementation of this method gets the destination object for each relationship using value(forKey:), and sends the final object a setValue(_:forKey:) message.Special ConsiderationsWhen using this method, and the destination object does not implement an accessor for the value, the default behavior is for that object to retain value rather than copy or assign value.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418139-setvalue
     */

  }, {
    key: 'setValueForKeyPath',
    value: function setValueForKeyPath(value, keyPath) {
      //console.log('NSObject.setValueForKeyPath: ' + keyPath)
      if (typeof keyPath !== 'string') {
        throw new Error('setValueForKeyPath: keyPath should be string');
      }
      var paths = keyPath.split('.');
      var key = paths.shift();
      if (paths.length === 0) {
        this.setValueForKey(value, key);
        return;
      }
      var target = this.valueForKey(key);
      if (target === null) {
        console.error('setValueForKeyPath: key ' + key + ' is null.');
        return;
      }
      //console.log(`NSObject.setValueForKeyPath: ${keyPath}: key ${key} target ${target}`)
      target.setValueForKeyPath(value, paths.join('.'));
    }

    /**
     * Invoked by setValue(_:forKey:) when it finds no property for a given key.
     * @access public
     * @param {?Object} value - The value for the key identified by key.
     * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
     * @returns {void}
     * @desc Subclasses can override this method to handle the request in some other way. The default implementation raises an NSUndefinedKeyException.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1413490-setvalue
     */

  }, {
    key: 'setValueForUndefinedKey',
    value: function setValueForUndefinedKey(value, key) {
      throw new Error('setValueForKey: undefined key: ' + key);
    }

    /**
     * Sets properties of the receiver with values from a given dictionary, using its keys to identify the properties.
     * @access public
     * @param {Map<string, Object>} keyedValues - A dictionary whose keys identify properties in the receiver. The values of the properties in the receiver are set to the corresponding values in the dictionary.
     * @returns {void}
     * @desc The default implementation invokes setValue(_:forKey:) for each key-value pair, substituting nil for NSNull values in keyedValues.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1417515-setvaluesforkeys
     */

  }, {
    key: 'setValuesForKeys',
    value: function setValuesForKeys(keyedValues) {}

    /**
     * Returns a Boolean value that indicates whether the value specified by a given pointer is valid for the property identified by a given key.
     * @access public
     * @param {AutoreleasingUnsafeMutablePointer<AnyObject?>} ioValue - A pointer to a new value for the property identified by key. This method may modify or replace the value in order to make it valid.
     * @param {string} inKey - 
     * @returns {void}
     * @throws {Error}
     * @desc The default implementation of this method searches the class of the receiver for a validation method whose name matches the pattern validate<Key>:error:. If such a method is found it is invoked and the result is returned. If no such method is found, true is returned.The sender of the message is never given responsibility for releasing ioValue or outError. See Adding Validation for more information.Handling Errors in Swift:
    In Swift, this method returns Void and is marked with the throws keyword to indicate that it throws an error in cases of failure.
    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1416754-validatevalue
     */

  }, {
    key: 'validateValueForKey',
    value: function validateValueForKey(ioValue, inKey) {}

    /**
     * Returns a Boolean value that indicates whether the value specified by a given pointer is valid for a given key path relative to the receiver. 
     * @access public
     * @param {AutoreleasingUnsafeMutablePointer<AnyObject?>} ioValue - A pointer to a new value for the property identified by keyPath. This method may modify or replace the value in order to make it valid.
     * @param {string} inKeyPath - 
     * @returns {void}
     * @throws {Error}
     * @desc The default implementation gets the destination object for each relationship using value(forKey:) and returns the result of a validateValue(_:forKey:) message to the final object.Handling Errors in Swift:
    In Swift, this method returns Void and is marked with the throws keyword to indicate that it throws an error in cases of failure.
    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1416245-validatevalue
     */

  }, {
    key: 'validateValueForKeyPath',
    value: function validateValueForKeyPath(ioValue, inKeyPath) {}

    /**
     * Returns the value for the property identified by a given key.
     * @access public
     * @param {string} key - The name of one of the receiver's properties.
     * @returns {?Object} - 
     * @desc The search pattern that valueForKey: uses to find the correct value to return is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1412591-value
     */

  }, {
    key: 'valueForKey',
    value: function valueForKey(key) {
      if (typeof key !== 'string') {
        throw new Error('error: valueForKey(key): key should be string');
      }
      if (typeof this[key] === 'undefined') {
        //console.log('valueForUndefinedKey func: ' + this.valueForUndefinedKey)
        return this.valueForUndefinedKey(key);
      }
      return this[key];
    }

    /**
     * Returns the value for the derived property identified by a given key path.
     * @access public
     * @param {string} keyPath - A key path of the form relationship.property (with one or more relationships); for example “department.name” or “department.manager.lastName”.
     * @returns {?Object} - 
     * @desc The default implementation gets the destination object for each relationship using value(forKey:) and returns the result of a value(forKey:) message to the final object.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1416468-value
     */

  }, {
    key: 'valueForKeyPath',
    value: function valueForKeyPath(keyPath) {
      if (typeof keyPath !== 'string') {
        throw new Error('valueForKeyPath(keyPath): keyPath should be string');
      }
      var paths = keyPath.split('.');
      var key = paths.shift();
      var value = this.valueForKey(key);
      if (paths.length === 0) {
        return value;
      }
      if (value === null) {
        return null;
      }
      return value.valueForKeyPath(paths.join('.'));
    }

    /**
     * Invoked by value(forKey:) when it finds no property corresponding to a given key.
     * @access public
     * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
     * @returns {?Object} - 
     * @desc Subclasses can override this method to return an alternate value for undefined keys. The default implementation raises an NSUndefinedKeyException.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1413457-value
     */

  }, {
    key: 'valueForUndefinedKey',
    value: function valueForUndefinedKey(key) {
      return undefined;
      //throw new Error(`valueForKey: undefined key: ${key}`)
    }

    /**
     * Informs the observed object that the specified change is about to be executed at given indexes for a specified ordered to-many relationship.
     * @access public
     * @param {NSKeyValueChange} changeKind - 
     * @param {Set} indexes - The indexes of the to-many relationship that will be affected by the change.
     * @param {string} key - The name of a property that is an ordered to-many relationship.
     * @returns {void}
     * @desc Use this method when implementing key-value-observing compliance manually.ImportantAfter the values have been changed, a corresponding didChange(_:valuesAt:forKey:) must be invoked with the same parameters.Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1412271-willchange
     */

  }, {
    key: 'willChangeValuesAtForKey',
    value: function willChangeValuesAtForKey(changeKind, indexes, key) {}

    /**
     * Informs the observed object that the value of a given property is about to change.
     * @access public
     * @param {string} key - The name of the property that will change.
     * @returns {void}
     * @desc Use this method when implementing key-value observer compliance manually to inform the observed object that the value at key is about to change.The change type of this method is NSKeyValueChangeSetting.ImportantAfter the values have been changed, a corresponding didChangeValue(forKey:) must be invoked with the same parameter. Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1416222-willchangevalue
     */

  }, {
    key: 'willChangeValueForKey',
    value: function willChangeValueForKey(key) {}

    /**
     * Informs the observed object that the specified change is about to be made to a specified unordered to-many relationship.
     * @access public
     * @param {string} key - The name of a property that is an unordered to-many relationship
     * @param {NSKeyValueSetMutationKind} mutationKind - The type of change that will be made.
     * @param {Set<AnyHashable>} objects - The objects that are involved in the change (see NSKeyValueSetMutationKind).
     * @returns {void}
     * @desc Use this method when implementing key-value observer compliance manually.ImportantAfter the values have been changed, a corresponding didChangeValue(forKey:withSetMutation:using:) must be invoked with the same parameters.Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1412323-willchangevalue
     */

  }, {
    key: 'willChangeValueForKeyWithSetMutationUsing',
    value: function willChangeValueForKeyWithSetMutationUsing(key, mutationKind, objects) {}

    /**
     * 
     * @access public
     * @param {!QLPreviewPanel} panel - 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1504653-acceptspreviewpanelcontrol
     */

  }, {
    key: 'acceptsPreviewPanelControl',
    value: function acceptsPreviewPanelControl(panel) {
      return false;
    }

    /**
     * Returns a localized description of the specified action.
     * @deprecated
     * @access public
     * @param {string} action - The action attribute.
     * @returns {?string} - 
     * @desc User interface classes must implement this method to return descriptions for all actions returned from accessibilityActionNames(). A button, for example, might return the string "press” for the NSAccessibilityPressAction action. Subclasses should invoke the superclass's implementation, if it exists, to obtain the descriptions of any inherited actions.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1533500-accessibilityactiondescription
     */

  }, {
    key: 'accessibilityActionDescription',
    value: function accessibilityActionDescription(action) {
      return null;
    }

    /**
     * Returns an array of action names supported by the accessibility element.
     * @deprecated
     * @access public
     * @returns {Object[]} - 
     * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, and append additional action names or remove unsupported actions. See Constants for some common action names.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1527905-accessibilityactionnames
     */

  }, {
    key: 'accessibilityActionNames',
    value: function accessibilityActionNames() {
      return null;
    }

    /**
     * Returns the count of the specified accessibility array attribute.
     * @access public
     * @param {string} attribute - The accessibility array attribute.
     * @returns {number} - 
     * @desc If attribute is not an array, an exception is raised.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1527138-accessibilityarrayattributecount
     */

  }, {
    key: 'accessibilityArrayAttributeCount',
    value: function accessibilityArrayAttributeCount(attribute) {
      return 0;
    }

    /**
     * Returns a subarray of values of an accessibility array attribute.
     * @access public
     * @param {string} attribute - The accessibility array attribute.
     * @param {number} index - The starting index.
     * @param {number} maxCount - The maximum desired number of items requested.
     * @returns {Object[]} - 
     * @desc Note that this method does not take a range. The maximum count is the maximum desired number of items requested by an accessibility client. This number may be beyond the bounds of your array.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1535909-accessibilityarrayattributevalue
     */

  }, {
    key: 'accessibilityArrayAttributeValues',
    value: function accessibilityArrayAttributeValues(attribute, index, maxCount) {
      return null;
    }

    /**
     * Returns an array of attribute names supported by the receiver.
     * @deprecated
     * @access public
     * @returns {Object[]} - 
     * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, and append additional attributes or remove unsupported attributes. See Constants for lists of attribute names.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1525181-accessibilityattributenames
     */

  }, {
    key: 'accessibilityAttributeNames',
    value: function accessibilityAttributeNames() {
      return null;
    }

    /**
     * Returns the value of the specified attribute in the receiver.
     * @deprecated
     * @access public
     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
     * @returns {?Object} - 
     * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, if attribute is not implemented in the subclass.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1532465-accessibilityattributevalue
     */

  }, {
    key: 'accessibilityAttributeValue',
    value: function accessibilityAttributeValue(attribute) {
      return null;
    }

    /**
     * Returns the value of the receiver's parameterized attribute corresponding to the specified attribute name and parameter.
     * @deprecated
     * @access public
     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
     * @param {?Object} parameter - The parameter.
     * @returns {?Object} - 
     * @desc If you implement this method, also implement accessibilityParameterizedAttributeNames().
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1524809-accessibilityattributevalue
     */

  }, {
    key: 'accessibilityAttributeValueForParameter',
    value: function accessibilityAttributeValueForParameter(attribute, parameter) {
      return null;
    }

    /**
     * Returns the deepest descendant of the accessibility hierarchy that contains the specified point.
     * @access public
     * @param {CGPoint} point - The point being hit-tested, in lower-left relative screen coordinates.
     * @returns {?Object} - 
     * @desc You can assume that the specified point has already been determined to lie within the accessibility element's frame. Override this method to do deeper hit-testing by identifying which child element, if any, contains the point. NSMatrix, for example, identifies which of its cells contains the point and propagates the hit-test to it. If the specified point is not contained within one of the accessibility element's children, either return self or, if available, invoke the superclass's implementation. The default NSView and NSCell implementations test whether the accessibility element is an ignored element and, if it is, return the receiver's first unignored parent; otherwise they return self.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1526136-accessibilityhittest
     */

  }, {
    key: 'accessibilityHitTest',
    value: function accessibilityHitTest(point) {
      return null;
    }

    /**
     * Returns the index of the specified accessibility child in the parent.
     * @access public
     * @param {Object} child - The accessibility child of an object.
     * @returns {number} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1533558-accessibilityindex
     */

  }, {
    key: 'accessibilityIndexOfChild',
    value: function accessibilityIndexOfChild(child) {
      return 0;
    }

    /**
     * Returns a Boolean value that indicates whether the value for the specified attribute in the receiver can be set.
     * @deprecated
     * @access public
     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
     * @returns {boolean} - 
     * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, if attribute is not implemented in the subclass.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1529207-accessibilityisattributesettable
     */

  }, {
    key: 'accessibilityIsAttributeSettable',
    value: function accessibilityIsAttributeSettable(attribute) {
      return false;
    }

    /**
     * Returns a Boolean value indicating whether the receiver should be ignored in the parent-child accessibility hierarchy.
     * @deprecated
     * @access public
     * @returns {boolean} - 
     * @desc When asking for an object's children, do not include ignored children; instead, replace the ignored children with their own unignored children. The same applies when asking for an object's parent: skip the ignored parent and treat the first unignored ancestor as the real parent.  Likewise, when a hit-test or focus test is satisfied by an ignored element, use the element's first unignored ancestor (or descendant in certain cases, such as single-celled controls) instead.Ignored elements let you provide a simplified version of the view and object ownership hierarchies. Accessibility clients can bypass intermediate objects, letting users access the real user interface objects more quickly. For example, NSControl objects are ignored when they are single-celled; the visible parent-child relationship is between the control's parent (or a higher ancestor if the parent is ignored, too) and the control's cell.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1526439-accessibilityisignored
     */

  }, {
    key: 'accessibilityIsIgnored',
    value: function accessibilityIsIgnored() {
      return false;
    }

    /**
     * Returns a list of parameterized attribute names supported by the receiver.
     * @deprecated
     * @access public
     * @returns {Object[]} - 
     * @desc If you implement this method, also implement accessibilityAttributeValue(_:forParameter:).
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1525455-accessibilityparameterizedattrib
     */

  }, {
    key: 'accessibilityParameterizedAttributeNames',
    value: function accessibilityParameterizedAttributeNames() {
      return null;
    }

    /**
     * Performs the action associated with the specified action.
     * @deprecated
     * @access public
     * @param {string} action - The action to perform.
     * @returns {void}
     * @desc User interface classes must implement this method to handle all the actions returned from accessibilityActionNames(). Subclasses should invoke the superclass's implementation, if it exists, if action is not implemented in the subclass.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1533528-accessibilityperformaction
     */

  }, {
    key: 'accessibilityPerformAction',
    value: function accessibilityPerformAction(action) {}

    /**
     * Overrides the specified attribute in the receiver or adds it if it does not exist, and sets its value to the specified value.
     * @deprecated
     * @access public
     * @param {?Object} value - The attribute value to be set. 
     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
     * @returns {boolean} - 
     * @desc This method is for changing the set of attributes on an instance, as an alternative to subclassing.This method works only on objects whose class already implements the NSAccessibility protocol. If the specified attribute is already supported by the object, the value specified by this method wins.If the specified attribute does not exist, it is created outside the NSAccessibility protocol, so accessibilityAttributeNames still returns the old list, which does not contain the new attribute. Likewise, accessibilityAttributeValue does not return attributes created by the override process nor does it return their overridden values.The values of overridden attributes are not settable by accessibility clients.If you need to undo the effect of using this method, call it again, passing nil for the value.Ensure that you invoke this method on the actual object that represents the user interface element. For example, for NSButton, use the underlying NSButtonCell object. NSButton itself is ignored by accessibility.This method works only on an object representing a single user interface element. So, for example, you cannot use it when a single object represents multiple user interface elements, as with NSSegmentedCell, which has only a single object but provides user interface elements for each segment.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1535843-accessibilitysetoverridevalue
     */

  }, {
    key: 'accessibilitySetOverrideValueForAttribute',
    value: function accessibilitySetOverrideValueForAttribute(value, attribute) {
      return false;
    }

    /**
     * Sets the value of the specified attribute in the receiver to the specified value.
     * @deprecated
     * @access public
     * @param {?Object} value - The attribute value to be set.
     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
     * @returns {void}
     * @desc User interface classes must implement this method if any of its attributes are settable. Subclasses should invoke the superclass's implementation, if it exists, if attribute is not implemented in the subclass.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1528477-accessibilitysetvalue
     */

  }, {
    key: 'accessibilitySetValueForAttribute',
    value: function accessibilitySetValueForAttribute(value, attribute) {}

    /**
     * Sent to the delegate to request the property the action applies to.
     * @access public
     * @returns {!string} - 
     * @desc See Table 1The documentation for property-list constants for the properties for person and group records.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411302-actionproperty
     */

  }, {
    key: 'actionProperty',
    value: function actionProperty() {
      return null;
    }

    /**
     * Sent by Cocoa’s built-in scripting support during execution of get or set script commands to find out if the delegate can handle operations on the specified key-value key.
     * @access public
     * @param {NSApplication} sender - The app object associated with the delegate. 
     * @param {string} key - The key to be handled.
     * @returns {boolean} - 
     * @desc The method should return true if the delegate for the app sender handles the key specified by key, which means it can get or set the scriptable property or element that corresponds to that key. The app implements methods for each of the keys that it handles, where the method name matches the key.For example, a scriptable app that doesn’t use Cocoa’s document-based app architecture can implement this method to supply its own document ordering. Such an app might want to do this because the standard app delegate expects to work with a document-based app. The TextEdit app (whose source is distributed with macOS developer tools) provides the following implementation:return [key isEqualToString:@"orderedDocuments"];
    TextEdit then implements the orderedDocuments method in its controller class to return an ordered list of documents. An app with its own window ordering might add a test for the key orderedWindows so that its delegate can provide its own version of orderedWindows.ImportantCocoa scripting does not invoke this method for script commands other than get or set. For information on working with other commands, see Script Commands in Cocoa Scripting Guide.return [key isEqualToString:@"orderedDocuments"];
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1494285-application
     */

  }, {
    key: 'applicationDelegateHandlesKey',
    value: function applicationDelegateHandlesKey(sender, key) {
      return false;
    }

    /**
     * Sent to the delegate to indicate the authorization object has been created or changed. If you have saved a copy of the authorization object for your own purposes, you should discard it and call authorization for a new authorization object.
     * @access public
     * @param {!SFAuthorizationView} view - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411010-authorizationviewcreatedauthoriz
     */

  }, {
    key: 'authorizationViewCreatedAuthorization',
    value: function authorizationViewCreatedAuthorization(view) {}

    /**
     * Sent to the delegate to indicate the user was authorized and the authorization view was changed to unlocked.
     * @access public
     * @param {!SFAuthorizationView} view - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411002-authorizationviewdidauthorize
     */

  }, {
    key: 'authorizationViewDidAuthorize',
    value: function authorizationViewDidAuthorize(view) {}

    /**
     * Sent to the delegate to indicate the user was deauthorized and the authorization view was changed to locked.
     * @access public
     * @param {!SFAuthorizationView} view - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411017-authorizationviewdiddeauthorize
     */

  }, {
    key: 'authorizationViewDidDeauthorize',
    value: function authorizationViewDidDeauthorize(view) {}

    /**
     * Sent to the delegate to indicate that the view’s visibility has changed.
     * @access public
     * @param {!SFAuthorizationView} view - 
     * @returns {void}
     * @desc This delegate method, if present, is called whenever the isHidden method is called to show or hide the view.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411034-authorizationviewdidhide
     */

  }, {
    key: 'authorizationViewDidHide',
    value: function authorizationViewDidHide(view) {}

    /**
     * Sent to the delegate to indicate that deauthorization is about to occur.
     * @access public
     * @param {!SFAuthorizationView} view - 
     * @returns {void}
     * @desc This method is called after deauthorization has been approved (either you called the deauthorize: method, or the user clicked an open lock icon and the authorizationViewShouldDeauthorize: delegate method did not cancel the operation), and before the user is deauthorized (that is, before the authorizationViewDidDeauthorize: delegate method is called). 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1410992-authorizationviewreleasedauthori
     */

  }, {
    key: 'authorizationViewReleasedAuthorization',
    value: function authorizationViewReleasedAuthorization(view) {}

    /**
     * Sent to the delegate when a user clicks the open lock icon.
     * @access public
     * @param {!SFAuthorizationView} view - 
     * @returns {number} - 
     * @desc  The delegate can react to this before deauthorization happens and avoid it by returning false. This delegate method is not called when you call the deauthorize: method.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411006-authorizationviewshoulddeauthori
     */

  }, {
    key: 'authorizationViewShouldDeauthorize',
    value: function authorizationViewShouldDeauthorize(view) {
      return 0;
    }

    /**
     * Prepares the receiver for service after it has been loaded from an Interface Builder archive, or nib file.
     * @access public
     * @returns {void}
     * @desc The nib-loading infrastructure sends an awakeFromNib message to each object recreated from a nib archive, but only after all the objects in the archive have been loaded and initialized. When an object receives an awakeFromNib message, it is guaranteed to have all its outlet and action connections already established.You must call the super implementation of awakeFromNib to give parent classes the opportunity to perform any additional initialization they require. Although the default implementation of this method does nothing, many UIKit classes provide non-empty implementations. You may call the super implementation at any point during your own awakeFromNib method.NoteDuring Interface Builder’s test mode, this message is also sent to objects instantiated from loaded Interface Builder plug-ins. Because plug-ins link against the framework containing the object definition code, Interface Builder is able to call their awakeFromNib method when present. The same is not true for custom objects that you create for your Xcode projects. Interface Builder knows only about the defined outlets and actions of those objects; it does not have access to the actual code for them.During the instantiation process, each object in the archive is unarchived and then initialized with the method befitting its type. Objects that conform to the NSCoding protocol (including all subclasses of UIView and UIViewController) are initialized using their initWithCoder: method. All objects that do not conform to the NSCoding protocol are initialized using their init method. After all objects have been instantiated and initialized, the nib-loading code reestablishes the outlet and action connections for all of those objects. It then calls the awakeFromNib method of the objects. For more detailed information about the steps followed during the nib-loading process, see Nib Files in Resource Programming Guide.ImportantBecause the order in which objects are instantiated from an archive is not guaranteed, your initialization methods should not send messages to other objects in the hierarchy. Messages to other objects can be sent safely from within an awakeFromNib method. Typically, you implement awakeFromNib for objects that require additional set up that cannot be done at design time. For example, you might use this method to customize the default configuration of any controls to match user preferences or the values in other controls. You might also use it to restore individual controls to some previous state of your application. 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1402907-awakefromnib
     */

  }, {
    key: 'awakeFromNib',
    value: function awakeFromNib() {}

    /**
     * 
     * @access public
     * @param {!QLPreviewPanel} panel - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1504204-beginpreviewpanelcontrol
     */

  }, {
    key: 'beginPreviewPanelControl',
    value: function beginPreviewPanelControl(panel) {}

    /**
     * Establishes a binding between a given property of the receiver and the property of a given object specified by a given key path.
     * @access public
     * @param {string} binding - The key path for a property of the receiver previously exposed using the exposeBinding(_:) method.
     * @param {Object} observable - 
     * @param {string} keyPath - A key path to a property reachable from observableController. The elements in the path must be key-value observing compliant (see Key-Value Observing Programming Guide).
     * @param {?Map<string, Object>} [options = null] - A dictionary containing options for the binding, such as placeholder objects or an NSValueTransformer identifier as described in Constants. This value is optional—pass nil to specify no options.
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458185-bind
     */

  }, {
    key: 'bindToWithKeyPath',
    value: function bindToWithKeyPath(binding, observable, keyPath) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    }

    /**
     * Returns an array of candidates.
     * @access public
     * @param {!Object} sender - The client object requesting the candidates.
     * @returns {!Object[]} - 
     * @desc An input method should look up its currently composed string and return a list of candidate strings that that string might map to.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1385360-candidates
     */

  }, {
    key: 'candidates',
    value: function candidates(sender) {
      return null;
    }

    /**
     * Implements custom help behavior for the modal panel.
     * @access public
     * @param {!SFCertificatePanel} sender - The certificate panel for which to implement custom help.
     * @returns {number} - 
     * @desc You can use this delegate method to implement custom help if you call the setShowsHelp: method to display a help button in the sheet or panel. If you are not implementing custom help, do not implement this method.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1514145-certificatepanelshowhelp
     */

  }, {
    key: 'certificatePanelShowHelp',
    value: function certificatePanelShowHelp(sender) {
      return 0;
    }

    /**
     * Sent to the first responder when the user selects a color in an NSColorPanel object.
     * @access public
     * @param {?Object} sender - The NSColorPanel sending the message.
     * @returns {void}
     * @desc When the user selects a color in an NSColorPanel object, the panel sends a changeColor(_:) action message to the first responder. You can override this method in any responder that needs to respond to a color change. 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1532638-changecolor
     */

  }, {
    key: 'changeColor',
    value: function changeColor(sender) {}

    /**
     * Informs responders of a font change.
     * @access public
     * @param {?Object} sender - The object that sent the message.
     * @returns {void}
     * @desc Generally this change is because the user changed the font either in the selection of a rich text field or in a whole plain text field. Any object that contains a font the user can change must respond to the changeFont(_:) message by sending a convert(_:) message back to sender (an NSFontManager object) for each font in the selection. For more information, see Responding to Font Changes.Be aware that selectedFont at this point may return unpredictable results. The font in this property may not be the last font selected, or there may be multiple fonts selected at the time changeFont(_:) is called. The use of selectedFont from within changeFont(_:) is strongly discouraged.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1462311-changefont
     */

  }, {
    key: 'changeFont',
    value: function changeFont(sender) {}

    /**
     * Implements custom help behavior for the modal panel.
     * @access public
     * @param {!SFChooseIdentityPanel} sender - The choose identity panel for which to implement custom help.
     * @returns {number} - 
     * @desc You can use this delegate method to implement custom help if you call the setShowsHelp: method to display a help button in the sheet or panel. If you are not implementing custom help, do not implement this method. 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1514140-chooseidentitypanelshowhelp
     */

  }, {
    key: 'chooseIdentityPanelShowHelp',
    value: function chooseIdentityPanelShowHelp(sender) {
      return 0;
    }

    /**
     * 
     * @deprecated
     * @access public
     * @param {Object} annotationClass - 
     * @returns {Object} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1436089-class
     */

  }, {
    key: 'classForAnnotationClass',
    value: function classForAnnotationClass(annotationClass) {
      return null;
    }

    /**
     * 
     * @deprecated
     * @access public
     * @returns {Object} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1436049-classforpage
     */

  }, {
    key: 'classForPage',
    value: function classForPage() {
      return null;
    }

    /**
     * Uses type info from the class description and NSScriptCoercionHandler to attempt to convert value for key to the proper type, if necessary.
     * @access public
     * @param {?Object} value - 
     * @param {string} key - 
     * @returns {?Object} - 
     * @desc  The method coerceValueFor<Key>: is used if it exists.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1416527-coercevalue
     */

  }, {
    key: 'coerceValueForKey',
    value: function coerceValueForKey(value, key) {
      return null;
    }

    /**
     * Informs the controller that the composition should be committed.
     * @access public
     * @param {!Object} sender - The client object requesting the input method to commit the composition.
     * @returns {void}
     * @desc If an input method implements this method, it is called when the client wants to end the composition session immediately. A typical response would be to call the insertText method of the client and then clean up any per-session buffers and variables. After receiving this message an input method should consider the given composition session finished.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1385539-commitcomposition
     */

  }, {
    key: 'commitComposition',
    value: function commitComposition(sender) {}

    /**
     * Returns whether the receiver was able to commit any pending edits.
     * @access public
     * @returns {boolean} - 
     * @desc A commit is denied if the receiver fails to apply the changes to the model object, perhaps due to a validation error.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458190-commitediting
     */

  }, {
    key: 'commitEditing',
    value: function commitEditing() {
      return false;
    }

    /**
     * Attempt to commit pending edits, returning an error in the case of failure.
     * @access public
     * @returns {void}
     * @throws {Error}
     * @desc During autosaving, commit editing may fail, due to a pending edit. Rather than interrupt the user with an unexpected alert, this method provides the caller with the option to either present the error or fail silently, leaving the pending edit in place and the user's editing uninterrupted. In your implementation of this method, you should attempt to commit editing, but if there is a failure return false and in error an error object to be presented or ignored as appropriate. Handling Errors in Swift:
    In Swift, this method returns Void and is marked with the throws keyword to indicate that it throws an error in cases of failure.
    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1458181-commiteditingandreturnerror
     */

  }, {
    key: 'commitEditingAndReturnError',
    value: function commitEditingAndReturnError() {}

    /**
     * Attempt to commit any currently edited results of the receiver.
     * @access public
     * @param {?Object} delegate - 
     * @param {?function} didCommitSelector - 
     * @param {?Object} contextInfo - 
     * @returns {void}
     * @desc The receiver must have been registered as the editor of an object using objectDidBeginEditing:, and has not yet been unregistered by a subsequent invocation of objectDidEndEditing:. When the committing has either succeeded or failed, send the following message to the specified object. The didCommitSelector method must have the following method signature: - (void)editor:(id)editor didCommit:(BOOL)didCommit contextInfo:(void *)contextInfo
    If an error occurs while attempting to commit, for example if key-value coding validation fails, an implementation of this method should typically send the NSView in which editing is being done a presentError:modalForWindow:delegate:didRecoverSelector:contextInfo: message, specifying the view's containing window.- (void)editor:(id)editor didCommit:(BOOL)didCommit contextInfo:(void *)contextInfo
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1458179-commitediting
     */

  }, {
    key: 'commitEditingWithDelegateDidCommit',
    value: function commitEditingWithDelegateDidCommit(delegate, didCommitSelector, contextInfo) {}

    /**
     * Return the current composed string.
     * @access public
     * @param {!Object} sender - The client object requesting the string.
     * @returns {!Object} - 
     * @desc  A composed string refers to the buffer that an input method typically maintains to mirror the text contained in the active inline area. It is called the composed string to reflect the fact that the input method composed the string by converting the characters input by the user. In addition, using the term composed string makes it easier to differentiate between an input method  buffer and the text in the active inline area that the user sees. 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1385416-composedstring
     */

  }, {
    key: 'composedString',
    value: function composedString(sender) {
      return null;
    }

    /**
     * Called after an input parameter in the composition parameter view has been edited.
     * @access public
     * @param {!QCCompositionParameterView} parameterView - The composition parameter view in which the parameter changed.
     * @param {!string} portKey - A key for one of the composition parameters, which is provided to you by the Quartz Composer engine.
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1505265-compositionparameterview
     */

  }, {
    key: 'compositionParameterViewDidChangeParameterWithKey',
    value: function compositionParameterViewDidChangeParameterWithKey(parameterView, portKey) {}

    /**
     * Allows you to define which composition parameters are visible in the user interface when the composition parameter view refreshes.  
     * @access public
     * @param {!QCCompositionParameterView} parameterView - The composition parameter view in which the selection changed.
     * @param {!string} portKey - A key for one of the composition parameters, which is provided to you by the Quartz Composer engine.
     * @param {!Map<AnyHashable, Object>} [portAttributes = new Map()] - A dictionary of the attributes that you want to display in the user interface.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503523-compositionparameterview
     */

  }, {
    key: 'compositionParameterViewShouldDisplayParameterWithKeyAttributes',
    value: function compositionParameterViewShouldDisplayParameterWithKeyAttributes(parameterView, portKey) {
      var portAttributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();

      return false;
    }

    /**
     * Performs custom tasks when the selected composition in the composition picker view changes. 
     * @access public
     * @param {!QCCompositionPickerView} pickerView - The composition picker view in which the selection changed.
     * @param {!QCComposition} composition - The selected composition or nil if the previously selected composition is no longer selected.
     * @returns {void}
     * @desc Quartz Composer invokes this method when the selected composition in the composition picker view changes. Implement this method if you want to perform custom tasks at that time.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1447352-compositionpickerview
     */

  }, {
    key: 'compositionPickerViewDidSelect',
    value: function compositionPickerViewDidSelect(pickerView, composition) {}

    /**
     * Performs custom tasks when the composition picker view starts animating a composition.
     * @access public
     * @param {!QCCompositionPickerView} pickerView - The composition picker view in which the composition started animating.
     * @returns {void}
     * @desc Quartz Composer invokes  this method when  the composition picker view starts animating a composition. Implement this method if you want to perform custom tasks at that time.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1447342-compositionpickerviewdidstartani
     */

  }, {
    key: 'compositionPickerViewDidStartAnimating',
    value: function compositionPickerViewDidStartAnimating(pickerView) {}

    /**
     * Performs custom tasks when the composition picker view stops animating a composition.
     * @access public
     * @param {!QCCompositionPickerView} pickerView - The composition picker view in which the composition stopped animating.
     * @returns {void}
     * @desc Quartz Composer invokes  this method whenever the composition picker view stops animating a composition. Implement this method if you want to perform custom tasks at that time.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1447348-compositionpickerviewwillstopani
     */

  }, {
    key: 'compositionPickerViewWillStopAnimating',
    value: function compositionPickerViewWillStopAnimating(pickerView) {}

    /**
     * Sent when a control with editable text begins an editing session.
     * @access public
     * @param {Notification} obj - 
     * @returns {void}
     * @desc This method is invoked when the user begins editing text in a control such as a text field or a form field. The control posts a NSControlTextDidBeginEditing notification, and if the control’s delegate implements this method, it is automatically registered to receive the notification. Use the key @"NSFieldEditor" to obtain the field editor from the userInfo dictionary of the notification object.  See controlTextDidEndEditing(_:) for an explanation of why you may not always get one invocation of controlTextDidBeginEditing(_:) for each invocation of controlTextDidEndEditing(_:).
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1428934-controltextdidbeginediting
     */

  }, {
    key: 'controlTextDidBeginEditing',
    value: function controlTextDidBeginEditing(obj) {}

    /**
     * Sent when the text in the receiving control changes. 
     * @access public
     * @param {Notification} obj - 
     * @returns {void}
     * @desc This method is invoked when text in a control such as a text field or form changes. The control posts a NSControlTextDidChange notification, and if the control’s delegate implements this method, it is automatically registered to receive the notification. Use the key @"NSFieldEditor" to obtain the field editor from the userInfo dictionary of the notification object.  
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1428982-controltextdidchange
     */

  }, {
    key: 'controlTextDidChange',
    value: function controlTextDidChange(obj) {}

    /**
     * Sent when a control with editable text ends an editing session.
     * @access public
     * @param {Notification} obj - 
     * @returns {void}
     * @desc This method is invoked when the user stops editing text in a control such as a text field or form. The control posts a NSControlTextDidEndEditing notification, and if the control’s delegate implements this method, it is automatically registered to receive the notification. Use the key @"NSFieldEditor" to obtain the field editor from the userInfo dictionary of the notification object.  WarningIn some cases, such as when editing within an instance of NSOutlineView, this method may be invoked without a previous invocation of controlTextDidBeginEditing(_:). You will only get the controlTextDidBeginEditing: notification if the user actually types something, but you can get the controlTextDidEndEditing: notification if the user just double-clicks the field and then clicks outside the field, without typing.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1428847-controltextdidendediting
     */

  }, {
    key: 'controlTextDidEndEditing',
    value: function controlTextDidEndEditing(obj) {}

    /**
     * Processes a command  generated by user action such as typing certain keys or pressing the mouse button.
     * @access public
     * @param {!function} aSelector - The action associated with the key down event. The selector can be an action specified in the input method  dictionary of keys and actions (that is, an action specific to the input method) or one of the NSResponder action methods such as insertNewline: or deleteBackward:. By definition such action methods do not return a value.
     * @param {!Object} sender - The client object sending the key down event.
     * @returns {boolean} - 
     * @desc This method is called when the system binds a key down event to an action method. If you implement this method you should test if it is appropriate to call the action method before actually calling it, because calling the action method implies that you agree to handle the command. Suppose you have implemented a version of insertNewline:  that terminates the conversion session and sends the fully converted text to the client. However, if you conversion buffer is empty, you want the application to receive the return key that triggered the call to insertNewline:. In that case, when didCommandBySelector:client: is called you should test your buffer before calling your implementation of insertNewline:. If the buffer is empty, return false to indicate that the return key should be passed on to the application. If the buffer is not empty, call insertNewline: and then return true as the result of didCommandBySelector:client:.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1385394-didcommand
     */

  }, {
    key: 'didCommandByClient',
    value: function didCommandByClient(aSelector, sender) {
      return false;
    }

    /**
     * Called for every match found during a find operation.
     * @access public
     * @param {PDFSelection} instance - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1436046-didmatchstring
     */

  }, {
    key: 'didMatchString',
    value: function didMatchString(instance) {}

    /**
     * Causes the receiver to discard any changes, restoring the previous values.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458076-discardediting
     */

  }, {
    key: 'discardEditing',
    value: function discardEditing() {}

    /**
     * Called when the PDFDocumentDidBeginFindNotification notification is posted. 
     * @access public
     * @param {Notification} notification - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1436080-documentdidbegindocumentfind
     */

  }, {
    key: 'documentDidBeginDocumentFind',
    value: function documentDidBeginDocumentFind(notification) {}

    /**
     * Called when the PDFDocumentDidBeginPageFindNotification notification is posted.
     * @access public
     * @param {Notification} notification - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1436094-documentdidbeginpagefind
     */

  }, {
    key: 'documentDidBeginPageFind',
    value: function documentDidBeginPageFind(notification) {}

    /**
     * Called when the PDFDocumentDidEndFindNotification notification is posted.
     * @access public
     * @param {Notification} notification - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1436068-documentdidenddocumentfind
     */

  }, {
    key: 'documentDidEndDocumentFind',
    value: function documentDidEndDocumentFind(notification) {}

    /**
     * Called when the PDFDocumentDidEndPageFindNotification notification is posted. 
     * @access public
     * @param {Notification} notification - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1436064-documentdidendpagefind
     */

  }, {
    key: 'documentDidEndPageFind',
    value: function documentDidEndPageFind(notification) {}

    /**
     * Called when the PDFDocumentDidFindMatchNotification notification is posted.
     * @access public
     * @param {Notification} notification - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1436044-documentdidfindmatch
     */

  }, {
    key: 'documentDidFindMatch',
    value: function documentDidFindMatch(notification) {}

    /**
     * Called when the PDFDocumentDidUnlockNotification notification is posted.
     * @access public
     * @param {Notification} notification - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1436029-documentdidunlock
     */

  }, {
    key: 'documentDidUnlock',
    value: function documentDidUnlock(notification) {}

    /**
     * Returns a Boolean value that indicates whether the receiver contains a given object.
     * @access public
     * @param {Object} object - The object to search for in the receiver.
     * @returns {boolean} - 
     * @desc Currently, doesContain(_:) messages are never sent to any object from within Cocoa itself. The default implementation for this method provided by NSObject returns true if the receiver is actually an NSArray object and an indexOfObjectIdentical(to:) message sent to the same object would return something other than NSNotFound.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393848-doescontain
     */

  }, {
    key: 'doesContain',
    value: function doesContain(object) {
      return false;
    }

    /**
     * 
     * @access public
     * @param {!QLPreviewPanel} panel - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1505044-endpreviewpanelcontrol
     */

  }, {
    key: 'endPreviewPanelControl',
    value: function endPreviewPanelControl(panel) {}

    /**
     * Implemented by the delegate to evaluate whether the delegating NSExceptionHandler instance should handle a given exception.
     * @access public
     * @param {!NSExceptionHandler} sender - The NSExceptionHandler object sending the message.
     * @param {!NSException} exception - An NSException object describing the exception to be evaluated.
     * @param {number} aMask - The bit mask indicating the types of exceptions handled by the NSExceptionHandler object. See Logging and Handling Constants and System Hang Constants for descriptions of the possible enum constants.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1489854-exceptionhandler
     */

  }, {
    key: 'exceptionHandlerShouldHandleMask',
    value: function exceptionHandlerShouldHandleMask(sender, exception, aMask) {
      return false;
    }

    /**
     * Implemented by the delegate to evaluate whether the delegating NSExceptionHandler instance should log a given exception.
     * @access public
     * @param {!NSExceptionHandler} sender - The NSExceptionHandler object sending the message.
     * @param {!NSException} exception - An NSException object describing the exception to be evaluated.
     * @param {number} aMask - The bit mask indicating the types of exceptions logged by the NSExceptionHandler object. See Logging and Handling Constants and System Hang Constants for descriptions of the possible enum constants.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1489856-exceptionhandler
     */

  }, {
    key: 'exceptionHandlerShouldLogExceptionMask',
    value: function exceptionHandlerShouldLogExceptionMask(sender, exception, aMask) {
      return false;
    }

    /**
     * 
     * @access public
     * @param {!OBEXFileTransferServices} inServices - 
     * @param {OBEXError} inError - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1430046-filetransferservicesabortcomplet
     */

  }, {
    key: 'fileTransferServicesAbortCompleteError',
    value: function fileTransferServicesAbortCompleteError(inServices, inError) {}

    /**
     * 
     * @access public
     * @param {!OBEXFileTransferServices} inServices - 
     * @param {OBEXError} inError - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1428872-filetransferservicesconnectionco
     */

  }, {
    key: 'fileTransferServicesConnectionCompleteError',
    value: function fileTransferServicesConnectionCompleteError(inServices, inError) {}

    /**
     * 
     * @access public
     * @param {!OBEXFileTransferServices} inServices - 
     * @param {OBEXError} inError - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1432094-filetransferservicescopyremotefi
     */

  }, {
    key: 'fileTransferServicesCopyRemoteFileCompleteError',
    value: function fileTransferServicesCopyRemoteFileCompleteError(inServices, inError) {}

    /**
     * 
     * @access public
     * @param {!OBEXFileTransferServices} inServices - 
     * @param {!Map<AnyHashable, Object>} inProgressDescription - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1431422-filetransferservicescopyremotefi
     */

  }, {
    key: 'fileTransferServicesCopyRemoteFileProgressTransferProgress',
    value: function fileTransferServicesCopyRemoteFileProgressTransferProgress(inServices, inProgressDescription) {}

    /**
     * 
     * @access public
     * @param {!OBEXFileTransferServices} inServices - 
     * @param {OBEXError} inError - 
     * @param {!string} inFolderName - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1430913-filetransferservicescreatefolder
     */

  }, {
    key: 'fileTransferServicesCreateFolderCompleteErrorFolder',
    value: function fileTransferServicesCreateFolderCompleteErrorFolder(inServices, inError, inFolderName) {}

    /**
     * 
     * @access public
     * @param {!OBEXFileTransferServices} inServices - 
     * @param {OBEXError} inError - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1434806-filetransferservicesdisconnectio
     */

  }, {
    key: 'fileTransferServicesDisconnectionCompleteError',
    value: function fileTransferServicesDisconnectionCompleteError(inServices, inError) {}

    /**
     * 
     * @access public
     * @param {!OBEXFileTransferServices} inServices - 
     * @param {OBEXError} inError - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1432086-filetransferservicesfilepreparat
     */

  }, {
    key: 'fileTransferServicesFilePreparationCompleteError',
    value: function fileTransferServicesFilePreparationCompleteError(inServices, inError) {}

    /**
     * 
     * @access public
     * @param {!OBEXFileTransferServices} inServices - 
     * @param {OBEXError} inError - 
     * @param {!string} inPath - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1432583-filetransferservicespathchangeco
     */

  }, {
    key: 'fileTransferServicesPathChangeCompleteErrorFinalPath',
    value: function fileTransferServicesPathChangeCompleteErrorFinalPath(inServices, inError, inPath) {}

    /**
     * 
     * @access public
     * @param {!OBEXFileTransferServices} inServices - 
     * @param {OBEXError} inError - 
     * @param {!string} inItemName - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1434702-filetransferservicesremoveitemco
     */

  }, {
    key: 'fileTransferServicesRemoveItemCompleteErrorRemovedItem',
    value: function fileTransferServicesRemoveItemCompleteErrorRemovedItem(inServices, inError, inItemName) {}

    /**
     * 
     * @access public
     * @param {!OBEXFileTransferServices} inServices - 
     * @param {OBEXError} inError - 
     * @param {!Object[]} inListing - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1434777-filetransferservicesretrievefold
     */

  }, {
    key: 'fileTransferServicesRetrieveFolderListingCompleteErrorListing',
    value: function fileTransferServicesRetrieveFolderListingCompleteErrorListing(inServices, inError, inListing) {}

    /**
     * 
     * @access public
     * @param {!OBEXFileTransferServices} inServices - 
     * @param {OBEXError} inError - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1434240-filetransferservicessendfilecomp
     */

  }, {
    key: 'fileTransferServicesSendFileCompleteError',
    value: function fileTransferServicesSendFileCompleteError(inServices, inError) {}

    /**
     * 
     * @access public
     * @param {!OBEXFileTransferServices} inServices - 
     * @param {!Map<AnyHashable, Object>} inProgressDescription - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1430365-filetransferservicessendfileprog
     */

  }, {
    key: 'fileTransferServicesSendFileProgressTransferProgress',
    value: function fileTransferServicesSendFileProgressTransferProgress(inServices, inProgressDescription) {}

    /**
     * Performs cleanup when the scripting environment is reset.
     * @access public
     * @returns {void}
     * @desc This method is invoked on objects exposed to the scripting environment just before the scripting environment is reset. After invocation, the receiving object will no longer be referenced by the scripting environment. Further references to WebScriptObject instances created by the exposed object will be invalid and may produce unpredictable results.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1528546-finalizeforwebscript
     */

  }, {
    key: 'finalizeForWebScript',
    value: function finalizeForWebScript() {}

    /**
     * Requests permission from the Font panel delegate to display the given font name in the Font panel.
     * @deprecated
     * @access public
     * @param {Object} sender - 
     * @param {string} fontName - The full PostScript name of the font to display, such as Helvetica-BoldOblique or Helvetica-Narrow-Bold.
     * @returns {boolean} - 
     * @desc In macOS versions 10.2 and earlier, this method is invoked repeatedly as necessary whenever the Font panel needs updating, such as when the Font panel is first loaded, and when the user selects a family name to see which typefaces in that family are available. Your implementation should execute fairly quickly to ensure the responsiveness of the Font panel.Important
    This delegate method is not called in macOS versions 10.3 and later.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1462359-fontmanager
     */

  }, {
    key: 'fontManagerWillIncludeFont',
    value: function fontManagerWillIncludeFont(sender, fontName) {
      return false;
    }

    /**
     * Handles key down and mouse events.
     * @access public
     * @param {!NSEvent} event - The event to handle.
     * @param {!Object} sender - The client object sending the event.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1385363-handle
     */

  }, {
    key: 'handleClient',
    value: function handleClient(event, sender) {
      return false;
    }

    /**
     * Performs custom tasks when the user right-clicks the image browser view background.
     * @access public
     * @param {!IKImageBrowserView} aBrowser - An image browser view.
     * @param {!NSEvent} event - The event that invoked the method.
     * @returns {void}
     * @desc This method signals  that the user either right-clicked the background or left-clicked it with the Alt key pressed. You can implement this method if you want to perform custom tasks at that time.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503526-imagebrowser
     */

  }, {
    key: 'imageBrowserBackgroundWasRightClickedWith',
    value: function imageBrowserBackgroundWasRightClickedWith(aBrowser, event) {}

    /**
     * Performs custom tasks when the user double-clicks an item in the image browser view.
     * @access public
     * @param {!IKImageBrowserView} aBrowser - An image browser view.
     * @param {number} index - The index of the cell.
     * @returns {void}
     * @desc This method signals that the user double-clicked an item in the image browser view. You can implement this method if you want to perform custom tasks at that time.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1504701-imagebrowser
     */

  }, {
    key: 'imageBrowserCellWasDoubleClickedAt',
    value: function imageBrowserCellWasDoubleClickedAt(aBrowser, index) {}

    /**
     * Performs custom tasks when the user right-clicks an item in the image browser view. 
     * @access public
     * @param {!IKImageBrowserView} aBrowser - An image browser view.
     * @param {number} index - The index of the cell.
     * @param {!NSEvent} event - The event that invoked the method.
     * @returns {void}
     * @desc This method signals that the user either right-clicked an item in the browser or left-clicked the item with the Alt key pressed. You can implement this method if you want to perform custom tasks at that time.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503802-imagebrowser
     */

  }, {
    key: 'imageBrowserCellWasRightClickedAtWith',
    value: function imageBrowserCellWasRightClickedAtWith(aBrowser, index, event) {}

    /**
     * Returns the group at the specified index.
     * @access public
     * @param {!IKImageBrowserView} aBrowser - An image browser view.
     * @param {number} index - The index of the group you want to retrieve.
     * @returns {!Map<AnyHashable, Object>} - 
     * @desc This method is optional.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503488-imagebrowser
     */

  }, {
    key: 'imageBrowserGroupAt',
    value: function imageBrowserGroupAt(aBrowser, index) {
      return null;
    }

    /**
     * Returns an object for the item in an image browser view that corresponds to the specified index.
     * @access public
     * @param {!IKImageBrowserView} aBrowser - An image browser view.
     * @param {number} index - The index of the item you want to retrieve.
     * @returns {!Object} - 
     * @desc Your data source must implement this method. The returned object must implement the required methods of the IKImageBrowserItem protocol. 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1504064-imagebrowser
     */

  }, {
    key: 'imageBrowserItemAt',
    value: function imageBrowserItemAt(aBrowser, index) {
      return null;
    }

    /**
     * Signals that the specified items should be moved to the specified destination. 
     * @access public
     * @param {!IKImageBrowserView} aBrowser - An image browser view.
     * @param {!Set} indexes - The indexes of the items that should be reordered.
     * @param {number} destinationIndex - The starting index of the destination the items should be moved to.
     * @returns {boolean} - 
     * @desc This method is optional. It is invoked by the image browser view after  Image Kit determines  that a reordering operation should be applied. The data source should update itself by reordering its elements. 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503616-imagebrowser
     */

  }, {
    key: 'imageBrowserMoveItemsAtTo',
    value: function imageBrowserMoveItemsAtTo(aBrowser, indexes, destinationIndex) {
      return false;
    }

    /**
     * Signals that a remove operation should be applied to the specified items.
     * @access public
     * @param {!IKImageBrowserView} aBrowser - An image browser view.
     * @param {!Set} indexes - The indexes of the items that should be removed.
     * @returns {void}
     * @desc This method is optional. It is invoked by the image browser after  Image Kit determines  that a remove operation should be applied. In response, the data source should update itself by removing the specified items.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503834-imagebrowser
     */

  }, {
    key: 'imageBrowserRemoveItemsAt',
    value: function imageBrowserRemoveItemsAt(aBrowser, indexes) {}

    /**
     * Signals that a drag should begin.
     * @access public
     * @param {!IKImageBrowserView} aBrowser - An image browser view.
     * @param {!Set} itemIndexes - The indexes of the items that should be dragged.
     * @param {!NSPasteboard} pasteboard - The pasteboard to copy the items to.
     * @returns {number} - 
     * @desc This method is optional. It is invoked after Image Kit determines that a drag should begin, but before the drag has been started. 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1504208-imagebrowser
     */

  }, {
    key: 'imageBrowserWriteItemsAtTo',
    value: function imageBrowserWriteItemsAtTo(aBrowser, itemIndexes, pasteboard) {
      return 0;
    }

    /**
     * Performs custom tasks when the selection changes.
     * @access public
     * @param {!IKImageBrowserView} aBrowser - An image browser view.
     * @returns {void}
     * @desc This method signals that the user changes the selection in the image browser view. You can implement this method if you want to perform custom tasks at that time.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503765-imagebrowserselectiondidchange
     */

  }, {
    key: 'imageBrowserSelectionDidChange',
    value: function imageBrowserSelectionDidChange(aBrowser) {}

    /**
     * Returns the image to display.
     * @access public
     * @returns {!Object} - 
     * @desc Your data source must implement this method. This method  is called frequently, so the receiver should cache the returned instance.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1504801-imagerepresentation
     */

  }, {
    key: 'imageRepresentation',
    value: function imageRepresentation() {
      return null;
    }

    /**
     * Returns the representation type of the image to display.
     * @access public
     * @returns {!string} - 
     * @desc Your data source must implement this method.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503547-imagerepresentationtype
     */

  }, {
    key: 'imageRepresentationType',
    value: function imageRepresentationType() {
      return null;
    }

    /**
     *  Returns the display subtitle of the image.
     * @access public
     * @returns {!string} - 
     * @desc This method is optional.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503725-imagesubtitle
     */

  }, {
    key: 'imageSubtitle',
    value: function imageSubtitle() {
      return null;
    }

    /**
     * Returns the display title of the image. 
     * @access public
     * @returns {!string} - 
     * @desc This method is optional.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1504080-imagetitle
     */

  }, {
    key: 'imageTitle',
    value: function imageTitle() {
      return null;
    }

    /**
     * Returns a unique string that identifies the data source item.
     * @access public
     * @returns {!string} - 
     * @desc Your data source must implement this method. The image browser view uses this identifier to associate the data source item and  its cache.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503516-imageuid
     */

  }, {
    key: 'imageUID',
    value: function imageUID() {
      return null;
    }

    /**
     * Returns the version of the item. 
     * @access public
     * @returns {number} - 
     * @desc This method is optional. The receiver can return a new version to let the image browser know that it should not use its cache for the item.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1504444-imageversion
     */

  }, {
    key: 'imageVersion',
    value: function imageVersion() {
      return 0;
    }

    /**
     * Returns the indices of the specified container objects.
     * @access public
     * @param {NSScriptObjectSpecifier} specifier - An object specifier for the container objects for which to obtain the indices.
     * @returns {?number[]} - 
     * @desc  Containers that want to evaluate some specifiers on their own should implement this method. If this method returns nil, the object specifier will go on to do its own evaluation, so you should only return nil if that's the behavior you want, or if an error occurs. If this method returns an array, the object specifier will use the NSNumber objects in it as the indices. So, if you evaluate the specifier and there are no objects that match, you should return an empty array, not nil. If you find only one object, you should still return its index in an array. Returning an array with a single index where the index is – is interpreted to mean all the objects.For an example implementation, see "Implementing Object Specifiers" in Object Specifiers in Cocoa Scripting Guide
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1417806-indicesofobjects
     */

  }, {
    key: 'indicesOfObjectsByEvaluatingObjectSpecifier',
    value: function indicesOfObjectsByEvaluatingObjectSpecifier(specifier) {
      return null;
    }

    /**
     * Returns a dictionary describing the receiver’s binding.
     * @access public
     * @param {string} binding - The name of a binding.
     * @returns {?Map<string, Object>} - 
     * @desc This method is mostly for use by subclasses which want to analyze the existing bindings of an object.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458122-infoforbinding
     */

  }, {
    key: 'infoForBinding',
    value: function infoForBinding(binding) {
      return null;
    }

    /**
     * Handles key down events that do not map to an action method.
     * @access public
     * @param {!string} string - The key down event, which is the text input by the client.
     * @param {!Object} sender - The client object sending the key down events.
     * @returns {boolean} - 
     * @desc An input method should implement this method when using key binding (that is, it implements didCommand(by:client:)).
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1385446-inputtext
     */

  }, {
    key: 'inputTextClient',
    value: function inputTextClient(string, sender) {
      return false;
    }

    /**
     * Receives Unicode, the key code that generated it, and any modifier flags.
     * @access public
     * @param {!string} string - The text input by the client.
     * @param {number} keyCode - The key code for the associated Unicode.
     * @param {number} flags - The modifier flags.
     * @param {!Object} sender - The client object.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1385436-inputtext
     */

  }, {
    key: 'inputTextKeyModifiersClient',
    value: function inputTextKeyModifiersClient(string, keyCode, flags, sender) {
      return false;
    }

    /**
     * Inserts an object at the specified index in the collection specified by the passed key.
     * @access public
     * @param {Object} value - 
     * @param {number} index - 
     * @param {string} key - 
     * @returns {void}
     * @desc  The method insertIn<Key>:atIndex: is invoked if it exists. If no corresponding scripting-KVC-compliant method (insertIn<Key>:atIndex: ) is found, this method invokes mutableArrayValueForKey: and mutates the result.Note Prior to OS X version 10.4, this method did not invoke -mutableArrayValueForKey:.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1417619-insertvalue
     */

  }, {
    key: 'insertValueAtInPropertyWithKey',
    value: function insertValueAtInPropertyWithKey(value, index, key) {}

    /**
     * Inserts an object in the collection specified by the passed key.
     * @access public
     * @param {Object} value - 
     * @param {string} key - 
     * @returns {void}
     * @desc  The method insertIn<Key>: is used if it exists. Otherwise, raises an NSUndefinedKeyException. This is part of Cocoa’s scripting support for inserting newly-created objects into containers without explicitly specifying a location.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1416203-insertvalue
     */

  }, {
    key: 'insertValueInPropertyWithKey',
    value: function insertValueInPropertyWithKey(value, key) {}

    /**
     * Executes when a script attempts to invoke a method on an exposed object directly.
     * @access public
     * @param {!Object[]} _arguments - 
     * @returns {!Object} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1528543-invokedefaultmethod
     */

  }, {
    key: 'invokeDefaultMethodWithArguments',
    value: function invokeDefaultMethodWithArguments(_arguments) {
      return null;
    }

    /**
     * Handles undefined method invocation from the scripting environment.
     * @access public
     * @param {!string} name - The name of the undefined method.
     * @param {!Object[]} _arguments - 
     * @returns {!Object} - 
     * @desc This method is invoked when a script attempts to invoke a method not directly exported to the scripting environment. You should return the result of the invocation, converted appropriately for the scripting environment.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1528562-invokeundefinedmethod
     */

  }, {
    key: 'invokeUndefinedMethodFromWebScriptWithArguments',
    value: function invokeUndefinedMethodFromWebScriptWithArguments(name, _arguments) {
      return null;
    }

    /**
     * Returns a Boolean value that indicates whether receiver is considered to be “like” a given string when the case of characters in the receiver is ignored.
     * @access public
     * @param {string} object - 
     * @returns {boolean} - 
     * @desc Currently, isCaseInsensitiveLike(_:) messages are never sent to any object from within Cocoa itself.The default implementation for this method provided by NSObject returns false. NSString also provides an implementation of this method, which returns true if the receiver matches a pattern described by aString, ignoring the case of the characters in the receiver.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393837-iscaseinsensitivelike
     */

  }, {
    key: 'isCaseInsensitiveLike',
    value: function isCaseInsensitiveLike(object) {
      return false;
    }

    /**
     * Returns a Boolean value that indicates whether the receiver is equal to another given object.
     * @access public
     * @param {?Object} object - The object with which to compare the receiver.
     * @returns {boolean} - 
     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSEqualToComparison, an isEqual(to:) message may be sent to each potentially specified object, if neither the potentially specified object nor the object being tested against implements a scriptingIsEqual(to:) method.The default implementation for this method provided by NSObject returns true if an isEqualTo: message sent to the same object would return true.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393823-isequal
     */

  }, {
    key: 'isEqualTo',
    value: function isEqualTo(object) {
      return false;
    }

    /**
     * Returns a Boolean value that indicates whether the receiver is greater than another given object.
     * @access public
     * @param {?Object} object - The object with which to compare the receiver.
     * @returns {boolean} - 
     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSGreaterThanComparison, an isGreaterThan(_:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsGreaterThan(_:) method and the object being tested against does not implement a scriptingIsLessThanOrEqual(to:) method.The default implementation for this method provided by NSObject returns true if a compare: message sent to the same object would return NSOrderedDescending.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393885-isgreaterthan
     */

  }, {
    key: 'isGreaterThan',
    value: function isGreaterThan(object) {
      return false;
    }

    /**
     * Returns a Boolean value that indicates whether the receiver is greater than or equal to another given object.
     * @access public
     * @param {?Object} object - The object with which to compare the receiver.
     * @returns {boolean} - 
     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSGreaterThanOrEqualToComparison, anisGreaterThanOrEqual(to:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsGreaterThanOrEqual(to:) method and the object being tested against does not implement a scriptingIsLessThan(_:) method.The default implementation for this method provided by NSObject returns true if a compare: message sent to the same object would return NSOrderedSame or NSOrderedDescending.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393862-isgreaterthanorequal
     */

  }, {
    key: 'isGreaterThanOrEqualTo',
    value: function isGreaterThanOrEqualTo(object) {
      return false;
    }

    /**
     * Returns a Boolean value that indicates whether the receiver is less than another given object.
     * @access public
     * @param {?Object} object - The object with which to compare the receiver.
     * @returns {boolean} - 
     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSLessThanComparison, an isLessThan(_:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsLessThan(_:) method and the object being tested against does not implement a scriptingIsGreaterThanOrEqual(to:) method.The default implementation for this method provided by NSObject method returns true if a compare: message sent to the same object would return NSOrderedAscending.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393841-islessthan
     */

  }, {
    key: 'isLessThan',
    value: function isLessThan(object) {
      return false;
    }

    /**
     * Returns a Boolean value that indicates whether the receiver is less than or equal to another given object. 
     * @access public
     * @param {?Object} object - The object with which to compare the receiver.
     * @returns {boolean} - 
     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSLessThanOrEqualToComparison, an isLessThanOrEqual(to:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsLessThanOrEqual(to:) method and the object being tested against does not implement a scriptingIsGreaterThan(_:) method.The default implementation for this method provided by NSObject method returns true if a compare: message sent to the same object would return NSOrderedAscending or NSOrderedSame.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393827-islessthanorequal
     */

  }, {
    key: 'isLessThanOrEqualTo',
    value: function isLessThanOrEqualTo(object) {
      return false;
    }

    /**
     * Returns a Boolean value that indicates whether the receiver is "like" another given object.
     * @access public
     * @param {string} object - The object with which to compare the receiver.
     * @returns {boolean} - 
     * @desc Currently, isLike(_:) messages are never sent to any object from within Cocoa itself.The default implementation for this method provided by NSObject method returns false. NSString also provides an implementation of this method, which returns true if the receiver matches a pattern described by object.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393866-islike
     */

  }, {
    key: 'isLike',
    value: function isLike(object) {
      return false;
    }

    /**
     * Returns a Boolean value that indicates whether the receiver is not equal to another given object.
     * @access public
     * @param {?Object} object - The object with which to compare the receiver.
     * @returns {boolean} - 
     * @desc Currently, isNotEqual(to:) messages are never sent to any object from within Cocoa itself.The default implementation for this method provided by NSObject method returns true if an isEqual: message sent to the same object would return false.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393843-isnotequal
     */

  }, {
    key: 'isNotEqualTo',
    value: function isNotEqualTo(object) {
      return false;
    }

    /**
     * Invoked when a resolution changes occurs for the window that hosts the layer.
     * @access public
     * @param {CALayer} layer - The layer whose scale and content might need updating.
     * @param {number} newScale - The new scale of the window. 
     * @param {NSWindow} window - The window that hosts the layer.
     * @returns {boolean} - 
     * @desc When a resolution change occurs for a given window, the system traverses the layer trees in that window to decide what action, if any, to take for each layer. The system queries the layer’s delegate to determine whether to change the layer’s contentsScale property to the new scale (either 2.0 or 1.0). Note that you don’t need to manage NSImage contents and that this method is not called on the delegate of a layer whose content is an NSImage object.If the delegate returns true, it should make any corresponding changes to the layer’s properties, as required by the resolution change. For example, a layer whose contents contain a CGImage object needs to determine whether an alternate CGImage object is available for the new scale factor. If the delegate finds a suitable CGImage object, then in addition to returning true, it should set the appropriate CGImage object as the layer’s new contents.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1483574-layer
     */

  }, {
    key: 'layerShouldInheritContentsScaleFrom',
    value: function layerShouldInheritContentsScaleFrom(layer, newScale, window) {
      return false;
    }

    /**
     * Returns the names of the files that the receiver promises to create at a specified location.
     * @deprecated
     * @access public
     * @param {string} dropDestination - A URL object that identifies the location at which the promised files will be created.
     * @returns {?string[]} - 
     * @desc This method is invoked when the drop has been accepted by the destination and the destination, in the case of another Cocoa application, invokes the NSDraggingInfo method namesOfPromisedFilesDropped(atDestination:). For long operations, you can cache dropDestination and defer the creation of the files until the draggedImage:endedAt:operation: method to avoid blocking the destination application.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1416082-namesofpromisedfilesdropped
     */

  }, {
    key: 'namesOfPromisedFilesDroppedAtDestination',
    value: function namesOfPromisedFilesDroppedAtDestination(dropDestination) {
      return null;
    }

    /**
     * Returns the number of groups in an image browser view.
     * @access public
     * @param {!IKImageBrowserView} aBrowser - An image browser view.
     * @returns {number} - 
     * @desc This method is optional.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503514-numberofgroups
     */

  }, {
    key: 'numberOfGroupsInImageBrowser',
    value: function numberOfGroupsInImageBrowser(aBrowser) {
      return 0;
    }

    /**
     * Returns the number of records managed by the data source object.
     * @access public
     * @param {!IKImageBrowserView} aBrowser - An image browser view.
     * @returns {number} - 
     * @desc Your data source must implement this method. An  IKImageView object uses this method to determine how many cells it should create and display.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503497-numberofitems
     */

  }, {
    key: 'numberOfItemsInImageBrowser',
    value: function numberOfItemsInImageBrowser(aBrowser) {
      return 0;
    }

    /**
     * This message should be sent to the receiver when editor has uncommitted changes that can affect the receiver.
     * @access public
     * @param {Object} editor - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458092-objectdidbeginediting
     */

  }, {
    key: 'objectDidBeginEditing',
    value: function objectDidBeginEditing(editor) {}

    /**
     * This message should be sent to the receiver when editor has finished editing a property belonging to the receiver.
     * @access public
     * @param {Object} editor - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458187-objectdidendediting
     */

  }, {
    key: 'objectDidEndEditing',
    value: function objectDidEndEditing(editor) {}

    /**
     * Returns an array describing the options for the specified binding.
     * @access public
     * @param {string} binding - The name of a binding
     * @returns {NSAttributeDescription[]} - 
     * @desc The NSAttributeDescription instances in the array are used by Interface Builder to build the options editor user interface of the bindings inspector.The option name displayed for the option in the bindings inspector is based on the value of the NSAttributeDescription method name. The type of editor displayed for the option in the bindings inspector is based on the value of the  NSAttributeDescription method attributeType.The default value displayed in the bindings inspector for the option is based on the value of the NSAttributeDescription method defaultValue.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458174-optiondescriptionsforbinding
     */

  }, {
    key: 'optionDescriptionsForBinding',
    value: function optionDescriptionsForBinding(binding) {
      return null;
    }

    /**
     * Return the a string that consists of the precomposed unicode characters.
     * @access public
     * @param {!Object} sender - The client object requesting the original string.
     * @returns {!string} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1385400-originalstring
     */

  }, {
    key: 'originalString',
    value: function originalString(sender) {
      return null;
    }

    /**
     * Implemented by an owner object to provide promised data.
     * @access public
     * @param {NSPasteboard} sender - The pasteboard that requires the specified data for a paste operation.
     * @param {string} type - The type of data the owner object must provide.
     * @returns {void}
     * @desc The receiver should have been previously declared in a declareTypes(_:owner:) message.The requested data should be written to sender using the setData(_:forType:), setPropertyList(_:forType:), or setString(_:forType:) method. The pasteboard(_:provideDataForType:) messages may also be sent to the owner when the application is shut down through an application’s terminate(_:) method. This is the method that is invoked in response to a Quit command. Thus the user can copy something to the pasteboard, quit the application, and still paste the data that was copied. A pasteboard(_:provideDataForType:) message is sent only if the specified type of data has not already been supplied to the pasteboard. Instead of writing all data types when the cut or copy operation is done, an application can choose to implement this method to provide the data for certain types only when they are requested.If an application writes data to the pasteboard in the richest, and therefore most preferred, type at the time of a cut or copy operation, its pasteboard(_:provideDataForType:) method can simply read that data from the pasteboard, convert it to the requested type, and write it back to the pasteboard as the new type.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1525907-pasteboard
     */

  }, {
    key: 'pasteboardProvideDataForType',
    value: function pasteboardProvideDataForType(sender, type) {}

    /**
     * Notifies a prior owner of the specified pasteboard (and owners of representations on the pasteboard) that the pasteboard has changed owners.
     * @access public
     * @param {NSPasteboard} sender - The pasteboard object whose owner changed.
     * @returns {void}
     * @desc Pasteboard owners only need to implement this method if they need to know when they have lost ownership.The owner is not able to read the contents of the pasteboard when responding to this method. The owner should be prepared to receive this method at any time, even from within the declareTypes(_:owner:) method used to declare ownership.Once an owner has provided all of its data for declared types, it will not receive a pasteboardChangedOwner: message. If, therefore, you are maintaining an object just for the purpose of providing data lazily, rather than relying solely on receipt of a pasteboardChangedOwner: message you need to keep track of what types were promised and what types have been provided. When all the types have been provided, you may release the owner.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1532824-pasteboardchangedowner
     */

  }, {
    key: 'pasteboardChangedOwner',
    value: function pasteboardChangedOwner(sender) {}

    /**
     * Sent to the delegate to perform the action.
     * @access public
     * @param {!ABPerson} person - The person on which the action will be taken.
     * @param {!string} identifier - The unique identifier of the selected value.
     * @returns {void}
     * @desc If the property returned by actionProperty() is a multivalue property, identifier contains the unique identifier of the value selected. The person being displayed in the Address Book application’s card view when the rollover menu is accesses is passed as person.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411298-performaction
     */

  }, {
    key: 'performActionFor',
    value: function performActionFor(person, identifier) {}

    /**
     * Called when a designable object is created in Interface Builder.
     * @access public
     * @returns {void}
     * @desc When Interface Builder instantiates a class with the IB_DESIGNABLE attribute, it calls this method to let the resulting object know that it was created at design time. You can implement this method in your designable classes and use it to configure their design-time appearance. For example, you might use the method to configure a custom text control with a default string. The system does not call this method; only Interface Builder calls it.Interface Builder waits until all objects in a graph have been created and initialized before calling this method. So if your object’s runtime configuration relies on subviews or parent views, those objects should exist by the time this method is called.Your implementation of this method must call super at some point so that parent classes can perform their own custom setup.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1402908-prepareforinterfacebuilder
     */

  }, {
    key: 'prepareForInterfaceBuilder',
    value: function prepareForInterfaceBuilder() {}

    /**
     * Supplies data to a CIImage object.
     * @access public
     * @param {Object} data - A pointer to image data. Note that data[0] refers to the first byte of the requested subimage, not the larger image buffer.
     * @param {number} rowbytes - The number of bytes per row.
     * @param {number} x - The x origin of the image data.
     * @param {number} y - The y origin of the image data.
     * @param {number} width - The width of the image data.
     * @param {number} height - The height of the image data.
     * @param {?Object} info - User supplied data, which is optional.
     * @returns {void}
     * @desc  You can supply the image provider to these methods of the CIImage class: imageWithImageProvider:size::format:colorSpace:options: to create a CIImage object from image datainit(imageProvider:size:_:format:colorSpace:options:) to initialize an existing CIImage with dataYou initialize the given bitmap with the subregion specified by the arguments x, y, width, and height. The subregion uses the local coordinate space of the image, with the origin at the upper-left corner of the image. If you change the virtual memory mapping of the buffer specified by the data argument (such as by using vm_copy to modify it), the behavior is undefined.That this callback always requests the full image data regardless of what is actually visible. All of the image is loaded or none of it is. The exception is when you create a tiled image by specifying the kCIImageProviderTileSize option. In this case, only the needed tiles are requested.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1438175-provideimagedata
     */

  }, {
    key: 'provideImageDataBytesPerRowOriginSizeUserInfo',
    value: function provideImageDataBytesPerRowOriginSizeUserInfo(data, rowbytes, x, y, width, height, info) {}

    /**
     * 
     * @access public
     * @param {!QuartzFilterManager} sender - 
     * @param {!QuartzFilter} filter - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1504951-quartzfiltermanager
     */

  }, {
    key: 'quartzFilterManagerDidAdd',
    value: function quartzFilterManagerDidAdd(sender, filter) {}

    /**
     * 
     * @access public
     * @param {!QuartzFilterManager} sender - 
     * @param {!QuartzFilter} filter - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503494-quartzfiltermanager
     */

  }, {
    key: 'quartzFilterManagerDidModifyFilter',
    value: function quartzFilterManagerDidModifyFilter(sender, filter) {}

    /**
     * 
     * @access public
     * @param {!QuartzFilterManager} sender - 
     * @param {!QuartzFilter} filter - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503483-quartzfiltermanager
     */

  }, {
    key: 'quartzFilterManagerDidRemove',
    value: function quartzFilterManagerDidRemove(sender, filter) {}

    /**
     * 
     * @access public
     * @param {!QuartzFilterManager} sender - 
     * @param {!QuartzFilter} filter - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503484-quartzfiltermanager
     */

  }, {
    key: 'quartzFilterManagerDidSelect',
    value: function quartzFilterManagerDidSelect(sender, filter) {}

    /**
     * 
     * @access public
     * @param {!Object} controller - 
     * @param {!IOBluetoothDevice} device - 
     * @param {!UnsafeMutablePointer<BluetoothHCILinkQualityInfo>} info - 
     * @param {IOReturn} error - 
     * @returns {void}
     * @desc This delegate gets invoked when an read link quality command complete event occurs. This could occur because you invoked it by issuing an -readLinkQualityForDevice: command, or someone else did from another app on the same controller.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1430075-readlinkquality
     */

  }, {
    key: 'readLinkQualityForDeviceComplete',
    value: function readLinkQualityForDeviceComplete(controller, device, info, error) {}

    /**
     * 
     * @access public
     * @param {!Object} controller - 
     * @param {!IOBluetoothDevice} device - 
     * @param {!UnsafeMutablePointer<BluetoothHCIRSSIInfo>} info - 
     * @param {IOReturn} error - 
     * @returns {void}
     * @desc This delegate gets invoked when an RSSI command complete event occurs. This could occur because you invoked it by issuing an -readRSSIForDevice: command, or someone else did from another app on the same controller.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1428399-readrssi
     */

  }, {
    key: 'readRSSIForDeviceComplete',
    value: function readRSSIForDeviceComplete(controller, device, info, error) {}

    /**
     * Removes the object at the specified index from the collection specified by the passed key.
     * @access public
     * @param {number} index - 
     * @param {string} key - 
     * @returns {void}
     * @desc  The method removeFrom<Key>AtIndex: is invoked if it exists. If no corresponding scripting-KVC-compliant method (-removeFrom<Key>AtIndex:) is found, this method invokes -mutableArrayValueForKey: and mutates the result.Note Prior to OS X version 10.4, this method did not invoke -mutableArrayValueForKey:.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1408773-removevalue
     */

  }, {
    key: 'removeValueAtFromPropertyWithKey',
    value: function removeValueAtFromPropertyWithKey(index, key) {}

    /**
     * Replaces the object at the specified index in the collection specified by the passed key.
     * @access public
     * @param {number} index - 
     * @param {string} key - 
     * @param {Object} value - 
     * @returns {void}
     * @desc  The method replaceIn<Key>:atIndex: is invoked if it exists. If no corresponding scripting-KVC-compliant method (-replaceIn<Key>atIndex:) is found, this method invokes -mutableArrayValueForKey: and mutates the result.Note Prior to OS X version 10.4, this method did not invoke -mutableArrayValueForKey:.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411225-replacevalue
     */

  }, {
    key: 'replaceValueAtInPropertyWithKeyWithValue',
    value: function replaceValueAtInPropertyWithKeyWithValue(index, key, value) {}

    /**
     * Called to determine if the specified uniform type identifier should be shown in the save panel.
     * @access public
     * @param {!IKSaveOptions} saveOptions - The IKSaveOptions instance that called the delegate.
     * @param {!string} utType - The uniform type identifier to test.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1503501-saveoptions
     */

  }, {
    key: 'saveOptionsShouldShowUTType',
    value: function saveOptionsShouldShowUTType(saveOptions, utType) {
      return false;
    }

    /**
     * Returns true if, in a scripting comparison, the compared object matches the beginning of object. A default implementation is provided for NSString and NSAttributedString.
     * @access public
     * @param {Object} object - 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393858-scriptingbegins
     */

  }, {
    key: 'scriptingBeginsWith',
    value: function scriptingBeginsWith(object) {
      return false;
    }

    /**
     * Returns true if, in a scripting comparison, the compared object contains object. A default implementation is provided for NSString and NSAttributedString.
     * @access public
     * @param {Object} object - 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393821-scriptingcontains
     */

  }, {
    key: 'scriptingContains',
    value: function scriptingContains(object) {
      return false;
    }

    /**
     * Returns true if, in a scripting comparison, the compared object matches the end of object. A default implementation is provided for NSString and NSAttributedString.
     * @access public
     * @param {Object} object - 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393819-scriptingends
     */

  }, {
    key: 'scriptingEndsWith',
    value: function scriptingEndsWith(object) {
      return false;
    }

    /**
     * Returns true if, in a scripting comparison, the compared object is equal to object. A default implementation is provided for NSString and NSAttributedString.
     * @access public
     * @param {Object} object - 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393835-scriptingisequal
     */

  }, {
    key: 'scriptingIsEqualTo',
    value: function scriptingIsEqualTo(object) {
      return false;
    }

    /**
     * Returns true if, in a scripting comparison, the compared object is greater than object. A default implementation is provided for NSString and NSAttributedString.
     * @access public
     * @param {Object} object - 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393831-scriptingisgreaterthan
     */

  }, {
    key: 'scriptingIsGreaterThan',
    value: function scriptingIsGreaterThan(object) {
      return false;
    }

    /**
     * Returns true if, in a scripting comparison, the compared object is greater than or equal to object. A default implementation is provided for NSString and NSAttributedString.
     * @access public
     * @param {Object} object - 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393829-scriptingisgreaterthanorequal
     */

  }, {
    key: 'scriptingIsGreaterThanOrEqualTo',
    value: function scriptingIsGreaterThanOrEqualTo(object) {
      return false;
    }

    /**
     * Returns true if, in a scripting comparison, the compared object is less than object. A default implementation is provided for NSString and NSAttributedString.
     * @access public
     * @param {Object} object - 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393887-scriptingislessthan
     */

  }, {
    key: 'scriptingIsLessThan',
    value: function scriptingIsLessThan(object) {
      return false;
    }

    /**
     * Returns true if, in a scripting comparison, the compared object is less than or equal to object. A default implementation is provided for NSString and NSAttributedString.
     * @access public
     * @param {Object} object - 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1393825-scriptingislessthanorequal
     */

  }, {
    key: 'scriptingIsLessThanOrEqualTo',
    value: function scriptingIsLessThanOrEqualTo(object) {
      return false;
    }

    /**
     * Sent to the delegate to determine whether the action should be enabled.
     * @access public
     * @param {!ABPerson} person - The person on which the action will be taken.
     * @param {!string} identifier - The unique identifier of the selected value.
     * @returns {boolean} - 
     * @desc If the property returned by actionProperty() is a multivalue property, identifier contains the unique identifier of the value selected.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411300-shouldenableaction
     */

  }, {
    key: 'shouldEnableActionFor',
    value: function shouldEnableActionFor(person, identifier) {
      return false;
    }

    /**
     * 
     * @deprecated
     * @access public
     * @param {Notification} notification - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1532645-textstoragedidprocessediting
     */

  }, {
    key: 'textStorageDidProcessEditing',
    value: function textStorageDidProcessEditing(notification) {}

    /**
     * 
     * @deprecated
     * @access public
     * @param {Notification} notification - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1533957-textstoragewillprocessediting
     */

  }, {
    key: 'textStorageWillProcessEditing',
    value: function textStorageWillProcessEditing(notification) {}

    /**
     * Sent to the delegate to request the title of the menu item for the action.
     * @access public
     * @param {!ABPerson} person - The person on which the action will be taken.
     * @param {!string} identifier - The unique identifier of the value for which the menu item will be displayed.
     * @returns {!string} - 
     * @desc If the property returned by actionProperty() is a multivalue property, identifier contains the unique identifier of the value selected.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411304-title
     */

  }, {
    key: 'titleFor',
    value: function titleFor(person, identifier) {
      return null;
    }

    /**
     * Removes a given binding between the receiver and a controller.
     * @access public
     * @param {string} binding - The name of a binding.
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458088-unbind
     */

  }, {
    key: 'unbind',
    value: function unbind(binding) {}

    /**
     * Returns the mode mask corresponding to the expected font panel mode.
     * @access public
     * @param {NSFontPanel} fontPanel - 
     * @returns {number} - 
     * @desc The mode masks are defined in Mode Masks. The Font Panel has the ability to hide elements that are not applicable for a given context by having the target respond to validModesForFontPanel(_:). If the target desires a font panel mode other than the standard mode mask, it must respond to this method.This message is sent up the responder chain to the first responder implementing the method. Ideally that object should be the first responder found that also implements changeFont(_:).
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1534415-validmodesforfontpanel
     */

  }, {
    key: 'validModesForFontPanel',
    value: function validModesForFontPanel(fontPanel) {
      return 0;
    }

    /**
     * Implemented to override the default action of enabling or disabling a specific menu item.
     * @access public
     * @param {NSMenuItem} menuItem - An NSMenuItem object that represents the menu item.
     * @returns {boolean} - 
     * @desc The object implementing this method must be the target of menuItem. You can determine which menu item menuItem is by querying it for its tag or action. The following example disables the menu item associated with the nextRecord action method when the selected line in a table view is the last one; conversely, it disables the menu item with priorRecord as its action method when the selected row is the first one in the table view. (The countryKeys array contains names that appear in the table view.)- (BOOL)validateMenuItem:(NSMenuItem *)item {
      int row = [tableView selectedRow];
      if ([item action] == @selector(nextRecord) &&
          (row == [countryKeys indexOfObject:[countryKeys lastObject]])) {
          return NO;
      }
      if ([item action] == @selector(priorRecord) && row == 0) {
          return NO;
      }
      return YES;
    }
    - (BOOL)validateMenuItem:(NSMenuItem *)item {
      int row = [tableView selectedRow];
      if ([item action] == @selector(nextRecord) &&
          (row == [countryKeys indexOfObject:[countryKeys lastObject]])) {
          return NO;
      }
      if ([item action] == @selector(priorRecord) && row == 0) {
          return NO;
      }
      return YES;
    }
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1518160-validatemenuitem
     */

  }, {
    key: 'validateMenuItem',
    value: function validateMenuItem(menuItem) {
      return false;
    }

    /**
     * If this method is implemented and returns false, NSToolbar will disable theItem; returning true causes theItem to be enabled.
     * @access public
     * @param {NSToolbarItem} item - 
     * @returns {boolean} - 
     * @desc NSToolbar only calls this method for image items.Note
    validateToolbarItem(_:) is called very frequently, so it must be efficient.If the receiver is the target for the actions of multiple toolbar items, it’s necessary to determine which toolbar item theItem refers to by testing the itemIdentifier.-(BOOL)validateToolbarItem:(NSToolbarItem *)toolbarItem
    {
      BOOL enable = NO;
      if ([[toolbarItem itemIdentifier] isEqual:SaveDocToolbarItemIdentifier]) {
          // We will return YES (enable the save item)
          // only when the document is dirty and needs saving
          enable = [self isDocumentEdited];
      } else if ([[toolbarItem itemIdentifier] isEqual:NSToolbarPrintItemIdentifier]) {
          // always enable print for this window
          enable = YES;
      }
      return enable;
    }
    -(BOOL)validateToolbarItem:(NSToolbarItem *)toolbarItem
    {
      BOOL enable = NO;
      if ([[toolbarItem itemIdentifier] isEqual:SaveDocToolbarItemIdentifier]) {
          // We will return YES (enable the save item)
          // only when the document is dirty and needs saving
          enable = [self isDocumentEdited];
      } else if ([[toolbarItem itemIdentifier] isEqual:NSToolbarPrintItemIdentifier]) {
          // always enable print for this window
          enable = YES;
      }
      return enable;
    }
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1524282-validatetoolbaritem
     */

  }, {
    key: 'validateToolbarItem',
    value: function validateToolbarItem(item) {
      return false;
    }

    /**
     * Retrieves an indexed object from the collection specified by the passed key.
     * @access public
     * @param {number} index - 
     * @param {string} key - 
     * @returns {?Object} - 
     * @desc  This actually works with a single-value key as well if index is 0. The method valueIn<Key>AtIndex: is used if it exists.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1407605-value
     */

  }, {
    key: 'valueAtInPropertyWithKey',
    value: function valueAtInPropertyWithKey(index, key) {
      return null;
    }

    /**
     * Returns the class of the value that will be returned for the specified binding.
     * @access public
     * @param {string} binding - The name of a binding.
     * @returns {?Object} - 
     * @desc This method is used by Interface Builder to determine the appropriate transformers for a binding. Implementation of this method is optional.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458101-valueclassforbinding
     */

  }, {
    key: 'valueClassForBinding',
    value: function valueClassForBinding(binding) {
      return null;
    }

    /**
     * Retrieves a named object from the collection specified by the passed key.
     * @access public
     * @param {string} name - 
     * @param {string} key - 
     * @returns {?Object} - 
     * @desc  The method valueIn<Key>WithName: is used if it exists. Otherwise, raises an NSUndefinedKeyException.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418031-value
     */

  }, {
    key: 'valueWithNameInPropertyWithKey',
    value: function valueWithNameInPropertyWithKey(name, key) {
      return null;
    }

    /**
     * Retrieves an object by ID from the collection specified by the passed key.
     * @access public
     * @param {Object} uniqueID - 
     * @param {string} key - 
     * @returns {?Object} - 
     * @desc  The method valueIn<Key>WithUniqueID: is invoked if it exists. Otherwise, raises an NSUndefinedKeyException. The declared type of uniqueID in the constructed method must be id, NSNumber *, NSString *, or one of the scalar types that can be encapsulated by NSNumber.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1407321-value
     */

  }, {
    key: 'valueWithUniqueIDInPropertyWithKey',
    value: function valueWithUniqueIDInPropertyWithKey(uniqueID, key) {
      return null;
    }

    /**
     * Returns the tool tip string to be displayed due to the cursor pausing at location point within the tool tip rectangle identified by tag in the view view.
     * @access public
     * @param {NSView} view - 
     * @param {NSToolTipTag} tag - 
     * @param {CGPoint} point - 
     * @param {?Object} data - 
     * @returns {string} - 
     * @desc  userData is additional information provided by the creator of the tool tip rectangle.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1483693-view
     */

  }, {
    key: 'viewStringForToolTipUserData',
    value: function viewStringForToolTipUserData(view, tag, point, data) {
      return '';
    }

    /**
     * Loads a URL into a web frame.
     * @access public
     * @param {!URLRequest} request - The request that specifies the URL.
     * @param {!string} target - The frame into which the URL is loaded.
     * @returns {void}
     * @desc If the frame specified by target is not found, a new window is opened, loaded with the URL request, and given the specified frame name. If target is nil, the frame enclosing the plug-in is loaded with the URL request.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1536649-webplugincontainerload
     */

  }, {
    key: 'webPlugInContainerLoadInFrame',
    value: function webPlugInContainerLoadInFrame(request, target) {}

    /**
     * Tells the container to show a status message.
     * @access public
     * @param {!string} message - The status message to be displayed.
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1537604-webplugincontainershowstatus
     */

  }, {
    key: 'webPlugInContainerShowStatus',
    value: function webPlugInContainerShowStatus(message) {}

    /**
     * Prepares the plug-in for deallocation.
     * @access public
     * @returns {void}
     * @desc Typically, this method frees the memory and other resources used by the plug-in. For example, if the plug-in had a copy of a WebPlugInContainer object, this method should relinquish ownership of that object. Do not send any other messages to the plug-in after invoking this method, because calling this method destroys the plug-in. No other methods in this interface may be called after the application has called this method.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1536659-webplugindestroy
     */

  }, {
    key: 'webPlugInDestroy',
    value: function webPlugInDestroy() {}

    /**
     * Initializes the plug-in.
     * @access public
     * @returns {void}
     * @desc Tells the plug-in to perform one-time initialization. This method must be called only once per instance of the plug-in object, before any other methods in the protocol are called.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1537623-webplugininitialize
     */

  }, {
    key: 'webPlugInInitialize',
    value: function webPlugInInitialize() {}

    /**
     * Invoked when an error occurs loading the main resource.
     * @access public
     * @param {!Error} error - An error object containing details of why the connection failed to load the request successfully.
     * @returns {void}
     * @desc This message is invoked when the underlying NSURLConnection object for the main resource sends the connection:didFailWithError: message to its delegate.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1536829-webpluginmainresourcedidfailwith
     */

  }, {
    key: 'webPlugInMainResourceDidFailWithError',
    value: function webPlugInMainResourceDidFailWithError(error) {}

    /**
     * Invoked when the connection successfully finishes loading data.
     * @access public
     * @returns {void}
     * @desc This message is invoked when the WebPlugInShouldLoadMainResourceKey plug-in command-line argument is set to false and the underlying NSURLConnection object for the main resource sends the connectionDidFinishLoading: message to its delegate.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1537693-webpluginmainresourcedidfinishlo
     */

  }, {
    key: 'webPlugInMainResourceDidFinishLoading',
    value: function webPlugInMainResourceDidFinishLoading() {}

    /**
     * Invoked when the connection receives sufficient data to construct the URL response for its request.
     * @access public
     * @param {!URLResponse} response - The URL response for the connection's request.
     * @returns {void}
     * @desc This message is invoked when the WebPlugInShouldLoadMainResourceKey plug-in command-line argument is set to false and the underlying NSURLConnection object for the main resource sends the connection:didReceiveResponse: message to its delegate.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1537895-webpluginmainresourcedidreceive
     */

  }, {
    key: 'webPlugInMainResourceDidReceive',
    value: function webPlugInMainResourceDidReceive(response) {}

    /**
     * Controls plug-in behavior based on its selection.
     * @access public
     * @param {boolean} isSelected - If true, the plug-in is currently selected. Otherwise, it is not selected.
     * @returns {void}
     * @desc This may be used, for example, to change the plug-in’s appearance when it is selected by the user.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1536477-webpluginsetisselected
     */

  }, {
    key: 'webPlugInSetIsSelected',
    value: function webPlugInSetIsSelected(isSelected) {}

    /**
     * Tells the plug-in to start normal operation.
     * @access public
     * @returns {void}
     * @desc The plug-in usually begins its primary task (such as drawing, playing sounds, or animating) in this method. This method may be called more than once, provided that the application has already called webPlugInInitialize() and that each call to this method is followed later by a call to webPlugInStop().
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1536197-webpluginstart
     */

  }, {
    key: 'webPlugInStart',
    value: function webPlugInStart() {}

    /**
     * Tells the plug-in to stop normal operation.
     * @access public
     * @returns {void}
     * @desc This method may be called more than once, provided that the application has already called webPlugInInitialize() and that each call to this method is preceded by a call to webPlugInStart().
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1536433-webpluginstop
     */

  }, {
    key: 'webPlugInStop',
    value: function webPlugInStop() {}

    /**
     * Invoked when the receiver's workflow encounters an error.
     * @access public
     * @param {AMWorkflowController} controller - The controller object sending the message.
     * @param {Error} error - If a workflow error occurs, upon return contains an instance of NSError that describes the problem.
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1419652-workflowcontroller
     */

  }, {
    key: 'workflowControllerDidError',
    value: function workflowControllerDidError(controller, error) {}

    /**
     * Invoked when an action in the receiver's workflow is finished running.
     * @access public
     * @param {AMWorkflowController} controller - The controller object sending the message.
     * @param {AMAction} action - The workflow action that ran.
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1419675-workflowcontroller
     */

  }, {
    key: 'workflowControllerDidRun',
    value: function workflowControllerDidRun(controller, action) {}

    /**
     * Invoked when an action in the receiver's workflow is about to run.
     * @access public
     * @param {AMWorkflowController} controller - The controller object sending the message.
     * @param {AMAction} action - The workflow action that will run.
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1419720-workflowcontroller
     */

  }, {
    key: 'workflowControllerWillRun',
    value: function workflowControllerWillRun(controller, action) {}

    /**
     * Tells the delegate that the workflow controller object has stopped.
     * @access public
     * @param {AMWorkflowController} controller - The workflow controller object that stopped.
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1419770-workflowcontrollerdidstop
     */

  }, {
    key: 'workflowControllerDidStop',
    value: function workflowControllerDidStop(controller) {}

    /**
     * Tells the delegate that the workflow controller object is about to stop.
     * @access public
     * @param {AMWorkflowController} controller - The workflow controller object to be stopped.
     * @returns {void}
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1419598-workflowcontrollerwillstop
     */

  }, {
    key: 'workflowControllerWillStop',
    value: function workflowControllerWillStop(controller) {}

    /**
     * Tells the element to activate itself and report the success or failure of the operation.
     * @access public
     * @returns {boolean} - 
     * @desc You can use this method to make complex controls more readily accessible to users. The accessibility system calls this method when a VoiceOver user double taps the selected element. Your implementation of this method should activate the element and perform whatever other tasks it deems appropriate. For example, you might use the method to activate a control that requires a complex gesture and would be difficult for VoiceOver users to perform, possibly because the gesture has a different meaning when VoiceOver is running.After performing any tasks, return an appropriate Boolean value to indicate success or failure.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615165-accessibilityactivate
     */

  }, {
    key: 'accessibilityActivate',
    value: function accessibilityActivate() {
      return false;
    }

    /**
     * 
     * @access public
     * @returns {?Set<String>} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615206-accessibilityassistivetechnology
     */

  }, {
    key: 'accessibilityAssistiveTechnologyFocusedIdentifiers',
    value: function accessibilityAssistiveTechnologyFocusedIdentifiers() {
      return null;
    }

    /**
     * Tells the accessibility element to decrement the value of its content.
     * @access public
     * @returns {void}
     * @desc If your element has the UIAccessibilityTraitAdjustable trait, you must implement this method. Use this method to decrement the value of the element. For example, a UISlider object uses this method to decrement its value by an appropriate amount. 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615169-accessibilitydecrement
     */

  }, {
    key: 'accessibilityDecrement',
    value: function accessibilityDecrement() {}

    /**
     * Returns the accessibility element at the specified index.
     * @access public
     * @param {number} index - The index of the accessibility element.
     * @returns {?Object} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615084-accessibilityelement
     */

  }, {
    key: 'accessibilityElementAt',
    value: function accessibilityElementAt(index) {
      return null;
    }

    /**
     * Returns the number of accessibility elements in the container.
     * @access public
     * @returns {number} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615149-accessibilityelementcount
     */

  }, {
    key: 'accessibilityElementCount',
    value: function accessibilityElementCount() {
      return 0;
    }

    /**
     * Sent after an assistive technology has set its virtual focus on the accessibility element.
     * @access public
     * @returns {void}
     * @desc Override accessibilityElementDidBecomeFocused if you need to know when an assistive technology has set its virtual focus on an accessibility element.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615183-accessibilityelementdidbecomefoc
     */

  }, {
    key: 'accessibilityElementDidBecomeFocused',
    value: function accessibilityElementDidBecomeFocused() {}

    /**
     * Sent after an assistive technology has removed its virtual focus from an accessibility element.
     * @access public
     * @returns {void}
     * @desc Override accessibilityElementDidLoseFocus if you need to know when an assistive technology has removed its virtual focus from an accessibility element. Note that accessibilityElementDidLoseFocus is sent before accessibilityElementDidBecomeFocused().
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615082-accessibilityelementdidlosefocus
     */

  }, {
    key: 'accessibilityElementDidLoseFocus',
    value: function accessibilityElementDidLoseFocus() {}

    /**
     * Returns a Boolean value indicating whether an assistive technology is focused on the accessibility element.
     * @access public
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615190-accessibilityelementisfocused
     */

  }, {
    key: 'accessibilityElementIsFocused',
    value: function accessibilityElementIsFocused() {
      return false;
    }

    /**
     * Tells the accessibility element to increment the value of its content.
     * @access public
     * @returns {void}
     * @desc If your element has the UIAccessibilityTraitAdjustable trait, you must implement this method. Use this method to increment the value of the element. For example, a UISlider object uses this method to increment its value by an appropriate amount. 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615076-accessibilityincrement
     */

  }, {
    key: 'accessibilityIncrement',
    value: function accessibilityIncrement() {}

    /**
     * Dismisses a modal view and returns the success or failure of the action.
     * @access public
     * @returns {boolean} - 
     * @desc Implement this method on an element or containing view that can be revealed modally or in a hierarchy. When a VoiceOver user performs a dismiss action, this method dismisses the view. For example, you might implement this method for a popover in order to give users a deliberate dismiss action to perform that closes the popover.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615091-accessibilityperformescape
     */

  }, {
    key: 'accessibilityPerformEscape',
    value: function accessibilityPerformEscape() {
      return false;
    }

    /**
     * Performs a salient action.
     * @access public
     * @returns {boolean} - 
     * @desc The exact action performed by this method depends your app, typically toggling the most important state of the app. For example, in the Phone app it answers and ends phone calls, in the Music app it plays and pauses playback, in the Clock app it starts and stops a timer, and in the Camera app it takes a picture.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615137-accessibilityperformmagictap
     */

  }, {
    key: 'accessibilityPerformMagicTap',
    value: function accessibilityPerformMagicTap() {
      return false;
    }

    /**
     * Scrolls screen content in an application-specific way and returns the success or failure of the action.
     * @access public
     * @param {UIAccessibilityScrollDirection} direction - A constant that specifies the direction of the scrolling action. See UIAccessibilityScrollDirection for descriptions of valid constants.
     * @returns {boolean} - 
     * @desc Implement this method if a view in the view hierarchy supports a scroll by page action.If the scrolling action succeeds for the specified direction, return true and post the UIAccessibilityPageScrolledNotification notification. If the scrolling action fails, accessibilityScroll: is called on a parent view in the hierarchy.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615161-accessibilityscroll
     */

  }, {
    key: 'accessibilityScroll',
    value: function accessibilityScroll(direction) {
      return false;
    }

    /**
     * Returns the index of the specified accessibility element.
     * @access public
     * @param {Object} element - The accessibility element.
     * @returns {number} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1615078-index
     */

  }, {
    key: 'indexOfAccessibilityElement',
    value: function indexOfAccessibilityElement(element) {
      return 0;
    }

    // Type Methods

    /**
     * Returns a Boolean value that indicates whether the observed object supports automatic key-value observation for the given key.
     * @access public
     * @param {string} key - 
     * @returns {boolean} - 
     * @desc The default implementation returns true. Starting in OS X 10.5, the default implementation of this method searches the receiving class for a method whose name matches the pattern +automaticallyNotifiesObserversOf<Key>, and returns the result of invoking that method if it is found. Any found methods must return BOOL. If no such method is found true is returned.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1409370-automaticallynotifiesobservers
     */

  }, {
    key: '_destroy',
    value: function _destroy() {
      if (this._destroyed) {
        throw new Error('_destroy() called twice');
      }
      this._destroyed = true;
      this._execDestroy();
    }
  }, {
    key: '_execDestroy',
    value: function _execDestroy() {
      // destroy objects
    }
  }, {
    key: 'autoContentAccessingProxy',


    // Discardable Content Proxy Support
    /**
     * A proxy for the receiving object
     * @type {Object}
     * @desc This property returns a proxy for the receiving object if the receiver adopts the NSDiscardableContent protocol and still has content that has not been discarded.The proxy calls beginContentAccess() on the receiver to keep the content available as long as the proxy lives, and calls endContentAccess() when the proxy is deallocated.The wrapper object is otherwise a subclass of NSProxy and forwards messages to the original receiver object as an NSProxy does.This method can be used to hide an NSDiscardableContent object's content volatility by creating an object that responds to the same messages but holds the contents of the original receiver available as long as the created proxy lives. Thus hidden, the NSDiscardableContent object (by way of the proxy) can be given out to unsuspecting recipients of the object who would otherwise not know they might have to call beginContentAccess() and endContentAccess() around particular usages (specific to each NSDiscardableContent object) of the NSDiscardableContent object.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1409224-autocontentaccessingproxy
     */
    get: function get() {
      return this._autoContentAccessingProxy;
    }
  }, {
    key: 'classForArchiver',

    /**
     * The class to substitute for the receiver's own class during archiving.
     * @type {?Object}
     * @desc 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411359-classforarchiver
     */
    get: function get() {
      return this._classForArchiver;
    }
    /**
     * Overridden by subclasses to substitute a class other than its own during coding.
     * @type {Object}
     * @desc This method is invoked by NSCoder. NSObject’s implementation returns the receiver’s class. The private subclasses of a class cluster substitute the name of their public superclass when being archived.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411876-classforcoder
     */

  }, {
    key: 'classForCoder',
    get: function get() {
      return this._classForCoder;
    }
    /**
     * Subclasses to substitute a new class for instances during keyed archiving.
     * @type {?Object}
     * @desc The object will be encoded as if it were a member of the class. This property is overridden by the encoder class and instance name to class encoding tables. If this property is nil, the result of this property is ignored.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1410512-classforkeyedarchiver
     */

  }, {
    key: 'classForKeyedArchiver',
    get: function get() {
      return this._classForKeyedArchiver;
    }
  }, {
    key: 'attributeKeys',
    get: function get() {
      return this._attributeKeys;
    }
    /**
     * An object containing information about the attributes and relationships of the receiver’s class.
     * @type {NSClassDescription}
     * @desc 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411858-classdescription
     */

  }, {
    key: 'classDescription',
    get: function get() {
      return this._classDescription;
    }
    /**
     * An array containing the keys for the to-many relationship properties of the receiver.
     * @type {string[]}
     * @desc 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1415662-tomanyrelationshipkeys
     */

  }, {
    key: 'toManyRelationshipKeys',
    get: function get() {
      return this._toManyRelationshipKeys;
    }
    /**
     * The keys for the to-one relationship properties of the receiver, if any.
     * @type {string[]}
     * @desc 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1414814-toonerelationshipkeys
     */

  }, {
    key: 'toOneRelationshipKeys',
    get: function get() {
      return this._toOneRelationshipKeys;
    }
  }, {
    key: 'classCode',
    get: function get() {
      return this._classCode;
    }

    /**
     * A string containing the name of the class.
     * @type {string}
     * @desc 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411337-classname
     */

  }, {
    key: 'className',
    get: function get() {
      return this.constructor._className;
    }

    /**
     * A string containing the name of the class.
     * @type {string}
     * @desc 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1411337-classname
     */

  }, {
    key: 'hashValue',
    get: function get() {
      return this._hashValue;
    }
    /**
     * The deepest descendant of the accessibility hierarchy that has the focus.
     * @type {?Object}
     * @desc You can assume that the search for the focus has already been narrowed down to the accessibility element. Override this method to do deeper searching by identifying which child element, if any, may have the focus. If a child element does not have the focus, either return self or, if available, invoke the superclass's implementation. The default NSView and NSCell implementations test whether the accessibility element is an ignored element and, if so, return the element’s first unignored parent; otherwise they return self
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1526100-accessibilityfocuseduielement
     */

  }, {
    key: 'accessibilityFocusedUIElement',
    get: function get() {
      return this._accessibilityFocusedUIElement;
    }
    /**
     * A Boolean value that indicates whether a custom accessibility object sends a notification when its corresponding UI element is destroyed.
     * @type {boolean}
     * @desc In macOS 10.9 and later, a custom accessibility object that is an NSObject subclass can post accessibility notifications if it meets the following criteria:The lifetime of the custom accessibility object must match the lifetime of the corresponding element in the app's UI.Typically, a custom accessibility object that acts as a proxy for an onscreen UI element gets autoreleased and deallocated immediately after the app responds to an accessibility request. Such an object can’t post accessibility notifications, because all registered observers get removed as soon as the object is deallocated. To correct this, an app must guarantee that a custom accessibility object remains allocated for as long as its corresponding UI element remains visible.The object must post the NSAccessibilityUIElementDestroyedNotification  notification at the appropriate time. The appropriate time is most likely to be when the corresponding UI element is removed from the screen, but it can also be when the object itself is deallocated. The object must implement accessibilityNotifiesWhenDestroyed and return true.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1534050-accessibilitynotifieswhendestroy
     */

  }, {
    key: 'accessibilityNotifiesWhenDestroyed',
    get: function get() {
      return this._accessibilityNotifiesWhenDestroyed;
    }
    /**
     * Returns an array containing the bindings exposed by the receiver.
     * @type {string[]}
     * @desc A subclass can override this method to remove bindings that are exposed by a superclass that are not appropriate for the subclass.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458048-exposedbindings
     */

  }, {
    key: 'exposedBindings',
    get: function get() {
      return this._exposedBindings;
    }
    /**
     * Returns an object that exposes the plug-in’s scripting interface.
     * @type {!Object}
     * @desc The methods of the object are exposed to the script environment. Messages sent to the returned object will be invoked in the scripting environment. See the WebScripting Protocol Reference informal protocol for more details.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1537612-objectforwebscript
     */

  }, {
    key: 'objectForWebScript',
    get: function get() {
      return this._objectForWebScript;
    }
    /**
     * Returns an object specifier for the receiver.
     * @type {?NSScriptObjectSpecifier}
     * @desc 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1409884-objectspecifier
     */

  }, {
    key: 'objectSpecifier',
    get: function get() {
      return this._objectSpecifier;
    }
    /**
     * Returns the WebFrame that contains the plug-in.
     * @type {!WebFrame}
     * @desc Only implemented by containers that are based on the WebKit’s plug-in architecture.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1537727-webframe
     */

  }, {
    key: 'webFrame',
    get: function get() {
      return this._webFrame;
    }
    /**
     * Returns the plug-in selection color.
     * @type {!CGColor}
     * @desc The color should be used for any special drawing when the plug-in is selected.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1536394-webplugincontainerselectioncolor
     */

  }, {
    key: 'webPlugInContainerSelectionColor',
    get: function get() {
      return this._webPlugInContainerSelectionColor;
    }
    /**
     * Returns a Boolean value that indicates whether the key-value coding methods should access the corresponding instance variable directly on finding no accessor method for a property.
     * @type {boolean}
     * @desc The default returns true. Subclasses can override it to return false, in which case the key-value coding methods won’t access instance variables.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1415307-accessinstancevariablesdirectly
     */

  }, {
    key: 'isSelectable',

    /**
     * 
     * @type {boolean}
     * @desc 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/2369549-isselectable
     */
    get: function get() {
      return this._isSelectable;
    }
  }], [{
    key: 'superclass',
    value: function superclass() {
      var superClass = Object.getPrototypeOf(this);
      if (superClass === Object.getPrototypeOf(Object)) {
        return null;
      }
      return superClass;
    }

    /**
     * Returns a Boolean value that indicates whether the receiving class is a subclass of, or identical to, a given class.
     * @access public
     * @param {Object} aClass - A class object.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418669-issubclass
     */

  }, {
    key: 'isSubclassOf',
    value: function isSubclassOf(aClass) {
      if (this.className === aClass.className) {
        return true;
      }

      var superClass = this.superclass();
      if (superClass === null) {
        return false;
      }
      if (superClass.className === aClass.className) {
        return true;
      }
      if (superClass.isSubclassOf(aClass)) {
        return true;
      }
      return false;
    }
  }, {
    key: 'instancesRespondTo',
    value: function instancesRespondTo(aSelector) {
      if (typeof this.prototype[aSelector] === 'function') {
        return true;
      }
      return false;
    }

    // Testing Protocol Conformance

    /**
     * Returns a Boolean value that indicates whether the receiver conforms to a given protocol.
     * @access public
     * @param {Object} protocol - 
     * @returns {boolean} - 
     * @desc A class is said to “conform to” a protocol if it adopts the protocol or inherits from another class that adopts it. Protocols are adopted by listing them within angle brackets after the interface declaration. For example, here MyClass adopts the (fictitious) AffiliationRequests and Normalization protocols:@interface MyClass : NSObject <AffiliationRequests, Normalization>
    A class also conforms to any protocols that are incorporated in the protocols it adopts or inherits. Protocols incorporate other protocols in the same way classes adopt them. For example, here the AffiliationRequests protocol incorporates the Joining protocol:@protocol AffiliationRequests <Joining>
    If a class adopts a protocol that incorporates another protocol, it must also implement all the methods in the incorporated protocol or inherit those methods from a class that adopts it.This method determines conformance solely on the basis of the formal declarations in header files, as illustrated above. It doesn’t check to see whether the methods declared in the protocol are actually implemented—that’s the programmer’s responsibility.The protocol required as this method’s argument can be specified using the @protocol() directive:BOOL canJoin = [MyClass conformsToProtocol:@protocol(Joining)];
    @interface MyClass : NSObject <AffiliationRequests, Normalization>
    @protocol AffiliationRequests <Joining>
    BOOL canJoin = [MyClass conformsToProtocol:@protocol(Joining)];
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1418893-conforms
     */

  }, {
    key: 'conformsTo',
    value: function conformsTo(protocol) {
      // TODO: implement
      return false;
    }
  }, {
    key: 'instanceMethodFor',
    value: function instanceMethodFor(aSelector) {
      return null;
    }

    // Describing Objects

    /**
     * Returns a string that represents the contents of the receiving class.
     * @access public
     * @returns {string} - 
     * @desc The debugger’s print-object command invokes this method to produce a textual description of an object.NSObject's implementation of this method simply prints the name of the class.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418799-description
     */

  }, {
    key: 'description',
    value: function description() {
      return this.className;
    }
  }, {
    key: 'cancelPreviousPerformRequestsWithTarget',
    value: function cancelPreviousPerformRequestsWithTarget(aTarget) {}

    /**
     * Cancels perform requests previously registered with perform(_:with:afterDelay:).
     * @access public
     * @param {Object} aTarget - The target for requests previously registered with the perform(_:with:afterDelay:) instance method
     * @param {function} aSelector - The Selector for requests previously registered with the perform(_:with:afterDelay:) instance method.
     * @param {?Object} anArgument - The argument for requests previously registered with the perform(_:with:afterDelay:) instance method. Argument equality is determined using isEqual(_:), so the value need not be the same object that was passed originally. Pass nil to match a request for nil that was originally passed as the argument.
     * @returns {void}
     * @desc All perform requests are canceled that have the same target as aTarget, argument as anArgument, and selector as aSelector. This method removes perform requests only in the current run loop, not all run loops.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1410849-cancelpreviousperformrequests
     */

  }, {
    key: 'cancelPreviousPerformRequestsWithTargetSelectorObject',
    value: function cancelPreviousPerformRequestsWithTargetSelectorObject(aTarget, aSelector, anArgument) {}
  }, {
    key: 'resolveClassMethod',
    value: function resolveClassMethod(sel) {
      return false;
    }

    /**
     * Dynamically provides an implementation for a given selector for an instance method.
     * @access public
     * @param {!function} sel - 
     * @returns {boolean} - 
     * @desc This method and resolveClassMethod(_:) allow you to dynamically provide an implementation for a given selector.An Objective-C method is simply a C function that take at least two arguments—self and _cmd. Using the class_addMethod(_:_:_:_:) function, you can add a function to a class as a method. Given the following function:void dynamicMethodIMP(id self, SEL _cmd)
    {
      // implementation ....
    }
    you can use resolveInstanceMethod: to dynamically add it to a class as a method (called resolveThisMethodDynamically) like this:+ (BOOL) resolveInstanceMethod:(SEL)aSEL
    {
      if (aSEL == @selector(resolveThisMethodDynamically))
      {
            class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
            return YES;
      }
      return [super resolveInstanceMethod:aSel];
    }
    Special ConsiderationsThis method is called before the Objective-C forwarding mechanism is invoked. If responds(to:) or instancesRespond(to:) is invoked, the dynamic method resolver is given the opportunity to provide an IMP for the given selector first.void dynamicMethodIMP(id self, SEL _cmd)
    {
      // implementation ....
    }
    + (BOOL) resolveInstanceMethod:(SEL)aSEL
    {
      if (aSEL == @selector(resolveThisMethodDynamically))
      {
            class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
            return YES;
      }
      return [super resolveInstanceMethod:aSel];
    }
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1418500-resolveinstancemethod
     */

  }, {
    key: 'resolveInstanceMethod',
    value: function resolveInstanceMethod(sel) {
      return false;
    }
  }, {
    key: 'classFallbacksForKeyedArchiver',
    value: function classFallbacksForKeyedArchiver() {
      return null;
    }

    /**
     * Overridden by subclasses to substitute a new class during keyed unarchiving.
     * @access public
     * @returns {Object} - 
     * @desc During keyed unarchiving, instances of the receiver will be decoded as members of the returned class. This method overrides the results of the decoder’s class and instance name to class encoding tables.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1410547-classforkeyedunarchiver
     */

  }, {
    key: 'classForKeyedUnarchiver',
    value: function classForKeyedUnarchiver() {
      return null;
    }
  }, {
    key: 'setVersion',
    value: function setVersion(aVersion) {}

    /**
     * Returns the version number assigned to the class.
     * @access public
     * @returns {number} - 
     * @desc If no version has been set, the default is 0. Version numbers are needed for decoding or unarchiving, so older versions of an object can be detected and decoded correctly.Caution should be taken when obtaining the version from within an NSCoding protocol or other methods. Use the class name explicitly when getting a class version number:version = [MyClass version];
    Don’t simply send version to the return value of class—a subclass version number may be returned instead.Special ConsiderationsThe version number applies to NSArchiver/NSUnarchiver, but not to NSKeyedArchiver/NSKeyedUnarchiver.  A keyed archiver does not encode class version numbers.version = [MyClass version];
      * @see https://developer.apple.com/documentation/objectivec/nsobject/1415151-version
     */

  }, {
    key: 'version',
    value: function version() {
      return 0;
    }
  }, {
    key: 'automaticallyNotifiesObserversForKey',
    value: function automaticallyNotifiesObserversForKey(key) {
      return false;
    }

    /**
     * 
     * @access public
     * @returns {string} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418711-debugdescription
     */

  }, {
    key: 'debugDescription',
    value: function debugDescription() {
      return '';
    }

    /**
     * 
     * @access public
     * @returns {number} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1418561-hash
     */

  }, {
    key: 'hash',
    value: function hash() {
      return 0;
    }

    /**
     * Returns a set of key paths for properties whose values affect the value of the specified key.
     * @access public
     * @param {string} key - The key whose value is affected by the key paths.
     * @returns {Set<String>} - 
     * @desc When an observer for the key is registered with an instance of the receiving class, key-value observing itself automatically observes all of the key paths for the same instance, and sends change notifications for the key to the observer when the value for any of those key paths changes.The default implementation of this method searches the receiving class for a method whose name matches the pattern +keyPathsForValuesAffecting<Key>, and returns the result of invoking that method if it is found. Any such method must return an NSSet. If no such method is found, an NSSet that is computed from information provided by previous invocations of the now-deprecated setKeys:triggerChangeNotificationsForDependentKey: method is returned, for backward binary compatibility.You can override this method when the getter method of one of your properties computes a value to return using the values of other properties, including those that are located by key paths. Your override should typically call super and return a set that includes any members in the set that result from doing that (so as not to interfere with overrides of this method in superclasses).NoteYou must not override this method when you add a computed property to an existing class using a category, overriding methods in categories is unsupported. In that case, implement a matching +keyPathsForValuesAffecting<Key> to take advantage of this mechanism.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1414299-keypathsforvaluesaffectingvalue
     */

  }, {
    key: 'keyPathsForValuesAffectingValueForKey',
    value: function keyPathsForValuesAffectingValueForKey(key) {
      return null;
    }

    /**
     * Returns an object that will be used as the placeholder for the binding, when a key value coding compliant property of an instance of the receiving class returns the value specified by marker, and no other placeholder has been specified. 
     * @access public
     * @param {?Object} marker - 
     * @param {string} binding - 
     * @returns {?Object} - 
     * @desc The marker can be nil or one of the constants described in Selection Markers.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458203-defaultplaceholder
     */

  }, {
    key: 'defaultPlaceholderForMarkerWithBinding',
    value: function defaultPlaceholderForMarkerWithBinding(marker, binding) {
      return null;
    }

    /**
     * Exposes the specified binding, advertising its availability. 
     * @access public
     * @param {string} binding - The key path for the property to be exposed.
     * @returns {void}
     * @desc The bound property will be accessed using key-value-coding compliant methods. This method is typically invoked in the class’s initialize implementation.Bindings exposed using exposeBinding will be exposed automatically in exposedBindings unless that method explicitly filters them out, for example in subclasses.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458184-exposebinding
     */

  }, {
    key: 'exposeBinding',
    value: function exposeBinding(binding) {}

    /**
     * Returns whether a key should be hidden from the scripting environment.
     * @access public
     * @param {!UnsafePointer<Int8>} name - The name of the attribute.
     * @returns {boolean} - 
     * @desc The default value is true.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1528545-iskeyexcluded
     */

  }, {
    key: 'isKeyExcludedFromWebScript',
    value: function isKeyExcludedFromWebScript(name) {
      return false;
    }

    /**
     * Returns whether a selector should be hidden from the scripting environment.
     * @access public
     * @param {!function} selector - 
     * @returns {boolean} - 
     * @desc Only methods with valid parameters and return types are exported to the WebKit JavaScript environment. The valid types are Objective-C objects and scalars. The default value is true.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1528532-isselectorexcluded
     */

  }, {
    key: 'isSelectorExcludedFromWebScript',
    value: function isSelectorExcludedFromWebScript(selector) {
      return false;
    }

    /**
     * Sets placeholder as the default placeholder for the binding, when a key value coding compliant property of an instance of the receiving class returns the value specified by marker, and no other placeholder has been specified.
     * @access public
     * @param {?Object} placeholder - 
     * @param {?Object} marker - 
     * @param {string} binding - 
     * @returns {void}
     * @desc The marker can be nil or one of the constants described in Selection Markers.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1458194-setdefaultplaceholder
     */

  }, {
    key: 'setDefaultPlaceholderForMarkerWithBinding',
    value: function setDefaultPlaceholderForMarkerWithBinding(placeholder, marker, binding) {}

    /**
     * Returns the scripting environment name for an attribute specified by a key.
     * @access public
     * @param {!UnsafePointer<Int8>} name - The name of the attribute.
     * @returns {!string} - 
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1528541-webscriptname
     */

  }, {
    key: 'webScriptNameForKey',
    value: function webScriptNameForKey(name) {
      return null;
    }

    /**
     * Returns the scripting environment name for a selector.
     * @access public
     * @param {!function} selector - 
     * @returns {!string} - 
     * @desc It is your responsibility to ensure that the returned name is unique to the script invoking this method. If this method returns nil or you do not implement it, the default name for the selector is constructed as follows: A colon (“:”) in the Objective-C selector is replaced by an underscore (“_”).An underscore in the Objective-C selector is prefixed with a dollar sign (“$”).A dollar sign in the Objective-C selector is prefixed with another dollar sign.The following table shows examples of how the default name is constructed:Objective-C selectorDefault script name for selectorsetFlag:setFlag_setFlag:forKey:withAttributes:setFlag_forKey_withAttributes_propertiesForExample_Object:propertiesForExample$_Object_set_$_forKey:withDictionary:set$_$$_$_forKey_withDictionary_Since the default construction for a method name can be confusing depending on its Objective-C name, you should implement this method and return a more human-readable name.Objective-C selectorDefault script name for selectorsetFlag:setFlag_setFlag:forKey:withAttributes:setFlag_forKey_withAttributes_propertiesForExample_Object:propertiesForExample$_Object_set_$_forKey:withDictionary:set$_$$_$_forKey_withDictionary_
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1528539-webscriptname
     */

  }, {
    key: 'webScriptNameFor',
    value: function webScriptNameFor(selector) {
      return null;
    }
  }, {
    key: 'initWithCoder',
    value: function initWithCoder(coder) {
      //console.log('initWithCoder: ' + this.className)
      var propTypes = {};

      // check if all property names are registered
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(coder._refObj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (key.charAt(0) === '$') {
            continue;
          }
          if (typeof this._propTypes[key] === 'undefined') {
            //console.warn(`unknown key ${key}`)
            if (this._propTypes.$unknownKey && this._propTypes.$unknownKey(key) !== null) {
              propTypes[key] = this._propTypes.$unknownKey(key
              //console.warn(`unknown key: ${key} => ${propTypes[key]}`)
              );
            } else {
              console.error(this.className + ': property ' + key + ' not registered');
              throw new Error(this.className + ': property ' + key + ' not registered');
            }
          } else {
            propTypes[key] = this._propTypes[key];
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var props = this._loadProperties(coder, propTypes);
      var propNames = props.names;
      var propValues = props.values;

      var instance = null;
      if (typeof this._propTypes.$constructor === 'function') {
        instance = this._propTypes.$constructor(propNames, propValues, coder);
      } else {
        instance = new this();
      }

      this._setProperties(instance, propNames, propValues, coder);

      return instance;
    }

    /**
     * @access private
     * @param {NSCoder} coder -
     * @param {Object} propTypes -
     * @returns {Object} -
     */

  }, {
    key: '_loadProperties',
    value: function _loadProperties(coder, propTypes) {
      var propNames = {};
      var propValues = {};

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = Object.keys(propTypes)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var key = _step2.value;

          //console.log(`key: ${key}`)
          if (!coder.containsValueForKey(key)) {
            console.log('!coder.containsValueForKey ' + key);
            continue;
          }
          var def = propTypes[key];
          var type = '';
          var propName = key;
          if (typeof def === 'string') {
            type = def;
          } else if (Array.isArray(def)) {
            type = def[0];
            if (def.length >= 2) {
              propName = def[1];
            }
          }

          //console.log(`type: ${type}, propName: ${propName}`)
          var value = null;
          switch (type) {
            case 'boolean':
              value = coder.decodeBoolForKey(key);
              break;
            case 'bytes':
              value = coder.decodeBytesForKeyReturnedLength(key, null);
              break;
            case 'double':
              value = coder.decodeDoubleForKey(key);
              break;
            case 'float':
              value = coder.decodeFloatForKey(key);
              break;
            case 'integer':
              value = coder.decodeCIntForKey(key);
              break;
            case 'int32':
              value = coder.decodeInt32ForKey(key);
              break;
            case 'int64':
              value = coder.decodeInt64ForKey(key);
              break;
            case 'point':
              value = coder.decodePointForKey(key);
              break;
            case 'rect':
              value = coder.decodeRectForKey(key);
              break;
            case 'size':
              value = coder.decodeSizeForKey(key);
              break;
            case 'plist':
              value = coder.decodePropertyListForKey(key);
              break;
            case 'string':
              value = coder.decodeObjectForKey(key);
              if (typeof value !== 'string') {
                //console.error(`${key}: value is not String type`)
                throw new Error(key + ': value is not String type');
              }
              break;
            default:
              {
                var classObj = _ClassList3.default.get(type);
                if (typeof classObj === 'undefined') {
                  //console.error(`unknown class name: ${type}`)
                  throw new Error('unknown class name: ' + type);
                }
                if (coder._refObj[key] instanceof Buffer) {
                  value = coder.decodeObjectOfTypeForKey(classObj, key);
                  if (!(value instanceof classObj)) {
                    //console.error(`${key}: value is not an instance of ${type}`)
                    throw new Error(key + ': value is not an instance of ' + type);
                  }
                } else {
                  value = coder.decodeObjectForKey(key);
                  if (value === '$null') {
                    value = null;
                  } else if (value instanceof Promise) {
                    // wait for loading
                  } else if (!(value instanceof classObj)) {
                    var exception = ['NSData', 'NSMutableData', // => Buffer
                    'NSArray', 'NSMutableArray', // => Array
                    'NSDictionary', 'NSMutableDictionary', // => Object
                    'NSColor', // => SKColor
                    'NSURL' // => String
                    ];
                    if (exception.indexOf(classObj.className) < 0) {
                      //console.error(`${key}: value is not an instance of ${type}`)
                      throw new Error(key + ': value is not an instance of ' + type);
                    }
                  }
                }
              }
          }
          //if(Array.isArray(value)){
          //  console.log(`value: Array[${value.length}]`)
          //}else if(typeof value === 'symbol'){
          //  console.log('value: Symbol()')
          //}else{
          //  console.log(`value: ${value}`)
          //}

          propValues[key] = value;
          propNames[key] = propName;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return { names: propNames, values: propValues };
    }

    /**
     * @access private
     * @param {Object} instance -
     * @param {string[]} propNames -
     * @param {Object[]} propValues -
     * @param {NSCoder} coder -
     * @returns {void}
     */

  }, {
    key: '_setProperties',
    value: function _setProperties(instance, propNames, propValues, coder) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = Object.keys(propValues)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var key = _step3.value;

          this._setProperty(instance, propNames[key], propValues[key], key, coder);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    /**
     * @access private
     * @param {Object} instance -
     * @param {string[]} propName -
     * @param {Object[]} propValue -
     * @param {string} key -
     * @param {NSCoder} coder -
     * @returns {void}
     */

  }, {
    key: '_setProperty',
    value: function _setProperty(instance, propName, propValue, key, coder) {
      var _this = this;

      if (propValue instanceof Promise) {
        propValue.then(function (loadedValue) {
          _this._setProperty(instance, propName, loadedValue, key, coder);
        });
      } else if (typeof propName === 'function') {
        propName(instance, propValue, key, coder);
      } else if (propName !== null) {
        instance[propName] = propValue;
      }
    }
  }, {
    key: 'className',
    get: function get() {
      return this.prototype.constructor._className;
    }
  }, {
    key: 'accessInstanceVariablesDirectly',
    get: function get() {
      return true;
    }
  }, {
    key: 'supportsSecureCoding',
    get: function get() {
      return true;
    }
  }]);

  return NSObject;
}();

exports.default = NSObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21).Buffer))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNVector = __webpack_require__(11);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A representation of a three-component vector.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scnvector3
 */
var SCNVector3 = function () {

  // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @param {number} x - 
   * @param {number} y - 
   * @param {number} z - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnvector3/1522904-init
   */
  function SCNVector3() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, SCNVector3);

    // Instance Properties
    /** @type {number} */
    this.x = x;
    /** @type {number} */
    this.y = y;
    /** @type {number} */
    this.z = z;

    //if(x instanceof Ammo.btVector3){
    //  this.x = x.x()
    //  this.y = x.y()
    //  this.z = x.z()
    //}
  }

  /**
   * @access private
   * @param {Buffer} data -
   * @param {number} [offset = 0] -
   * @param {boolean} [bigEndian = false] -
   * @returns {SCNVector3} -
   */


  _createClass(SCNVector3, [{
    key: '_copy',
    value: function _copy() {
      return new SCNVector3(this.x, this.y, this.z);
    }
  }, {
    key: '_copyFrom',
    value: function _copyFrom(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
    }

    // extensions

  }, {
    key: 'zero',
    value: function zero() {
      return new SCNVector3();
    }

    /**
     * @access public
     * @param {SCNVector3} v -
     * @returns {SCNVector3} -
     */

  }, {
    key: 'add',
    value: function add(v) {
      var r = new SCNVector3();
      r.x = this.x + v.x;
      r.y = this.y + v.y;
      r.z = this.z + v.z;
      return r;
    }

    /**
     * @access public
     * @param {SCNVector3} v -
     * @returns {SCNVector3} -
     */

  }, {
    key: 'sub',
    value: function sub(v) {
      var r = new SCNVector3();
      r.x = this.x - v.x;
      r.y = this.y - v.y;
      r.z = this.z - v.z;
      return r;
    }

    /**
     * @access public
     * @param {number} n -
     * @returns {SCNVector3} -
     */

  }, {
    key: 'mul',
    value: function mul(n) {
      var r = new SCNVector3();
      r.x = this.x * n;
      r.y = this.y * n;
      r.z = this.z * n;
      return r;
    }

    /**
     * @access public
     * @param {SCNVector3} v -
     * @returns {SCNVector3}
     */

  }, {
    key: 'mulv',
    value: function mulv(v) {
      var r = new SCNVector3();
      r.x = this.x * v.x;
      r.y = this.y * v.y;
      r.z = this.z * v.z;
      return r;
    }

    /**
     * @access public
     * @param {SCNVector3} v -
     * @returns {number} -
     */

  }, {
    key: 'dot',
    value: function dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    }

    /**
     * @access public
     * @param {SCNVecor3} v -
     * @returns {SCNVector3} -
     */

  }, {
    key: 'cross',
    value: function cross(v) {
      var r = new SCNVector3();
      r.x = this.y * v.z - this.z * v.y;
      r.y = this.z * v.x - this.x * v.z;
      r.z = this.x * v.y - this.y * v.x;
      return r;
    }

    /**
     * @access public
     * @param {SCNVector3} v -
     * @param {number} rate -
     * @returns {SCNVector3} -
     */

  }, {
    key: 'lerp',
    value: function lerp(v, rate) {
      var r = new SCNVector3();
      r.x = this.x + rate * (v.x - this.x);
      r.y = this.y + rate * (v.y - this.y);
      r.z = this.z + rate * (v.z - this.z);
      return r;
    }

    /**
     * @access public
     * @returns {SCNVector3} -
     */

  }, {
    key: 'normalize',
    value: function normalize() {
      var len = this.length();
      var r = new SCNVector3();
      if (len === 0) {
        return r;
      }
      var sqr = 1.0 / len;
      r.x = this.x * sqr;
      r.y = this.y * sqr;
      r.z = this.z * sqr;

      return r;
    }

    /**
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'length2',
    value: function length2() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }

    /**
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'length',
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }

    /**
     * @access public
     * @param {SCNMatrix4} m -
     * @returns {SCNVector3} -
     */

  }, {
    key: 'transform',
    value: function transform(m) {
      var r = new SCNVector3();
      var w = this.x * m.m14 + this.y * m.m24 + this.z * m.m34 + m.m44;
      if (w === 0) {
        return r;
      }
      var iw = 1.0 / w;
      r.x = (this.x * m.m11 + this.y * m.m21 + this.z * m.m31 + m.m41) * iw;
      r.y = (this.x * m.m12 + this.y * m.m22 + this.z * m.m32 + m.m42) * iw;
      r.z = (this.x * m.m13 + this.y * m.m23 + this.z * m.m33 + m.m43) * iw;
      return r;
    }

    /**
     * @access public
     * @param {SCNMatrix4} m -
     * @returns {SCNVector3} -
     */

  }, {
    key: 'rotate',
    value: function rotate(m) {
      var r = new SCNVector3();
      r.x = this.x * m.m11 + this.y * m.m21 + this.z * m.m31;
      r.y = this.x * m.m12 + this.y * m.m22 + this.z * m.m32;
      r.z = this.x * m.m13 + this.y * m.m23 + this.z * m.m33;
      return r;
    }

    /**
     * @access public
     * @param {SCNVector4} q -
     * @returns {SCNVector3} -
     */

  }, {
    key: 'rotateWithQuaternion',
    value: function rotateWithQuaternion(q) {
      return this.rotate(q.rotMatrix());
    }

    /**
     * @access public
     * @returns {SCNVector4} -
     */

  }, {
    key: 'eulerAnglesToRotation',
    value: function eulerAnglesToRotation() {
      var rot = new _SCNVector2.default();
      var halfX = this.x * 0.5;
      var halfY = this.y * 0.5;
      var halfZ = this.z * 0.5;
      var cosX = Math.cos(halfX);
      var sinX = Math.sin(halfX);
      var cosY = Math.cos(halfY);
      var sinY = Math.sin(halfY);
      var cosZ = Math.cos(halfZ);
      var sinZ = Math.sin(halfZ);

      var q = new _SCNVector2.default();
      var x = sinX * cosY * cosZ - cosX * sinY * sinZ;
      var y = cosX * sinY * cosZ + sinX * cosY * sinZ;
      var z = cosX * cosY * sinZ - sinX * sinY * cosZ;
      var d = x * x + y * y + z * z;
      if (d === 0) {
        rot.x = 0;
        rot.y = 0;
        rot.z = 0;
        rot.w = 0;
      } else {
        var r = 1.0 / Math.sqrt(d);
        rot.x = x * r;
        rot.y = y * r;
        rot.z = z * r;
        rot.w = 2 * Math.acos(cosX * cosY * cosZ + sinX * sinY * sinZ);
      }

      return rot;
    }

    /**
     * @access public
     * @returns {SCNVector4} -
     */

  }, {
    key: 'eulerAnglesToQuat',
    value: function eulerAnglesToQuat() {
      return this.eulerAnglesToRotation().rotationToQuat();
    }

    /**
     * @access public
     * @returns {number[]} -
     */

  }, {
    key: 'floatArray',
    value: function floatArray() {
      return [this.x, this.y, this.z];
    }

    /**
     * @access public
     * @returns {Float32Array} -
     */

  }, {
    key: 'float32Array',
    value: function float32Array() {
      return new Float32Array([this.x, this.y, this.z]);
    }

    /**
     * @access private
     * @returns {Ammo.btVector3} -
     * @desc call Ammo.destroy(vec) after using it.
     */

  }, {
    key: '_createBtVector3',
    value: function _createBtVector3() {
      //return new Ammo.btVector3(this.x, this.y, this.z)
    }
  }], [{
    key: '_initWithData',
    value: function _initWithData(data) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var bigEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var instance = new SCNVector3();
      if (bigEndian) {
        instance.x = data.readFloatBE(offset + 0);
        instance.y = data.readFloatBE(offset + 4);
        instance.z = data.readFloatBE(offset + 8);
      } else {
        instance.x = data.readFloatLE(offset + 0);
        instance.y = data.readFloatLE(offset + 4);
        instance.z = data.readFloatLE(offset + 8);
      }
      return instance;
    }
  }]);

  return SCNVector3;
}();

exports.default = SCNVector3;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import NSColorSpaceModel from '../AppKit/NSColorSpaceModel'

/**
 * An object that stores color data and sometimes opacity (that is, alpha value). 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/uikit/uicolor
 */
var SKColor = function (_NSObject) {
  _inherits(SKColor, _NSObject);

  _createClass(SKColor, null, [{
    key: '_initWithData',


    /**
     * @access private
     * @param {Buffer} data -
     * @param {number} [offset = 0] -
     * @param {boolean} [bigEndian = false] -
     * @returns {SKColor}
     */
    value: function _initWithData(data) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var bigEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var instance = new SKColor();
      if (bigEndian) {
        instance.red = data.readFloatBE(offset + 0);
        instance.green = data.readFloatBE(offset + 4);
        instance.blue = data.readFloatBE(offset + 8);
        instance.alpha = data.readFloatBE(offset + 12);
      } else {
        instance.red = data.readFloatLE(offset + 0);
        instance.green = data.readFloatLE(offset + 4);
        instance.blue = data.readFloatLE(offset + 8);
        instance.alpha = data.readFloatLE(offset + 12);
      }
      return instance;
    }

    // Initializers

    /**
     * 
     * @access public
     * @constructor
     * @param {number} red - 
     * @param {number} green - 
     * @param {number} blue - 
     * @param {number} alpha - 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1625015-init
     */

  }, {
    key: '_propTypes',
    get: function get() {
      return {
        $constructor: function $constructor(propNames, propValues) {
          if (typeof propValues.NSColorSpace !== 'undefined') {
            // initialize for NSColor
            /*
            const buf = propValues.NSRGB || propValues.NSWhite
            const ascii = buf.toString('ascii')
            const values = ascii.split(' ')
            const space = propValues.NSColorSpace - 1
            switch(space){
              case NSColorSpaceModel.gray:
                break
              case NSColorSpaceModel.RGB: {
                const r = parseFloat(values[0])
                const g = parseFloat(values[1])
                const b = parseFloat(values[2])
                const a = 1.0
                console.log(`NSColor -> SKColor: r:${r} g:${g} b:${b} a:${a}`)
                return new SKColor(r, g, b, a)
              }
              case NSColorSpaceModel.CMYK:
                if(propValues.NSWhite){
                  const w = parseFloat(values[0])
                  return new SKColor(w, w, w, 1.0)
                }
                break
              case NSColorSpaceModel.LAB:
                break
              case NSColorSpaceModel.deviceN:
                break
              case NSColorSpaceModel.indexed:
                break
              case NSColorSpaceModel.patterned:
                break
            }
            console.error(`unknown color space: ${propValues.NSColorSpace}`)
            throw new Error(`unknown color space: ${propValues.NSColorSpace}`)
            */
            if (typeof propValues.NSRGB !== 'undefined') {
              var ascii = propValues.NSRGB.toString('ascii');
              var values = ascii.split(' ');
              var r = parseFloat(values[0]);
              var g = parseFloat(values[1]);
              var b = parseFloat(values[2]);
              var a = 1.0;
              //console.log(`NSColor -> SKColor NSRGB: r:${r} g:${g} b:${b} a:${a}`)
              //if(propValues.NSColorSpace === 1){
              //  return new SKColor(1, 1, 1, 1)
              //}
              return new SKColor(r, g, b, a);
            } else if (typeof propValues.NSWhite !== 'undefined') {
              var _ascii = propValues.NSWhite.toString('ascii');
              var _values = _ascii.split(' ');
              var w = parseFloat(_values[0]);
              var _a = 1.0;
              //console.log(`NSColor -> SKColor NSWhite: r:${w} g:${w} b:${w} a:${a}`)
              return new SKColor(w, w, w, _a);
            }

            console.error('unknown color space');
            throw new Error('unknown color space');
          }

          // TODO: implement
          return new SKColor();
        },
        // for NSColor
        NSRGB: ['bytes', null],
        NSWhite: ['bytes', null],
        NSComponents: ['bytes', null],
        NSColorSpace: ['integer', null],
        NSCustomColorSpace: ['NSColorSpace', null]
      };
    }
  }]);

  function SKColor(red, green, blue, alpha) {
    _classCallCheck(this, SKColor);

    /**
     * @type {number}
     */
    var _this = _possibleConstructorReturn(this, (SKColor.__proto__ || Object.getPrototypeOf(SKColor)).call(this));

    _this.red = red;

    /**
     * @type {number}
     */
    _this.green = green;

    /**
     * @type {number}
     */
    _this.blue = blue;

    /**
     * @type {number}
     */
    _this.alpha = alpha;
    return _this;
  }

  // Creating a Color Object with a Predefined Color

  /**
   * A color object in the sRGB color space whose grayscale value is 0.0 and whose alpha value is 1.0.
   * @type {SKColor}
   * @desc 
   * @see https://developer.apple.com/documentation/uikit/uicolor/1621929-black
   */


  _createClass(SKColor, [{
    key: 'withAlphaComponent',


    // Creating a Custom UIColor Object in a Specific Color Space

    /**
     * Initializes and returns a color object using the specified opacity and grayscale values. 
     * @access public
     * @param {number} white - The grayscale value of the color object. On applications linked for iOS 10 or later, the color is specified in an extended color space, and the input value  is never clamped. On earlier versions of iOS, white values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.
     * @param {number} alpha - The opacity value of the color object, specified as a value from 0.0 to 1.0. Alpha values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0
     * @returns {void}
     * @desc On applications linked on iOS 10 or later, the input parameters are not clamped. On earlier versions of iOS, values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621944-init
     */
    //init(white, alpha) {
    //}

    // Creating a UIColor Object from another Representation of Color

    /**
     * Creates and returns a color object that has the same color space and component values as the receiver, but has the specified alpha component. 
     * @access public
     * @param {number} alpha - The opacity value of the new color object, specified as a value from 0.0 to 1.0. Alpha values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0
     * @returns {SKColor} - 
     * @desc A subclass with explicit opacity components should override this method to return a color with the specified alpha.
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621922-withalphacomponent
     */
    value: function withAlphaComponent(alpha) {
      return new SKColor(this.red, this.green, this.blue, alpha);
    }

    // Creating a UIColor Object that Draws Using a Pattern

    /**
     * Initializes and returns a color object using the specified Quartz color reference. 
     * @access public
     * @param {Image} image - The image to use when creating the pattern color. 
     * @returns {void}
     * @desc You can use pattern colors to set the fill or stroke color just as you would a solid color. During drawing, the image in the pattern color is tiled as necessary to cover the given area. By default, the phase of the returned color is 0, which causes the top-left corner of the image to be aligned with the drawing origin. To change the phase, make the color the current color and then use the setPatternPhase(_:) function to change the phase.
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621933-init
     */

  }, {
    key: 'initPatternImage',
    value: function initPatternImage(image) {}

    // Setting the Graphics Context’s Drawing Color

    /**
     * Sets the color of subsequent stroke and fill operations to the color that the receiver represents. 
     * @access public
     * @returns {void}
     * @desc If you subclass UIColor, you must implement this method in your subclass. Your custom implementation should modify both the stroke and fill color in the current graphics context by setting them both to the color represented by the receiver.
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621928-set
     */

  }, {
    key: 'set',
    value: function set() {}

    /**
     * Sets the color of subsequent fill operations to the color that the receiver represents.
     * @access public
     * @returns {void}
     * @desc If you subclass UIColor, you must implement this method in your subclass. Your custom implementation should modify the fill color in the current graphics context by setting it to the color represented by the receiver.
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621926-setfill
     */

  }, {
    key: 'setFill',
    value: function setFill() {}

    /**
     * Sets the color of subsequent stroke operations to the color that the receiver represents.
     * @access public
     * @returns {void}
     * @desc If you subclass UIColor, you must implement this method in your subclass. Your custom implementation should modify the stroke color in the current graphics context by setting it to the color represented by the receiver.
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621948-setstroke
     */

  }, {
    key: 'setStroke',
    value: function setStroke() {}

    // Retrieving Color Information

    /**
     * Returns the components that make up the color in the HSB color space.
     * @access public
     * @returns {Object} -
     * @property {number} color.hue - On return, the hue component of the color object. On applications linked for iOS 10 or later, the hue component is specified in an extended range color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
     * @property {number} color.saturation - On return, the saturation component of the color object. On applications linked for iOS 10 or later, the saturation component is specified in an extended range color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
     * @property {number} color.brightness - On return, the brightness component of the color object. On applications linked for iOS 10 or later, the brightness component is specified in an extended range color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
     * @property {number} color.alpha - On return, the opacity component of the color object, specified as a value between 0.0 and 1.0.
     * @desc If the color is in a compatible color space, the color is converted into the HSB color space and its components are returned to your application. If the color is not in a compatible color space, the parameters are unchanged.
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621949-gethue
     */

  }, {
    key: 'getHSBA',
    value: function getHSBA() {
      // TODO: implement
      var color = {
        hue: 0,
        saturation: 0,
        brightness: 0,
        alpha: 0
      };
      return color;
    }

    /**
     * Returns the components that make up the color in the RGB color space.
     * @access public
     * @param {number} red -
     * @param {number} green -
     * @param {number} blue -
     * @param {number} alpha -
     * @returns {Object} -
     * @property {number} color.red - On return, the red component of the color object. On applications linked for iOS 10 or later, the red component is specified in an extended range sRGB color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
     * @property {number} color.green - On return, the green component of the color object. On applications linked for iOS 10 or later, the green component is specified in an extended range sRGB color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
     * @property {number} color.blue - On return, the blue component of the color object. On applications linked for iOS 10 or later, the blue component is specified in an extended range sRGB color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
     * @property {number} color.alpha - On return, the opacity component of the color object, specified as a value between 0.0 and 1.0.
     * @desc If the color is in a compatible color space, the color is converted into RGB format and its components are returned to your application. If the color is not in a compatible color space, the parameters are unchanged.
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621919-getred
     */

  }, {
    key: 'getRGBA',
    value: function getRGBA(red, green, blue, alpha) {
      var color = {
        red: this.red,
        green: this.green,
        blue: this.blue,
        alpha: this.alpha
      };
      return color;
    }

    /**
     * Returns the grayscale components of the color.
     * @access public
     * @param {?UnsafeMutablePointer<CGFloat>} white - On return, the grayscale component of the color object. On applications linked for iOS 10 or later, the grayscale component is specified in an extended range gray color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
     * @param {?UnsafeMutablePointer<CGFloat>} alpha - On return, the opacity component of the color object, specified as a value between 0.0 and 1.0.
     * @returns {boolean} - 
     * @desc If the color is in a compatible color space, the color is converted into grayscale format and returned to your application. If the color is not in a compatible color space, the parameters are unchanged.
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621927-getwhite
     */
    //getWhite(white, alpha) {
    //  return false
    //}

    /**
     * HTML color representation
     * @access public
     * @type {string}
     */

  }, {
    key: '_copy',


    /**
     * @access private
     * @returns {SKColor} -
     */
    value: function _copy() {
      return new SKColor(this.red, this.green, this.blue, this.alpha);
    }

    /**
     * @access private
     * @param {SKColor} c -
     * @param {number} rate -
     * @returns {SKColor} -
     */

  }, {
    key: '_lerp',
    value: function _lerp(c, rate) {
      var r = new SKColor();
      r.red = this.red + rate * (c.red - this.red);
      r.green = this.green + rate * (c.green - this.green);
      r.blue = this.blue + rate * (c.blue - this.blue);
      r.alpha = this.alpha + rate * (c.alpha - this.alpha);
      return r;
    }
  }, {
    key: 'zero',
    value: function zero() {
      return new SKColor(0, 0, 0, 0);
    }

    /**
     * @access public
     * @param {SKColor} c -
     * @returns {SKColor} -
     */

  }, {
    key: 'add',
    value: function add(c) {
      var r = new SKColor();
      r.red = this.red + c.red;
      r.green = this.green + c.green;
      r.blue = this.blue + c.blue;
      r.alpha = this.alpha + c.alpha;
      return r;
    }

    /**
     * @access public
     * @param {SKColor} c -
     * @returns {SKColor} -
     */

  }, {
    key: 'sub',
    value: function sub(c) {
      var r = new SKColor();
      r.red = this.red - c.red;
      r.green = this.green - c.green;
      r.blue = this.blue - c.blue;
      r.alpha = this.alpha - c.alpha;
      return r;
    }

    /**
     * @access private
     * @param {number} val -
     * @returns {number} -
     */

  }, {
    key: '_srgbToLinear',
    value: function _srgbToLinear(val) {
      if (val <= 0.04045) {
        return val / 12.92;
      }
      return Math.pow((val + 0.055) / 1.055, 2.4);
    }

    /**
     * @access private
     * @param {number} val -
     * @returns {number} -
     */

  }, {
    key: '_linearToSrgb',
    value: function _linearToSrgb(val) {
      if (val <= 0.0031308) {
        return val * 12.92;
      }
      return 1.055 * Math.pow(val, 1.0 / 2.4);
    }

    /**
     * @access public
     * @returns {SKColor} -
     */

  }, {
    key: 'srgbToLinear',
    value: function srgbToLinear() {
      var r = new SKColor();
      r.red = this._srgbToLinear(this.red);
      r.green = this._srgbToLinear(this.green);
      r.blue = this._srgbToLinear(this.blue);
      r.alpha = this.alpha;
      return r;
    }

    /**
     * @access public
     * @returns {SKColor} -
     */

  }, {
    key: 'linearToSrgb',
    value: function linearToSrgb() {
      var r = new SKColor();
      r.red = this._linearToSrgb(this.red);
      r.green = this._linearToSrgb(this.green);
      r.blue = this._linearToSrgb(this.blue);
      r.alpha = this.alpha;
      return r;
    }

    /**
     * @access public
     * @returns {number[]} -
     */

  }, {
    key: 'floatArray',
    value: function floatArray() {
      return [this.red, this.green, this.blue, this.alpha];
    }

    /**
     * @access public
     * @returns {Float32Array} -
     */

  }, {
    key: 'float32Array',
    value: function float32Array() {
      return new Float32Array([this.red, this.green, this.blue, this.alpha]);
    }
  }, {
    key: 'htmlColor',
    get: function get() {
      var r = Math.round(this.red * 255);
      var g = Math.round(this.green * 255);
      var b = Math.round(this.blue * 255);
      return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + this.alpha + ')';
    }

    /**
     * HTML color representation
     * @access public
     * @type {string}
     */

  }, {
    key: 'hexColor',
    get: function get() {
      var r = Math.round(this.red * 255).toString(16);
      var g = Math.round(this.green * 255).toString(16);
      var b = Math.round(this.blue * 255).toString(16);
      return '#' + r + g + b;
    }
  }], [{
    key: 'black',
    get: function get() {
      return new SKColor(0.0, 0.0, 0.0, 1.0);
    }

    /**
     * A color object whose RGB values are 0.0, 0.0, and 1.0 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621947-blue
     */

  }, {
    key: 'blue',
    get: function get() {
      return new SKColor(0.0, 0.0, 1.0, 1.0);
    }

    /**
     * A color object whose RGB values are 0.6, 0.4, and 0.2 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621950-brown
     */

  }, {
    key: 'brown',
    get: function get() {
      return new SKColor(0.6, 0.4, 0.2, 1.0);
    }

    /**
     * A color object whose grayscale and alpha values are both 0.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621945-clear
     */

  }, {
    key: 'clear',
    get: function get() {
      return new SKColor(0.0, 0.0, 0.0, 0.0);
    }

    /**
     * A color object whose RGB values are 0.0, 1.0, and 1.0 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621942-cyan
     */

  }, {
    key: 'cyan',
    get: function get() {
      return new SKColor(0.0, 1.0, 1.0, 1.0);
    }

    /**
     * A color object whose grayscale value is 1/3 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621952-darkgray
     */

  }, {
    key: 'darkGray',
    get: function get() {
      var third = 1.0 / 3.0;
      return new SKColor(third, third, third, 1.0);
    }

    /**
     * A color object whose grayscale value is 0.5 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621941-gray
     */

  }, {
    key: 'gray',
    get: function get() {
      return new SKColor(0.5, 0.5, 0.5, 1.0);
    }

    /**
     * A color object whose RGB values are 0.0, 1.0, and 0.0 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621946-green
     */

  }, {
    key: 'green',
    get: function get() {
      return new SKColor(0.0, 1.0, 0.0, 1.0);
    }

    /**
     * A color object whose grayscale value is 2/3 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621932-lightgray
     */

  }, {
    key: 'lightGray',
    get: function get() {
      var twoThirds = 2.0 / 3.0;
      return new SKColor(twoThirds, twoThirds, twoThirds, 1.0);
    }

    /**
     * A color object whose RGB values are 1.0, 0.0, and 1.0 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621934-magenta
     */

  }, {
    key: 'magenta',
    get: function get() {
      return new SKColor(1.0, 0.0, 1.0, 1.0);
    }

    /**
     * A color object whose RGB values are 1.0, 0.5, and 0.0 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621956-orange
     */

  }, {
    key: 'orange',
    get: function get() {
      return new SKColor(1.0, 0.5, 0.0, 1.0);
    }

    /**
     * A color object whose RGB values are 0.5, 0.0, and 0.5 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621923-purple
     */

  }, {
    key: 'purple',
    get: function get() {
      return new SKColor(0.5, 0.0, 0.5, 1.0);
    }

    /**
     * A color object whose RGB values are 1.0, 0.0, and 0.0 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621924-red
     */

  }, {
    key: 'red',
    get: function get() {
      return new SKColor(1.0, 0.0, 0.0, 1.0);
    }

    /**
     * A color object whose grayscale value is 1.0 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621920-white
     */

  }, {
    key: 'white',
    get: function get() {
      return new SKColor(1.0, 1.0, 1.0, 1.0);
    }

    /**
     * A color object whose RGB values are 1.0, 1.0, and 0.0 and whose alpha value is 1.0.
     * @type {SKColor}
     * @desc 
     * @see https://developer.apple.com/documentation/uikit/uicolor/1621953-yellow
     */

  }, {
    key: 'yellow',
    get: function get() {
      return new SKColor(1.0, 1.0, 0.0, 1.0);
    }
  }]);

  return SKColor;
}(_NSObject3.default);

exports.default = SKColor;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var _InstanceOf = function _InstanceOf(instance, aClass) {
  return instance && instance.isInstanceOf && instance.isInstanceOf(aClass);
};
exports.default = _InstanceOf;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _CAMediaTimingFunction = __webpack_require__(47);

var _CAMediaTimingFunction2 = _interopRequireDefault(_CAMediaTimingFunction);

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _CGRect = __webpack_require__(16);

var _CGRect2 = _interopRequireDefault(_CGRect);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _SCNVector3 = __webpack_require__(11);

var _SCNVector4 = _interopRequireDefault(_SCNVector3);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

var _constants = __webpack_require__(25);

var Constants = _interopRequireWildcard(_constants);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNAudioSource from './SCNAudioSource'
//import SCNNode from './SCNNode'

//import SCNActionTimingFunction from './SCNActionTimingFunction'
//import SCNActionRotate from './SCNActionRotate'
//import SCNActionSequence from './SCNActionSequence'
//import SCNActionRepeat from './SCNActionRepeat'
//import SCNActionGroup from './SCNActionGroup'
//import SCNActionFade from './SCNActionFade'
//import SCNActionPlaySound from './SCNActionPlaySound'
//import SCNActionJavaScript from './SCNActionJavaScript'
//import SCNActionRunBlock from './SCNActionRunBlock'
//import SCNActionReference from './SCNActionReference'
//import SCNActionCustom from './SCNActionCustom'
//import SCNActionWait from './SCNActionWait'
//import SCNActionRemove from './SCNActionRemove'
//import SCNActionPerformSelector from './SCNActionPerformSelector'
//import SCNActionScale from './SCNActionScale'
//import SCNActionMove from './SCNActionMove'
//import SCNActionHide from './SCNActionHide'
//import SCNActionRunAction from './SCNActionRunAction'


/**
 * A simple, reusable animation that changes attributes of any node you attach it to.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnaction
 */
var SCNAction = function (_NSObject) {
  _inherits(SCNAction, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNAction() {
    _classCallCheck(this, SCNAction);

    // Adjusting an Action’s Animation Properties

    /**
     * The duration required to complete an action.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1524162-duration
     */
    var _this = _possibleConstructorReturn(this, (SCNAction.__proto__ || Object.getPrototypeOf(SCNAction)).call(this));

    _this._duration = 0;

    /**
     * A speed factor that modifies how fast an action runs.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522811-speed
     */
    _this._speed = 1.0;

    /**
     * The timing mode used to execute an action.
     * @type {SCNActionTimingMode}
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1524055-timingmode
     */
    _this._timingMode = _SCNActionTimingMode2.default.linear;

    /**
     * A block SceneKit calls to determine the action’s animation timing.
     * @type {?SCNActionTimingFunction}
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1524130-timingfunction
     */
    _this._timingFunction = null;

    /**
     * @access private
     * @type {boolean}
     */
    _this._finished = false;

    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    _this._completionHandler = null;

    _this.__actionStartTime = null;
    return _this;
  }

  // Creating Actions That Move a Node

  /**
   * Creates an action that moves a node relative to its current position.
   * @access public
   * @param {number} deltaX - The distance to move the node in the X direction of its parent node’s local coordinate space.
   * @param {number} deltaY - The distance to move the node in the Y direction of its parent node’s local coordinate space.
   * @param {number} deltaZ - The distance to move the node in the Z direction of its parent node’s local coordinate space.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];
  [SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523238-moveby
   */


  _createClass(SCNAction, [{
    key: 'reversed',


    // Reversing an Action

    /**
     * Creates an action that reverses the behavior of another action.
     * @access public
     * @returns {SCNAction} - 
     * @desc This method always returns an action object; however, not all actions are reversible. When reversed, some actions return an object that either does nothing or performs the same action as the original action. For details on how an action is reversed, see the description of the class method used to create that action.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522815-reversed
     */
    value: function reversed() {
      return null;
    }

    /**
     * @access public
     * @returns {SCNAction} -
     */

  }, {
    key: 'copy',
    value: function copy() {
      var action = _get(SCNAction.prototype.__proto__ || Object.getPrototypeOf(SCNAction.prototype), 'copy', this).call(this);

      action._beginTime = this._beginTime;
      action._duration = this._duration;
      action._speed = this.speed;
      action._timingMode = this.timingMode;
      action._timingFunction = this.timingFunction;
      action._finished = this._finished;
      //action._isRunning = this._isRunning
      //action._pausedTime = this._pausedTime
      //action._completionHandler = this._completionHandler

      return action;
    }
  }, {
    key: '_applyAction',


    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var t = this._getTime(time, needTimeConversion
      //this._handleEvents(obj, t)
      );
    }
  }, {
    key: '_getTime',
    value: function _getTime(time, needTimeConversion) {
      var t = this.__getTime(time, needTimeConversion);
      if (this._timingMode === _SCNActionTimingMode2.default.easeIn) {
        return _CAMediaTimingFunction2.default.functionWithName(Constants.kCAMediaTimingFunctionEaseIn)._getValueAtTime(t);
      } else if (this._timingMode === _SCNActionTimingMode2.default.easeOut) {
        return _CAMediaTimingFunction2.default.functionWithName(Constants.kCAMediaTimingFunctionEaseOut)._getValueAtTime(t);
      } else if (this._timingMode === _SCNActionTimingMode2.default.easeInEaseOut) {
        return _CAMediaTimingFunction2.default.functionWithName(Constants.kCAMediaTimingFunctionEaseInEaseOut)._getValueAtTime(t);
      }
      return t;
    }
  }, {
    key: '__getTime',
    value: function __getTime(time, needTimeConversion) {
      if (!needTimeConversion) {
        if (time >= 1.0 && !this._finished) {
          this._finished = true;
        }
        return time;
      }

      var baseTime = this._basetimeFromTime(time);
      if (this.timingFunction === null) {
        return baseTime;
      }

      return this.timingFunction._getValueAtTime(baseTime);
    }

    /**
     * convert parent time to base time
     * @access private
     * @param {number} time - parent time
     * @returns {number} - animation base time for the current frame (0-1 or null).
     */

  }, {
    key: '_basetimeFromTime',
    value: function _basetimeFromTime(time) {
      var activeTime = time - this._actionStartTime;
      return this._basetimeFromActivetime(activeTime);
    }

    /**
     * convert parent time to active time
     * @access private
     * @param {number} time - parent time
     * @returns {number} - animation active time for the current frame.
     */

  }, {
    key: '_activetimeFromTime',
    value: function _activetimeFromTime(time) {
      return time - this._actionStartTime;
    }

    /**
     * convert active time to base time
     * @access private
     * @param {number} time - active time
     * @returns {number} - animation base time for the current frame (0-1 or null).
     */

  }, {
    key: '_basetimeFromActivetime',
    value: function _basetimeFromActivetime(time) {
      var dt = time - this._beginTime;
      if (this.speed === 0) {
        return 0;
      }
      if (this._duration === 0) {
        return dt / Math.abs(this.speed);
      }
      var duration = this._duration / Math.abs(this.speed);
      if (duration === 0) {
        duration = 0.25;
      }

      if (dt >= duration) {
        // the action is over.
        if (!this._finished) {
          this._finished = true;
        }
      }

      return dt / duration;
    }

    /**
     * @access private
     * @param {Object} from -
     * @param {Object} to -
     * @param {number} t -
     * @returns {Object} -
     */

  }, {
    key: '_lerp',
    value: function _lerp(from, to, t) {
      if (t === null) {
        // the action is over.
        return to;
      }
      if ((0, _InstanceOf3.default)(from, _SCNVector4.default)) {
        // TODO: slerp for Quaternion
        return from.lerp(to, t);
      } else if ((0, _InstanceOf3.default)(from, _SCNVector2.default)) {
        return from.lerp(to, t);
      } else if ((0, _InstanceOf3.default)(from, _CGSize2.default)) {
        return from.lerp(to, t);
      } else if ((0, _InstanceOf3.default)(from, _CGPoint2.default)) {
        return from.lerp(to, t);
      } else if ((0, _InstanceOf3.default)(from, _CGRect2.default)) {
        return from.lerp(to, t);
      } else if ((0, _InstanceOf3.default)(from, _SKColor2.default)) {
        return from._lerp(to, t);
      }
      return from + (to - from) * t;
    }

    /**
     * @access private
     * @param {Object} from -
     * @param {Object} to -
     * @param {number} t -
     * @returns {Object} -
     */

  }, {
    key: '_slerp',
    value: function _slerp(from, to, t) {
      if (!(0, _InstanceOf3.default)(from, _SCNVector4.default)) {
        throw new Error('SCNAction._slerp: object is not SCNVector4');
      }
      return from.slerp(to, t);
    }
  }, {
    key: '_resetFinished',
    value: function _resetFinished() {
      this._finished = false;
    }
  }, {
    key: '_actionStartTime',
    get: function get() {
      return this.__actionStartTime;
    },
    set: function set(newValue) {
      this.__actionStartTime = newValue;
    }
  }, {
    key: 'duration',
    get: function get() {
      return this._duration;
    },
    set: function set(newValue) {
      this._duration = newValue;
    }
  }, {
    key: 'speed',
    get: function get() {
      return this._speed;
    },
    set: function set(newValue) {
      this._speed = newValue;
    }
  }, {
    key: 'timingMode',
    get: function get() {
      return this._timingMode;
    },
    set: function set(newValue) {
      this._timingMode = newValue;
    }
  }, {
    key: 'timingFunction',
    get: function get() {
      return this._timingFunction;
    },
    set: function set(newValue) {
      this._timingFunction = newValue;
    }
  }], [{
    key: 'moveByXYZ',
    value: function moveByXYZ(deltaX, deltaY, deltaZ, duration) {
      //return SCNActionMove.moveByXYZ(deltaX, deltaY, deltaZ, duration)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that moves a node relative to its current position.
     * @access public
     * @param {SCNVector3} delta - A vector that describes the change to be applied to the node’s position.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code had been executed:SCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);
    [SCNAction moveBy: reverseDelta duration: duration];
    SCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);
    [SCNAction moveBy: reverseDelta duration: duration];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1522605-move
     */

  }, {
    key: 'moveBy',
    value: function moveBy(delta, duration) {
      //return SCNActionMove.moveBy(delta, duration)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that moves a node to a new position.
     * @access public
     * @param {SCNVector3} location - The coordinates for the node’s new position in its parent node’s local coordinate space.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is not reversible; the reverse of this action has the same duration but does not move the node.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522826-move
     */

  }, {
    key: 'moveTo',
    value: function moveTo(location, duration) {
      //return SCNActionMove.moveTo(location, duration)
      throw new Error('not implemented');
    }

    // Creating Actions That Rotate a Node

    /**
     * Creates an action that rotates the node in each of the three principal axes by angles relative to its current orientation.
     * @access public
     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
    [SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1523522-rotateby
     */

  }, {
    key: 'rotateByXYZ',
    value: function rotateByXYZ(xAngle, yAngle, zAngle, duration) {
      //return SCNActionRotate.rotateByXYZ(xAngle, yAngle, zAngle, duration)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that rotates the node to absolute angles in each of the three principal axes.
     * @access public
     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s rotation property animates to the new angle. Calling this method is equivalent to calling rotateTo(x:y:z:duration:usesShortestUnitArc:) and passing false for the shortestUnitArc parameter.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1524044-rotateto
     */

  }, {
    key: 'rotateToXYZ',
    value: function rotateToXYZ(xAngle, yAngle, zAngle, duration) {
      //return SCNActionRotate.rotateToXYZ(xAngle, yAngle, zAngle, duration)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that rotates the node to absolute angles in each of the three principal axes.
     * @access public
     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @param {boolean} shortestUnitArc - If false (the default), the animation interpolates each component of the node’s rotation between its current value and the new value. If true, the animation makes the most direct rotation possible from the node’s current orientation to the new orientation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522808-rotateto
     */

  }, {
    key: 'rotateToXYZUsesShortestUnitArc',
    value: function rotateToXYZUsesShortestUnitArc(xAngle, yAngle, zAngle, duration, shortestUnitArc) {
      //return SCNActionRotate.rotateToXYZUsesShortestUnitArc(xAngle, yAngle, zAngle, duration, shortestUnitArc)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that rotates the node by an angle around a specified axis.
     * @access public
     * @param {number} angle - The amount to rotate the node counterclockwise around the specified axis, in radians.
     * @param {SCNVector3} axis - A vector in the node’s local coordinate space whose direction specifies the axis of rotation.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
    [SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1523805-rotate
     */

  }, {
    key: 'rotateByAround',
    value: function rotateByAround(angle, axis, duration) {
      //return SCNActionRotate.rotateByAround(angle, axis, duration)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that rotates the node to an absolute angle around a specified axis.
     * @access public
     * @param {SCNVector4} axisAngle - A four-component vector whose first three components are a vector in the node’s local coordinate space specifying an axis and whose fourth component is the amount to rotate the node counterclockwise around that axis, in radians.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1524191-rotate
     */

  }, {
    key: 'rotateToAxisAngle',
    value: function rotateToAxisAngle(axisAngle, duration) {
      //return SCNActionRotate.rotateToAxisAngle(axisAngle, duration)
      throw new Error('not implemented');
    }

    // Creating Actions That Change a Node’s Scale

    /**
     * Creates an action that uniformly changes the scale factor of a node by a relative value.
     * @access public
     * @param {number} scale - The amount of change to make to all three components of the node’s scale.
     * @param {number} sec - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s scale property animates to the new value.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction scaleBy: -scale duration: sec];
    [SCNAction scaleBy: -scale duration: sec];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1523129-scale
     */

  }, {
    key: 'scaleByDuration',
    value: function scaleByDuration(scale, sec) {
      //return SCNActionScale.scaleByDuration(scale, sec)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that uniformly changes the scale factor of a node to an absolute value.
     * @access public
     * @param {number} scale - The new value for all three components of the node’s scale.
     * @param {number} sec - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s scale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1523322-scale
     */

  }, {
    key: 'scaleToDuration',
    value: function scaleToDuration(scale, sec) {
      //return SCNActionScale.scaleToDuration(scale, sec)
      throw new Error('not implemented');
    }

    // Creating Actions That Change a Node’s Opacity

    /**
     * Creates an action that changes the opacity of the node to 1.0.
     * @access public
     * @param {number} sec - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s opacity property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOutWithDuration: sec];
    [SCNAction fadeOutWithDuration: sec];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1522777-fadein
     */

  }, {
    key: 'fadeInDuration',
    value: function fadeInDuration(sec) {
      //return SCNActionFade.fadeInDuration(sec)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that changes the opacity of the node to 0.0.
     * @access public
     * @param {number} sec - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s opacity property animates from its current value to 0.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeInWithDuration: sec];
    [SCNAction fadeInWithDuration: sec];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1523922-fadeout
     */

  }, {
    key: 'fadeOutDuration',
    value: function fadeOutDuration(sec) {
      //return SCNActionFade.fadeOutDuration(sec)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that adjusts the opacity of a node by a relative value.
     * @access public
     * @param {number} factor - The amount to change the node’s opacity by.
     * @param {number} sec - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s opacity property animates to its new value.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOpacityBy: -factor duration: sec];
    [SCNAction fadeOpacityBy: -factor duration: sec];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1523595-fadeopacity
     */

  }, {
    key: 'fadeOpacityByDuration',
    value: function fadeOpacityByDuration(factor, sec) {
      //return SCNActionFade.fadeOpacityByDuration(factor, sec)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that adjusts the opacity of a node to a new value.
     * @access public
     * @param {number} opacity - The new opacity value of the node.
     * @param {number} sec - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s opacity property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1523875-fadeopacity
     */

  }, {
    key: 'fadeOpacityToDuration',
    value: function fadeOpacityToDuration(opacity, sec) {
      //return SCNActionFade.fadeOpacityToDuration(opacity, sec)
      throw new Error('not implemented');
    }

    // Creating Actions That Change a Node’s Visibility

    /**
     * Creates an action that hides a node.
     * @access public
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s isHidden property is set to true.This action is reversible; the reverse is equivalent to the unhide() action.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1523487-hide
     */

  }, {
    key: 'hide',
    value: function hide() {
      //return SCNActionHide.hide()
      throw new Error('not implemented');
    }

    /**
     * Creates an action that ensures a node is not hidden.
     * @access public
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s isHidden property is set to false.This action is reversible; the reverse is equivalent to the hide() action.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1524205-unhide
     */

  }, {
    key: 'unhide',
    value: function unhide() {
      //return SCNActionHide.unhide()
      throw new Error('not implemented');
    }

    // Creating Actions That Remove Nodes from the Scene

    /**
     * Creates an action that removes the node from its parent.
     * @access public
     * @returns {SCNAction} - 
     * @desc When the action executes, the node is immediately removed from its parent.This action is not reversible; the reverse of this action is the same action.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522966-removefromparentnode
     */

  }, {
    key: 'removeFromParentNode',
    value: function removeFromParentNode() {
      //return SCNActionRemove.removeFromParentNode()
      throw new Error('not implemented');
    }

    // Creating Actions That Play Audio

    /**
     * Creates an action that plays an audio source.
     * @access public
     * @param {SCNAudioSource} source - The audio source to play.
     * @param {boolean} wait - If true, the duration of this action is the same as the length of the audio playback. If false, the action is considered to have completed immediately.
     * @returns {SCNAction} - 
     * @desc When the action executes, SceneKit plays the audio source on the target node—any positional audio effects are based on the node’s position. For more information about positional audio in SceneKit, see SCNAudioPlayer.This action is not reversible; the reverse of this action is the same action.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1523651-playaudio
     */

  }, {
    key: 'playAudioWaitForCompletion',
    value: function playAudioWaitForCompletion(source, wait) {
      //return SCNActionPlaySound.playAudioWaitForCompletion(source, wait)
      throw new Error('not implemented');
    }

    // Creating Actions That Combine or Repeat Other Actions

    /**
     * Creates an action that runs a collection of actions in parallel.
     * @access public
     * @param {SCNAction[]} actions - An array of SCNAction objects.
     * @returns {SCNAction} - 
     * @desc When the action executes, the actions that make up the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the group’s duration, the action completes and then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522779-group
     */

  }, {
    key: 'group',
    value: function group(actions) {
      //return SCNActionGroup.group(actions)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that runs a collection of actions sequentially.
     * @access public
     * @param {SCNAction[]} actions - An array of SCNAction objects.
     * @returns {SCNAction} - 
     * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, the actions reverseSequence and sequenceReverse in the code example below are equivalent:SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
    SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
                                                      [actionB reversedAction],
                                                      [actionA reversedAction] ]];
    SCNAction *sequenceReverse = [sequence reversedAction];
    SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
    SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
                                                      [actionB reversedAction],
                                                      [actionA reversedAction] ]];
    SCNAction *sequenceReverse = [sequence reversedAction];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1522793-sequence
     */

  }, {
    key: 'sequence',
    value: function sequence(actions) {
      //return SCNActionSequence.sequence(actions)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that repeats another action a specified number of times.
     * @access public
     * @param {SCNAction} action - The action to be executed.
     * @param {number} count - The number of times to execute the action.
     * @returns {SCNAction} - 
     * @desc When the action executes, the associated action runs to completion and then repeats, until the count is reached.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522764-repeat
     */

  }, {
    key: 'repeat',
    value: function repeat(action, count) {
      //return SCNActionRepeat.repeat(action, count)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that repeats another action forever.
     * @access public
     * @param {SCNAction} action - The action to execute.
     * @returns {SCNAction} - 
     * @desc When the action executes, the associated action runs to completion and then repeats.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.NoteThe action to be repeated must have a non-instantaneous duration.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522908-repeatforever
     */

  }, {
    key: 'repeatForever',
    value: function repeatForever(action) {
      //return SCNActionRepeat.repeatForever(action)
      throw new Error('not implemented');
    }

    // Creating Actions That Add Delays to Action Sequences

    /**
     * Creates an action that idles for a specified period of time.
     * @access public
     * @param {number} sec - The amount of time to wait.
     * @returns {SCNAction} - 
     * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1523915-wait
     */

  }, {
    key: 'waitDuration',
    value: function waitDuration(sec) {
      //return SCNActionWait.waitDuration(sec)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that idles for a randomized period of time.
     * @access public
     * @param {number} sec - The average amount of time to wait.
     * @param {number} durationRange - The range of possible values for the duration.
     * @returns {SCNAction} - 
     * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1523086-wait
     */

  }, {
    key: 'waitDurationWithRange',
    value: function waitDurationWithRange(sec, durationRange) {
      //return SCNActionWait.waitDurationWithRange(sec, durationRange)
      throw new Error('not implemented');
    }

    // Creating Custom Actions

    /**
     * Creates an action that executes a block.
     * @access public
     * @param {function(arg1: SCNNode): void} block - The block to run. The block takes a single parameter:nodeThe node on which the action is running.
     * @returns {SCNAction} - 
     * @desc When the action executes, SceneKit calls the block. This action takes place instantaneously.This action is not reversible; the reverse action executes the same block.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1523637-run
     */

  }, {
    key: 'run',
    value: function run(block) {
      //return SCNActionRunBlock.run(block)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that executes a block periodically over a specified duration.
     * @access public
     * @param {number} seconds - The duration of the action, in seconds.
     * @param {function(arg1: SCNNode, arg2: number): void} block - The block to run. The block takes the following parameters:nodeThe node on which the action is running.elapsedTimeThe amount of time that has passed since the action began executing.
     * @returns {SCNAction} - 
     * @desc When the action executes, SceneKit calls the block repeatedly until the action’s duration expires. For each call, SceneKit computes the elapsed time and passes it to the block.This action is not reversible; the reverse action executes the same block.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1523692-customaction
     */

  }, {
    key: 'customActionDurationAction',
    value: function customActionDurationAction(seconds, block) {
      //return SCNActionCustom.customActionDurationAction(seconds, block)
      throw new Error('not implemented');
    }

    /**
     * Creates an action that executes a JavaScript script periodically over a specified duration.
     * @access public
     * @param {string} script - A string containing JavaScript source code.
     * @param {number} seconds - The duration of the action, in seconds.
     * @returns {SCNAction} - 
     * @desc SceneKit exposes its classes, methods, and functions in the JavaScript context that runs the script—see the SCNJavaScript.h header file for details.When the action executes, SceneKit runs the script repeatedly until the action’s duration expires. Each time SceneKit runs the script, it computes the elapsed time since the action began executing (as a fraction of the action’s duration between 0.0 and 1.0) and makes it available to the script as a variable named elapsedTime. The script can also reference the SCNNode object running the action as a variable named node.This action is not reversible; the reverse action executes the same script.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1523984-javascriptaction
     */

  }, {
    key: 'javaScriptActionWithScriptDuration',
    value: function javaScriptActionWithScriptDuration(script, seconds) {
      //return SCNActionJavaScript.javaScriptActionWithScriptDuration(script, seconds)
      throw new Error('not implemented');
    }
  }]);

  return SCNAction;
}(_NSObject3.default);

exports.default = SCNAction;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Constants affecting the animation curve of an action, used by the timingMode property.
 * @typedef {Object} SCNActionTimingMode
 * @property {number} linear - Linear pacing. The animation progresses evenly throughout its duration.
 * @property {number} easeIn - Ease-in pacing. The animation begins slowly, and then speeds up as it progresses.
 * @property {number} easeOut - Ease-out pacing. The animation begins quickly, and then slows as it completes.
 * @property {number} easeInEaseOut - Ease-in ease-out pacing. The animation begins slowly, accelerates through the middle of its duration, and then slows again before completing.
 * @see https://developer.apple.com/documentation/scenekit/scnactiontimingmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNActionTimingMode = {
  linear: 0,
  easeIn: 1,
  easeOut: 2,
  easeInEaseOut: 3
};

exports.default = SCNActionTimingMode;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _SCNVector3 = __webpack_require__(11);

var _SCNVector4 = _interopRequireDefault(_SCNVector3);

var _SCNMatrix4MakeTranslation = __webpack_require__(18);

var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*global Buffer*/

var _Semantic = {
  boneIndices: 'kGeometrySourceSemanticBoneIndices',
  boneWeights: 'kGeometrySourceSemanticBoneWeights',
  color: 'kGeometrySourceSemanticColor',
  edgeCrease: 'kGeometrySourceSemanticEdgeCrease',
  normal: 'kGeometrySourceSemanticNormal',
  tangent: 'kGeometrySourceSemanticTangent',
  texcoord: 'kGeometrySourceSemanticTexcoord',
  vertex: 'kGeometrySourceSemanticVertex',
  vertexCrease: 'kGeometrySourceSemanticVertexCrease'

  /**
   * A container for vertex data forming part of the definition for a three-dimensional object, or geometry.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/scenekit/scngeometrysource
   */
};
var SCNGeometrySource = function (_NSObject) {
  _inherits(SCNGeometrySource, _NSObject);

  _createClass(SCNGeometrySource, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        $constructor: function $constructor(propNames, propValues) {
          return new SCNGeometrySource(propValues.data, propValues.semantic, propValues.vectorCount, propValues.floatComponents, propValues.componentsPerVector, propValues.bytesPerComponent, propValues.dataOffset, propValues.dataStride);
        },
        data: ['NSMutableData', null],
        semantic: ['string', null],
        vectorCount: ['integer', null],
        floatComponents: ['boolean', null],
        componentsPerVector: ['integer', null],
        bytesPerComponent: ['integer', null],
        dataOffset: ['integer', null],
        dataStride: ['integer', null],
        mkSemantic: ['boolean', null] // ?
      };
    }

    /**
     * Creates a geometry source from the specified data and options.
     * @access public
     * @constructor
     * @param {number[]|Buffer} data - The data for the geometry source.
     * @param {SCNGeometrySource.Semantic} semantic - The semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.
     * @param {number} vectorCount - The number of geometry source vectors.
     * @param {boolean} floatComponents - A Boolean value that indicates whether vector components are floating-point values. Specify true for floating-point values, or false for integer values.
     * @param {number} componentsPerVector - The number of scalar components in each vector.
     * @param {number} bytesPerComponent - The size, in bytes, of each vector component.
     * @param {number} offset - The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
     * @param {number} stride - The number of bytes from each vector to the next in the data.
     * @desc A geometry source’s data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other parameters determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector. You can use the offset and stride parameters together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1523320-init
     */

  }]);

  function SCNGeometrySource(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, offset, stride) {
    _classCallCheck(this, SCNGeometrySource);

    // Inspecting a Geometry Source
    var _this = _possibleConstructorReturn(this, (SCNGeometrySource.__proto__ || Object.getPrototypeOf(SCNGeometrySource)).call(this));

    _this._data = data;
    _this._semantic = semantic;
    _this._vectorCount = vectorCount;
    _this._usesFloatComponents = floatComponents;
    _this._componentsPerVector = componentsPerVector;
    _this._bytesPerComponent = bytesPerComponent;
    _this._dataOffset = offset;
    _this._dataStride = stride;

    if (data instanceof Buffer) {
      var loadFunc = null;
      if (floatComponents) {
        switch (bytesPerComponent) {
          case 4:
            loadFunc = function loadFunc(_offset) {
              return data.readFloatLE(_offset);
            };
            break;
          case 8:
            loadFunc = function loadFunc(_offset) {
              return data.readDoubleLE(_offset);
            };
            break;
          case 1:
            loadFunc = function loadFunc(_offset) {
              return data.readIntLE(_offset, 1) / 255.0;
            };
            break;
          default:
            throw new Error('unknown float data size: ' + bytesPerComponent);
        }
      } else {
        loadFunc = function loadFunc(_offset) {
          return data.readIntLE(_offset, bytesPerComponent);
        };
      }

      var _data = [];
      var count = data.length / bytesPerComponent;
      var _offset = 0;
      for (var i = 0; i < count; i++) {
        _data.push(loadFunc(_offset));
        _offset += bytesPerComponent;
      }
      _this._data = _data;
    }

    /**
     * @type {TypedArray}
     * @access private
     */
    //this._glData = null
    //if(this._hasTypedArrayData()){
    //  this._glData = this._data
    //}else{
    //  if(floatComponents){
    //    if(bytesPerComponent === 4){
    //      this._glData = new Float32Array(this._data)
    //    }else if(bytesPerComponent === 8){
    //      this._glData = new Float64Array(this._data)
    //    }
    //  }else{
    //    if(bytesPerComponent === 1){
    //      this._glData = new Uint8Array(this._data)
    //    }else if(bytesPerComponent === 2){
    //      this._glData = new Uint16Array(this._data)
    //    }else if(bytesPerComponent === 4){
    //      this._glData = new Uint32Array(this._data)
    //    }
    //  }
    //}

    //if(this._glData === null){
    //  throw new Error(`unknown buffer data type: float: ${floatComponents}, size: ${bytesPerComponent}`)
    //}

    _this._buffer = null;
    return _this;
  }

  _createClass(SCNGeometrySource, [{
    key: '_createBuffer',
    value: function _createBuffer(context) {
      var gl = context;
      this._buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer
      // FIXME: dynamic data
      );gl.bufferData(gl.ARRAY_BUFFER, this._glData, gl.STATIC_DRAW);
      return this._buffer;
    }

    /**
     * @access private
     * @returns {boolean} -
     */

  }, {
    key: '_hasTypedArrayData',
    value: function _hasTypedArrayData() {
      if (this._usesFloatComponents) {
        if (this._bytesPerComponent === 4) {
          return this._data instanceof Float32Array;
        } else if (this._bytesPerComponent === 8) {
          return this._data instanceof Float64Array;
        }
      } else {
        if (this._bytesPerComponent === 1) {
          return this._data instanceof Uint8Array;
        } else if (this._bytesPerComponent === 2) {
          return this._data instanceof Uint16Array;
        } else if (this._bytesPerComponent === 4) {
          return this._data instanceof Uint32Array;
        }
      }
      return false;
    }

    // Creating Geometry Sources

    /**
     * Creates a geometry source from the specified data and options.
     * @access public
     * @param {number[]} data - The data for the geometry source.
     * @param {SCNGeometrySource.Semantic} semantic - The semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.
     * @param {number} vectorCount - The number of geometry source vectors.
     * @param {boolean} floatComponents - A Boolean value that indicates whether vector components are floating-point values. Specify true for floating-point values, or false for integer values.
     * @param {number} componentsPerVector - The number of scalar components in each vector.
     * @param {number} bytesPerComponent - The size, in bytes, of each vector component.
     * @param {number} dataOffset - The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
     * @param {number} dataStride - The number of bytes from each vector to the next in the data.
     * @returns {SCNGeometrySource} -
     * @desc A geometry source’s data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other parameters determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector. You can use the offset and stride parameters together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1523320-init
     */

  }, {
    key: '_vectorAt',


    /**
     * @access private
     * @param {number} index -
     * @returns {number[]} -
     */
    value: function _vectorAt(index) {
      if (index < 0 || index >= this.vectorCount) {
        throw new Error('index out of range: ' + index + ' (0 - ' + (this.vectorCount - 1) + ')');
      }
      var indexStride = this._dataStride / this._bytesPerComponent;
      var ind = index * indexStride + this._dataOffset / this._bytesPerComponent;
      var arr = [];
      for (var i = 0; i < this._componentsPerVector; i++) {
        arr.push(this._data[ind + i]);
      }
      return arr;
    }

    /**
     * @access private
     * @param {number} index -
     * @returns {SCNVector3|SCNVector4|number[]} -
     */

  }, {
    key: '_scnVectorAt',
    value: function _scnVectorAt(index) {
      var vec = this._vectorAt(index);
      if (vec.length === 2) {
        return new _CGPoint2.default(vec[0], vec[1]);
      } else if (vec.length === 3) {
        return new _SCNVector2.default(vec[0], vec[1], vec[2]);
      } else if (vec.length === 4) {
        return new _SCNVector4.default(vec[0], vec[1], vec[2], vec[3]);
      }
      return vec;
    }

    /**
     * @access public
     * @param {number[]|SCNVector3|SCNVector4} v -
     * @param {number} index -
     * @returns {void}
     */

  }, {
    key: '_setVectorAt',
    value: function _setVectorAt(v, index) {
      if (index < 0 || index >= this.vectorCount) {
        throw new Error('index out of range: ' + index + ' (0 - ' + (this.vectorCount - 1) + ')');
      }
      var data = v;
      if ((0, _InstanceOf3.default)(v, _SCNVector2.default)) {
        data = [v.x, v.y, v.z];
      } else if ((0, _InstanceOf3.default)(v, _SCNVector4.default)) {
        data = [v.x, v.y, v.z, v.w];
      }
      if (data.length !== this._componentsPerVector) {
        throw new Error('vector size inconsistent: ' + data.length + ' != ' + this._componentsPerVector);
      }

      var indexStride = this._dataStride / this._bytesPerComponent;
      var ind = index * indexStride + this._dataOffset / this._bytesPerComponent;
      for (var i = 0; i < this._componentsPerVector; i++) {
        this._data[ind + i] = data[i];
      }
    }

    /**
     * 
     * @access private
     * @param {SCNMatrix4} transform -
     * @returns {Object} -
     */

  }, {
    key: '_createBoundingBox',
    value: function _createBoundingBox() {
      var transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var t = transform ? transform : (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);
      var min = new _SCNVector2.default(Infinity, Infinity, Infinity);
      var max = new _SCNVector2.default(-Infinity, -Infinity, -Infinity);
      if (this._componentsPerVector !== 3) {
        throw new Error('componentsPerVector !== 3');
      }

      var indexStride = this._dataStride / this._bytesPerComponent;
      var ind = this._dataOffset / this._bytesPerComponent;
      var len = this._vectorCount;
      var arr = [];
      for (var i = 0; i < len; i++) {
        var p = new _SCNVector2.default(this._data[ind + 0], this._data[ind + 1], this._data[ind + 2]).transform(t
        //const x = this._data[ind + 0]
        //const y = this._data[ind + 1]
        //const z = this._data[ind + 2]
        );if (p.x < min.x) {
          min.x = p.x;
        }
        if (p.x > max.x) {
          max.x = p.x;
        }
        if (p.y < min.y) {
          min.y = p.y;
        }
        if (p.y > max.y) {
          max.y = p.y;
        }
        if (p.z < min.z) {
          min.z = p.z;
        }
        if (p.z > max.z) {
          max.z = p.z;
        }
        ind += indexStride;
      }

      return { min: min, max: max };
    }

    /**
     * 
     * @access public
     * @param {number} value -
     * @returns {void}
     */

  }, {
    key: 'fill',
    value: function fill(value) {
      var index = this._dataOffset / this._bytesPerComponent;
      var stride = this._dataStride / this._bytesPerComponent;
      for (var i = 0; i < this._vectorCount; i++) {
        for (var j = 0; j < this._componentsPerVector; j++) {
          this._data[index + j] = value;
        }
        index += stride;
      }
    }
  }, {
    key: 'copy',
    value: function copy() {
      var source = new SCNGeometrySource(this._data.slice(0), this._semantic, this._vectorCount, this._usesFloatComponents, this._componentsPerVector, this._bytesPerComponent, this._dataOffset, this._dataStride);
      return source;
    }
  }, {
    key: 'data',


    // Inspecting a Geometry Source

    /**
     * The data for the geometry source.
     * @type {Data}
     * @desc A geometry source’s data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other properties of the geometry source determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector.
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522881-data
     */
    get: function get() {
      return this._data.slice(0);
    }

    /**
     * The semantic value (or attribute) the geometry source describes for each vertex.
     * @type {SCNGeometrySource.Semantic}
     * @desc A semantic describes an attribute for each vertex, such as position, color, surface normal vector, or texture coordinates.See Geometry Semantic Identifiers for available values.
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1523071-semantic
     */

  }, {
    key: 'semantic',
    get: function get() {
      return this._semantic;
    }

    /**
     * The number of vectors in the data.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522648-vectorcount
     */

  }, {
    key: 'vectorCount',
    get: function get() {
      return this._vectorCount;
    }

    /**
     * A Boolean value that indicates whether vector components are floating-point values.
     * @type {boolean}
     * @desc If true, SceneKit interprets the geometry source’s data as an array of vectors whose components are floating-point values. The type of floating-point value is determined by the SCNGeometrySource property: 4 bytes for float values or 8 bytes for double values. If false, SceneKit interprets the geometry source’s data as an array of vectors whose components are integer values. The type of integer value is determined by the SCNGeometrySource property; for example, 2 bytes for unsigned short values or 4 bytes for unsigned int values.
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522920-usesfloatcomponents
     */

  }, {
    key: 'usesFloatComponents',
    get: function get() {
      return this._usesFloatComponents;
    }

    /**
     * The number of scalar components in each vector.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522832-componentspervector
     */

  }, {
    key: 'componentsPerVector',
    get: function get() {
      return this._componentsPerVector;
    }

    /**
     * The size, in bytes, of each vector component.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522633-bytespercomponent
     */

  }, {
    key: 'bytesPerComponent',
    get: function get() {
      return this._bytesPerComponent;
    }

    /**
     * The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
     * @type {number}
     * @desc You can use the SCNGeometrySource and SCNGeometrySource parameters can together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522834-dataoffset
     */

  }, {
    key: 'dataOffset',
    get: function get() {
      return this._dataOffset;
    }

    /**
     * The number of bytes from a vector to the next one in the data.
     * @type {number}
     * @desc You can use the SCNGeometrySource and SCNGeometrySource parameters can together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1524197-datastride
     */

  }, {
    key: 'dataStride',
    get: function get() {
      return this._dataStride;
    }

    // Creating GPU-Mutable Geometry Sources

    /**
     * Creates a geometry source whose vertex data resides in the specified Metal buffer, allowing modification through a Metal compute shader.
     * @access public
     * @param {MTLBuffer} mtlBuffer - A Metal buffer containing per-vertex data for the geometry source.
     * @param {MTLVertexFormat} vertexFormat - The type of per-vertex data in the buffer. A MTLVertexFormat value defines the number of components for each vector in the geometry source and the data type and size of each component.
     * @param {SCNGeometrySource.Semantic} semantic - The semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.
     * @param {number} vertexCount - The number of vertices in the geometry source.
     * @param {number} offset - The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
     * @param {number} stride - The number of bytes from each vector to the next in the data.
     * @returns {SCNGeometrySource} -
     * @desc Use this method to create a geometry source whose underlying data can be modified at render time by a Metal compute shader running on the GPU. To create a MTLBuffer object for use with a geometry source, use the device property of the SceneKit view (or other renderer) responsible for drawing your scene.// Create and fill a buffer.
    id <MTLDevice> device = self.scnView.device;
    self.geometryBuffer = [device newBufferWithBytes:myData length:myLength options:myOptions];
    // Create a geometry source from the buffer.
    SCNGeometrySource *source = [SCNGeometrySource geometrySourceWithBuffer:buffer
                               vertexFormat:myVertexFormat
                                   semantic:SCNGeometrySourceSemanticVertex
                                vertexCount:myVertexCount
                                 dataOffset:0
                                 dataStride:0];
    Then, to modify the buffer’s contents at render time, implement a scene renderer delegate and schedule a compute command encoder during a render delegate method such as renderer(_:willRenderScene:atTime:).- (void)renderer:(id <SCNSceneRenderer>)aRenderer willRenderScene:(SCNScene *)scene atTime:(NSTimeInterval)time {
       // Get a command buffer and compute encoder from the view (or other renderer).
       id<MTLCommandBuffer> myCommandBuffer = [aRenderer.commandQueue commandBuffer];
       id<MTLComputeCommandEncoder> myComputeEncoder = [myCommandBuffer computeCommandEncoder];
         // Configure the compute command encoder.
       // (Note pipeline state is preconfigured outside of the render loop.)
       [myComputeEncoder setComputePipelineState:self.pipelineState];
       [myComputeEncoder setBuffer:self.geometryBuffer offset:0 atIndex:0];
         // Schedule the compute command and commit the command buffer.
       [myComputeEncoder dispatchThreadgroups:myThreadgroupCount
                        threadsPerThreadgroup:myThreadCount];
       [myComputeEncoder endEncoding];
       [myCommandBuffer commit];
    }
    NoteGeometry sources backed by a Metal buffer are available only with SceneKit views (or other renderers) whose renderingAPI property is metal. Metal commands that modify the buffer’s contents must be enqueued from within one of the render loop methods defined in the SCNSceneRendererDelegate protocol. The result of attempting to modify a buffer at any other time is undefined.// Create and fill a buffer.
    id <MTLDevice> device = self.scnView.device;
    self.geometryBuffer = [device newBufferWithBytes:myData length:myLength options:myOptions];
    // Create a geometry source from the buffer.
    SCNGeometrySource *source = [SCNGeometrySource geometrySourceWithBuffer:buffer
                               vertexFormat:myVertexFormat
                                   semantic:SCNGeometrySourceSemanticVertex
                                vertexCount:myVertexCount
                                 dataOffset:0
                                 dataStride:0];
    - (void)renderer:(id <SCNSceneRenderer>)aRenderer willRenderScene:(SCNScene *)scene atTime:(NSTimeInterval)time {
       // Get a command buffer and compute encoder from the view (or other renderer).
       id<MTLCommandBuffer> myCommandBuffer = [aRenderer.commandQueue commandBuffer];
       id<MTLComputeCommandEncoder> myComputeEncoder = [myCommandBuffer computeCommandEncoder];
         // Configure the compute command encoder.
       // (Note pipeline state is preconfigured outside of the render loop.)
       [myComputeEncoder setComputePipelineState:self.pipelineState];
       [myComputeEncoder setBuffer:self.geometryBuffer offset:0 atIndex:0];
         // Schedule the compute command and commit the command buffer.
       [myComputeEncoder dispatchThreadgroups:myThreadgroupCount
                        threadsPerThreadgroup:myThreadCount];
       [myComputeEncoder endEncoding];
       [myCommandBuffer commit];
    }
      * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522873-init
     */

  }], [{
    key: 'geometrySourceWithDataSemanticVectorCountFloatComponentsComponentsPerVectorBytesPerComponentDataOffsetDataStride',
    value: function geometrySourceWithDataSemanticVectorCountFloatComponentsComponentsPerVectorBytesPerComponentDataOffsetDataStride(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, dataOffset, dataStride) {
      var instance = new SCNGeometrySource(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, dataOffset, dataStride);

      return instance;
    }

    /**
     * Creates a geometry source from an array of vertex positions. 
     * @access public
     * @param {SCNVector3[]} vertices - An array of three-component vectors, each of which represents a vertex position for the geometry source.
     * @param {number} count - The number of vertices
     * @returns {SCNGeometrySource} -
     * @desc SceneKit converts this data to its own format to optimize rendering performance. To read the converted data, examine the properties of the created SCNGeometrySource object.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/2034708-init
     */

  }, {
    key: 'geometrySourceWithVerticesCount',
    value: function geometrySourceWithVerticesCount(vertices, count) {
      var data = [];
      for (var i = 0; i < count; i++) {
        data.push(vertices[i].x, vertices[i].y, vertices[i].z);
      }

      var instance = new SCNGeometrySource(data, // data
      SCNGeometrySource.Semantic.vertex, // semantic
      count, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      12 // stride
      );
      return instance;
    }

    /**
     * Creates a geometry source from an array of texture coordinate points.
     * @access public
     * @param {CGPoint[]} texcoord - An array of points, each of which represents a texture coordinate pair for the geometry source.
     * @param {number} count - The number of texture coordinate points.
     * @returns {SCNGeometrySource} -
     * @desc SceneKit converts this data to its own format to optimize rendering performance. To read the converted data, examine the properties of the created SCNGeometrySource object.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource/1522718-init
     */

  }, {
    key: 'geometrySourceWithTextureCoordinatesCount',
    value: function geometrySourceWithTextureCoordinatesCount(texcoord, count) {
      var data = [];
      for (var i = 0; i < count; i++) {
        data.push(texcoord[i].x, texcoord[i].y);
      }

      var instance = new SCNGeometrySource(data, // data
      SCNGeometrySource.Semantic.texcoord, // semantic
      count, // vectorCount
      true, // floatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      8 // stride
      );
      return instance;
    }

    /**
     * Creates a geometry source from an array of normal vertices.
     * @access public
     * @param {SCNVector3[]} normals - An array of vectors, which represents a normal vector for the geometry source.
     * @param {number} count - The number of normals
     * @returns {SCNGeometrySource} -
     */

  }, {
    key: 'geometrySourceWithNormalsCount',
    value: function geometrySourceWithNormalsCount(normals, count) {
      var data = [];
      for (var i = 0; i < count; i++) {
        data.push(normals[i].x, normals[i].y, normals[i].z);
      }

      var instance = new SCNGeometrySource(data, // data
      SCNGeometrySource.Semantic.normal, // semantic
      count, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      12 // stride
      );
      return instance;
    }
  }, {
    key: 'initBufferDataOffsetDataStride',
    value: function initBufferDataOffsetDataStride(mtlBuffer, vertexFormat, semantic, vertexCount, offset, stride) {}

    // Structures

    /**
     * @type {Object} Semantic
     * @property {string} boneIndices The semantic for bone index data, used for skeletal animation of skinned surfaces.
     * @property {string} boneWeights The semantic for bone weight data, used for skeletal animation of skinned surfaces.
     * @property {string} color The semantic for per-vertex color data.
     * @property {string} edgeCrease The semantic for edge crease data, used for subdividing surfaces.
     * @property {string} normal The semantic for surface normal data.
     * @property {string} tangent The semantic for surface tangent vector data.
     * @property {string} texcoord The semantic for texture coordinate data.
     * @property {string} vertex The semantic for vertex position data.
     * @property {string} vertexCrease The semantic for vertex crease data, used for subdividing surfaces.
     * @see https://developer.apple.com/documentation/scenekit/scngeometrysource.semantic
     */

  }, {
    key: 'Semantic',
    get: function get() {
      return _Semantic;
    }
  }]);

  return SCNGeometrySource;
}(_NSObject3.default);

exports.default = SCNGeometrySource;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21).Buffer))

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _SCNVector3 = __webpack_require__(11);

var _SCNVector4 = _interopRequireDefault(_SCNVector3);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _epsilon = 0.0000001;

/**
 * A representation of a 4 x 4 matrix.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scnmatrix4
 */

var SCNMatrix4 = function () {

  // Initializers

  /**
   * 
   * @access public
   * @construtor
   * @param {number[][]} [m = null] - 
   * @see https://developer.apple.com/documentation/quartzcore/catransform3d/1524036-init
   */
  function SCNMatrix4() {
    var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, SCNMatrix4);

    // Instance Properties

    /** @type {number} */
    this.m11 = 0;
    /** @type {number} */
    this.m12 = 0;
    /** @type {number} */
    this.m13 = 0;
    /** @type {number} */
    this.m14 = 0;
    /** @type {number} */
    this.m21 = 0;
    /** @type {number} */
    this.m22 = 0;
    /** @type {number} */
    this.m23 = 0;
    /** @type {number} */
    this.m24 = 0;
    /** @type {number} */
    this.m31 = 0;
    /** @type {number} */
    this.m32 = 0;
    /** @type {number} */
    this.m33 = 0;
    /** @type {number} */
    this.m34 = 0;
    /** @type {number} */
    this.m41 = 0;
    /** @type {number} */
    this.m42 = 0;
    /** @type {number} */
    this.m43 = 0;
    /** @type {number} */
    this.m44 = 0;

    if ((0, _InstanceOf3.default)(m, SCNMatrix4)) {
      this.m11 = m.m11;
      this.m12 = m.m12;
      this.m13 = m.m13;
      this.m14 = m.m14;
      this.m21 = m.m21;
      this.m22 = m.m22;
      this.m23 = m.m23;
      this.m24 = m.m24;
      this.m31 = m.m31;
      this.m32 = m.m32;
      this.m33 = m.m33;
      this.m34 = m.m34;
      this.m41 = m.m41;
      this.m42 = m.m42;
      this.m43 = m.m43;
      this.m44 = m.m44;
    } else if (arguments.length >= 16) {
      this.m11 = arguments[0];
      this.m12 = arguments[1];
      this.m13 = arguments[2];
      this.m14 = arguments[3];
      this.m21 = arguments[4];
      this.m22 = arguments[5];
      this.m23 = arguments[6];
      this.m24 = arguments[7];
      this.m31 = arguments[8];
      this.m32 = arguments[9];
      this.m33 = arguments[10];
      this.m34 = arguments[11];
      this.m41 = arguments[12];
      this.m42 = arguments[13];
      this.m43 = arguments[14];
      this.m44 = arguments[15];
    } else if (m !== null) {
      // TODO: type check
      this.m11 = m[0][0];
      this.m12 = m[0][1];
      this.m13 = m[0][2];
      this.m14 = m[0][3];
      this.m21 = m[1][0];
      this.m22 = m[1][1];
      this.m23 = m[1][2];
      this.m24 = m[1][3];
      this.m31 = m[2][0];
      this.m32 = m[2][1];
      this.m33 = m[2][2];
      this.m34 = m[2][3];
      this.m41 = m[3][0];
      this.m42 = m[3][1];
      this.m43 = m[3][2];
      this.m44 = m[3][3];
    }
  }

  /**
   * @access private
   * @param {Buffer} data -
   * @param {number} [offset = 0] -
   * @param {boolean} [bigEndian = false] -
   * @returns {SCNMatrix4} -
   */


  _createClass(SCNMatrix4, [{
    key: '_copy',
    value: function _copy() {
      return new SCNMatrix4(this);
    }

    // extensions

    /**
     * @access public
     * @param {SCNMatrix4} m -
     * @returns {SCNMatrix4} - 
     */

  }, {
    key: 'add',
    value: function add(m) {
      var r = new SCNMatrix4();
      r.m11 = this.m11 + m.m11;
      r.m12 = this.m12 + m.m12;
      r.m13 = this.m13 + m.m13;
      r.m14 = this.m14 + m.m14;
      r.m21 = this.m21 + m.m21;
      r.m22 = this.m22 + m.m22;
      r.m23 = this.m23 + m.m23;
      r.m24 = this.m24 + m.m24;
      r.m31 = this.m31 + m.m31;
      r.m32 = this.m32 + m.m32;
      r.m33 = this.m33 + m.m33;
      r.m34 = this.m34 + m.m34;
      r.m41 = this.m41 + m.m41;
      r.m42 = this.m42 + m.m42;
      r.m43 = this.m43 + m.m43;
      r.m44 = this.m44 + m.m44;
      return r;
    }

    /**
     * @access public
     * @param {number} t -
     * @returns {SCNMatrix4} - 
     */

  }, {
    key: 'mul',
    value: function mul(t) {
      var r = new SCNMatrix4();
      r.m11 = this.m11 * t;
      r.m12 = this.mj2 * t;
      r.m13 = this.m13 * t;
      r.m14 = this.m14 * t;
      r.m21 = this.m21 * t;
      r.m22 = this.m22 * t;
      r.m23 = this.m23 * t;
      r.m24 = this.m24 * t;
      r.m31 = this.m31 * t;
      r.m32 = this.m32 * t;
      r.m33 = this.m33 * t;
      r.m34 = this.m34 * t;
      r.m41 = this.m41 * t;
      r.m42 = this.m42 * t;
      r.m43 = this.m43 * t;
      r.m44 = this.m44 * t;
      return r;
    }

    /**
     * @access public
     * @param {SCNMatrix4} m -
     * @returns {SCNMatrix4} - 
     */

  }, {
    key: 'mult',
    value: function mult(m) {
      var r = new SCNMatrix4();
      r.m11 = this.m11 * m.m11 + this.m12 * m.m21 + this.m13 * m.m31 + this.m14 * m.m41;
      r.m12 = this.m11 * m.m12 + this.m12 * m.m22 + this.m13 * m.m32 + this.m14 * m.m42;
      r.m13 = this.m11 * m.m13 + this.m12 * m.m23 + this.m13 * m.m33 + this.m14 * m.m43;
      r.m14 = this.m11 * m.m14 + this.m12 * m.m24 + this.m13 * m.m34 + this.m14 * m.m44;
      r.m21 = this.m21 * m.m11 + this.m22 * m.m21 + this.m23 * m.m31 + this.m24 * m.m41;
      r.m22 = this.m21 * m.m12 + this.m22 * m.m22 + this.m23 * m.m32 + this.m24 * m.m42;
      r.m23 = this.m21 * m.m13 + this.m22 * m.m23 + this.m23 * m.m33 + this.m24 * m.m43;
      r.m24 = this.m21 * m.m14 + this.m22 * m.m24 + this.m23 * m.m34 + this.m24 * m.m44;
      r.m31 = this.m31 * m.m11 + this.m32 * m.m21 + this.m33 * m.m31 + this.m34 * m.m41;
      r.m32 = this.m31 * m.m12 + this.m32 * m.m22 + this.m33 * m.m32 + this.m34 * m.m42;
      r.m33 = this.m31 * m.m13 + this.m32 * m.m23 + this.m33 * m.m33 + this.m34 * m.m43;
      r.m34 = this.m31 * m.m14 + this.m32 * m.m24 + this.m33 * m.m34 + this.m34 * m.m44;
      r.m41 = this.m41 * m.m11 + this.m42 * m.m21 + this.m43 * m.m31 + this.m44 * m.m41;
      r.m42 = this.m41 * m.m12 + this.m42 * m.m22 + this.m43 * m.m32 + this.m44 * m.m42;
      r.m43 = this.m41 * m.m13 + this.m42 * m.m23 + this.m43 * m.m33 + this.m44 * m.m43;
      r.m44 = this.m41 * m.m14 + this.m42 * m.m24 + this.m43 * m.m34 + this.m44 * m.m44;
      return r;
    }

    /**
     * @access public
     * @param {SCNMatrix4} m -
     * @param {number} rate -
     * @returns {SCNMatrix4} - 
     */

  }, {
    key: 'lerp',
    value: function lerp(m, rate) {
      var r = new SCNMatrix4();
      r.m11 = this.m11 + rate * (this.m11 - m.m11);
      r.m12 = this.m12 + rate * (this.m12 - m.m12);
      r.m13 = this.m13 + rate * (this.m13 - m.m13);
      r.m14 = this.m14 + rate * (this.m14 - m.m14);
      r.m21 = this.m21 + rate * (this.m21 - m.m21);
      r.m22 = this.m22 + rate * (this.m22 - m.m22);
      r.m23 = this.m23 + rate * (this.m23 - m.m23);
      r.m24 = this.m24 + rate * (this.m24 - m.m24);
      r.m31 = this.m31 + rate * (this.m31 - m.m31);
      r.m32 = this.m32 + rate * (this.m32 - m.m32);
      r.m33 = this.m33 + rate * (this.m33 - m.m33);
      r.m34 = this.m34 + rate * (this.m34 - m.m34);
      r.m41 = this.m41 + rate * (this.m41 - m.m41);
      r.m42 = this.m42 + rate * (this.m42 - m.m42);
      r.m43 = this.m43 + rate * (this.m43 - m.m43);
      r.m44 = this.m44 + rate * (this.m44 - m.m44);
      return r;
    }

    /**
     * @access public
     * @returns {SCNVector4} -
     */

  }, {
    key: 'quaternion',
    value: function quaternion() {
      var r = new _SCNVector4.default();
      r.x = this.m32 - this.m23;
      r.y = this.m13 - this.m31;
      r.z = this.m21 - this.m12;
      r.w = Math.acos((this.m11 + this.m22 + this.m33 - 1) * 0.5);
      return r;
    }

    /**
     * @access public
     * @returns {SCNMatrix4} -
     */

  }, {
    key: 'invert',
    value: function invert() {
      var mat = SCNMatrix4._identity();
      var tmp = new SCNMatrix4(this);

      var buf = 0;
      var w1 = Math.abs(tmp.m11);
      var w2 = Math.abs(tmp.m21);
      var w3 = Math.abs(tmp.m31);
      var w4 = Math.abs(tmp.m41);
      var max = w1 > w2 ? w1 : w2;
      if (max < w3) max = w3;

      // 1
      if (max < w4) {
        buf = 1.0 / tmp.m41;
        w1 = tmp.m11;
        w2 = tmp.m12;
        w3 = tmp.m13;
        w4 = tmp.m14;
        tmp.m12 = tmp.m42 * buf;
        tmp.m13 = tmp.m43 * buf;
        tmp.m14 = tmp.m44 * buf;
        tmp.m41 = w1;
        tmp.m42 = w2;
        tmp.m43 = w3;
        tmp.m44 = w4;
        mat.m11 = 0.0;
        mat.m14 = buf;
        mat.m41 = 1.0;
        mat.m44 = 0.0;
      } else if (max === w1) {
        buf = 1.0 / tmp.m11;
        tmp.m12 *= buf;
        tmp.m13 *= buf;
        tmp.m14 *= buf;
        mat.m11 = buf;
      } else if (max === w2) {
        buf = 1.0 / tmp.m21;
        w1 = tmp.m11;
        w2 = tmp.m12;
        w3 = tmp.m13;
        w4 = tmp.m14;
        tmp.m12 = tmp.m22 * buf;
        tmp.m13 = tmp.m23 * buf;
        tmp.m14 = tmp.m24 * buf;
        tmp.m21 = w1;
        tmp.m22 = w2;
        tmp.m23 = w3;
        tmp.m24 = w4;
        mat.m11 = 0.0;
        mat.m12 = buf;
        mat.m21 = 1.0;
        mat.m22 = 0.0;
      } else {
        buf = 1.0 / tmp.m31;
        w1 = tmp.m11;
        w2 = tmp.m12;
        w3 = tmp.m13;
        w4 = tmp.m14;
        tmp.m12 = tmp.m32 * buf;
        tmp.m13 = tmp.m33 * buf;
        tmp.m14 = tmp.m34 * buf;
        tmp.m31 = w1;
        tmp.m32 = w2;
        tmp.m33 = w3;
        tmp.m34 = w4;
        mat.m11 = 0.0;
        mat.m13 = buf;
        mat.m31 = 1.0;
        mat.m33 = 0.0;
      }

      buf = tmp.m21;
      tmp.m22 -= tmp.m12 * buf;
      tmp.m23 -= tmp.m13 * buf;
      tmp.m24 -= tmp.m14 * buf;
      mat.m21 -= mat.m11 * buf;
      mat.m22 -= mat.m12 * buf;
      mat.m23 -= mat.m13 * buf;
      mat.m24 -= mat.m14 * buf;

      buf = tmp.m31;
      tmp.m32 -= tmp.m12 * buf;
      tmp.m33 -= tmp.m13 * buf;
      tmp.m34 -= tmp.m14 * buf;
      mat.m31 -= mat.m11 * buf;
      mat.m32 -= mat.m12 * buf;
      mat.m33 -= mat.m13 * buf;
      mat.m34 -= mat.m14 * buf;

      buf = tmp.m41;
      tmp.m42 -= tmp.m12 * buf;
      tmp.m43 -= tmp.m13 * buf;
      tmp.m44 -= tmp.m14 * buf;
      mat.m41 -= mat.m11 * buf;
      mat.m42 -= mat.m12 * buf;
      mat.m43 -= mat.m13 * buf;
      mat.m44 -= mat.m14 * buf;

      // 2
      w2 = Math.abs(tmp.m22);
      w3 = Math.abs(tmp.m32);
      w4 = Math.abs(tmp.m42);
      max = w2 > w3 ? w2 : w3;
      if (max < w4) {
        buf = 1.0 / tmp.m42;
        w2 = tmp.m22;
        w3 = tmp.m23;
        w4 = tmp.m24;
        tmp.m23 = tmp.m43 * buf;
        tmp.m24 = tmp.m44 * buf;
        tmp.m42 = w2;
        tmp.m43 = w3;
        tmp.m44 = w4;
        w1 = mat.m21;
        w2 = mat.m22;
        w3 = mat.m23;
        w4 = mat.m24;
        mat.m21 = mat.m41 * buf;
        mat.m22 = mat.m42 * buf;
        mat.m23 = mat.m43 * buf;
        mat.m24 = mat.m44 * buf;
        mat.m41 = w1;
        mat.m42 = w2;
        mat.m43 = w3;
        mat.m44 = w4;
      } else if (w2 > w3) {
        buf = 1.0 / tmp.m22;
        tmp.m23 *= buf;
        tmp.m24 *= buf;
        mat.m21 *= buf;
        mat.m22 *= buf;
        mat.m23 *= buf;
        mat.m24 *= buf;
      } else {
        buf = 1.0 / tmp.m32;
        w2 = tmp.m22;
        w3 = tmp.m23;
        w4 = tmp.m24;
        tmp.m23 = tmp.m33 * buf;
        tmp.m24 = tmp.m34 * buf;
        tmp.m32 = w2;
        tmp.m33 = w3;
        tmp.m34 = w4;
        w1 = mat.m21;
        w2 = mat.m22;
        w3 = mat.m23;
        w4 = mat.m24;
        mat.m21 = mat.m31 * buf;
        mat.m22 = mat.m32 * buf;
        mat.m23 = mat.m33 * buf;
        mat.m24 = mat.m34 * buf;
        mat.m31 = w1;
        mat.m32 = w2;
        mat.m33 = w3;
        mat.m34 = w4;
      }

      buf = tmp.m12;
      tmp.m13 -= tmp.m23 * buf;
      tmp.m14 -= tmp.m24 * buf;
      mat.m11 -= mat.m21 * buf;
      mat.m12 -= mat.m22 * buf;
      mat.m13 -= mat.m23 * buf;
      mat.m14 -= mat.m24 * buf;

      buf = tmp.m32;
      tmp.m33 -= tmp.m23 * buf;
      tmp.m34 -= tmp.m24 * buf;
      mat.m31 -= mat.m21 * buf;
      mat.m32 -= mat.m22 * buf;
      mat.m33 -= mat.m23 * buf;
      mat.m34 -= mat.m24 * buf;

      buf = tmp.m42;
      tmp.m43 -= tmp.m23 * buf;
      tmp.m44 -= tmp.m24 * buf;
      mat.m41 -= mat.m21 * buf;
      mat.m42 -= mat.m22 * buf;
      mat.m43 -= mat.m23 * buf;
      mat.m44 -= mat.m24 * buf;

      // 3
      if (Math.abs(tmp.m33) > Math.abs(tmp.m43)) {
        buf = 1.0 / tmp.m33;
        tmp.m34 *= buf;
        mat.m31 *= buf;
        mat.m32 *= buf;
        mat.m33 *= buf;
        mat.m34 *= buf;
      } else {
        buf = 1.0 / tmp.m43;
        w3 = tmp.m33;
        w4 = tmp.m34;
        tmp.m34 = tmp.m44 * buf;
        tmp.m43 = w3;
        tmp.m44 = w4;
        w1 = mat.m31;
        w2 = mat.m32;
        w3 = mat.m33;
        w4 = mat.m34;
        mat.m31 = mat.m41 * buf;
        mat.m32 = mat.m42 * buf;
        mat.m33 = mat.m43 * buf;
        mat.m34 = mat.m44 * buf;
        mat.m41 = w1;
        mat.m42 = w2;
        mat.m43 = w3;
        mat.m44 = w4;
      }
      buf = tmp.m13;
      tmp.m14 -= tmp.m34 * buf;
      mat.m11 -= mat.m31 * buf;
      mat.m12 -= mat.m32 * buf;
      mat.m13 -= mat.m33 * buf;
      mat.m14 -= mat.m34 * buf;

      buf = tmp.m23;
      tmp.m24 -= tmp.m34 * buf;
      mat.m21 -= mat.m31 * buf;
      mat.m22 -= mat.m32 * buf;
      mat.m23 -= mat.m33 * buf;
      mat.m24 -= mat.m34 * buf;

      buf = tmp.m43;
      tmp.m44 -= tmp.m34 * buf;
      mat.m41 -= mat.m31 * buf;
      mat.m42 -= mat.m32 * buf;
      mat.m43 -= mat.m33 * buf;
      mat.m44 -= mat.m34 * buf;

      // 4
      buf = 1.0 / tmp.m44;
      mat.m41 *= buf;
      mat.m42 *= buf;
      mat.m43 *= buf;
      mat.m44 *= buf;

      buf = tmp.m14;
      mat.m11 -= mat.m41 * buf;
      mat.m12 -= mat.m42 * buf;
      mat.m13 -= mat.m43 * buf;
      mat.m14 -= mat.m44 * buf;

      buf = tmp.m24;
      mat.m21 -= mat.m41 * buf;
      mat.m22 -= mat.m42 * buf;
      mat.m23 -= mat.m43 * buf;
      mat.m24 -= mat.m44 * buf;

      buf = tmp.m34;
      mat.m31 -= mat.m41 * buf;
      mat.m32 -= mat.m42 * buf;
      mat.m33 -= mat.m43 * buf;
      mat.m34 -= mat.m44 * buf;

      return mat;
    }

    /**
     * @access public
     * @returns {SCNMatrix4} -
     */

  }, {
    key: 'transpose',
    value: function transpose() {
      var r = new SCNMatrix4();
      r.m11 = this.m11;
      r.m12 = this.m21;
      r.m13 = this.m31;
      r.m14 = this.m41;
      r.m21 = this.m12;
      r.m22 = this.m22;
      r.m23 = this.m32;
      r.m24 = this.m42;
      r.m31 = this.m13;
      r.m32 = this.m23;
      r.m33 = this.m33;
      r.m34 = this.m43;
      r.m41 = this.m14;
      r.m42 = this.m24;
      r.m43 = this.m34;
      r.m44 = this.m44;
      return r;
    }

    /**
     * @access public
     * @param {number} x -
     * @param {number} y -
     * @param {number} z -
     * @returns {SCNMatrix4} -
     */

  }, {
    key: 'scale',
    value: function scale(x, y, z) {
      var m = SCNMatrix4.matrixWithScale(x, y, z);
      return this.mult(m);
    }

    /**
     * @access public
     * @param {number} x -
     * @param {number} y -
     * @param {number} z -
     * @returns {SCNMatrix4} -
     */

  }, {
    key: 'rotation',


    /**
     * @access public
     * @param {number} x -
     * @param {number} y -
     * @param {number} z -
     * @param {number} w -
     * @returns {SCNMatrix4} -
     */
    value: function rotation(x, y, z, w) {
      if ((0, _InstanceOf3.default)(x, _SCNVector4.default)) {
        var v = x;
        x = v.x;
        y = v.y;
        z = v.z;
        w = v.w;
      }

      var m = SCNMatrix4.matrixWithRotation(x, y, z, w);
      return this.mult(m);
    }

    /**
     * @access public
     * @param {number} x -
     * @param {number} y -
     * @param {number} z -
     * @param {number} w -
     * @returns {SCNMatrix4} -
     */

  }, {
    key: 'translation',


    /**
     * @access public
     * @param {number} x -
     * @param {number} y -
     * @param {number} z -
     * @returns {SCNMatrix4} -
     */
    value: function translation(x, y, z) {
      var m = SCNMatrix4.matrixWithTranslation(x, y, z);
      return this.mult(m);
    }

    /**
     * @access public
     * @param {number} x -
     * @param {number} y -
     * @param {number} z -
     * @returns {SCNMatrix4} -
     */

  }, {
    key: 'equalTo',


    /**
     * Returns a Boolean value that indicates whether the corresponding elements of two matrices are equal.
     * @access public
     * @param {SCNMatrix4} m -
     * @returns {boolean} -
     * @desc This function performs a numeric (not bitwise) comparison of each pair of elements.
     * @see https://developer.apple.com/documentation/scenekit/1409665-scnmatrix4equaltomatrix4
     */
    value: function equalTo(m) {
      if (!(0, _InstanceOf3.default)(m, SCNMatrix4)) {
        return false;
      }

      return Math.abs(this.m11 - m.m11) < _epsilon && Math.abs(this.m12 - m.m12) < _epsilon && Math.abs(this.m13 - m.m13) < _epsilon && Math.abs(this.m14 - m.m14) < _epsilon && Math.abs(this.m21 - m.m21) < _epsilon && Math.abs(this.m22 - m.m22) < _epsilon && Math.abs(this.m23 - m.m23) < _epsilon && Math.abs(this.m24 - m.m24) < _epsilon && Math.abs(this.m31 - m.m31) < _epsilon && Math.abs(this.m32 - m.m32) < _epsilon && Math.abs(this.m33 - m.m33) < _epsilon && Math.abs(this.m34 - m.m34) < _epsilon && Math.abs(this.m41 - m.m41) < _epsilon && Math.abs(this.m42 - m.m42) < _epsilon && Math.abs(this.m43 - m.m43) < _epsilon && Math.abs(this.m44 - m.m44) < _epsilon;
    }

    /**
     * Returns a Boolean value that indicates whether the matrix is equal to the identity matrix.
     * @access public
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/scenekit/1409715-scnmatrix4isidentity
     */

  }, {
    key: 'isIdentity',
    value: function isIdentity() {
      return this.equalTo(SCNMatrix4._identity());
    }

    /**
     * @access public
     * @returns {SCNVector3} -
     */

  }, {
    key: 'getScale',
    value: function getScale() {
      var det = this.m11 * this.m22 * this.m33 + this.m12 * this.m23 * this.m31 + this.m13 * this.m21 * this.m32 - this.m11 * this.m23 * this.m32 - this.m12 * this.m21 * this.m33 - this.m13 * this.m22 * this.m31;
      var sign = det > 0 ? 1 : -1;
      var r = sign / this.m44;
      var sx = new _SCNVector2.default(this.m11, this.m12, this.m13);
      var sy = new _SCNVector2.default(this.m21, this.m22, this.m23);
      var sz = new _SCNVector2.default(this.m31, this.m32, this.m33);
      return new _SCNVector2.default(sx.length() * r, sy.length() * r, sz.length() * r);
    }

    /**
     * @access public
     * @returns {SCNVector3} -
     */

  }, {
    key: 'getTranslation',
    value: function getTranslation() {
      return new _SCNVector2.default(this.m41 / this.m44, this.m42 / this.m44, this.m43 / this.m44);
    }

    /**
     * @access public
     * @returns {SCNVector4} -
     */

  }, {
    key: 'getRotation',
    value: function getRotation() {
      var e = [];
      var scale = this.getScale().mul(this.m44);
      var v = new _SCNVector4.default();
      var n1 = new _SCNVector2.default(this.m11, this.m12, this.m13).mul(1.0 / scale.x);
      var n2 = new _SCNVector2.default(this.m21, this.m22, this.m23).mul(1.0 / scale.y);
      var n3 = new _SCNVector2.default(this.m31, this.m32, this.m33).mul(1.0 / scale.z);
      e[0] = n1.x - n2.y - n3.z + 1.0;
      e[1] = -n1.x + n2.y - n3.z + 1.0;
      e[2] = -n1.x - n2.y + n3.z + 1.0;
      e[3] = n1.x + n2.y + n3.z + 1.0;
      var maxIndex = 0;
      for (var i = 1; i < 4; i++) {
        if (e[i] > e[maxIndex]) {
          maxIndex = i;
        }
      }
      if (e[maxIndex] < 0) {
        throw new Error('something is wrong...');
      }
      var d = Math.sqrt(e[maxIndex]) * 0.5;
      var r = 0.25 / d;

      //console.log(`n1: ${n1.x}, ${n1.y}, ${n1.z}`)
      //console.log(`n2: ${n2.x}, ${n2.y}, ${n2.z}`)
      //console.log(`n3: ${n3.x}, ${n3.y}, ${n3.z}`)
      //console.log(`d: ${d}, r: ${r}`)
      switch (maxIndex) {
        case 0:
          v.x = d;
          v.y = (n1.y + n2.x) * r;
          v.z = (n3.x + n1.z) * r;
          v.w = (n2.z - n3.y) * r;
          break;
        case 1:
          v.x = (n1.y + n2.x) * r;
          v.y = d;
          v.z = (n2.z + n3.y) * r;
          v.w = (n3.x - n1.z) * r;
          break;
        case 2:
          v.x = (n3.x + n1.z) * r;
          v.y = (n2.z + n3.y) * r;
          v.z = d;
          v.w = (n1.y - n2.x) * r;
          break;
        case 3:
          v.x = (n2.z - n3.y) * r;
          v.y = (n3.x - n1.z) * r;
          v.z = (n1.y - n2.x) * r;
          v.w = d;
          break;
      }
      if (v.x === 0 && v.y === 0 && v.z === 0) {
        v.w = 0;
      } else {
        var w = Math.acos(v.w);
        if (isNaN(w)) {
          v.w = 0;
        } else {
          v.w = w * 2.0;
        }
      }

      return v;
    }

    /**
     * @access public
     * @returns {SCNVector4} -
     */

  }, {
    key: 'getOrientation',
    value: function getOrientation() {
      return this.getRotation().rotationToQuat
      /*
      const e = []
      const scale = this.getScale().mul(this.m44)
      const v = new SCNVector4()
      const n1 = (new SCNVector3(this.m11, this.m12, this.m13)).mul(1.0 / scale.x)
      const n2 = (new SCNVector3(this.m21, this.m22, this.m23)).mul(1.0 / scale.y)
      const n3 = (new SCNVector3(this.m31, this.m32, this.m33)).mul(1.0 / scale.z)
      e[0] = n1.x - n2.y - n3.z + 1.0
      e[1] = -n1.x + n2.y - n3.z + 1.0
      e[2] = -n1.x - n2.y + n3.z + 1.0
      e[3] = n1.x + n2.y + n3.z + 1.0
      let maxIndex = 0
      for(let i=1; i<4; i++){
        if(e[i] > e[maxIndex]){
          maxIndex = i
        }
      }
      console.log(`maxIndex: ${maxIndex} => ${e[maxIndex]}`)
      if(e[maxIndex] < 0){
        throw new Error('something is wrong...')
      }
      const d = Math.sqrt(e[maxIndex]) * 0.5
      const r = 0.25 / d
       //console.log(`n1: ${n1.x}, ${n1.y}, ${n1.z}`)
      //console.log(`n2: ${n2.x}, ${n2.y}, ${n2.z}`)
      //console.log(`n3: ${n3.x}, ${n3.y}, ${n3.z}`)
      //console.log(`d: ${d}, r: ${r}`)
      switch(maxIndex){
        case 0:
          v.x = d
          v.y = (n1.y + n2.x) * r
          v.z = (n3.x + n1.z) * r
          v.w = (n2.z - n3.y) * r
          break
        case 1:
          v.x = (n1.y + n2.x) * r
          v.y = d
          v.z = (n2.z + n3.y) * r
          v.w = (n3.x - n1.z) * r
          break
        case 2:
          v.x = (n3.x + n1.z) * r
          v.y = (n2.z + n3.y) * r
          v.z = d
          v.w = (n1.y - n2.x) * r
          break
        case 3:
          v.x = (n2.z - n3.y) * r
          v.y = (n3.x - n1.z) * r
          v.z = (n1.y - n2.x) * r
          v.w = d
          break
      }
      const len = 1.0 / Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
      v.x *= len
      v.y *= len
      v.z *= len
       return v
      */
      ();
    }

    /**
     * @access public
     * @returns {number[]} -
     */

  }, {
    key: 'floatArray',
    value: function floatArray() {
      return [this.m11, this.m12, this.m13, this.m14, this.m21, this.m22, this.m23, this.m24, this.m31, this.m32, this.m33, this.m34, this.m41, this.m42, this.m43, this.m44];
    }

    /**
     * @access public
     * @returns {Float32Array} -
     */

  }, {
    key: 'float32Array',
    value: function float32Array() {
      return new Float32Array([this.m11, this.m12, this.m13, this.m14, this.m21, this.m22, this.m23, this.m24, this.m31, this.m32, this.m33, this.m34, this.m41, this.m42, this.m43, this.m44]);
    }

    /**
     * @access public
     * @returns {number[]} -
     */

  }, {
    key: 'floatArray3x4f',
    value: function floatArray3x4f() {
      return [this.m11, this.m21, this.m31, this.m41, this.m12, this.m22, this.m32, this.m42, this.m13, this.m23, this.m33, this.m43];
    }

    /**
     * @access public
     * @returns {Float32Array} -
     */

  }, {
    key: 'float32Array3x4f',
    value: function float32Array3x4f() {
      return new Float32Array([this.m11, this.m21, this.m31, this.m41, this.m12, this.m22, this.m32, this.m42, this.m13, this.m23, this.m33, this.m43]);
    }
  }], [{
    key: '_initWithData',
    value: function _initWithData(data) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var bigEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var instance = new SCNMatrix4();
      if (bigEndian) {
        instance.m11 = data.readFloatBE(offset + 0);
        instance.m12 = data.readFloatBE(offset + 4);
        instance.m13 = data.readFloatBE(offset + 8);
        instance.m14 = data.readFloatBE(offset + 12);
        instance.m21 = data.readFloatBE(offset + 16);
        instance.m22 = data.readFloatBE(offset + 20);
        instance.m23 = data.readFloatBE(offset + 24);
        instance.m24 = data.readFloatBE(offset + 28);
        instance.m31 = data.readFloatBE(offset + 32);
        instance.m32 = data.readFloatBE(offset + 36);
        instance.m33 = data.readFloatBE(offset + 40);
        instance.m34 = data.readFloatBE(offset + 44);
        instance.m41 = data.readFloatBE(offset + 48);
        instance.m42 = data.readFloatBE(offset + 52);
        instance.m43 = data.readFloatBE(offset + 56);
        instance.m44 = data.readFloatBE(offset + 60);
      } else {
        instance.m11 = data.readFloatLE(offset + 0);
        instance.m12 = data.readFloatLE(offset + 4);
        instance.m13 = data.readFloatLE(offset + 8);
        instance.m14 = data.readFloatLE(offset + 12);
        instance.m21 = data.readFloatLE(offset + 16);
        instance.m22 = data.readFloatLE(offset + 20);
        instance.m23 = data.readFloatLE(offset + 24);
        instance.m24 = data.readFloatLE(offset + 28);
        instance.m31 = data.readFloatLE(offset + 32);
        instance.m32 = data.readFloatLE(offset + 36);
        instance.m33 = data.readFloatLE(offset + 40);
        instance.m34 = data.readFloatLE(offset + 44);
        instance.m41 = data.readFloatLE(offset + 48);
        instance.m42 = data.readFloatLE(offset + 52);
        instance.m43 = data.readFloatLE(offset + 56);
        instance.m44 = data.readFloatLE(offset + 60);
      }
      return instance;
    }
  }, {
    key: 'matrixWithScale',
    value: function matrixWithScale(x, y, z) {
      var _x = x;
      var _y = y;
      var _z = z;
      if ((0, _InstanceOf3.default)(x, _SCNVector2.default)) {
        var v = x;
        _x = v.x;
        _y = v.y;
        _z = v.z;
      }

      //const m = new SCNMatrix4()
      var m = SCNMatrix4._identity();
      m.m11 = _x;
      m.m22 = _y;
      m.m33 = _z;
      return m;
    }
  }, {
    key: 'matrixWithRotation',
    value: function matrixWithRotation(x, y, z, w) {
      if ((0, _InstanceOf3.default)(x, _SCNVector4.default)) {
        var _v = x;
        x = _v.x;
        y = _v.y;
        z = _v.z;
        w = _v.w;
      }

      var c = Math.cos(w);
      var s = Math.sin(w);
      var v = new _SCNVector2.default(x, y, z).normalize();
      var m = SCNMatrix4._identity();

      var nx = v.x;
      var ny = v.y;
      var nz = v.z;

      m.m11 = nx * nx * (1.0 - c) + c;
      m.m12 = ny * nx * (1.0 - c) + nz * s;
      m.m13 = nz * nx * (1.0 - c) - ny * s;
      m.m14 = 0.0;
      m.m21 = nx * ny * (1.0 - c) - nz * s;
      m.m22 = ny * ny * (1.0 - c) + c;
      m.m23 = nz * ny * (1.0 - c) + nx * s;
      m.m24 = 0.0;
      m.m31 = nx * nz * (1.0 - c) + ny * s;
      m.m32 = ny * nz * (1.0 - c) - nx * s;
      m.m33 = nz * nz * (1.0 - c) + c;
      m.m34 = 0.0;
      m.m41 = 0.0;
      m.m42 = 0.0;
      m.m43 = 0.0;
      m.m44 = 1.0;

      return m;
    }
  }, {
    key: 'matrixWithOrientation',
    value: function matrixWithOrientation(orientation) {
      return SCNMatrix4.matrixWithRotation(orientation.quatToRotation());
    }
  }, {
    key: 'matrixWithTranslation',
    value: function matrixWithTranslation(x, y, z) {
      var _x = x;
      var _y = y;
      var _z = z;
      if ((0, _InstanceOf3.default)(x, _SCNVector2.default)) {
        var v = x;
        _x = v.x;
        _y = v.y;
        _z = v.z;
      }

      //const m = new SCNMatrix4()
      var m = SCNMatrix4._identity();
      m.m41 = _x;
      m.m42 = _y;
      m.m43 = _z;
      return m;
    }
  }, {
    key: '_identity',
    value: function _identity() {
      return new SCNMatrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
  }]);

  return SCNMatrix4;
}();

exports.default = SCNMatrix4;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A structure that contains width and height values.
 * @access public
 * @see https://developer.apple.com/documentation/coregraphics/cgsize
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CGSize = function () {
  _createClass(CGSize, null, [{
    key: '_initWithData',

    /**
     * @access private
     * @param {Buffer} data -
     * @param {number} [offset = 0] -
     * @param {boolean} [bigEndian = false] -
     * @returns {CGSize} -
     */
    value: function _initWithData(data) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var bigEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      throw new Error('not implemented');
    }

    // Initializers

    /**
     * Creates a size with dimensions specified as floating-point values.    
     * @access public
     * @constructor
     * @param {number} width - 
     * @param {number} height - 
     * @see https://developer.apple.com/documentation/coregraphics/cgsize/1454915-init
     */

  }]);

  function CGSize(width, height) {
    _classCallCheck(this, CGSize);

    // Geometric Properties
    this.width = width;
    this.height = height;
  }

  // Geometric Properties

  // Special Values
  /**
   * The size whose width and height are both zero.
   * @type {CGSize}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgsize/1455512-zero
   */


  _createClass(CGSize, [{
    key: 'applying',


    // Transforming Sizes

    /**
     * Returns the height and width resulting from a transformation of an existing height and width.
     * @access public
     * @param {CGAffineTransform} t - The affine transform to apply. 
     * @returns {CGSize} - 
     * @see https://developer.apple.com/documentation/coregraphics/cgsize/1454806-applying
     */
    value: function applying(t) {
      return null;
    }

    // Alternate Representations

    /**
     * Creates a size from a canonical dictionary representation. 
     * @access public
     * @param {Map} dict - A dictionary containing width and height values for the size to create, in the format used by the dictionaryRepresentation property.
     * @returns {void}
     * @see https://developer.apple.com/documentation/coregraphics/cgsize/2427155-init
     */

  }, {
    key: 'equalTo',


    // Comparing Sizes

    /**
     * Returns whether two sizes are equal. 
     * @access public
     * @param {CGSize} size2 - 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/coregraphics/cgsize/1455176-equalto
     */
    value: function equalTo(size2) {
      var epsilon = 0.00001;
      return Math.abs(this.width - size2.width) < epsilon && Math.abs(this.height - size2.height) < epsilon;
    }
  }, {
    key: 'zero',
    value: function zero() {
      return new CGSize(0, 0);
    }
  }, {
    key: 'add',
    value: function add(size2) {
      return new CGSize(this.width + size2.width, this.height + size2.height);
    }
  }, {
    key: 'sub',
    value: function sub(size2) {
      return new CGSize(this.width - size2.width, this.height - size2.height);
    }

    /**
     * @access public
     * @param {CGSize} s -
     * @param {number} rate -
     * @returns {CGSize} -
     */

  }, {
    key: 'lerp',
    value: function lerp(s, rate) {
      var w = this.width + rate * (s.width - this.width);
      var h = this.height + rate * (s.height - this.height);
      return new CGSize(w, h);
    }
  }, {
    key: 'copy',
    value: function copy() {
      return new CGSize(this.width, this.height);
    }
  }, {
    key: 'dictionaryRepresentation',


    /**
     * Returns a dictionary representation of the specified size.
     * @type {Map}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgsize/1455274-dictionaryrepresentation
     */
    get: function get() {
      var map = new Map();
      map.set('width', this.width);
      map.set('height', this.height);
      return map;
    }

    /**
     * A textual representation of the size's dimensions.  
     * @type {string}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgsize/1645822-debugdescription
     */

  }, {
    key: 'debugDescription',
    get: function get() {
      return '{width: ' + this.width + ', height: ' + this.height + '}';
    }

    /**
     * A representation of the size's structure and display style for use in debugging. 
     * @type {Mirror}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgsize/1645828-custommirror
     */

  }, {
    key: 'customMirror',
    get: function get() {
      return null;
    }
    /**
     * A representation of the size for use in Playgrounds. 
     * @type {PlaygroundQuickLook}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgsize/1645830-customplaygroundquicklook
     */

  }, {
    key: 'customPlaygroundQuickLook',
    get: function get() {
      return null;
    }
  }], [{
    key: 'sizeWithDictionaryRepresentation',
    value: function sizeWithDictionaryRepresentation(dict) {
      return new CGSize(dict.get('width'), dict.get('height'));
    }
  }, {
    key: 'zero',
    get: function get() {
      return new CGSize(0, 0);
    }
  }]);

  return CGSize;
}();

exports.default = CGSize;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNCullMode = __webpack_require__(48);

var _SCNCullMode2 = _interopRequireDefault(_SCNCullMode);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNOrderedDictionary = __webpack_require__(22);

var _SCNOrderedDictionary2 = _interopRequireDefault(_SCNOrderedDictionary);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNAnimatable from './SCNAnimatable'

//import SCNBoundingVolume from './SCNBoundingVolume'
//import SCNShadable from './SCNShadable'

//import SCNGeometryElement from './SCNGeometryElement'
//import SCNLevelOfDetail from './SCNLevelOfDetail'

//import SCNMatrix4MakeTranslation from './SCNMatrix4MakeTranslation'


/**
 * A three-dimensional shape (also called a model or mesh) that can be displayed in a scene, with attached materials that define its appearance.
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @implements {SCNBoundingVolume}
 * @implements {SCNShadable}
 * @see https://developer.apple.com/documentation/scenekit/scngeometry
 */
var SCNGeometry = function (_NSObject) {
  _inherits(SCNGeometry, _NSObject);

  _createClass(SCNGeometry, null, [{
    key: '_propTypes',
    get: function get() {
      var addSources = function addSources(obj, sources, key, coder) {
        var _obj$_geometrySources;

        //console.log(`addSources source.length: ${sources.length}, key: ${key}`)
        (_obj$_geometrySources = obj._geometrySources).push.apply(_obj$_geometrySources, _toConsumableArray(sources));
      };
      return {
        name: 'string',
        levelsOfDetail: 'NSArray',
        materials: 'NSArray',
        tessellator: 'SCNGeometryTessellator',
        subdivisionLevel: 'integer',
        // program
        // shaderModifiers
        elements: ['NSArray', '_geometryElements'],
        kGeometrySourceSemanticColor: ['NSArray', addSources],
        kGeometrySourceSemanticEdgeCrease: ['NSArray', addSources],
        kGeometrySourceSemanticNormal: ['NSArray', addSources],
        kGeometrySourceSemanticTangent: ['NSArray', addSources],
        kGeometrySourceSemanticTexcoord: ['NSArray', addSources],
        kGeometrySourceSemanticVertex: ['NSArray', function (obj, sources) {
          addSources(obj, sources);
          obj._updateBoundingBox();
        }],
        kGeometrySourceSemanticVertexCrease: ['NSArray', addSources],
        wantsAdaptiveSubdivision: 'boolean',
        adaptiveSubdivision: ['boolean', null],

        entityID: ['string', '_entityID'],
        subdivisionSettings: ['bytes', null],
        shadableHelper: ['SCNShadableHelper', '_shadableHelper']
      };
    }

    // Creating a Geometry Object

    /**
     * Creates a new geometry built from the specified geometry sources and elements.
     * @access public
     * @constructor
     * @param {SCNGeometrySource[]} sources - An array of SCNGeometrySource objects describing vertices in the geometry and their attributes.
     * @param {?SCNGeometryElement[]} elements - An array of SCNGeometryElement objects describing how to connect the geometry’s vertices.
     * @desc A geometry's visible content comes from the combination of geometry sources, which contain data describing its vertices, with geometry elements, which contain data describing how the vertices connect to form a surface. Each SCNGeometrySource object describes an attribute of all vertices in the geometry (vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source's semantic property. To create a custom geometry you must provide at least one source, for the vertex semantic. Typically, you also provide sources for normals and texture coordinates for use in lighting and shading.Sources for the vertex, normal, and color semantics must be unique-if multiple objects in the sources array have the same semantic, SceneKit uses only the first. A geometry may have multiple sources for the texcoord semantic-the order of texture coordinate sources in the sources array determines the value to use for the mappingChannel property when attaching materials.Each SCNGeometryElement object describes how vertices from the geometry sources are combined into polygons to create the geometry's shape. Creating a custom geometry requires at least one element. If the elements array contains multiple objects, their order determines the arrangement of the geometry's materials-for details, see the discussion of the materials property.
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1522803-init
     */

  }]);

  function SCNGeometry() {
    var sources = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, SCNGeometry);

    var _this = _possibleConstructorReturn(this, (SCNGeometry.__proto__ || Object.getPrototypeOf(SCNGeometry)).call(this));

    if (!Array.isArray(sources)) {
      throw new Error('SCNGeometry(sources, elements): sources must be Array');
    }
    if (!Array.isArray(elements)) {
      throw new Error('SCNGeometry(sources, elements): elements must be Array');
    }

    // Managing Geometry Attributes

    /**
     * A name associated with the geometry object.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1522953-name
     */
    _this.name = null;

    /**
     * An array of SCNLevelOfDetail objects for managing the geometry’s appearance when viewed from far away.
     * @type {?SCNLevelOfDetail[]}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523745-levelsofdetail
     */
    _this.levelsOfDetail = null;

    // Managing a Geometry’s Materials

    /**
     * An array of SCNMaterial objects that determine the geometry’s appearance when rendered.
     * @type {SCNMaterial[]}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523472-materials
     */
    _this.materials = [];

    // Managing Geometry Data

    _this._geometryElements = elements;
    _this._geometrySources = sources;
    _this._vertexArrayObjects = null;
    _this._materialBuffer = null;
    //this._textureFlagBuffer = null
    _this._shadowVAO = null;
    _this._hitTestVAO = null;

    // Working with Subdivision Surfaces

    /**
     * The number of subdivisions SceneKit uses to smooth the geometry’s surface at render time.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1524177-subdivisionlevel
     */
    _this.subdivisionLevel = 0;

    /**
     * The geometry element identifying which edges of the geometry’s surface should remain sharp after subdivision.
     * @type {?SCNGeometryElement}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523246-edgecreaseselement
     */
    _this.edgeCreasesElement = null;

    /**
     * The geometry source specifying the smoothness or sharpness of edges after surface subdivision.
     * @type {?SCNGeometrySource}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523479-edgecreasessource
     */
    _this.edgeCreasesSource = null;

    /////////////////
    // SCNShadable //
    /////////////////

    // Assigning a Custom Shader Program

    /**
     * A program used when rendering the object.
     * @type {?SCNProgram}
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523689-program
     */
    _this.program = null;

    // Customizing SceneKit’s Shader Programs

    /**
     * A dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.
     * @type {?Map<SCNShaderModifierEntryPoint, string>}
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523348-shadermodifiers
     */
    _this.shaderModifiers = null;

    /**
     * @access private
     * @type {Map<string, SCNBindingBlock>}
     */
    _this._bindingHandler = {};

    /**
     * @access private
     * @type {Map<string, SCNBindingBlock>}
     */
    _this._unbindingHandler = {};

    /**
     * @access private
     * @type {Object}
     */
    _this._valuesForUndefinedKeys = {};

    ///////////////////
    // SCNAnimatable //
    ///////////////////

    /**
     * @access private
     * @type {SCNOrderedDictionary}
     */
    _this._animations = new _SCNOrderedDictionary2.default();

    ///////////////////////
    // SCNBoundingVolume //
    ///////////////////////

    // Working with Bounding Volumes

    /**
     * The minimum and maximum corner points of the object’s bounding box.
     * @type {{min: SCNVector3, max: SCNVector3}}
     * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034705-boundingbox
     */
    _this.boundingBox = null;

    /**
     * The center point and radius of the object’s bounding sphere.
     * @access private
     * @type {Object}
     * @parameter {SCNVector3} _boundingSphere.center
     * @parameter {number} _boundingSphere.radius
     */
    //this._boundingSphere = null

    /**
     * 
     * @type {SCNGeometryTessellator}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/2867472-tessellator
     */
    _this.tessellator = null;

    /**
     *
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/2888353-wantsadaptivesubdivision
     */
    _this.wantsAdaptiveSubdivision = false; // TODO: check the default value

    _this._vertexBuffer = null;
    _this._indexBuffer = null;

    _this._isPresentationInstance = false;
    _this._presentation = null;

    /**
     * @access private
     * @type {?string}
     */
    _this._entityID = null;

    /**
     * @access private
     * @type {?SCNShadableHelper}
     */
    _this._shadableHelper = null;

    _this._btVertices = null;
    _this._btMesh = null;
    _this._btShape = null;

    /**
     * @access private
     * @type {Promise}
     */
    _this._loadedPromise = null;
    return _this;
  }

  // Managing a Geometry’s Materials

  /**
   * The first material attached to the geometry.
   * @type {?SCNMaterial}
   * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523485-firstmaterial
   */


  _createClass(SCNGeometry, [{
    key: 'materialNamed',


    /**
     * Returns the first material attached to the geometry with the specified name.
     * @access public
     * @param {string} name - The name of the material to be retrieved.
     * @returns {?SCNMaterial} - 
     * @desc You can use the name property of each SCNMaterial object to make managing your scene graph easier. Materials loaded from a scene file may have names assigned by an artist using a 3D authoring tool.If a geometry has multiple materials attached with the same name, this method returns the first according to the order of the materials array.
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523789-material
     */
    value: function materialNamed(name) {
      return null;
    }

    /**
     * Attaches a material to the geometry at the specified index.
     * @access public
     * @param {SCNMaterial} material - The material to attach.
     * @param {number} index - The location in the geometry’s materials array at which to add the new material.ImportantRaises an exception (rangeException) if index is greater than the number of elements in the materials array.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1522876-insertmaterial
     */

  }, {
    key: 'insertMaterialAt',
    value: function insertMaterialAt(material, index) {}

    /**
     * Removes a material attached to the geometry.
     * @access public
     * @param {number} index - The index of the attached material to be removed.ImportantRaises an exception (rangeException) if index is beyond the bounds of the materials array.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1522646-removematerial
     */

  }, {
    key: 'removeMaterialAt',
    value: function removeMaterialAt(index) {}

    /**
     * Replaces a material attached to the geometry with another.
     * @access public
     * @param {number} index - The index of the attached material to be replaced.ImportantRaises an exception (rangeException) if index is beyond the bounds of the materials array.
     * @param {SCNMaterial} material - The material with which to replace the attached material.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1522714-replacematerial
     */

  }, {
    key: 'replaceMaterialAtIndexWith',
    value: function replaceMaterialAtIndexWith(index, material) {}

    // Managing Geometry Data

    /**
     * Returns the geometry element at a specified index.
     * @access public
     * @param {number} elementIndex - The index of the geometry element.
     * @returns {SCNGeometryElement} - 
     * @desc Each SCNGeometryElement object describes how vertices from the geometry’s sources are combined into polygons to create the geometry’s shape. Visible geometries contain at least one element.
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523266-geometryelement
     */

  }, {
    key: 'geometryElementAtIndex',
    value: function geometryElementAtIndex(elementIndex) {
      return this._geometryElements[elementIndex];
    }

    /**
     * Returns the geometry sources for a specified semantic.
     * @access public
     * @param {SCNGeometrySource.Semantic} semantic - A constant identifying a semantic for which to return geometry sources. See Geometry Semantic Identifiers for possible values.
     * @returns {SCNGeometrySource[]} - 
     * @desc Each SCNGeometrySource object describes an attribute of all vertices in the geometry (such as vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source’s semantic property. A geometry always has at least one source, for the vertex semantic, typically has additional sources for use in lighting and shading, and may have other sources for skeletal animation or surface subdivision information.The vertex, normal, and color semantics each refer to at most one source. A geometry may have multiple sources for the texcoord semantic—in this case, indices in the returned array correspond to values for the mappingChannel property used when attaching textures to materials.
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1522926-getgeometrysources
     */

  }, {
    key: 'getGeometrySourcesForSemantic',
    value: function getGeometrySourcesForSemantic(semantic) {
      return this._geometrySources.filter(function (source) {
        return source.semantic === semantic;
      });
    }

    /**
     * An array of geometry elements that describe the geometry’s shape.
     * @type {SCNGeometryElement[]}
     * @desc Each SCNGeometryElement object describes how vertices from the geometry’s sources are combined into polygons to create the geometry’s shape. Visible geometries contain at least one element.For geometries with multiple elements, you can use the materials property to attach different materials to each element.
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523046-geometryelements
     */

  }, {
    key: 'getBoundingSphere',


    ///////////////////////
    // SCNBoundingVolume //
    ///////////////////////

    // Working with Bounding Volumes

    /**
     * The center point and radius of the object’s bounding sphere.
     * @type {Object}
     * @parameter {SCNVector3} _boundingSphere.center -
     * @parameter {number} _boundingSphere.radius -
     * @returns {Object} -
     * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a node’s bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of node’s geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
     * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034707-boundingsphere
     */
    value: function getBoundingSphere() {
      if (this.boundingBox === null) {
        return { center: new _SCNVector2.default(0, 0, 0), radius: 0 };
      }
      var max = this.boundingBox.max;
      var min = this.boundingBox.min;
      var w = (max.x - min.x) * 0.5;
      var h = (max.y - min.y) * 0.5;
      var l = (max.z - min.z) * 0.5;
      var r = Math.sqrt(w * w + h * h + l * l);
      var c = new _SCNVector2.default(min.x + w, min.y + h, min.z + l);

      return { center: c, radius: r };
    }

    /////////////////
    // SCNShadable //
    /////////////////

    // Handling Parameters in Custom OpenGL Shader Programs

    /**
     * Specifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.
     * @access public
     * @param {string} symbol - A GLSL uniform variable or attribute name.
     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
     * @returns {void}
     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
      }];
    This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
      }];
      * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523063-handlebinding
     */

  }, {
    key: 'handleBindingOfSymbolHandler',
    value: function handleBindingOfSymbolHandler(symbol) {
      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._bindingHandler[symbol] = block;
    }

    /**
     * Specifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.
     * @access public
     * @param {string} symbol - A GLSL uniform variable or attribute name.
     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
     * @returns {void}
     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1522783-handleunbinding
     */

  }, {
    key: 'handleUnbindingOfSymbolHandler',
    value: function handleUnbindingOfSymbolHandler(symbol) {
      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._unbindingHandler[symbol] = block;
    }

    /**
     * @access private
     * @param {SCNNode} node -
     * @param {WebGLProgram} glProgram -
     * @param {WebGLRenderingContext} gl -
     * @param {SCNRenderer} renderer -
     * @returns {void}
     */

  }, {
    key: '_callBindingHandlerForNodeProgramContextRenderer',
    value: function _callBindingHandlerForNodeProgramContextRenderer(node, glProgram, gl, renderer) {
      var bindingKeys = Object.keys(this._bindingHandler);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = bindingKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          var handler = this._bindingHandler[key];
          var loc = gl.getUniformBlockIndex(glProgram, key);
          handler(glProgram, loc, node, renderer);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * @access private
     * @param {SCNNode} node -
     * @param {WebGLProgram} glProgram -
     * @param {WebGLRenderingContext} gl -
     * @param {SCNRenderer} renderer -
     * @returns {void}
     */

  }, {
    key: '_callUnindingHandlerForNodeProgramContextRenderer',
    value: function _callUnindingHandlerForNodeProgramContextRenderer(node, glProgram, gl, renderer) {
      var bindingKeys = Object.keys(this._unbindingHandler);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = bindingKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var key = _step2.value;

          var handler = this._unbindingHandler[key];
          var loc = gl.getUniformBlockIndex(glProgram, key);
          handler(glProgram, loc, node, renderer);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    ///////////////////
    // SCNAnimatable //
    ///////////////////

    // Managing Animations

    /**
     * Required. Adds an animation object for the specified key.
     * @access public
     * @param {CAAnimation} animation - The animation object to be added.
     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
     * @returns {void}
     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation
     */

  }, {
    key: 'addAnimationForKey',
    value: function addAnimationForKey(animation, key) {
      if (typeof key === 'undefined' || key === null) {
        key = Symbol();
      }
      var anim = animation.copy
      // FIXME: use current frame time
      ();anim._animationStartTime = Date.now() * 0.001;
      anim._prevTime = anim._animationStartTime - 0.0000001;

      this._animations.set(key, anim);
    }

    /**
     * Required. Returns the animation with the specified key.
     * @access public
     * @param {string} key - A string identifying a previously added animation.
     * @returns {?CAAnimation} - 
     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation
     */

  }, {
    key: 'animationForKey',
    value: function animationForKey(key) {
      return this._animations.get(key);
    }

    /**
     * Required. Removes all the animations currently attached to the object.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations
     */

  }, {
    key: 'removeAllAnimations',
    value: function removeAllAnimations() {
      this._animations.clear();
    }

    /**
     * Required. Removes the animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation to remove.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation
     */

  }, {
    key: 'removeAnimationForKey',
    value: function removeAnimationForKey(key) {
      this._animations.delete(key
      // TODO: reset values
      );
    }

    /**
     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
     * @access public
     * @param {string} key - A string identifying an attached animation to remove.
     * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
     * @returns {void}
     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation
     */

  }, {
    key: 'removeAnimationForKeyFadeOutDuration',
    value: function removeAnimationForKeyFadeOutDuration(key, duration) {}

    /**
     * Required. An array containing the keys of all animations currently attached to the object.
     * @type {string[]}
     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys
     */

  }, {
    key: 'pauseAnimationForKey',


    // Pausing and Resuming Animations

    /**
     * Required. Pauses the animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {void}
     * @desc This method has no effect if no animation is attached to the object with the specified key.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation
     */
    value: function pauseAnimationForKey(key) {}

    /**
     * Required. Resumes a previously paused animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {void}
     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation
     */

  }, {
    key: 'resumeAnimationForKey',
    value: function resumeAnimationForKey(key) {}

    /**
     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused
     */

  }, {
    key: 'isAnimationPausedForKey',
    value: function isAnimationPausedForKey(key) {
      return false;
    }

    // Instance Methods

    /**
     * Required. 
     * @access public
     * @param {number} speed - 
     * @param {string} key - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed
     */

  }, {
    key: 'setAnimationSpeedForKey',
    value: function setAnimationSpeedForKey(speed, key) {}

    /**
     * @access private
     * @param {WebGLContext} gl -
     * @param {SCNGeometry} geometry - 
     * @param {boolean} update -
     * @returns {WebGLBuffer} -
     */
    //_createVertexBuffer(gl, baseGeometry, update = false) {

  }, {
    key: '_createVertexBuffer',
    value: function _createVertexBuffer(gl, node) {
      var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var _base = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var baseGeometry = _base === null ? node.geometry : _base;
      var baseSkinner = node.skinner;
      var skinner = node.presentation.skinner;
      if (this._vertexBuffer === null) {
        this._vertexBuffer = gl.createBuffer();
      } else if (!update) {
        return this._vertexBuffer;
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
      var arr = [];
      var vertexSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
      var normalSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
      var tangentSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.tangent)[0];
      var colorSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.color)[0];
      var texcoordSource0 = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];
      var texcoordSource1 = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[1];
      var indexSource = baseSkinner ? baseSkinner._boneIndices : null;
      var weightSource = baseSkinner ? baseSkinner._boneWeights : null;
      var vectorCount = vertexSource.vectorCount;

      var pVertexSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
      var pNormalSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
      var pTangentSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.tangent)[0];
      var pColorSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.color)[0];
      var pTexcoordSource0 = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];
      var pTexcoordSource1 = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[1];
      //const pIndexSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.boneIndices)[0]
      var pIndexSource = skinner ? skinner._boneIndices : null;
      //const pWeightSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.boneWeights)[0]
      var pWeightSource = skinner ? skinner._boneWeights : null;

      if (typeof vertexSource === 'undefined') {
        throw new Error('vertexSource is undefined');
      }
      if (typeof normalSource !== 'undefined' && normalSource.vectorCount !== vectorCount) {
        throw new Error('normalSource.vectorCount !== vertexSource.vectorCount');
      }
      if (typeof tangentSource !== 'undefined' && tangentSource.vectorCount !== vectorCount) {
        throw new Error('tangentSource.vectorCount !== vertexSource.vectorCount');
      }
      if (typeof colorSource !== 'undefined' && colorSource.vectorCount !== vectorCount) {
        throw new Error('colorSource.vectorCount !== vertexSource.vectorCount');
      }
      if (typeof texcoordSource0 !== 'undefined' && texcoordSource0.vectorCount !== vectorCount) {
        throw new Error('texcoordSource0.vectorCount !== vertexSource.vectorCount');
      }
      if (typeof texcoordSource1 !== 'undefined' && texcoordSource1.vectorCount !== vectorCount) {
        throw new Error('texcoordSource1.vectorCount !== vertexSource.vectorCount');
      }
      if (typeof tangentSource === 'undefined' && this.materials.find(function (m) {
        return !(0, _InstanceOf3.default)(m._normal._contents, _SKColor2.default);
      })) {
        tangentSource = this._createTangentSource();
        pTangentSource = tangentSource;
        this._geometrySources.push(tangentSource);
        if (baseGeometry !== this) {
          baseGeometry._geometrySources.push(tangentSource);
        }
      }

      //const vertexArray = vertexSource ? vertexSource.data : null
      var vertexComponents = vertexSource ? vertexSource.componentsPerVector : 0;
      //const normalArray = normalSource ? normalSource.data : null
      var normalComponents = normalSource ? normalSource.componentsPerVector : 0;
      var tangentComponents = tangentSource ? tangentSource.componentsPerVector : 0;
      var colorComponents = colorSource ? colorSource.componentsPerVector : 0;
      //const texcoordArray = texcoordSource ? texcoordSource.data : null
      var texcoord0Components = texcoordSource0 ? texcoordSource0.componentsPerVector : 0;
      var texcoord1Components = texcoordSource1 ? texcoordSource1.componentsPerVector : 0;

      for (var i = 0; i < vectorCount; i++) {
        if (vertexSource) {
          arr.push.apply(arr, _toConsumableArray(vertexSource._vectorAt(i)));
        }
        if (normalSource) {
          arr.push.apply(arr, _toConsumableArray(normalSource._vectorAt(i)));
        }
        if (tangentSource) {
          arr.push.apply(arr, _toConsumableArray(tangentSource._vectorAt(i)));
        }
        if (colorSource) {
          arr.push.apply(arr, _toConsumableArray(colorSource._vectorAt(i)));
        }
        if (texcoordSource0) {
          arr.push.apply(arr, _toConsumableArray(texcoordSource0._vectorAt(i)));
        }
        if (texcoordSource1) {
          arr.push.apply(arr, _toConsumableArray(texcoordSource1._vectorAt(i)));
        }
      }

      //console.log(`vertex(0): ${vertexSource._vectorAt(0)}`)
      //console.log(`normal(0): ${normalSource._vectorAt(0)}`)
      //console.log(`texcoord(0): ${texcoordSource._vectorAt(0)}`)

      // update geometry sources
      // FIXME: Don't change geometry sources. Use other variables
      var bytesPerComponent = 4;
      var offset = 0;
      var stride = (vertexComponents + normalComponents + tangentComponents + colorComponents + texcoord0Components + texcoord1Components) * bytesPerComponent;

      pVertexSource._bytesPerComponent = bytesPerComponent;
      pVertexSource._dataOffset = offset;
      pVertexSource._dataStride = stride;
      offset += vertexComponents * bytesPerComponent;

      if (pNormalSource) {
        pNormalSource._bytesPerComponent = bytesPerComponent;
        pNormalSource._dataOffset = offset;
        pNormalSource._dataStride = stride;
        offset += normalComponents * bytesPerComponent;
      }
      if (pTangentSource) {
        pTangentSource._bytesPerComponent = bytesPerComponent;
        pTangentSource._dataOffset = offset;
        pTangentSource._dataStride = stride;
        offset += tangentComponents * bytesPerComponent;
      }
      if (pColorSource) {
        pColorSource._bytesPerComponent = bytesPerComponent;
        pColorSource._dataOffset = offset;
        pColorSource._dataStride = stride;
        offset += colorComponents * bytesPerComponent;
      }
      if (pTexcoordSource0) {
        pTexcoordSource0._bytesPerComponent = bytesPerComponent;
        pTexcoordSource0._dataOffset = offset;
        pTexcoordSource0._dataStride = stride;
        offset += texcoord0Components * bytesPerComponent;
      }
      if (pTexcoordSource1) {
        pTexcoordSource1._bytesPerComponent = bytesPerComponent;
        pTexcoordSource1._dataOffset = offset;
        pTexcoordSource1._dataStride = stride;
        offset += texcoord1Components * bytesPerComponent;
      }

      //console.log(`offset: ${offset}, vectorCount: ${vectorCount}`)
      offset *= vectorCount;

      var indexArray = indexSource ? indexSource.data : null;
      var indexComponents = indexSource ? indexSource.componentsPerVector : 0;
      var weightArray = weightSource ? weightSource.data : null;
      var weightComponents = weightSource ? weightSource.componentsPerVector : 0;
      var boneStride = (indexComponents + weightComponents) * bytesPerComponent;

      for (var _i = 0; _i < vectorCount; _i++) {
        if (indexSource) {
          arr.push.apply(arr, _toConsumableArray(indexSource._vectorAt(_i)));
        }
        if (weightSource) {
          arr.push.apply(arr, _toConsumableArray(weightSource._vectorAt(_i)));
        }
      }

      if (pIndexSource) {
        pIndexSource._bytesPerComponent = bytesPerComponent;
        pIndexSource._dataOffset = offset;
        pIndexSource._dataStride = boneStride;
        offset += indexComponents * bytesPerComponent;
      }
      if (pWeightSource) {
        pWeightSource._bytesPerComponent = bytesPerComponent;
        pWeightSource._dataOffset = offset;
        pWeightSource._dataStride = boneStride;
        offset += weightComponents * bytesPerComponent;
      }

      var vertexData = new Float32Array(arr);
      //console.log(`vertexData length: ${arr.length}`)
      gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW

      // set new data
      );pVertexSource._data = arr;
      if (pNormalSource) {
        pNormalSource._data = arr;
      }
      if (pTangentSource) {
        pTangentSource._data = arr;
      }
      if (pColorSource) {
        pColorSource._data = arr;
      }
      if (pTexcoordSource0) {
        pTexcoordSource0._data = arr;
      }
      if (pTexcoordSource1) {
        pTexcoordSource1._data = arr;
      }
      if (pIndexSource) {
        pIndexSource._data = arr;
      }
      if (pWeightSource) {
        pWeightSource._data = arr;
      }

      return this._vertexBuffer;
    }

    /**
     * @access private
     * @param {WebGLContext} gl -
     * @param {boolean} update -
     * @returns {WebGLBuffer} -
     */

  }, {
    key: '_createIndexBuffer',
    value: function _createIndexBuffer(gl) {
      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this._indexBuffer && !update) {
        return this._indexBuffer;
      }
      this._indexBuffer = this._geometryElements[0]._createBuffer(gl);
      return this._indexBuffer;
    }

    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @param {SCNGeometry} baseGeometry - 
     * @returns {void}
     */

  }, {
    key: '_updateVertexBuffer',
    value: function _updateVertexBuffer(gl, baseGeometry) {
      var pVertexSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
      var vertexData = new Float32Array(pVertexSource._data);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW);
    }

    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @param {WebGLProgram} program -
     * @param {number} index - material index
     * @param {number} opacity -
     * @returns {void}
     */

  }, {
    key: '_bufferMaterialData',
    value: function _bufferMaterialData(gl, program, index, opacity) {
      // TODO: move this function to SCNProgram
      var materialCount = this.materials.length;
      var material = this.materials[index % materialCount];
      if (!material) {
        // FIXME: What should I do if there's no material? 
        material = new _SCNMaterial2.default();
      }

      if (material.lightingModel === _SCNMaterial2.default.LightingModel.constant) {
        this._bindMaterialDataForConstantLighting(material, gl, program, opacity);
        return;
      }

      var diffuse = material.diffuse.float32Array();
      diffuse[3] *= opacity;
      var ambient = null;
      if (material.locksAmbientWithDiffuse) {
        ambient = diffuse;
      } else {
        ambient = material.ambient.float32Array();
        ambient[3] *= opacity;
      }

      var materialData = new Float32Array([].concat(_toConsumableArray(ambient), _toConsumableArray(diffuse), _toConsumableArray(material.specular.float32Array()), _toConsumableArray(material.normal.float32Array()), _toConsumableArray(material.reflective.float32Array()), _toConsumableArray(material.emission.float32Array()), _toConsumableArray(material.transparent.float32Array()), _toConsumableArray(material.multiply.float32Array()), _toConsumableArray(material.ambientOcclusion.float32Array()), [material.shininess * 100.0, material.fresnelExponent, 0, 0 // needs padding for 16-byte alignment
      ]));

      gl.bindBuffer(gl.UNIFORM_BUFFER, this._materialBuffer);
      gl.bufferData(gl.UNIFORM_BUFFER, materialData, gl.DYNAMIC_DRAW);
      gl.bindBuffer(gl.UNIFORM_BUFFER, null);

      var textureFlags = [];

      // emission
      var selfIllumination = 0;
      if (material._selfIllumination._contents instanceof Image || material._selfIllumination._contents instanceof WebGLTexture) {
        this._setTextureToName(gl, material._selfIllumination, 'TEXTURE0', textureFlags);
        selfIllumination = 1;
      } else if (material._emission._contents instanceof Image || material._emission._contents instanceof WebGLTexture) {
        this._setTextureToName(gl, material._emission, 'TEXTURE0', textureFlags);
      } else {
        textureFlags.push(0);
      }
      gl.uniform1i(gl.getUniformLocation(program, 'selfIllumination'), selfIllumination

      // ambient
      );this._setTextureToName(gl, material._ambient, 'TEXTURE1', textureFlags

      // diffuse
      );this._setTextureToName(gl, material._diffuse, 'TEXTURE2', textureFlags

      // specular
      );this._setTextureToName(gl, material._specular, 'TEXTURE3', textureFlags

      // reflective
      );this._setCubeTextureToName(gl, material._reflective, 'TEXTURE4', textureFlags

      // transparent
      );this._setTextureToName(gl, material._transparent, 'TEXTURE5', textureFlags

      // multiply
      );this._setTextureToName(gl, material._multiply, 'TEXTURE6', textureFlags

      // normal
      );this._setTextureToName(gl, material._normal, 'TEXTURE7', textureFlags

      // TODO: cache uniform location
      );gl.uniform1iv(gl.getUniformLocation(program, 'textureFlags'), new Int32Array(textureFlags));

      if (material.isDoubleSided) {
        gl.disable(gl.CULL_FACE);
      } else {
        gl.enable(gl.CULL_FACE);
        if (material.cullMode === _SCNCullMode2.default.back) {
          gl.cullFace(gl.BACK);
        } else {
          gl.cullFace(gl.FRONT);
        }
      }

      var blendFuncSrc = [gl.SRC_ALPHA, // alpha
      gl.ONE, // add
      gl.ZERO, // subtract
      gl.ZERO, // multiply
      gl.SRC_ALPHA, // screen
      gl.ONE // replace
      ];
      var blendFuncDst = [gl.ONE_MINUS_SRC_ALPHA, // alpha
      gl.ONE, // add
      gl.ONE_MINUS_SRC_COLOR, // subtract
      gl.SRC_COLOR, // multiply
      gl.ONE, // screen
      gl.ZERO // replace
      ];
      gl.blendFunc(blendFuncSrc[material.blendMode], blendFuncDst[material.blendMode]);
    }

    /**
     * @access private
     * @param {SCNMaterial} material -
     * @param {WebGLRenderingContext} gl -
     * @param {WebGLProgram} program -
     * @param {number} opacity -
     */

  }, {
    key: '_bindMaterialDataForConstantLighting',
    value: function _bindMaterialDataForConstantLighting(material, gl, program, opacity) {
      var ambient = material.ambient.float32Array();
      ambient[3] *= opacity;
      var materialData = new Float32Array([].concat(_toConsumableArray(ambient), [0, 0, 0, 1, // diffuse
      0, 0, 0, 1, // specular
      0, 0, 0, 1, // normal
      0, 0, 0, 1, // reflective
      0, 0, 0, 1, // emission
      0, 0, 0, 1, // transparent
      1, 1, 1, 1, // multiply
      0, 0, 0, 1, // ambientOcclusion
      0, // shininess
      0, // fresnelExponent
      0, 0 // needs padding for 16-byte alignment
      ]));

      gl.bindBuffer(gl.UNIFORM_BUFFER, this._materialBuffer);
      gl.bufferData(gl.UNIFORM_BUFFER, materialData, gl.DYNAMIC_DRAW);
      gl.bindBuffer(gl.UNIFORM_BUFFER, null);

      var textureFlags = [];

      // emission
      textureFlags.push(0);

      gl.uniform1i(gl.getUniformLocation(program, 'selfIllumination'), 0

      // ambient
      );this._setTextureToName(gl, material._ambient, 'TEXTURE1', textureFlags);

      textureFlags.push(0 // diffuse
      );textureFlags.push(0 // specular
      );textureFlags.push(0 // reflective
      );textureFlags.push(0 // transparent
      );textureFlags.push(0 // multiply
      );textureFlags.push(0 // normal

      // TODO: cache uniform location
      );gl.uniform1iv(gl.getUniformLocation(program, 'textureFlags'), new Int32Array(textureFlags));

      if (material.isDoubleSided) {
        gl.disable(gl.CULL_FACE);
      } else {
        gl.enable(gl.CULL_FACE);
        if (material.cullMode === _SCNCullMode2.default.back) {
          gl.cullFace(gl.BACK);
        } else {
          gl.cullFace(gl.FRONT);
        }
      }

      var blendFuncSrc = [gl.SRC_ALPHA, // alpha
      gl.ONE, // add
      gl.ZERO, // subtract
      gl.ZERO, // multiply
      gl.SRC_ALPHA, // screen
      gl.ONE // replace
      ];
      var blendFuncDst = [gl.ONE_MINUS_SRC_ALPHA, // alpha
      gl.ONE, // add
      gl.ONE_MINUS_SRC_COLOR, // subtract
      gl.SRC_COLOR, // multiply
      gl.ONE, // screen
      gl.ZERO // replace
      ];
      gl.blendFunc(blendFuncSrc[material.blendMode], blendFuncDst[material.blendMode]);
    }

    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @param {SCNMaterialProperty} m -
     * @param {string} name -
     * @param {boolean[]} textureFlags -
     * @returns {void}
     */

  }, {
    key: '_setCubeTextureToName',
    value: function _setCubeTextureToName(gl, m, name, textureFlags) {
      if (m._contents instanceof Image) {
        m._contents = this._createCubeTexture(gl, m._contents);
      }
      if (m._contents instanceof WebGLTexture) {
        textureFlags.push(1);
        gl.activeTexture(gl[name]);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, m._contents);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, m._magnificationFilterFor(gl));
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, m._minificationFilterFor(gl));
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, m._wrapSFor(gl));
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, m._wrapTFor(gl));
      } else {
        textureFlags.push(0);
      }
    }

    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @param {SCNMaterialProperty} m -
     * @param {string} name -
     * @param {boolean[]} textureFlags -
     * @returns {void}
     */

  }, {
    key: '_setTextureToName',
    value: function _setTextureToName(gl, m, name, textureFlags) {
      if (m._contents instanceof Image) {
        m._contents = this._createTexture(gl, m._contents);
      }
      if (m._contents instanceof WebGLTexture) {
        textureFlags.push(1);
        gl.activeTexture(gl[name]);
        gl.bindTexture(gl.TEXTURE_2D, m._contents);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, m._magnificationFilterFor(gl));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, m._minificationFilterFor(gl));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, m._wrapSFor(gl));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, m._wrapTFor(gl));
      } else {
        textureFlags.push(0);
      }
    }
  }, {
    key: '_createTangentSource',
    value: function _createTangentSource() {
      var elements = this._geometryElements;
      var vertex = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
      var texcoord = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];

      var data = [];
      var semantic = _SCNGeometrySource2.default.Semantic.tangent;
      var vectorCount = vertex.vectorCount;
      var floatComponents = true;
      var componentsPerVector = 3;
      var bytesPerComponent = 4;
      var dataOffset = 0;
      var dataStride = 12;

      var tangent = [];
      for (var i = 0; i < vectorCount; i++) {
        tangent.push(new _SCNVector2.default(0, 0, 0));
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = elements[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var element = _step3.value;

          var len = element.primitiveCount;
          for (var _i3 = 0; _i3 < len; _i3++) {
            var index = element._indexAt(_i3);
            var pos0 = vertex._scnVectorAt(index[0]);
            var pos1 = vertex._scnVectorAt(index[1]);
            var pos2 = vertex._scnVectorAt(index[2]);
            var tex0 = texcoord._scnVectorAt(index[0]);
            var tex1 = texcoord._scnVectorAt(index[1]);
            var tex2 = texcoord._scnVectorAt(index[2]);

            var p1 = pos1.sub(pos0);
            var p2 = pos2.sub(pos0);
            var t1 = tex1.sub(tex0);
            var t2 = tex2.sub(tex0);

            var t = p1.mul(t2.y).sub(p2.mul(t1.y));
            tangent[index[0]] = tangent[index[0]].add(t);
            tangent[index[1]] = tangent[index[1]].add(t);
            tangent[index[2]] = tangent[index[2]].add(t);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      for (var _i2 = 0; _i2 < vectorCount; _i2++) {
        data.push.apply(data, _toConsumableArray(tangent[_i2].normalize().floatArray()));
      }

      return new _SCNGeometrySource2.default(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, dataOffset, dataStride);
    }
  }, {
    key: 'copy',
    value: function copy() {
      var geometry = new SCNGeometry();
      geometry.name = this.name;
      geometry.levelsOfDetail = this.levelsOfDetail;
      geometry.materials = this.materials;
      geometry._geometryElements = this._geometryElements.slice(0);
      geometry._geometrySources = this._geometrySources.slice(0);
      geometry._vertexArrayObjects = this._vertexArrayObjects ? this._vertexArrayObjects.slice(0) : null;
      geometry.subdivisonLevel = this.subdivisionLevel;
      geometry.edgeCreasesElement = this.edgeCreasesElement;
      geometry.edgeCreasesSource = this.edgeCreasesSource;
      geometry.program = this.program;
      geometry.shaderModifiers = this.shaderModifiers;
      //geometry._animationKeys = this._animationKeys
      geometry.boundingBox = this.boundingBox;
      //geometry._boundingSphere = this._boundingSphere
      geometry._vertexBuffer = this._vertexBuffer;
      geometry._indexBuffer = this._indexBuffer;
      geometry._animations = this._animations.copy();
      geometry._shadableHelper = this._shadableHelper;

      return geometry;
    }

    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @param {Image} image -
     * @returns {WebGLTexture} -
     */

  }, {
    key: '_createCubeTexture',
    value: function _createCubeTexture(gl, image) {
      var texture = gl.createTexture();

      gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture
      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
      // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
      );var targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Y];
      //const tx = [0, 1.0/6.0, 2.0/6.0, 3.0/6.0, 4.0/6.0, 5.0/6.0, 1]
      //const itx = [4, 1, 5, 0, 2, 3]
      var margin = 0.001;
      var sx = [4.0 / 6.0 + margin, 1.0 / 6.0 + margin, 5.0 / 6.0 + margin, 0 + margin, 2.0 / 6.0 + margin, 3.0 / 6.0 + margin];
      var imageWidth = image.naturalWidth;
      var imageHeight = image.naturalHeight;
      var srcWidth = imageHeight - margin * 2;

      for (var i = 0; i < 6; i++) {
        var canvas = document.createElement('canvas');
        canvas.width = imageHeight;
        canvas.height = imageHeight;
        canvas.getContext('2d').drawImage(image, sx[i], 0, srcWidth, imageHeight, 0, 0, imageHeight, imageHeight);

        gl.texImage2D(targets[i], 0, gl.RGBA, imageHeight, imageHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
      }

      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
      return texture;
    }

    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @param {Image} image -
     * @returns {WebGLTexture} -
     */

  }, {
    key: '_createTexture',
    value: function _createTexture(gl, image) {
      var texture = gl.createTexture();

      var canvas = document.createElement('canvas');
      canvas.width = image.naturalWidth;
      canvas.height = image.naturalHeight;
      //console.warn(`image size: ${image.naturalWidth} ${image.naturalHeight}`)
      canvas.getContext('2d').drawImage(image, 0, 0);

      gl.bindTexture(gl.TEXTURE_2D, texture
      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
      // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
      );gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
      gl.generateMipmap(gl.TEXTURE_2D
      //gl.bindTexture(gl.TEXTURE_2D, null)
      );return texture;
    }

    /**
     * @access private
     * @returns {Ammo.btCollisionShape} -
     * @desc call Ammo.destroy(shape) after using it.
     */

  }, {
    key: '_createBtCollisionShape',
    value: function _createBtCollisionShape() {
      return this._createBtConvexTriangleMeshShape();
    }
  }, {
    key: '_createBtConvexTriangleMeshShape',
    value: function _createBtConvexTriangleMeshShape() {
      //this._destoryShape()
      //this._btVertices = []

      //const vertexSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0]
      //const vertexCount = vertexSource.vectorCount
      //for(let i=0; i<vertexCount; i++){
      //  this._btVertices.push(vertexSource._scnVectorAt(i)._createBtVector3())
      //}

      //this._btMesh = new Ammo.btTriangleMesh(false, false) // 16bit indices, 3 component vertices
      //for(const element of this._geometryElements){
      //  const indexCount = element._primitiveCount
      //  for(let i=0; i<indexCount; i++){
      //    // TODO: check primitiveType
      //    const indices = element._indexAt(i)
      //    this._btMesh.addTriangle(
      //      this._btVertices[indices[0]],
      //      this._btVertices[indices[1]],
      //      this._btVertices[indices[2]],
      //      true
      //    )
      //  }
      //}

      //const calcAabb = true
      //this._btShape = new Ammo.btTriangleMeshShape(this._btMesh, calcAabb)

      //return this._btShape
    }
  }, {
    key: '_destroyShape',
    value: function _destroyShape() {
      //if(this._btShape === null){
      //  return
      //}
      //Ammo.destroy(this._btShape)
      //this._btShape = null

      //Ammo.destroy(this._btMesh)
      //this._btMesh = null

      //for(const v of this._btVertices){
      //  Ammo.destroy(v)
      //}
      //this._btVerices = null
    }
  }, {
    key: '_execDestory',
    value: function _execDestory() {
      // TODO: delete indexBuffer, vertexBuffer
      this._destroyShape();
    }
  }, {
    key: '_updateBoundingBox',
    value: function _updateBoundingBox() {
      return this._updateBoundingBoxForSkinner();
    }
  }, {
    key: '_updateBoundingBoxForSkinner',
    value: function _updateBoundingBoxForSkinner() {
      var skinner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var transform = null;
      if (skinner) {
        transform = skinner.baseGeometryBindTransform;
      }

      var sources = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex);
      var min = new _SCNVector2.default(Infinity, Infinity, Infinity);
      var max = new _SCNVector2.default(-Infinity, -Infinity, -Infinity);
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = sources[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var src = _step4.value;

          var result = src._createBoundingBox(transform);
          if (result.min.x < min.x) {
            min.x = result.min.x;
          }
          if (result.max.x > max.x) {
            max.x = result.max.x;
          }
          if (result.min.y < min.y) {
            min.y = result.min.y;
          }
          if (result.max.y > max.y) {
            max.y = result.max.y;
          }
          if (result.min.z < min.z) {
            min.z = result.min.z;
          }
          if (result.max.z > max.z) {
            max.z = result.max.z;
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this.boundingBox = { min: min, max: max };
      return this.boundingBox;
    }

    /**
     * @access private
     * @param {SCNGeometry} geometry -
     * @returns {boolean} -
     */

  }, {
    key: '_intersectsBoundingBox',
    value: function _intersectsBoundingBox(geometry) {
      var b1 = this.boundingBox;
      var b2 = geometry.boundingBox;

      if (b1.min.x > b2.max.x || b1.max.x < b2.min.x) {
        return false;
      }
      if (b1.min.y > b2.max.y || b1.max.y < b2.min.y) {
        return false;
      }
      if (b1.min.z > b2.max.z || b1.max.z < b2.min.z) {
        return false;
      }
      return true;
    }

    /**
     * @access private
     * @returns {Promise} -
     */

  }, {
    key: '_getLoadedPromise',
    value: function _getLoadedPromise() {
      if (this._loadedPromise) {
        return this._loadedPromise;
      }

      var promises = [];
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.materials[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var m = _step5.value;

          promises.push(m.didLoad);
        }
        //this._loadedPromise = Promise.all(promises)
        //return this._loadedPromise
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return Promise.all(promises);
    }

    /**
     * @access public
     * @type {Promise} -
     */

  }, {
    key: 'setValueForUndefinedKey',


    /**
     * Invoked by setValue(_:forKey:) when it finds no property for a given key.
     * @access public
     * @param {?Object} value - The value for the key identified by key.
     * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
     * @returns {void}
     * @desc Subclasses can override this method to handle the request in some other way. The default implementation raises an NSUndefinedKeyException.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1413490-setvalue
     */
    value: function setValueForUndefinedKey(value, key) {
      this._valuesForUndefinedKeys[key] = value;
    }

    /**
     * Invoked by value(forKey:) when it finds no property corresponding to a given key.
     * @access public
     * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
     * @returns {?Object} - 
     * @desc Subclasses can override this method to return an alternate value for undefined keys. The default implementation raises an NSUndefinedKeyException.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1413457-value
     */

  }, {
    key: 'valueForUndefinedKey',
    value: function valueForUndefinedKey(key) {
      if (typeof this._valuesForUndefinedKeys[key] !== 'undefined') {
        return this._valuesForUndefinedKeys[key];
      }
      return _get(SCNGeometry.prototype.__proto__ || Object.getPrototypeOf(SCNGeometry.prototype), 'valueForUndefinedKey', this).call(this, key);
    }
  }, {
    key: 'firstMaterial',
    get: function get() {
      return this.materials[0];
    },
    set: function set(newValue) {
      this.materials[0] = newValue;
    }
  }, {
    key: 'geometryElements',
    get: function get() {
      return this._geometryElements.slice(0);
    }

    /**
     * An array of geometry sources that provide vertex data for the geometry.
     * @type {SCNGeometrySource[]}
     * @desc Each SCNGeometrySource object describes an attribute of all vertices in the geometry (such as vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source’s semantic property. A geometry always has at least one source (for the vertex semantic), typically has additional sources for use in lighting and shading, and may have other sources for skeletal animation or surface subdivision information.
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523662-geometrysources
     */

  }, {
    key: 'geometrySources',
    get: function get() {
      return this._geometrySources.slice(0);
    }
  }, {
    key: 'geometryGLSource',
    get: function get() {
      return new Float32Array(this._geometrySources[0]);
    }

    /**
     * The number of geometry elements in the geometry.
     * @type {number}
     * @desc Each SCNGeometryElement object describes how vertices from the geometry’s sources are combined into polygons to create the geometry’s shape. Visible geometries contain at least one element.For geometries with multiple elements, you can use the materials property to attach different materials to each element.
     * @see https://developer.apple.com/documentation/scenekit/scngeometry/1523800-geometryelementcount
     */

  }, {
    key: 'geometryElementCount',
    get: function get() {
      return this._geometryElements.length;
    }
  }, {
    key: 'animationKeys',
    get: function get() {
      var keys = [];
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this._animations.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var key = _step6.value;

          keys.push(key);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return keys;
    }
  }, {
    key: 'didLoad',
    get: function get() {
      return this._getLoadedPromise();
    }
  }]);

  return SCNGeometry;
}(_NSObject3.default);

exports.default = SCNGeometry;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A structure that contains a point in a two-dimensional coordinate system.
 * @access public
 * @see https://developer.apple.com/documentation/coregraphics/cgpoint
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CGPoint = function () {
  // Creating Point Values

  /**
   * Creates a point with coordinates specified as integer values.   
   * @access public
   * @constructor
   * @param {number} x - 
   * @param {number} y - 
   * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1455965-init
   */
  function CGPoint() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, CGPoint);

    // Geometric Properties
    this.x = x;
    this.y = y;
  }

  // Special Values

  /**
   * The point with location (0,0).
   * @type {CGPoint}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1454433-zero
   */


  _createClass(CGPoint, [{
    key: 'applying',


    // Geometric Properties

    // Transforming Points

    /**
     * Returns the point resulting from an affine transformation of an existing point.
     * @access public
     * @param {CGAffineTransform} t - The affine transform to apply. 
     * @returns {CGPoint} - 
     * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1454251-applying
     */
    value: function applying(t) {
      return null;
    }

    // Alternate Representations

    /**
     * Creates a point from a canonical dictionary representation.
     * @access public
     * @param {Map} dict - A dictionary containing x and y values for the point to create, in the format used by the dictionaryRepresentation property.
     * @returns {void}
     * @see https://developer.apple.com/documentation/coregraphics/cgpoint/2427118-init
     */

  }, {
    key: 'equalTo',


    // Comparing Points

    /**
     * Returns whether two points are equal. 
     * @access public
     * @param {CGPoint} point2 - 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1456179-equalto
     */
    value: function equalTo(point2) {
      var epsilon = 0.00001;
      return Math.abs(this.x - point2.x) < epsilon && Math.abs(this.y - point2.y) < epsilon;
    }

    /**
     * @access public
     * @returns {CGPoint} -
     */

  }, {
    key: 'copy',
    value: function copy() {
      return new CGPoint(this.x, this.y);
    }
  }, {
    key: 'zero',
    value: function zero() {
      return new CGPoint(0, 0);
    }

    /**
     * @access public
     * @param {CGPoint} p -
     * @returns {CGPoint} -
     */

  }, {
    key: 'add',
    value: function add(p) {
      var r = new CGPoint();
      r.x = this.x + p.x;
      r.y = this.y + p.y;
      return r;
    }

    /**
     * @access public
     * @param {CGPoint} p -
     * @returns {CGPoint} -
     */

  }, {
    key: 'sub',
    value: function sub(p) {
      var r = new CGPoint();
      r.x = this.x - p.x;
      r.y = this.y - p.y;
      return r;
    }

    /**
     * @access public
     * @param {number} n -
     * @returns {CGPoint} -
     */

  }, {
    key: 'mul',
    value: function mul(n) {
      var r = new CGPoint();
      r.x = this.x * n;
      r.y = this.y * n;
      return r;
    }

    /**
     * @access public
     * @param {CGPoint} p -
     * @returns {number} -
     */

  }, {
    key: 'dot',
    value: function dot(p) {
      return this.x * p.x + this.y * p.y;
    }

    /**
     * @access public
     * @param {CGPoint} p -
     * @param {number} rate -
     * @returns {CGPoint} -
     */

  }, {
    key: 'lerp',
    value: function lerp(p, rate) {
      var r = new CGPoint();
      r.x = this.x + rate * (p.x - this.x);
      r.y = this.y + rate * (p.y - this.y);
      return r;
    }

    /**
     * @access public
     * @returns {CGPoint} -
     */

  }, {
    key: 'normalize',
    value: function normalize() {
      var len = this.length();
      var r = new CGPoint();
      if (len === 0) {
        return r;
      }
      var sqr = 1.0 / len;
      r.x = this.x * sqr;
      r.y = this.y * sqr;
      return r;
    }

    /**
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'length',
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    /**
     * @access public
     * @returns {number[]} -
     */

  }, {
    key: 'floatArray',
    value: function floatArray() {
      return [this.x, this.y];
    }

    /**
     * @access public
     * @returns {Float32Array} -
     */

  }, {
    key: 'float32Array',
    value: function float32Array() {
      return new Float32Array([this.x, this.y]);
    }
  }, {
    key: 'dictionaryRepresentation',


    /**
     * Returns a dictionary representation of the specified point.
     * @type {Map}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1455382-dictionaryrepresentation
     */
    get: function get() {
      var map = new Map();
      map.set('x', this.x);
      map.set('y', this.y);
      return map;
    }

    /**
     * A textual representation of the point's coordinate values. 
     * @type {string}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1645825-debugdescription
     */

  }, {
    key: 'debugDescription',
    get: function get() {
      return '{x: ' + this.x + ', y: ' + this.y + '}';
    }

    /**
     * A representation of the point's structure and display style for use in debugging.
     * @type {Mirror}
     * @desc Mirrors are used by playgrounds and the debugger.
     * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1645834-custommirror
     */

  }, {
    key: 'customMirror',
    get: function get() {
      return null;
    }

    /**
     * A representation of the point for use in Playgrounds.
     * @type {PlaygroundQuickLook}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgpoint/1645835-customplaygroundquicklook
     */

  }, {
    key: 'customPlaygroundQuickLook',
    get: function get() {
      return null;
    }
  }], [{
    key: 'pointWithDictionaryRepresentation',
    value: function pointWithDictionaryRepresentation(dict) {
      return new CGPoint(dict.get('x'), dict.get('y'));
    }
  }, {
    key: 'zero',
    get: function get() {
      return new CGPoint(0, 0);
    }
  }]);

  return CGPoint;
}();

exports.default = CGPoint;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A representation of a four-component vector.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scnvector4
 */
var SCNVector4 = function () {
  // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @param {number} x - 
   * @param {number} y - 
   * @param {number} z - 
   * @param {number} w - 
   * @see https://developer.apple.com/documentation/scenekit/scnvector4/1523931-init
   */
  function SCNVector4() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    _classCallCheck(this, SCNVector4);

    // Instance Properties
    /** @type {number} */
    this.x = x;
    /** @type {number} */
    this.y = y;
    /** @type {number} */
    this.z = z;
    /** @type {number} */
    this.w = w;

    //if(x instanceof Ammo.btVector4){
    //  this.x = x.x()
    //  this.y = x.y()
    //  this.z = x.z()
    //  this.w = x.w()
    //}
  }

  /**
   * @access private
   * @param {Buffer} data -
   * @param {number} [offset = 0] -
   * @param {boolean} [bigEndian = false] -
   * @returns {SCNVector4} -
   */


  _createClass(SCNVector4, [{
    key: '_copy',
    value: function _copy() {
      return new SCNVector4(this.x, this.y, this.z, this.w);
    }
  }, {
    key: '_copyFrom',
    value: function _copyFrom(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.z;
    }

    // extensions

  }, {
    key: 'zero',
    value: function zero() {
      return new SCNVector4();
    }

    /**
     * @access public
     * @param {SCNVector4} v -
     * @returns {SCNVector4} -
     */

  }, {
    key: 'add',
    value: function add(v) {
      var r = new SCNVector4();
      r.x = this.x + v.x;
      r.y = this.y + v.y;
      r.z = this.z + v.z;
      r.w = this.w + v.w;
      return r;
    }

    /**
     * @access public
     * @param {SCNVector4} v -
     * @returns {SCNVector4} -
     */

  }, {
    key: 'sub',
    value: function sub(v) {
      var r = new SCNVector4();
      r.x = this.x - v.x;
      r.y = this.y - v.y;
      r.z = this.z - v.z;
      r.w = this.w - v.w;
      return r;
    }

    /**
     * @access public
     * @param {number} n -
     * @returns {SCNVector4} -
     */

  }, {
    key: 'mul',
    value: function mul(n) {
      var r = new SCNVector4();
      r.x = this.x * n;
      r.y = this.y * n;
      r.z = this.z * n;
      r.w = this.w * n;
      return r;
    }

    /**
     * @access public
     * @param {SCNVector4} v -
     * @returns {SCNVector4}
     */

  }, {
    key: 'mulv',
    value: function mulv(v) {
      var r = new SCNVector4();
      r.x = this.x * v.x;
      r.y = this.y * v.y;
      r.z = this.z * v.z;
      r.z = this.w * v.w;
      return r;
    }

    /**
     * @access public
     * @param {SCNVector4} v -
     * @returns {number} -
     */

  }, {
    key: 'dot',
    value: function dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }

    /**
     * @access public
     * @param {SCNVecor4} v -
     * @returns {SCNVector4} -
     */

  }, {
    key: 'cross',
    value: function cross(v) {
      var r = new SCNVector4();
      r.x = this.w * v.x + this.x * v.w + this.y * v.z - this.z * v.y;
      r.y = this.w * v.y - this.x * v.z + this.y * v.w + this.z * v.x;
      r.z = this.w * v.z + this.x * v.y - this.y * v.x + this.z * v.w;
      r.w = this.w * v.w - this.x * v.x - this.y * v.y - this.z * v.z;
      return r;
    }

    /**
     * @access public
     * @param {SCNVector4} v -
     * @param {number} rate -
     * @returns {SCNVector4} -
     */

  }, {
    key: 'lerp',
    value: function lerp(v, rate) {
      var r = new SCNVector4();
      r.x = this.x + rate * (v.x - this.x);
      r.y = this.y + rate * (v.y - this.y);
      r.z = this.z + rate * (v.z - this.z);
      r.w = this.w + rate * (v.w - this.w);
      return r;
    }

    /**
     * @access public
     * @param {SCNVector4} v -
     * @param {number} rate -
     * @returns {SCNVector4} -
     */

  }, {
    key: 'slerp',
    value: function slerp(v, rate) {
      var r = new SCNVector4();
      var qr = this.dot(v);

      if (qr < 0) {
        r.x = this.x - (this.x + v.x) * rate;
        r.y = this.y - (this.y + v.y) * rate;
        r.z = this.z - (this.z + v.z) * rate;
        r.w = this.w - (this.w + v.w) * rate;
      } else {
        r.x = this.x + (v.x - this.x) * rate;
        r.y = this.y + (v.y - this.y) * rate;
        r.z = this.z + (v.z - this.z) * rate;
        r.w = this.w + (v.w - this.w) * rate;
      }
      return r.normalize();
    }

    /**
     * @access public
     * @returns {SCNVector4} -
     */

  }, {
    key: 'normalize',
    value: function normalize() {
      var r = new SCNVector4();
      var sqr = 1.0 / this.length();
      r.x = this.x * sqr;
      r.y = this.y * sqr;
      r.z = this.z * sqr;
      r.w = this.w * sqr;
      return r;
    }

    /**
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'length2',
    value: function length2() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }

    /**
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'length',
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
  }, {
    key: 'transform',
    value: function transform(m) {
      var r = new SCNVector4();
      r.x = this.x * m.m11 + this.y * m.m21 + this.z * m.m31 + this.w * m.m41;
      r.y = this.x * m.m12 + this.y * m.m22 + this.z * m.m32 + this.w * m.m42;
      r.z = this.x * m.m13 + this.y * m.m23 + this.z * m.m33 + this.w * m.m43;
      r.w = this.x * m.m14 + this.y * m.m24 + this.z * m.m34 + this.w * m.m44;
      return r;
    }

    /**
     * @access public
     * @returns {SCNVector4} -
     */

  }, {
    key: 'ln',
    value: function ln() {
      var r = new SCNVector4();
      var v = this.normalize();

      var n = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
      if (n === 0) {
        r.x = 0;
        r.y = 0;
        r.z = 0;
        r.w = 0;
        return r;
      }
      var theta = Math.atan2(n, v.w) / n;

      r.x = theta * v.x;
      r.y = theta * v.y;
      r.z = theta * v.z;
      r.w = 0;
      return r;
    }

    /**
     * @access public
     * @returns {SCNVector4} -
     */

  }, {
    key: 'exp',
    value: function exp() {
      var r = new SCNVector4();
      var n = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

      if (n > 0.0) {
        var sinn = Math.sin(n);
        r.x = sinn * this.x / n;
        r.y = sinn * this.y / n;
        r.z = sinn * this.z / n;
        r.w = Math.cos(n);
      } else {
        r.x = 0.0;
        r.y = 0.0;
        r.z = 0.0;
        r.w = 1.0;
      }
      return r;
    }

    /**
     * @access public
     * @returns {SCNMatrix4} -
     */

  }, {
    key: 'rotMatrix',
    value: function rotMatrix() {
      var r = new _SCNMatrix2.default();
      var x2 = this.x * this.x * 2.0;
      var y2 = this.y * this.y * 2.0;
      var z2 = this.z * this.z * 2.0;
      var xy = this.x * this.y * 2.0;
      var yz = this.y * this.z * 2.0;
      var zx = this.z * this.x * 2.0;
      var xw = this.x * this.w * 2.0;
      var yw = this.y * this.w * 2.0;
      var zw = this.z * this.w * 2.0;

      r.m11 = 1.0 - y2 - z2;
      r.m12 = xy + zw;
      r.m13 = zx - yw;
      r.m14 = 0.0;
      r.m21 = xy - zw;
      r.m22 = 1.0 - z2 - x2;
      r.m23 = yz + xw;
      r.m24 = 0.0;
      r.m31 = zx + yw;
      r.m32 = yz - xw;
      r.m33 = 1.0 - x2 - y2;
      r.m34 = 0.0;
      r.m41 = 0.0;
      r.m42 = 0.0;
      r.m43 = 0.0;
      r.m44 = 1.0;
      return r;
    }

    /**
     * @access public
     * @returns {SCNVector4} -
     */

  }, {
    key: 'rotationToQuat',
    value: function rotationToQuat() {
      var quat = new SCNVector4();
      if (this.x === 0 && this.y === 0 && this.z === 0) {
        quat.x = 0;
        quat.y = 0;
        quat.z = 0;
        quat.w = 1.0;
      } else {
        var r = 1.0 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        var cosW = Math.cos(this.w * 0.5);
        var sinW = Math.sin(this.w * 0.5) * r;
        quat.x = this.x * sinW;
        quat.y = this.y * sinW;
        quat.z = this.z * sinW;
        quat.w = cosW;
      }

      return quat;
    }

    /**
     * @access public
     * @returns {SCNVector4} -
     */

  }, {
    key: 'quatToRotation',
    value: function quatToRotation() {
      var rot = new SCNVector4();
      if (this.x === 0 && this.y === 0 && this.z === 0) {
        rot.x = 0;
        rot.y = 0;
        rot.z = 0;
        if (Math.abs(this.w) > 1) {
          // actually, if this.w < -1, rotation will be NaN...
          rot.w = 0;
        } else {
          // I don't know why it needs to be double but I make it the same as SceneKit
          rot.w = Math.acos(this.w) * 2.0;
        }
      } else {
        var quat = this.normalize();
        var r = 1.0 / Math.sqrt(quat.x * quat.x + quat.y * quat.y + quat.z * quat.z);
        rot.x = quat.x * r;
        rot.y = quat.y * r;
        rot.z = quat.z * r;

        var w = Math.acos(quat.w);
        if (isNaN(w)) {
          rot.w = 0;
        } else {
          // I don't know why it needs to be double but I make it the same as SceneKit
          rot.w = w * 2.0;
        }
      }
      return rot;
    }

    /**
     * @access public
     * @returns {SCNVector3} -
     */

  }, {
    key: 'rotationToEulerAngles',
    value: function rotationToEulerAngles() {
      var euler = new _SCNVector2.default();
      var sinW = Math.sin(this.w);
      var cosW = Math.cos(this.w);
      var cosWR = 1.0 - cosW;
      var len2 = this.x * this.x + this.y * this.y + this.z * this.z;
      if (len2 === 0) {
        return euler;
      }
      var r = 1.0 / Math.sqrt(len2);
      var x = this.x * r;
      var y = this.y * r;
      var z = this.z * r;
      var s = y * sinW - x * z * cosWR;

      //console.log(`s: ${s}`)
      //const threshold = 0.998
      var threshold = 0.999999;
      if (s > threshold) {
        // TODO: check SceneKit implementation
        euler.x = 0;
        euler.y = -Math.PI * 0.5;
        euler.z = -2.0 * Math.atan2(z * Math.sin(this.w * 0.5), Math.cos(this.w * 0.5));
      } else if (s < -threshold) {
        // TODO: check SceneKit implementation
        euler.x = 0;
        euler.y = Math.PI * 0.5;
        euler.z = 2.0 * Math.atan2(z * Math.sin(this.w * 0.5), Math.cos(this.w * 0.5));
      } else {
        var m23 = x * sinW + y * z * cosWR;
        //const m33 = 1 - (y * y + x * x) * cosWR
        var m33 = cosW + z * z * cosWR;
        var m12 = z * sinW + x * y * cosWR;
        //const m11 = 1 - (z * z + y * y) * cosWR
        var m11 = cosW + x * x * cosWR;
        euler.x = Math.atan2(m23, m33);
        euler.y = Math.asin(s // How can I get euler.y > pi/2 ?
        );euler.z = Math.atan2(m12, m11);
      }

      return euler;
    }

    /**
     * @access public
     * @returns {SCNVector3} -
     */

  }, {
    key: 'quatToEulerAngles',
    value: function quatToEulerAngles() {
      return this.quatToRotation().rotationToEulerAngles();
    }
  }, {
    key: 'floatArray',


    /**
     * @access public
     * @returns {number[]} -
     */
    value: function floatArray() {
      return [this.x, this.y, this.z, this.w];
    }

    /**
     * @access public
     * @returns {Float32Array} -
     */

  }, {
    key: 'float32Array',
    value: function float32Array() {
      return new Float32Array([this.x, this.y, this.z, this.w]);
    }

    /**
     * @access private
     * @returns {Ammo.btVector4} -
     * @desc call Ammo.destroy(vec) after using it.
     */

  }, {
    key: '_createBtVector4',
    value: function _createBtVector4() {}
    //return new Ammo.btVector4(this.x, this.y, this.z, this.w)


    /**
     * @access private
     * @returns {Ammo.btQuaternion} -
     * @desc call Ammo.destroy(quat) after using it.
     */

  }, {
    key: '_createBtQuaternion',
    value: function _createBtQuaternion() {
      //return new Ammo.btQuaternion(this.x, this.y, this.z, this.w)
    }
  }, {
    key: 'angle',
    get: function get() {
      return this.quatToRotation().w;
    }
  }], [{
    key: '_initWithData',
    value: function _initWithData(data) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var bigEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var instance = new SCNVector4();
      if (bigEndian) {
        instance.x = data.readFloatBE(offset + 0);
        instance.y = data.readFloatBE(offset + 4);
        instance.z = data.readFloatBE(offset + 8);
        instance.w = data.readFloatBE(offset + 12);
      } else {
        instance.x = data.readFloatLE(offset + 0);
        instance.y = data.readFloatLE(offset + 4);
        instance.z = data.readFloatLE(offset + 8);
        instance.w = data.readFloatLE(offset + 12);
      }
      return instance;
    }
  }]);

  return SCNVector4;
}();

exports.default = SCNVector4;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNBlendMode = __webpack_require__(79);

var _SCNBlendMode2 = _interopRequireDefault(_SCNBlendMode);

var _SCNColorMask = __webpack_require__(80);

var _SCNColorMask2 = _interopRequireDefault(_SCNColorMask);

var _SCNCullMode = __webpack_require__(48);

var _SCNCullMode2 = _interopRequireDefault(_SCNCullMode);

var _SCNFillMode = __webpack_require__(81);

var _SCNFillMode2 = _interopRequireDefault(_SCNFillMode);

var _SCNMaterialProperty = __webpack_require__(26);

var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

var _SCNOrderedDictionary = __webpack_require__(22);

var _SCNOrderedDictionary2 = _interopRequireDefault(_SCNOrderedDictionary);

var _SCNTransparencyMode = __webpack_require__(84);

var _SCNTransparencyMode2 = _interopRequireDefault(_SCNTransparencyMode);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNAnimatable from './SCNAnimatable'

//import SCNShadable from './SCNShadable'


var _LightingModel = {
  blinn: 'SCNLightingModelBlinn',
  constant: 'SCNLightingModelConstant',
  lambert: 'SCNLightingModelLambert',
  phong: 'SCNLightingModelPhong',
  physicallyBased: 'SCNLightingModelPhysicallyBased'

  /**
   * A set of shading attributes that define the appearance of a geometry's surface when rendered.
   * @access public
   * @extends {NSObject}
   * @implements {SCNAnimatable}
   * @implements {SCNShadable}
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial
   */
};
var SCNMaterial = function (_NSObject) {
  _inherits(SCNMaterial, _NSObject);

  _createClass(SCNMaterial, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        diffuse: ['SCNMaterialProperty', function (obj, value) {
          obj._diffuse = value;
          value._createPresentation();
        }],
        ambient: ['SCNMaterialProperty', function (obj, value) {
          obj._ambient = value;
          value._createPresentation();
        }],
        specular: ['SCNMaterialProperty', function (obj, value) {
          obj._specular = value;
          value._createPresentation();
        }],
        normal: ['SCNMaterialProperty', function (obj, value) {
          obj._normal = value;
          value._createPresentation();
        }],
        reflective: ['SCNMaterialProperty', function (obj, value) {
          obj._reflective = value;
          value._createPresentation();
        }],
        emission: ['SCNMaterialProperty', function (obj, value) {
          obj._emission = value;
          value._createPresentation();
        }],
        transparent: ['SCNMaterialProperty', function (obj, value) {
          obj._transparent = value;
          value._createPresentation();
        }],
        multiply: ['SCNMaterialProperty', function (obj, value) {
          obj._multiply = value;
          value._createPresentation();
        }],
        ambientOcclusion: ['SCNMaterialProperty', function (obj, value) {
          obj._ambientOcclusion = value;
          value._createPresentation();
        }],
        selfIllumination: ['SCNMaterialProperty', function (obj, value) {
          obj._selfIllumination = value;
          value._createPresentation();
        }],
        metalness: ['SCNMaterialProperty', function (obj, value) {
          obj._metalness = value;
          value._createPresentation();
        }],
        roughness: ['SCNMaterialProperty', function (obj, value) {
          obj._roughness = value;
          value._createPresentation();
        }],
        displacement: ['SCNMaterialProperty', function (obj, value) {
          obj._displacement = value;
          value._createPresentation();
        }],
        name: 'string',
        shininess: 'float',
        fresnelExponent: 'float',
        transparency: 'integer',
        transparencyMode: 'integer',
        lightingModelName: ['string', 'lightingModel'],
        litPerPixel: ['boolean', 'isLitPerPixel'],
        doubleSided: ['boolean', 'isDoubleSided'],
        cullMode: 'integer',
        blendMode: 'integer',
        locksAmbientWithDiffuse: 'boolean',
        writesToDepthBuffer: 'boolean',
        readsFromDepthBuffer: 'boolean',
        colorBufferWriteMask: 'integer',
        fillMode: 'integer',
        valuesForUndefinedKeys: ['NSMutableDictionary', '_valuesForUndefinedKeys'],
        shadableHelper: ['SCNShadableHelper', '_shadableHelper'],

        avoidsOverLighting: ['boolean', null],
        entityID: ['string', '_entityID'],
        indexOfRefraction: ['integer', null],
        selfIlluminationOcclusion: ['integer', null]
      };
    }

    // Creating a Material

    /**
     * Creates a material from the specified Model I/O material object.
     * @access public
     * @constructor
     * @param {MDLMaterial} mdlMaterial - A Model I/O material object.
     * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLMaterial class is a generic description of surface rendering to be used in rendering 3D object, supporting a superset of the attributes described by the SCNMaterial class. 
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1419835-init
     */

  }]);

  function SCNMaterial(mdlMaterial) {
    _classCallCheck(this, SCNMaterial);

    // Configuring a Material’s Visual Properties

    var _this = _possibleConstructorReturn(this, (SCNMaterial.__proto__ || Object.getPrototypeOf(SCNMaterial)).call(this));

    _this._diffuse = new _SCNMaterialProperty2.default(_SKColor2.default.white);
    _this._ambient = new _SCNMaterialProperty2.default(new _SKColor2.default(0.485, 0.485, 0.485, 1.0));
    _this._specular = new _SCNMaterialProperty2.default(_SKColor2.default.black);
    _this._normal = new _SCNMaterialProperty2.default(_SKColor2.default.white);
    _this._reflective = new _SCNMaterialProperty2.default(_SKColor2.default.black);
    _this._emission = new _SCNMaterialProperty2.default(_SKColor2.default.black);
    _this._transparent = new _SCNMaterialProperty2.default(_SKColor2.default.white);
    _this._multiply = new _SCNMaterialProperty2.default(_SKColor2.default.white);
    _this._ambientOcclusion = new _SCNMaterialProperty2.default(_SKColor2.default.white);
    _this._selfIllumination = new _SCNMaterialProperty2.default(_SKColor2.default.black);
    _this._metalness = new _SCNMaterialProperty2.default(_SKColor2.default.black);
    _this._roughness = new _SCNMaterialProperty2.default(new _SKColor2.default(0.485, 0.485, 0.485, 1.0));
    _this._displacement = new _SCNMaterialProperty2.default(_SKColor2.default.black); // TODO: check the default value

    // Customizing a Material

    /**
     * A name associated with the material.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462525-name
     */
    _this.name = null;

    /**
     * The sharpness of specular highlights. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462533-shininess
     */
    _this.shininess = 1.0;

    /**
     * A factor affecting the material’s reflectivity. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462587-fresnelexponent
     */
    _this.fresnelExponent = 0.0;

    /**
     * The uniform transparency of the material. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462567-transparency
     */
    _this.transparency = 1.0;

    /**
     * The mode SceneKit uses to calculate transparency for the material.
     * @type {SCNTransparencyMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462549-transparencymode
     */
    _this.transparencyMode = _SCNTransparencyMode2.default.aOne;

    /**
     * The lighting formula that SceneKit uses to render the material.
     * @type {SCNMaterial.LightingModel}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462518-lightingmodel
     */
    _this.lightingModel = _LightingModel.blinn;

    /**
     * A Boolean value that determines whether SceneKit performs lighting calculations per vertex or per pixel. Animatable.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462580-islitperpixel
     */
    _this.isLitPerPixel = true;

    /**
     * A Boolean value that determines whether SceneKit should render both front and back faces of a surface. Animatable.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462531-isdoublesided
     */
    _this.isDoubleSided = false;

    /**
     * The mode determining which faces of a surface SceneKit renders. Animatable.
     * @type {SCNCullMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462571-cullmode
     */
    _this.cullMode = _SCNCullMode2.default.back;

    /**
     * The mode that determines how pixel colors rendered using this material blend with other pixel colors in the rendering target.
     * @type {SCNBlendMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462585-blendmode
     */
    _this.blendMode = _SCNBlendMode2.default.alpha;

    /**
     * A Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462522-locksambientwithdiffuse
     */
    _this.locksAmbientWithDiffuse = true;

    /**
     * A Boolean value that determines whether SceneKit produces depth information when rendering the material.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462545-writestodepthbuffer
     */
    _this.writesToDepthBuffer = true;

    /**
     * A Boolean value that determines whether SceneKit uses depth information when rendering the material.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462562-readsfromdepthbuffer
     */
    _this.readsFromDepthBuffer = true;

    /**
     *
     * @type {SCNColorMask}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/2867554-colorbufferwritemask
     */
    _this.colorBufferWriteMask = _SCNColorMask2.default.all;

    /**
     * 
     * @type {SCNFillMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/2867442-fillmode
     */
    _this.fillMode = _SCNFillMode2.default.fill;

    /////////////////
    // SCNShadable //
    /////////////////

    // Assigning a Custom Shader Program

    /**
     * A program used when rendering the object.
     * @type {?SCNProgram}
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523689-program
     */
    _this.program = null;

    // Customizing SceneKit’s Shader Programs

    /**
     * A dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.
     * @type {?Map<SCNShaderModifierEntryPoint, string>}
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523348-shadermodifiers
     */
    _this.shaderModifiers = null;

    /**
     * @access private
     * @type {Map<string, SCNBindingBlock>}
     */
    _this._bindingHandler = {};

    /**
     * @access private
     * @type {Map<string, SCNBindingBlock>}
     */
    _this._unbindingHandler = {};

    /**
     * @access private
     * @type {Object}
     */
    _this._valuesForUndefinedKeys = {};

    ///////////////////
    // SCNAnimatable //
    ///////////////////

    /**
     * @access private
     * @type {Map}
     */
    _this._animations = new _SCNOrderedDictionary2.default();

    /**
     * @access private
     * @type {?string}
     */
    _this._entityID = null;

    _this._createPresentationProperties

    /**
     * @access private
     * @type {?SCNShadableHelper}
     */
    ();_this._shadableHelper = null;

    /**
     * @access private
     * @type {Promise}
     */
    _this._loadedPromise = null;

    return _this;
  }

  // Configuring a Material’s Visual Properties

  /**
   * An object that manages the material’s diffuse response to lighting.
   * @type {SCNMaterialProperty}
   * @desc Diffuse shading describes the amount and color of light reflected equally in all directions from each point on the material’s surface. The diffuse color of a pixel is independent of the point of view, so it can be thought of as a material’s “base” color or texture. By default, the diffuse property’s contents object is a white color. Figure 1 shows the effect of setting the diffuse property’s contents to a texture image on a material whose other properties have default contents.Figure 1 Adding a diffuse texture to a materialThe material’s lightingModel property determines the formula SceneKit uses to combine its diffuse color and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.Adding a diffuse texture to a material
   * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462589-diffuse
   */


  _createClass(SCNMaterial, [{
    key: '_createPresentationProperties',
    value: function _createPresentationProperties() {
      this._diffuse._createPresentation();
      this._ambient._createPresentation();
      this._specular._createPresentation();
      this._normal._createPresentation();
      this._reflective._createPresentation();
      this._emission._createPresentation();
      this._transparent._createPresentation();
      this._multiply._createPresentation();
      this._ambientOcclusion._createPresentation();
      this._selfIllumination._createPresentation();
      this._metalness._createPresentation();
      this._roughness._createPresentation();
    }
  }, {
    key: '_copyPresentationProperties',
    value: function _copyPresentationProperties() {
      this._diffuse._copyPresentation();
      this._ambient._copyPresentation();
      this._specular._copyPresentation();
      this._normal._copyPresentation();
      this._reflective._copyPresentation();
      this._emission._copyPresentation();
      this._transparent._copyPresentation();
      this._multiply._copyPresentation();
      this._ambientOcclusion._copyPresentation();
      this._selfIllumination._copyPresentation();
      this._metalness._copyPresentation();
      this._roughness._copyPresentation();
    }

    // Structures

    /**
     * @type {Object} LightingModel
     * @property {string} blinn Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Blinn-Phong  formula.
     * @property {string} constant Uniform shading that incorporates ambient lighting only.
     * @property {string} lambert Shading that incorporates ambient and diffuse properties only.
     * @property {string} phong Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Phong  formula.
     * @property {string} physicallyBased Shading based on a realistic abstraction of physical lights and materials.
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial.lightingmodel
     */

  }, {
    key: 'handleBindingOfSymbolHandler',


    /////////////////
    // SCNShadable //
    /////////////////

    // Handling Parameters in Custom OpenGL Shader Programs

    /**
     * Specifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.
     * @access public
     * @param {string} symbol - A GLSL uniform variable or attribute name.
     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
     * @returns {void}
     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
      }];
    This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
      }];
      * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523063-handlebinding
     */
    value: function handleBindingOfSymbolHandler(symbol) {
      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._bindingHandler[symbol] = block;
    }

    /**
     * Specifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.
     * @access public
     * @param {string} symbol - A GLSL uniform variable or attribute name.
     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
     * @returns {void}
     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1522783-handleunbinding
     */

  }, {
    key: 'handleUnbindingOfSymbolHandler',
    value: function handleUnbindingOfSymbolHandler(symbol) {
      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._unbindingHandler[symbol] = block;
    }

    /**
     * @access private
     * @param {SCNNode} node -
     * @param {WebGLProgram} glProgram -
     * @param {WebGLRenderingContext} gl -
     * @param {SCNRenderer} renderer -
     * @returns {void}
     */

  }, {
    key: '_callBindingHandlerForNodeProgramContextRenderer',
    value: function _callBindingHandlerForNodeProgramContextRenderer(node, glProgram, gl, renderer) {
      var bindingKeys = Object.keys(this._bindingHandler);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = bindingKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          var handler = this._bindingHandler[key];
          var loc = gl.getUniformBlockIndex(glProgram, key);
          handler(glProgram, loc, node, renderer);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * @access private
     * @param {SCNNode} node -
     * @param {WebGLProgram} glProgram -
     * @param {WebGLRenderingContext} gl -
     * @param {SCNRenderer} renderer -
     * @returns {void}
     */

  }, {
    key: '_callUnindingHandlerForNodeProgramContextRenderer',
    value: function _callUnindingHandlerForNodeProgramContextRenderer(node, glProgram, gl, renderer) {
      var bindingKeys = Object.keys(this._unbindingHandler);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = bindingKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var key = _step2.value;

          var handler = this._unbindingHandler[key];
          var loc = gl.getUniformBlockIndex(glProgram, key);
          handler(glProgram, loc, node, renderer);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    ///////////////////
    // SCNAnimatable //
    ///////////////////

    // Managing Animations

    /**
     * Required. Adds an animation object for the specified key.
     * @access public
     * @param {CAAnimation} animation - The animation object to be added.
     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
     * @returns {void}
     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation
     */

  }, {
    key: 'addAnimationForKey',
    value: function addAnimationForKey(animation, key) {
      if (typeof key === 'undefined' || key === null) {
        key = Symbol();
      }
      var anim = animation.copy
      // FIXME: use current frame time
      ();anim._animationStartTime = Date.now() * 0.001;
      anim._prevTime = anim._animationStartTime - 0.0000001;

      this._animations.set(key, anim);
    }

    /**
     * Required. Returns the animation with the specified key.
     * @access public
     * @param {string} key - A string identifying a previously added animation.
     * @returns {?CAAnimation} - 
     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation
     */

  }, {
    key: 'animationForKey',
    value: function animationForKey(key) {
      return this._animations.get(key);
    }

    /**
     * Required. Removes all the animations currently attached to the object.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations
     */

  }, {
    key: 'removeAllAnimations',
    value: function removeAllAnimations() {
      this._animations.clear();
    }

    /**
     * Required. Removes the animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation to remove.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation
     */

  }, {
    key: 'removeAnimationForKey',
    value: function removeAnimationForKey(key) {
      this._animations.delete(key
      // TODO: reset values
      );
    }

    /**
     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
     * @access public
     * @param {string} key - A string identifying an attached animation to remove.
     * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
     * @returns {void}
     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation
     */

  }, {
    key: 'removeAnimationForKeyFadeOutDuration',
    value: function removeAnimationForKeyFadeOutDuration(key, duration) {}

    /**
     * Required. An array containing the keys of all animations currently attached to the object.
     * @type {string[]}
     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys
     */

  }, {
    key: 'pauseAnimationForKey',


    // Pausing and Resuming Animations

    /**
     * Required. Pauses the animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {void}
     * @desc This method has no effect if no animation is attached to the object with the specified key.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation
     */
    value: function pauseAnimationForKey(key) {}

    /**
     * Required. Resumes a previously paused animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {void}
     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation
     */

  }, {
    key: 'resumeAnimationForKey',
    value: function resumeAnimationForKey(key) {}

    /**
     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused
     */

  }, {
    key: 'isAnimationPausedForKey',
    value: function isAnimationPausedForKey(key) {
      return false;
    }

    // Instance Methods

    /**
     * Required. 
     * @access public
     * @param {number} speed - 
     * @param {string} key - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed
     */

  }, {
    key: 'setAnimationSpeedForKey',
    value: function setAnimationSpeedForKey(speed, key) {}

    /**
     * @access private
     * @returns {Promise} -
     */

  }, {
    key: '_getLoadedPromise',
    value: function _getLoadedPromise() {
      if (this._loadedPromise) {
        return this._loadedPromise;
      }

      var properties = [this._ambient, this._specular, this._normal, this._reflective, this._emission, this._transparent, this._multiply, this._ambientOcclusion, this._metalness, this._roughness];
      var promises = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var p = _step3.value;

          if (p) {
            promises.push(p.didLoad);
          }
        }
        //this._loadedPromise = Promise.all(promises)
        //return this._loadedPromise
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return Promise.all(promises);
    }

    /**
     * @access public
     * @type {Promise} -
     */

  }, {
    key: 'setValueForUndefinedKey',


    /**
     * Invoked by setValue(_:forKey:) when it finds no property for a given key.
     * @access public
     * @param {?Object} value - The value for the key identified by key.
     * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
     * @returns {void}
     * @desc Subclasses can override this method to handle the request in some other way. The default implementation raises an NSUndefinedKeyException.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1413490-setvalue
     */
    value: function setValueForUndefinedKey(value, key) {
      this._valuesForUndefinedKeys[key] = value;
    }

    /**
     * Invoked by value(forKey:) when it finds no property corresponding to a given key.
     * @access public
     * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
     * @returns {?Object} - 
     * @desc Subclasses can override this method to return an alternate value for undefined keys. The default implementation raises an NSUndefinedKeyException.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1413457-value
     */

  }, {
    key: 'valueForUndefinedKey',
    value: function valueForUndefinedKey(key) {
      if (typeof this._valuesForUndefinedKeys[key] !== 'undefined') {
        return this._valuesForUndefinedKeys[key];
      }
      return _get(SCNMaterial.prototype.__proto__ || Object.getPrototypeOf(SCNMaterial.prototype), 'valueForUndefinedKey', this).call(this, key);
    }
  }, {
    key: 'diffuse',
    get: function get() {
      return this._diffuse;
    }

    /**
     * An object that manages the material’s response to ambient lighting.
     * @type {SCNMaterialProperty}
     * @desc Ambient shading describes the amount and color of ambient light reflected by the material. Ambient shading is uniform in all directions at all points on a surface. If a scene does not contain lights whose type is ambient, this property has no effect on a material’s appearance. By default, the ambient property’s contents object is a dark gray color. Changing the ambient property’s contents lets you specify a different color or texture for the areas of a surface not directly illuminated by lights in a scene. To make the material respond identically to both ambient and diffuse light, set its locksAmbientWithDiffuse property to true. Figure 1 shows a material (with a texture for its diffuse property) before and after setting the ambient property’s contents to a solid color.Figure 1 Adding an ambient color to a materialThe material’s lightingModel property determines the formula SceneKit uses to combine its ambient color and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.This material property does not apply to physically-based materials (see physicallyBased).Adding an ambient color to a material
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462558-ambient
     */

  }, {
    key: 'ambient',
    get: function get() {
      return this._ambient;
    }

    /**
     * An object that manages the material’s specular response to lighting.
     * @type {SCNMaterialProperty}
     * @desc Specular shading describes the amount and color of light reflected by the material directly toward the viewer, forming a bright highlight on the surface and simulating a glossy or shiny appearance. You adjust the sharpness of specular highlights using the material’s shininess property.By default, the specular property’s contents object is a black color, causing the material to appear dull or matte. Changing the specular property’s contents to a brighter color causes specular highlights to appear in that color, making the surface appear shiny. When you apply a texture to the specular property, the texture image becomes a specular map—the brightness of each pixel in the image determines the tendency of each point on the material’s surface to create specular highlights when lit. Figure 1 shows a material (with a texture for its diffuse property) before and after providing a specular map image. Notice that the bright specular highlights appear only on portions of the surface where the specular map image is white.Figure 1 Adding a specular map to a materialThe material’s lightingModel property determines the formula SceneKit uses to combine its specularity and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.This material property does not apply to physically-based materials (see physicallyBased).Adding a specular map to a material
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462516-specular
     */

  }, {
    key: 'specular',
    get: function get() {
      return this._specular;
    }

    /**
     * An object that defines the nominal orientation of the surface at each point for use in lighting.
     * @type {SCNMaterialProperty}
     * @desc Simulating the interaction of lights with a material requires information about the orientation of the surface at each point. Typically, normal vectors provided by a geometry object provide this information. However, this limits the level of detail for surface contours because a geometry can only provide one unique surface normal vector per vertex (and increasing vertex count to model a highly detailed surface exacts a high performance cost).Alternatively, you can use a texture image as a normal map that describes the orientation of a surface for each pixel in the texture. When SceneKit uses an image, it treats the R, G, and B components of each as the X, Y, and Z components of a surface normal vector. Because a normal map texture can store much more detailed surface information than a geometry, you can use a material’s normal property to simulate rough surfaces such as stone or add embossed or engraved designs to an otherwise smooth surface.By default, the normal property’s contents object is a white color. Setting the normal property’s contents to any solid color disables normal mapping, causing SceneKit to shade the material using only the surface normal information provided by its geometry. Setting the normal property’s contents to an image or other texture-mapped content enables normal mapping, which also automatically sets the material’s isLitPerPixel property to true. Figure 1 shows the effect of setting the normal property’s contents to a texture image on a material whose other properties have default contents.Figure 1 Adding a normal map to a materialThe material’s lightingModel property determines the formula SceneKit uses to combine its surface normals and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.Adding a normal map to a material
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462542-normal
     */

  }, {
    key: 'normal',
    get: function get() {
      return this._normal;
    }

    /**
     * An object that defines the reflected color for each point on a surface.
     * @type {SCNMaterialProperty}
     * @desc You can simulate a mirrored or chromed finish on a surface by causing it to reflect its environment. SceneKit does not render real-time reflections of the objects in a scene, but it can use an environment map texture to simulate reflection of a static or animated image. When rendering each pixel on the surface, SceneKit traces the light from that point to a pixel in the environment map as if the surface was reflecting that image.By default, the reflective property’s contents object is a white color, causing the property to have no visible effect. Setting the reflective property’s contents to any solid color adds uniform shading to the material. To create a reflective effect, set the property’s contents to an image or other texture-mapped content.To produce a mirror-finish effect using an environment map, the texture image should take one of two forms:A sphere map, a square image whose content depicts an environment as reflected by a mirrored sphere.A cube map, an array of six square images which together form an imaginary cube enclosing the scene, whose inner surfaces are reflected by the material. You create a cube map by setting the reflective property’s contents object to an NSArray instance containing six images, each corresponding to a direction in the scene’s world coordinate space in the following order: +X, -X, +Y, -Y, +Z, -Z (or Right, Left, Top, Bottom, Near, Far).Figure 1 shows a material (with a texture for its normal property) before and after providing a cube map for the reflective property.Figure 1 Adding a reflective cube map to a materialThis material property does not apply to physically-based materials (see physicallyBased). Instead, such materials reflect environment-based lighting (see the SCNScene lightingEnvironment property) based on their metalness and roughness properties.Adding a reflective cube map to a material
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462520-reflective
     */

  }, {
    key: 'reflective',
    get: function get() {
      return this._reflective;
    }

    /**
     * An object that defines the color emitted by each point on a surface.
     * @type {SCNMaterialProperty}
     * @desc You can use an emissive map texture to simulate parts of a surface that glow with their own light. SceneKit does not treat the material as a light source—rather, the emission property determines colors for a material independent of lighting. (To create an object that appears to glow, you may wish to combine a geometry with an emissive map and additional SCNLight objects added to the scene.)By default, the emissive property’s contents object is a black color, causing the property to have no visible effect. Setting the emissive property’s contents to any solid color adds a uniform color to the material independent of lighting. To create a selective glow effect, set the property’s contents to an image or other texture-mapped content whose glowing areas use bright colors and whose other areas use darker colors. In the darker-colored portions of the emissive map (and portions with reduced opacity), the other visual properties of the material contribute to its appearance under scene lighting.Figure 1 shows a material (with a texture for its diffuse property) before and after providing an emissive map image.Figure 1 Adding an emissive map to a materialAdding an emissive map to a material
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462527-emission
     */

  }, {
    key: 'emission',
    get: function get() {
      return this._emission;
    }

    /**
     * An object that determines the opacity of each point in a material.
     * @type {SCNMaterialProperty}
     * @desc Use this property to selectively make parts of a material appear transparent. You can uniformly adjust the opacity of a material using its transparency property, or of all the content attached to a node using the node’s opacity property.By default, the transparent property’s contents object is a fully opaque black color, causing the property to have no visible effect. Setting the transparent property’s contents to any solid color uniformly fades the opacity of the material based on that color’s opacity value. To make parts of a material appear transparent, set the property’s contents to an image or other texture-mapped content whose alpha channel defines areas of full or partial opacity.Figure 1 shows a semitransparent material before and after providing a texture image for its transparent property. (To make the transparency effect more visible, a blue sphere is shown behind the transparent material.)Figure 1 Adding a transparent texture to a materialThe transparencyMode property controls how SceneKit interprets color information from the transparent property’s contents.Adding a transparent texture to a material
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462583-transparent
     */

  }, {
    key: 'transparent',
    get: function get() {
      return this._transparent;
    }

    /**
     * An object that provides color values that are multiplied with pixels in a material after all other shading is complete.
     * @type {SCNMaterialProperty}
     * @desc After combining a material’s other visual properties with lighting and other information about a scene, Scene kit multiplies the color of each rendered pixel by the color this property provides. You can use this property to darken or tint a surface independent of the effects of lighting and other properties, or to add precomputed lighting to a scene via a shadow map.By default, the multiply property’s contents object is a white color, causing the property to have no visible effect.Figure 1 shows a material (with textures for its diffuse and emission properties) before and after setting the multiply property’s contents to a solid color. Notice that the multiply color modulates even the bright areas added by the emissive map.Figure 1 Adding a multiply color to a materialAdding a multiply color to a material
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462575-multiply
     */

  }, {
    key: 'multiply',
    get: function get() {
      return this._multiply;
    }

    /**
     * An object that provides color values to be multiplied with the ambient light affecting the material.
     * @type {SCNMaterialProperty}
     * @desc Use this property to assign an ambient occlusion texture map to a surface. This property has no effect if there is no ambient light in the scene. If this property is not nil, SceneKit ignores the ambient property.When using physically-based shading (see physicallyBased), ambient occlusion approximates large-scale surface details that obscure global illumination.
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462579-ambientocclusion
     */

  }, {
    key: 'ambientOcclusion',
    get: function get() {
      return this._ambientOcclusion;
    }

    /**
     * An object that provides color values representing the global illumination of the surface.
     * @type {SCNMaterialProperty}
     * @desc Self-illumination applies to all materials, but is especially useful for those using physically-based shading (see physicallyBased). Physically-based materials work best with environment-based lighting (see the SCNScene property lightingEnvironment), but for some materials it can be useful to let a surface itself define part of its lighting—for example, an object whose position obscures it from the “sky” that provides the main lighting environment. When you assign contents to this property, they override the environmental lighting contribution to diffuse shading, but environmental lighting still contributes to specular effects.
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1462524-selfillumination
     */

  }, {
    key: 'selfIllumination',
    get: function get() {
      return this._selfIllumination;
    }

    /**
     * An object that provides color values to determine how metallic the material’s surface appears.
     * @type {SCNMaterialProperty}
     * @desc This property measures only the total intensity of color values; texture contents are best defined in grayscale.This property generally approximates aspects of a physical surface—such as index of refraction, tendency to produce sharp reflections, and tendency to produce Fresnel reflections at grazing angles—that together produce an overall metallic or nonmetallic (also called dielectric) appearance. Lower values (darker colors) cause the material to appear more like a dielectric surface. Higher values (brighter colors) cause the surface to appear more metallic.This property applies only when the material’s lightingModel value is physicallyBased.
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1640554-metalness
     */

  }, {
    key: 'metalness',
    get: function get() {
      return this._metalness;
    }

    /**
     * An object that provides color values to determine the apparent smoothness of the surface.
     * @type {SCNMaterialProperty}
     * @desc This property measures only the total intensity of color values; texture contents are best defined in grayscale.This property approximates the level of microscopic detail—for example tiny bumps and cracks—in a surface. By approximating these “microfacets” as a single term, this property helps produce lighting calculations that resemble the energy-conserving laws of real-world physics, resulting in more realistic variation between matte and shiny surfaces. Lower values (darker colors) cause the material to appear shiny, with well-defined specular highlights. Higher values (brighter colors) cause specular highlights to spread out and the diffuse color of the material to become more retroreflective.This property applies only when the material’s lightingModel value is physicallyBased.
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/1640555-roughness
     */

  }, {
    key: 'roughness',
    get: function get() {
      return this._roughness;
    }

    /**
     * 
     * @type {SCNMaterialProperty}
     * @desc
     * @see https://developer.apple.com/documentation/scenekit/scnmaterial/2867516-displacement
     */

  }, {
    key: 'displacement',
    get: function get() {
      return this._displacement;
    }
  }, {
    key: 'animationKeys',
    get: function get() {
      var keys = [];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._animations.keys()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var key = _step4.value;

          keys.push(key);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return keys;
    }
  }, {
    key: 'didLoad',
    get: function get() {
      return this._getLoadedPromise();
    }
  }], [{
    key: 'LightingModel',
    get: function get() {
      return _LightingModel;
    }
  }]);

  return SCNMaterial;
}(_NSObject3.default);

exports.default = SCNMaterial;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The drawing primitive that connects vertices when rendering a geometry element, used by the primitiveType property to specify how SceneKit interprets the geometry element’s data.
 * @typedef {Object} SCNGeometryPrimitiveType
 * @property {number} triangles - The geometry element’s data is a sequence of triangles, with each triangle described by three new vertices.
 * @property {number} triangleStrip - The geometry element’s data is a sequence of triangles, with each triangle described by one new vertex and two vertices from the previous triangle. 
 * @property {number} line - The geometry element’s data is a sequence of line segments, with each line segment described by two new vertices. 
 * @property {number} point - The geometry element’s data is a sequence of unconnected points.
 * @property {number} polygon - 
 * @see https://developer.apple.com/documentation/scenekit/scngeometryprimitivetype
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNGeometryPrimitiveType = {
  triangles: 0,
  triangleStrip: 1,
  line: 2,
  point: 3,
  polygon: 4
};

exports.default = SCNGeometryPrimitiveType;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CAAnimationGroup = __webpack_require__(76);

var _CAAnimationGroup2 = _interopRequireDefault(_CAAnimationGroup);

var _CABasicAnimation = __webpack_require__(45);

var _CABasicAnimation2 = _interopRequireDefault(_CABasicAnimation);

var _CAMediaTimingFunction = __webpack_require__(47);

var _CAMediaTimingFunction2 = _interopRequireDefault(_CAMediaTimingFunction);

var _CAKeyframeAnimation = __webpack_require__(77);

var _CAKeyframeAnimation2 = _interopRequireDefault(_CAKeyframeAnimation);

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

var _SCNMatrix4MakeTranslation = __webpack_require__(18);

var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _SCNVector3 = __webpack_require__(11);

var _SCNVector4 = _interopRequireDefault(_SCNVector3);

var _SCNMovabilityHint = __webpack_require__(78);

var _SCNMovabilityHint2 = _interopRequireDefault(_SCNMovabilityHint);

var _SCNOrderedDictionary = __webpack_require__(22);

var _SCNOrderedDictionary2 = _interopRequireDefault(_SCNOrderedDictionary);

var _SCNPhysicsWorld = __webpack_require__(33);

var _SCNPhysicsWorld2 = _interopRequireDefault(_SCNPhysicsWorld);

var _SCNTransaction = __webpack_require__(35);

var _SCNTransaction2 = _interopRequireDefault(_SCNTransaction);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _constants = __webpack_require__(25);

var Constants = _interopRequireWildcard(_constants);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNActionable from './SCNActionable'
//import SCNAnimatable from './SCNAnimatable'
//import SCNBoundingVolume from './SCNBoundingVolume'
//import SCNGeometry from './SCNGeometry'
//import SCNGeometrySource from './SCNGeometrySource'
//import SCNLight from './SCNLight'
//import SCNCamera from './SCNCamera'
//import SCNMorpher from './SCNMorpher'
//import SCNSkinner from './SCNSkinner'

//import SCNMatrix4MakeScale from './SCNMatrix4MakeScale'

//import SCNQuaternion from './SCNQuaternion'
//import SCNConstraint from './SCNConstraint'

//import SCNNodeRendererDelegate from './SCNNodeRendererDelegate'

//import SCNParticleSystem from './SCNParticleSystem'
//import SCNPhysicsBody from './SCNPhysicsBody'
//import SCNPhysicsField from './SCNPhysicsField'

//import SCNAudioPlayer from './SCNAudioPlayer'
//import SCNHitTestResult from './SCNHitTestResult'


var _localFront = new _SCNVector2.default(0, 0, 1);
var _localRight = new _SCNVector2.default(1, 0, 0);
var _localUp = new _SCNVector2.default(0, 1, 0);

/**
 * A structural element of a scene graph, representing a position and transform in a 3D coordinate space, to which you can attach geometry, lights, cameras, or other displayable content.
 * @access public
 * @extends {NSObject}
 * @implements {SCNActionable}
 * @implements {SCNAnimatable}
 * @implements {SCNBoundingVolume}
 * @see https://developer.apple.com/documentation/scenekit/scnnode
 */

var SCNNode = function (_NSObject) {
  _inherits(SCNNode, _NSObject);

  _createClass(SCNNode, null, [{
    key: '_propTypes',
    get: function get() {
      var _this2 = this;

      return {
        name: 'string',
        light: 'SCNLight',
        camera: 'SCNCamera',
        geometry: ['SCNGeometry', function (obj, value) {
          obj.geometry = value;
          obj.boundingBox = value.boundingBox;
        }],
        morpher: 'SCNMorpher',
        skinner: 'SCNSkinner',
        categoryBitMask: 'integer',
        paused: ['boolean', 'isPaused'],
        position: ['SCNVector3', '_position'],
        rotation: ['SCNVector4', '_rotation'],
        orientation: ['SCNVector4', function (obj, value) {
          obj.orientation = value;
        }],
        scale: ['SCNVector3', '_scale'],
        hidden: ['boolean', 'isHidden'],
        opacity: ['float', '_opacity'],
        renderingOrder: 'integer',
        castsShadow: 'boolean',
        childNodes: ['NSArray', function (obj, childNodes) {
          childNodes.forEach(function (child) {
            obj.addChildNode(child);
          });
        }],
        physicsBody: ['SCNPhysicsBody', function (obj, body) {
          obj.physicsBody = body;
        }],
        physicsField: 'SCNPhysicsField',
        particleSystem: ['NSArray', '_particleSystems'],
        animations: ['NSMutableDictionary', function (obj, anims) {
          _this2._loadAnimationArray(obj, anims);
          obj._setAnimationsToPlayers();
        }],
        'animation-keys': ['NSMutableArray', function (obj, keys) {
          obj._animationPlayers._keys = keys;
        }],
        'animation-players': ['NSMutableArray', function (obj, players) {
          obj._animationPlayers._values = players;
          obj._setAnimationsToPlayers();
        }],
        'action-keys': ['NSArray', null],
        actions: ['NSMutableDictionary', function (obj, acts) {
          _this2._loadActionArray(obj, acts);
        }],
        eulerAngles: ['SCNVector3', function (obj, value) {
          obj.eulerAngles = value;
        }],
        movabilityHint: 'integer',

        clientAttributes: ['NSMutableDictionary', null],
        nodeID: ['string', '_nodeID'],
        entityID: ['string', '_entityID']
      };
    }

    // Creating a Node

    /**
     * Creates and returns a node object with the specified geometry attached.
     * @access public
     * @constructor
     * @param {?SCNGeometry} [geometry = null] - The geometry to be attached.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408020-init
     */

  }]);

  function SCNNode() {
    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, SCNNode);

    // Managing Node Attributes

    /**
     * A name associated with the node.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408014-name
     */
    var _this = _possibleConstructorReturn(this, (SCNNode.__proto__ || Object.getPrototypeOf(SCNNode)).call(this));

    _this.name = null;

    /**
     * The light attached to the node.
     * @type {?SCNLight}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408004-light
     */
    _this.light = null;

    /**
     * The camera attached to the node.
     * @type {?SCNCamera}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407976-camera
     */
    _this.camera = null;

    /**
     * The geometry attached to the node.
     * @type {?SCNGeometry}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407966-geometry
     */
    _this._geometry = geometry;

    /**
     * The morpher object responsible for blending the node’s geometry.
     * @type {?SCNMorpher}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408022-morpher
     */
    _this.morpher = null;

    /**
     * The skinner object responsible for skeletal animations of node’s contents.
     * @type {?SCNSkinner}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407953-skinner
     */
    _this.skinner = null;

    /**
     * A mask that defines which categories the node belongs to.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407994-categorybitmask
     */
    _this.categoryBitMask = 0;

    // Working With Node Animation

    /**
     * A Boolean value that determines whether to run actions and animations attached to the node and its child nodes.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407962-ispaused
     */
    _this.isPaused = false;

    /**
     * A node object representing the state of the node as it currently appears onscreen.
     * @type {SCNNode}
     * @access private
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408030-presentation
     */
    _this._presentation = null;

    /**
     * 
     * @type {boolean}
     * @access private
     */
    _this._isPresentationInstance = false;

    // Managing the Node’s Transformation

    /**
     * The transformation applied to the node relative to its parent. Animatable.
     * @type {SCNMatrix4}
     * @access private
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407964-transform
     */
    _this._transform = new _SCNMatrix2.default();

    _this._worldTransform = new _SCNMatrix2.default();

    /**
     * 
     * @type {boolean}
     * @access private
     */
    _this._transformUpToDate = false;

    /**
     * The translation applied to the node. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408026-position
     */
    _this._position = new _SCNVector2.default(0, 0, 0);

    /**
     * The node’s orientation, expressed as a rotation angle about an axis. Animatable.
     * @type {SCNVector4}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408034-rotation
     */
    _this._rotation = new _SCNVector4.default(1, 0, 0, 0);

    /**
     * The node’s orientation, expressed as pitch, yaw, and roll angles, each in radians. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407980-eulerangles
     */
    //this.eulerAngles = null

    /**
     * The node’s orientation, expressed as a quaternion. Animatable.
     * @type {SCNQuaternion}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408048-orientation
     */
    //this.orientation = null

    /**
     * The scale factor applied to the node. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408050-scale
     */
    _this._scale = new _SCNVector2.default(1, 1, 1);

    /**
     * The pivot point for the node’s position, rotation, and scale. Animatable.
     * @type {SCNMatrix4}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408044-pivot
     */
    _this.pivot = null;

    /**
     * A list of constraints affecting the node’s transformation.
     * @type {?SCNConstraint[]}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408016-constraints
     */
    _this.constraints = null;

    //this._worldTransform = null

    // Modifying the Node Visibility

    /**
     * A Boolean value that determines the visibility of the node’s contents. Animatable.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407967-ishidden
     */
    _this.isHidden = false;

    /**
     * The opacity value of the node. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408010-opacity
     */
    _this._opacity = 1;
    _this._worldOpacity = 1;

    /**
     * The order the node’s content is drawn in relative to that of other nodes.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407978-renderingorder
     */
    _this.renderingOrder = 0;

    /**
     * A Boolean value that determines whether SceneKit renders the node’s contents into shadow maps.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407955-castsshadow
     */
    _this.castsShadow = false;

    /**
     * A value that indicates how SceneKit should handle the node when rendering movement-related effects.
     * @type {SCNMovabilityHint}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1690499-movabilityhint
     */
    _this.movabilityHint = _SCNMovabilityHint2.default.fixed;

    // Managing the Node Hierarchy

    /**
     * The node’s parent in the scene graph hierarchy.
     * @type {?SCNNode}
     * @access private
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407968-parent
     */
    _this._parent = null;

    /**
     * An array of the node’s children in the scene graph hierarchy.
     * @type {SCNNode[]}
     * @access private
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407984-childnodes
     */
    _this._childNodes = [];

    // Customizing Node Rendering

    /**
     * An array of Core Image filters to be applied to the rendered contents of the node.
     * @type {?CIFilter[]}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407949-filters
     */
    _this.filters = null;

    /**
     * An object responsible for rendering custom contents for the node using Metal or OpenGL.
     * @type {?SCNNodeRendererDelegate}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408012-rendererdelegate
     */
    _this.rendererDelegate = null;

    // Adding Physics to a Node

    /**
     * The physics body associated with the node.
     * @type {?SCNPhysicsBody}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407988-physicsbody
     */
    _this._physicsBody = null;

    /**
     * The physics field associated with the node.
     * @type {?SCNPhysicsField}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408006-physicsfield
     */
    _this.physicsField = null;

    // Working With Particle Systems

    _this._particleSystems = null;

    // Working With Positional Audio

    _this._audioPlayers = [];

    /**
     * 
     * @type {?GKEntity}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2873004-entity
     */
    _this.entity = null;

    /**
     * 
     * @type {SCNNodeFocusBehavior}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2881853-focusbehavior
     */
    _this.focusBehavior = null;

    ///////////////////
    // SCNActionable //
    ///////////////////

    // Inspecting a Node’s Running Action
    //this._hasActions = false

    /**
     * @access private
     * @type {Map}
     */
    _this._actions = new Map();

    ///////////////////
    // SCNAnimatable //
    ///////////////////

    /**
     * @access private
     * @type {SCNOrderedDictionary}
     */
    _this._animations = new _SCNOrderedDictionary2.default();

    /**
     * @access private
     * @type {SCNOrderedDictionary}
     */
    _this._animationPlayers = new _SCNOrderedDictionary2.default();

    ///////////////////////
    // SCNBoundingVolume //
    ///////////////////////

    // Working with Bounding Volumes

    /**
     * The minimum and maximum corner points of the object’s bounding box.
     * @type {{min: SCNVector3, max: SCNVector3}}
     * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034705-boundingbox
     */
    _this._boundingBox = null;
    _this._fixedBoundingBox = null;

    //this._boundingSphere = null


    /**
     * @access private
     * @type {?string}
     */
    _this._entityID = null;

    /**
     * @access private
     * @type {?string}
     */
    _this._nodeID = null;

    _this._updateBoundingBox

    /**
     * @access private
     * @type {Promise}
     */
    ();_this._loadedPromise = null;
    return _this;
  }

  _createClass(SCNNode, [{
    key: '_createPresentation',
    value: function _createPresentation() {
      if (this._isPresentationInstance) {
        return;
      } else if (this._presentation) {
        return;
      }
      var p = this.copy();
      p._isPresentationInstance = true;
      if (this.geometry !== null) {
        p.geometry = this.geometry.copy();
        p.geometry._isPresentationInstance = true;
        p.geometry._geometryElements = [];
        this.geometry._geometryElements.forEach(function (element) {
          p.geometry._geometryElements.push(element.copy());
        });
        p.geometry._geometrySources = [];
        this.geometry._geometrySources.forEach(function (source) {
          p.geometry._geometrySources.push(source.copy());
        });
        this.geometry._presentation = p.geometry;
      }
      if (this._particleSystems) {
        p._particleSystems = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._particleSystems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var system = _step.value;

            var pSystem = system._createPresentation();
            p._particleSystems.push(pSystem);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      this._presentation = p;
    }

    // Managing the Node’s Transformation

    /**
     * The transformation applied to the node relative to its parent. Animatable.
     * @type {SCNMatrix4}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407964-transform
     */

  }, {
    key: '_updateWorldTransform',
    value: function _updateWorldTransform() {
      var p = null;
      if (this._parent === null) {
        p = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);
      } else {
        p = this._parent._worldTransform;
      }
      this._worldTransform = this.transform.mult(p);

      if (this._presentation) {
        var pp = null;
        var ppOpacity = 1.0;
        if (this._parent === null) {
          pp = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);
        } else if (this._parent._presentation === null) {
          pp = this._parent._worldTransform;
          ppOpacity = this._parent._worldOpacity;
        } else {
          pp = this._parent._presentation._worldTransform;
          ppOpacity = this._parent._presentation._worldOpacity;
        }
        this._presentation._updateTransform();
        this._presentation._worldTransform = this._presentation.transform.mult(pp);
        this._presentation._worldOpacity = this._presentation._opacity * ppOpacity;
      }

      this._childNodes.forEach(function (child) {
        child._updateWorldTransform();
      });
    }

    /*
    _updatePresentationTransform() {
      let p = null
      if(this._parent === null){
        p = SCNMatrix4MakeTranslation(0, 0, 0)
      }else{
        p = this._parent._presentation._worldTransform
      }
      
      this._presentation._worldTransform = this._presentation.transform.mult(parentTransform)
      this._childNodes.forEach((child) => {
        child._updatePrsentationTransform(this._presentation._worldTransform)
      })
    }
    */

    /**
     * The translation applied to the node. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408026-position
     */

  }, {
    key: 'addChildNode',


    // Managing the Node Hierarchy

    /**
     * Adds a node to the node’s array of children.
     * @access public
     * @param {SCNNode} child - The node to be added.
     * @returns {void}
     * @desc Calling this method appends the node to the end of the childNodes array.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407974-addchildnode
     */
    value: function addChildNode(child) {
      if (this._childNodes.indexOf(child) >= 0) {
        return;
      }
      child.removeFromParentNode();
      this._childNodes.push(child);
      child._parent = this;

      child._resetPhysicsTransformRecursively(true);
    }

    /**
     * Adds a node to the node’s array of children at a specified index.
     * @access public
     * @param {SCNNode} child - The node to be inserted.ImportantRaises an exception (invalidArgumentException) if child is nil.
     * @param {number} index - The position at which to insert the new child node.ImportantRaises an exception (rangeException) if index is greater than the number of elements in the node’s childNodes array.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407958-insertchildnode
     */

  }, {
    key: 'insertChildNodeAt',
    value: function insertChildNodeAt(child, index) {
      if (this._childNodes.indexOf(child) >= 0) {
        return;
      }
      child.removeFromParentNode();
      this._insertObjectInChildNodesAtIndex(child, index);
      this._parent = this;
    }

    /**
     * Removes the node from its parent’s array of child nodes.
     * @access public
     * @returns {void}
     * @desc Removing nodes from the node hierarchy serves two purposes. Nodes own their contents (child nodes or attached lights, geometries, and other objects), so deallocating unneeded nodes can reduce memory usage. Additionally, SceneKit does more work at rendering time with a large, complex node hierarchy, so removing nodes whose contents you don’t need to display can improve rendering performance.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407991-removefromparentnode
     */

  }, {
    key: 'removeFromParentNode',
    value: function removeFromParentNode() {
      var parentNode = this._parent;
      if (parentNode === null) {
        return;
      }
      var index = parentNode._childNodes.indexOf(this);
      if (index < 0) {
        return;
      }
      parentNode._removeObjectFromChildNodesAtIndex(index);
    }

    /**
     * Removes a child from the node’s array of children and inserts another node in its place. 
     * @access public
     * @param {SCNNode} oldChild - 
     * @param {SCNNode} newChild - 
     * @returns {void}
     * @desc If both the child and child2 nodes are children of the node, calling this method swaps their positions in the array. Note that removing a node from the node hierarchy may result in it being deallocated.Calling this method results in undefined behavior if the child parameter does not refer to a child of this node.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408002-replacechildnode
     */

  }, {
    key: 'replaceChildNodeWith',
    value: function replaceChildNodeWith(oldChild, newChild) {
      var index = this._childNodes.indexOf(oldChild);
      if (index < 0) {
        return;
      }
      this._removeObjectFromChildNodesAtIndex(index);
      this._insertObjectInChildNodesAtIndex(newChild, index);
    }

    /**
     *
     * @access private
     * @param {number} index -
     * @returns {void}
     */

  }, {
    key: '_removeObjectFromChildNodesAtIndex',
    value: function _removeObjectFromChildNodesAtIndex(index) {
      var arr = this._childNodes.splice(index, 1);
      if (arr.length === 0) {
        return;
      }
      var obj = arr[0];

      obj._parent = null;
      obj._transformUpToDate = false;
    }

    /**
     *
     * @access private
     * @param {SCNNode} object -
     * @param {number} index -
     * @returns {void}
     */

  }, {
    key: '_insertObjectInChildNodesAtIndex',
    value: function _insertObjectInChildNodesAtIndex(object, index) {
      var length = this._childNodes.length;
      if (index > length) {
        throw new Error('SCNNode.childNodes out of index: ' + index + ' > ' + length);
      }
      this._childNodes.splice(index, 0, object);
    }

    /**
     * @access private
     * @type {?SCNNode}
     */

  }, {
    key: 'childNodesPassingTest',


    // Searching the Node Hierarchy

    /**
     * Returns all nodes in the node’s child node subtree that satisfy the test applied by a block.
     * @access public
     * @param {function(child: SCNNode, stop: UnsafeMutablePointer<ObjCBool>): boolean} predicate - The block to apply to the node’s child and descendant nodes .The block takes two parameters:child The child node currently being searched. stop A reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.The block returns a Boolean value indicating whether to include the child node in the search results array.
     * @returns {SCNNode[]} - 
     * @desc Use this method to search for nodes using a test you specify. For example, you can search for empty nodes using a block that returns YES for nodes whose light, camera, and geometry properties are all nil.SceneKit uses a recursive preorder traversal to search the child node subtree—that is, the block searches a node before it searches each of the node’s children, and it searches all children of a node before searching any of that node’s sibling nodes.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407982-childnodes
     */
    value: function childNodesPassingTest(predicate) {
      var result = [];
      return result;
    }

    /**
     * Returns the first node in the node’s child node subtree with the specified name.
     * @access public
     * @param {string} name - The name of the node to search for.
     * @param {boolean} [recursively = true] - true to search the entire child node subtree, or false to search only the node’s immediate children.
     * @returns {?SCNNode} - 
     * @desc If the recursive parameter is true, SceneKit uses a preorder traversal to search the child node subtree—that is, the block searches a node before it searches each of the node’s children, and it searches all children of a node before searching any of that node’s sibling nodes. Otherwise, SceneKit searches only those nodes in the node’s childNodes array.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407951-childnode
     */

  }, {
    key: 'childNodeWithNameRecursively',
    value: function childNodeWithNameRecursively(name) {
      var recursively = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      for (var i = 0; i < this._childNodes.length; i++) {
        if (this._childNodes[i].name === name) {
          return this._childNodes[i];
        }
        if (recursively) {
          var result = this._childNodes[i].childNodeWithNameRecursively(name, recursively);
          if (result !== null) {
            return result;
          }
        }
      }

      return null;
    }

    /**
     * Returns the first node in the node’s child nodearray with the specified name.
     * @access public
     * @param {string} name - The name of the node to search for.
     * @returns {?SCNNode} - 
     * @desc SceneKit searches only those nodes in the node’s childNodes array.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407951-childnode
     */

  }, {
    key: 'childNodeWithName',
    value: function childNodeWithName(name) {
      return this.childNodeWithNameRecursively(name, false);
    }

    /**
     * @access private
     * @param {string} nodeID -
     * @param {boolean} recursively -
     * @returns {?SCNNode} -
     */

  }, {
    key: '_childNodeWithNodeIDRecursively',
    value: function _childNodeWithNodeIDRecursively(nodeID) {
      var recursively = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      for (var i = 0; i < this._childNodes.length; i++) {
        if (this._childNodes[i]._nodeID === nodeID) {
          return this._childNodes[i];
        }
        if (recursively) {
          var result = this._childNodes[i]._childNodeWithNodeIDRecursively(nodeID, recursively);
          if (result !== null) {
            return result;
          }
        }
      }

      return null;
    }

    /**
     * @access private
     * @param {string} nodeID -
     * @returns {?SCNNode} -
     */

  }, {
    key: '_childNodeWithNodeID',
    value: function _childNodeWithNodeID(nodeID) {
      return this._childNodeWithNodeIDRecursively(name, false);
    }

    /**
     * Executes the specified block for each of the node’s child and descendant nodes.
     * @access public
     * @param {function(child: SCNNode, stop: UnsafeMutablePointer<ObjCBool>): void} block - The block to apply to the node’s child and descendant nodes.The block takes two parameters:childThe child node currently being evaluated.stopA reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.
     * @returns {void}
     * @desc SceneKit uses a recursive preorder traversal to process the child node subtree—that is, the block runs for a node before it runs for each of the node’s children, and it processes all children of a node before processing any of that node’s sibling nodes.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408032-enumeratechildnodes
     */

  }, {
    key: 'enumerateChildNodes',
    value: function enumerateChildNodes(block) {
      var _this3 = this;

      //this._childNodes.some((child) => {
      this.childNodes.some(function (child) {
        return _this3._enumerateChildNodesRecursive(child, block);
      });
    }

    /**
     * Executes the specified block for each of the node’s child and descendant nodes, as well as for the node itself.
     * @access public
     * @param {function(arg1: SCNNode, arg2: UnsafeMutablePointer<ObjCBool>): void} block - The block to apply to the node’s child and descendant nodes.The block takes two parameters:childThe child node currently being evaluated.stopA reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.
     * @returns {void}
     * @desc SceneKit uses a recursive preorder traversal to process the child node subtree—that is, the block runs for a node before it runs for each of the node’s children, and it processes all children of a node before processing any of that node’s sibling nodes.This method is equivalent to the enumerateChildNodes(_:) method, but unlike that method it also runs the block to process the node itself, not just its child nodes.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1642248-enumeratehierarchy
     */

  }, {
    key: 'enumerateHierarchy',
    value: function enumerateHierarchy(block) {
      this._enumerateChildNodesRecursive(this, block);
    }
  }, {
    key: '_enumerateChildNodesRecursive',
    value: function _enumerateChildNodesRecursive(node, block) {
      var _this4 = this;

      var stop = block(node);
      if (stop === true) {
        return true;
      }
      stop = node._childNodes.some(function (child) {
        return _this4._enumerateChildNodesRecursive(child, block);
      });
      return stop;
    }

    // Adding Physics to a Node

  }, {
    key: '_resetPhysicsTransformRecursively',
    value: function _resetPhysicsTransformRecursively() {
      var updateWorldTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this._physicsBody) {
        this._physicsBody._resetTransform(updateWorldTransform);
      }
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._childNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var child = _step2.value;

          child._resetPhysicsTransformRecursively(updateWorldTransform);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    // Working With Particle Systems

    /**
     * Attaches a particle system to the node.
     * @access public
     * @param {SCNParticleSystem} system - A particle system.
     * @returns {void}
     * @desc When attached to a node, a particle system’s emitter location follows that node as it moves through the scene. To instead attach a particle system to a location in the scene’s world coordinate space, use the corresponding method on SCNScene.For details on particle systems, see SCNParticleSystem.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1523123-addparticlesystem
     */

  }, {
    key: 'addParticleSystem',
    value: function addParticleSystem(system) {
      if (this._particleSystems === null) {
        this._particleSystems = [];
      }
      system.reset();
      this._particleSystems.push(system);
    }

    /**
     * Removes a particle system attached to the node.
     * @access public
     * @param {SCNParticleSystem} system - A particle system.
     * @returns {void}
     * @desc This method has no effect if the system parameter does not reference a particle system directly attached to the node.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1524014-removeparticlesystem
     */

  }, {
    key: 'removeParticleSystem',
    value: function removeParticleSystem(system) {
      if (this._particleSystems === null) {
        return;
      }
      var index = this._particleSystems.indexOf(system);
      this._particleSystems.splice(index, 1);
    }

    /**
     * Removes any particle systems directly attached to the node.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1522801-removeallparticlesystems
     */

  }, {
    key: 'removeAllParticleSystems',
    value: function removeAllParticleSystems() {
      this._particleSystems = [];
    }

    /**
     * The particle systems attached to the node.
     * @access public
     * @type {?SCNParticleSystem[]}
     * @desc An array of SCNParticleSystem objects directly attached to the node. This array does not include particle systems attached to the node's child nodes. For details on particle systems, see SCNParticleSystem.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1522705-particlesystems
     */

  }, {
    key: 'addAudioPlayer',


    // Working With Positional Audio

    /**
     * Adds the specified auto player to the node and begins playback.
     * @access public
     * @param {SCNAudioPlayer} player - An audio player object.
     * @returns {void}
     * @desc Positional audio effects from a player attached to a node are based on that node’s position relative to the audioListener position in the scene.After playback has completed, SceneKit automatically removes the audio player from the node.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1523464-addaudioplayer
     */
    value: function addAudioPlayer(player) {
      if (this._audioPlayers.indexOf(player) < 0) {
        this._audioPlayers.push(player);
        player._play();
      }
    }

    /**
     * Removes the specified audio player from the node, stopping playback.
     * @access public
     * @param {SCNAudioPlayer} player - An audio player attached to the node.
     * @returns {void}
     * @desc This method has no effect if the player parameter does not reference an audio player directly attached to the node.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1522767-removeaudioplayer
     */

  }, {
    key: 'removeAudioPlayer',
    value: function removeAudioPlayer(player) {
      var index = this._audioPlayers.indexOf(player);
      if (index >= 0) {
        player._stop();
        delete this._audioPlayers[index];
      }
    }

    /**
     * Removes all audio players attached to the node, stopping playback.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1523570-removeallaudioplayers
     */

  }, {
    key: 'removeAllAudioPlayers',
    value: function removeAllAudioPlayers() {
      this._audioPlayers.forEach(function (player) {
        player._stop();
      });
      this._audioPlayers = [];
    }

    /**
     * The audio players currently attached to the node.
     * @type {SCNAudioPlayer[]}
     * @desc Positional audio effects from a player attached to a node are based on that node’s position relative to the audioListener position in the scene.After an audio player completes playback, SceneKit automatically removes it from the node. Therefore, this array always contains audio players that are currently playing back audio.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1523244-audioplayers
     */

  }, {
    key: 'clone',


    // Copying a Node

    /**
     * Creates a copy of the node and its children.
     * @access public
     * @returns {SCNNode} - 
     * @desc This method recursively copies the node and its child nodes. For a nonrecursive copy, use the inherited copy() method, which creates a copy of the node without any child nodes.Cloning or copying a node creates a duplicate of the node object, but not the geometries, lights, cameras, and other SceneKit objects attached to it—instead, each copied node shares references to these objects.This behavior means that you can use cloning to, for example, place the same geometry at several locations within a scene without  maintaining multiple copies of the geometry and its materials. However, it also means that changes to the objects attached to one node will affect other nodes that share the same attachments. For example, to render two copies of a node using different materials, you must copy both the node and its geometry before assigning a new material.- (void)duplicateNode:(SCNNode *)node withMaterial:(SCNMaterial *)material
    {
      SCNNode *newNode = [node clone];
      newNode.geometry = [node.geometry copy];
      newNode.geometry.firstMaterial = material;
    }
    Multiple copies of an SCNGeometry object efficiently share the same vertex data, so you can copy geometries without a significant performance penalty.- (void)duplicateNode:(SCNNode *)node withMaterial:(SCNMaterial *)material
    {
      SCNNode *newNode = [node clone];
      newNode.geometry = [node.geometry copy];
      newNode.geometry.firstMaterial = material;
    }
      * @see https://developer.apple.com/documentation/scenekit/scnnode/1408046-clone
     */
    value: function clone() {
      var node = this.copy();

      this._childNodes.forEach(function (child) {
        node.addChildNode(child.clone());
      });

      return node;
    }

    /**
     * Creates an optimized copy of the node and its children.
     * @access public
     * @returns {SCNNode} - 
     * @desc Rendering complex node hierarchies can incur a performance cost. Each geometry and material requires a separate draw command to be sent to the GPU, and each draw command comes with a performance overhead. If you plan for a portion of your scene’s node hierarchy to remain static (with respect to itself, if not the rest of the scene), use this method to create a single node containing all elements of that node hierarchy that SceneKit can render using fewer draw commands.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407960-flattenedclone
     */

  }, {
    key: 'flattenedClone',
    value: function flattenedClone() {
      return null;
    }

    // Hit-Testing

    /**
     * Searches the node’s child node subtree for objects intersecting a line segment between two specified points.
     * @access public
     * @param {SCNVector3} pointA - An endpoint of the line segment to search along, specified in the node’s local coordinate system.
     * @param {SCNVector3} pointB - The other endpoint of the line segment to search along, specified in the node’s local coordinate system.
     * @param {?Map<string, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
     * @returns {SCNHitTestResult[]} - 
     * @desc Hit-testing is the process of finding elements of a scene located along a specified line segment in the scene’s coordinate space (or that of a particular node in the scene). For example, you can use this method to determine whether a projectile launched by a game character will hit its target.To search for the scene element corresponding to a two-dimensional point in the rendered image, use the renderer’s hitTest(_:options:) method instead.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407998-hittestwithsegment
     */

  }, {
    key: 'hitTestWithSegmentFromTo',
    value: function hitTestWithSegmentFromTo(pointA, pointB) {
      var _this5 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var worldPointA = this.convertPositionTo(pointA, null);
      var worldPointB = this.convertPositionTo(pointB, null);
      var results = [];
      this.enumerateChildNodes(function (child) {
        if (child.presentation.geometry) {
          var hits = _SCNPhysicsWorld2.default._hitTestWithSegmentNode(worldPointA, worldPointB, child.presentation);
          if (hits.length > 0) {
            // convert from the child's coordinate to this node's coordinate
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = hits[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var h = _step3.value;

                h._node = child;
                h._worldCoordinates = child.convertPositionTo(h._localCoordinates, null);
                h._worldNormal = child.convertPositionTo(h._localNormal, null);
                h._localCoordinates = _this5.convertPositionFrom(h._localCoordinates, child);
                h._localNormal = _this5.convertPositionFrom(h._localNormal, child);
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            results.push.apply(results, _toConsumableArray(hits));
          }
        }
      }
      // TODO: sort by the distance
      );if (results.length > 0) {
        console.error('hitTestWithSegmentFromTo: ' + results.length);
      }
      return results;
    }

    // Converting Between Node Coordinate Spaces

    /**
     * Converts a position to the node’s coordinate space from that defined by another node.
     * @access public
     * @param {SCNVector3} position - A position in the local coordinate space defined by the other node.
     * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert from the scene’s world coordinate space.
     * @returns {SCNVector3} - 
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408018-convertposition
     */

  }, {
    key: 'convertPositionFrom',
    value: function convertPositionFrom(position, node) {
      if (node === null) {
        return position.transform(this._worldTransform.invert());
      }
      return position.transform(node._worldTransform).transform(this._worldTransform.invert());
    }

    /**
     * Converts a position from the node’s coordinate space to that defined by another node.
     * @access public
     * @param {SCNVector3} position - A position in the node’s local coordinate space.
     * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert to the scene’s world coordinate space.
     * @returns {SCNVector3} - 
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407990-convertposition
     */

  }, {
    key: 'convertPositionTo',
    value: function convertPositionTo(position, node) {
      if (node === null) {
        return position.transform(this._worldTransform);
      }
      return position.transform(this._worldTransform).transform(node._worldTransform.invert());
    }

    /**
     * Converts a transformation to the node’s coordinate space from that defined by another node.
     * @access public
     * @param {SCNMatrix4} transform - A transformation relative to the local coordinate space defined by the other node.
     * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert from the scene’s world coordinate space.
     * @returns {SCNMatrix4} - 
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407996-converttransform
     */

  }, {
    key: 'convertTransformFrom',
    value: function convertTransformFrom(transform) {
      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (node === null) {
        return transform.mult(this._worldTransform.invert());
      }
      return transform.mult(node._worldTransform).mult(this._worldTransform.invert());
    }

    /**
     * Converts a transformation from the node’s coordinate space to that defined by another node.
     * @access public
     * @param {SCNMatrix4} transform - A transformation relative to the node’s coordinate space.
     * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert to the scene’s world coordinate space.
     * @returns {SCNMatrix4} - 
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407986-converttransform
     */

  }, {
    key: 'convertTransformTo',
    value: function convertTransformTo(transform) {
      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (node === null) {
        return transform.mult(this._worldTransform);
      }
      return transform.mult(this._worldTransform).mult(node._worldTransform.invert());
    }

    /**
     * 
     * @type {SCNVector3}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867392-worldfront
     */

  }, {
    key: 'convertVectorFrom',


    /**
     * 
     * @access public
     * @param {SCNVector3} vector - 
     * @param {?SCNNode} node - 
     * @returns {SCNVector3} - 
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867403-convertvector
     */
    value: function convertVectorFrom(vector, node) {}
    // TODO: implement


    /**
     * 
     * @access public
     * @param {SCNVector3} vector - 
     * @param {?SCNNode} node - 
     * @returns {SCNVector3} - 
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867397-convertvector
     */

  }, {
    key: 'convertVectorTo',
    value: function convertVectorTo(vector, node) {}
    // TODO: implement


    /**
     * 
     * @access public
     * @param {SCNQuaternion} rotation - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867398-localrotate
     */

  }, {
    key: 'localRotateBy',
    value: function localRotateBy(rotation) {}
    // TODO: implement


    /**
     * 
     * @access public
     * @param {SCNVector3} translation - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867383-localtranslate
     */

  }, {
    key: 'localTranslateBy',
    value: function localTranslateBy(translation) {}
    // TODO: implement


    /**
     * 
     * @access public
     * @param {SCNVector3} worldTarget - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867394-look
     */

  }, {
    key: 'lookAt',
    value: function lookAt(worldTarget) {}
    // TODO: implement


    /**
     * 
     * @access public
     * @param {SCNVector3} worldTarget - 
     * @param {SCNVector3} worldUp - 
     * @param {SCNVector3} localFront - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867396-look
     */

  }, {
    key: 'lookAtUp',
    value: function lookAtUp(worldTarget, worldUp, localFront) {}
    // TODO: implement


    /**
     * 
     * @access public
     * @param {SCNQuaternion} worldRotation - 
     * @param {SCNVector3} worldTarget - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867399-rotate
     */

  }, {
    key: 'rotateByAroundTarget',
    value: function rotateByAroundTarget(worldRotation, worldTarget) {}
    // TODO: implement


    /**
     * 
     * @access public
     * @param {SCNMatrix4} worldTransform - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867401-setworldtransform
     */

  }, {
    key: 'setWorldTransform',
    value: function setWorldTransform(worldTransform) {}
    // TODO: implement


    ///////////////////
    // SCNActionable //
    ///////////////////

    // Running Actions

    /**
     * Required. Adds an action to the list of actions executed by the node.
     * @access public
     * @param {SCNAction} action - The action to be performed.
     * @returns {void}
     * @desc SceneKit begins running a newly added action when it prepares to render the next frame.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523164-runaction
     */

  }, {
    key: 'runAction',
    value: function runAction(action) {
      this.runActionForKey(action, Symbol());
    }

    /**
     * Required. Adds an action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
     * @access public
     * @param {SCNAction} action - The action to be performed.
     * @param {?function(): void} [block = null] - A completion block that SceneKit calls when the action completes.
     * @returns {void}
     * @desc The new action is processed the next time SceneKit prepares to render a frame.SceneKit calls your block after the action’s duration is complete. For example, in a game you could use this method to show a Game Over message after performing a fade-out action on a node that displays a player character.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1524219-runaction
     */

  }, {
    key: 'runActionCompletionHandler',
    value: function runActionCompletionHandler(action) {
      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this.runActionForKeyCompletionHandler(action, Symbol(), block);
    }

    /**
     * Required. Adds an identifiable action to the list of actions executed by the node.
     * @access public
     * @param {SCNAction} action - The action to be performed.
     * @param {?string} key - A unique key used to identify the action.
     * @returns {void}
     * @desc This method is identical to runAction(_:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1524222-runaction
     */

  }, {
    key: 'runActionForKey',
    value: function runActionForKey(action, key) {
      this.runActionForKeyCompletionHandler(action, key, null);
    }

    /**
     * Required. Adds an identifiable action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
     * @access public
     * @param {SCNAction} action - The action to be performed.
     * @param {?string} key - A unique key used to identify the action.
     * @param {?function(): void} [block = null] - A completion block called when the action completes.
     * @returns {void}
     * @desc This method is identical to runAction(_:completionHandler:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.SceneKit calls your block after the action’s duration is complete. For example, you can use this method with a wait action to execute some code after a timed delay. If during the delay period you need to prevent the code from running, use the removeAction(forKey:) method to cancel it.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1522791-runaction
     */

  }, {
    key: 'runActionForKeyCompletionHandler',
    value: function runActionForKeyCompletionHandler(action, key) {
      var block = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (typeof key === 'undefined' || key === null) {
        key = Symbol();
      }
      var act = action.copy
      // FIXME: use current frame time
      ();act._actionStartTime = Date.now() * 0.001;
      act._completionHandler = block;
      this._actions.set(key, act
      //this._copyTransformToPresentationRecursive()
      );
    }

    // Inspecting a Node’s Running Actions

    /**
     * Required. Returns an action associated with a specific key.
     * @access public
     * @param {string} key - A string that uniquely identifies a action.
     * @returns {?SCNAction} - 
     * @desc Use this method to retrieve actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523287-action
     */

  }, {
    key: 'actionForKey',
    value: function actionForKey(key) {
      return this._actions.get(key);
    }

    /**
     * Required. A Boolean value that indicates whether the node is currently executing any actions.
     * @type {boolean}
     * @desc This value is true if the node has any executing actions; otherwise the value is false.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523794-hasactions
     */

  }, {
    key: 'removeActionForKey',


    // Canceling a Node’s Running Actions

    /**
     * Required. Removes an action associated with a specific key.
     * @access public
     * @param {string} key - A string that uniquely identifies a action.
     * @returns {void}
     * @desc If the node is currently running an action that matches the key, SceneKit removes that action from the node, skipping any remaining animation it would perform but keeping any changes already made to the node.Use this method to cancel actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523617-removeaction
     */
    value: function removeActionForKey(key) {
      // TODO: stop action
      this._actions.delete(key);
    }

    /**
     * Required. Ends and removes all actions from the node.
     * @access public
     * @returns {void}
     * @desc When SceneKit removes an action from a node, it skips any remaining animation the action would perform. However, any changes the action has already made to the node’s state remain in effect.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1524181-removeallactions
     */

  }, {
    key: 'removeAllActions',
    value: function removeAllActions() {
      // TODO: stop actions
      this._actions.clear();
    }

    ///////////////////
    // SCNAnimatable //
    ///////////////////

    // Managing Animations

    /**
     * Required. Adds an animation object for the specified key.
     * @access public
     * @param {CAAnimation} animation - The animation object to be added.
     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
     * @returns {void}
     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation
     */

  }, {
    key: 'addAnimationForKey',
    value: function addAnimationForKey(animation, key) {
      if (typeof key === 'undefined' || key === null) {
        key = Symbol();
      }
      //const anim = animation.copy()
      var anim = animation;

      // FIXME: use current frame time
      anim._animationStartTime = Date.now() * 0.001;

      this._animations.set(key, anim);
      this._copyTransformToPresentationRecursive();
    }

    /**
     * @access private
     * @param {CAAnimation} animatino -
     * @param {number} time -
     * @returns {void}
     */
    /*
    _setAnimationStartTime(animation, time) {
      animation._animationStartTime = time
      animation._prevTime = time - 0.0000001
      if(animation instanceof CAAnimationGroup){
        animation.animations.forEach((anim) => {
          this._setAnimationStartTime(anim, time)
        })
      }
    }
    */

    /**
     * Required. Returns the animation with the specified key.
     * @access public
     * @param {string} key - A string identifying a previously added animation.
     * @returns {?CAAnimation} - 
     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation
     */

  }, {
    key: 'animationForKey',
    value: function animationForKey(key) {
      return this._animations.get(key);
    }

    /**
     * Required. Removes all the animations currently attached to the object.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations
     */

  }, {
    key: 'removeAllAnimations',
    value: function removeAllAnimations() {
      // TODO: stop animations
      this._animations.clear();
    }

    /**
     * Required. Removes the animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation to remove.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation
     */

  }, {
    key: 'removeAnimationForKey',
    value: function removeAnimationForKey(key) {
      this.removeAnimationForKeyBlendOutDuration(key, 0);
    }

    /**
     *
     * @access public
     * @param {string} key -
     * @param {number} duration -
     * @returns {void}
     */

  }, {
    key: 'removeAnimationForKeyBlendOutDuration',
    value: function removeAnimationForKeyBlendOutDuration(key, duration) {
      // FIXME: use duration
      this._animations.delete(key);
      this._copyTransformToPresentationRecursive();
    }

    /**
     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
     * @access public
     * @param {string} key - A string identifying an attached animation to remove.
     * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
     * @returns {void}
     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation
     */

  }, {
    key: 'removeAnimationForKeyFadeOutDuration',
    value: function removeAnimationForKeyFadeOutDuration(key, duration) {
      // FIXME: use fadeout duration
      this.removeAnimationForKey(key);
    }

    /**
     * Required. An array containing the keys of all animations currently attached to the object.
     * @type {string[]}
     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys
     */

  }, {
    key: 'pauseAnimationForKey',


    // Pausing and Resuming Animations

    /**
     * Required. Pauses the animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {void}
     * @desc This method has no effect if no animation is attached to the object with the specified key.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation
     */
    value: function pauseAnimationForKey(key) {}

    /**
     * Required. Resumes a previously paused animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {void}
     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation
     */

  }, {
    key: 'resumeAnimationForKey',
    value: function resumeAnimationForKey(key) {}

    /**
     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused
     */

  }, {
    key: 'isAnimationPausedForKey',
    value: function isAnimationPausedForKey(key) {
      return false;
    }

    // Instance Methods

    /**
     * Required. 
     * @access public
     * @param {number} speed - 
     * @param {string} key - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed
     */

  }, {
    key: 'setAnimationSpeedForKey',
    value: function setAnimationSpeedForKey(speed, key) {}
  }, {
    key: '_setAnimationsToPlayers',
    value: function _setAnimationsToPlayers() {
      var len = this._animationPlayers._values.length;
      if (len > 0 && this._animations._values.length > 0) {
        for (var i = 0; i < len; i++) {
          this._animationPlayers._values[i]._animation = this._animations._values[i];
        }
      }
    }

    /**
     *
     * @access public
     * @param {SCNAnimationPlayer} player -
     * @param {?string} key -
     * @returns {void}
     */

  }, {
    key: 'addAnimationPlayerForKey',
    value: function addAnimationPlayerForKey(player, key) {
      if (typeof key === 'undefined' || key === null) {
        key = Symbol();
      }

      this._animationPlayers.set(key, player);
      this._copyTransformToPresentationRecursive();
    }

    /**
     * 
     * @access public
     * @param {string} key -
     * @returns {SCNAnimationPlayer} -
     */

  }, {
    key: 'animationPlayerForKey',
    value: function animationPlayerForKey(key) {
      return this._animationPlayers.get(key);
    }

    ///////////////////////
    // SCNBoundingVolume //
    ///////////////////////

    // Working with Bounding Volumes

    /**
     * The minimum and maximum corner points of the object’s bounding box.
     * @type {{min: SCNVector3, max: SCNVector3}}
     * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034705-boundingbox
     */

  }, {
    key: '_geometryBoundingBox',
    value: function _geometryBoundingBox() {
      if (this._geometry === null) {
        return {
          min: new _SCNVector2.default(Infinity, Infinity, Infinity),
          max: new _SCNVector2.default(-Infinity, -Infinity, -Infinity)
        };
      }
      var boundingBox = this._geometry.boundingBox;
      // FIXME: rotate and scale
      if (this.skinner && this.skinner.baseGeometryBindTransform) {
        var tx = this.skinner.baseGeometryBindTransform.m41;
        var ty = this.skinner.baseGeometryBindTransform.m42;
        var tz = this.skinner.baseGeometryBindTransform.m43;
        boundingBox.min.x += tx;
        boundingBox.min.y += ty;
        boundingBox.min.z += tz;
        boundingBox.max.x += tx;
        boundingBox.max.y += ty;
        boundingBox.max.z += tz;
      }

      //return this._geometry.boundingBox
      //return this._geometry._updateBoundingBoxForSkinner(this.skinner)
      return boundingBox;
    }
  }, {
    key: '_updateBoundingBox',
    value: function _updateBoundingBox() {
      // FIXME: use rotation of the node
      var box = this._geometryBoundingBox();
      var p = this._presentation ? this._presentation : this;
      if (p.geometry !== null) {
        if (box === null) {
          box = p.geometry._updateBoundingBox();
        }
        box = this._unionBoundingBox(box, p.geometry.boundingBox);
      }
      var scale = p._scale;
      if (scale.x < 0) {
        var minX = box.max.x * scale.x;
        var maxX = box.min.x * scale.x;
        box.min.x = minX;
        box.max.x = maxX;
      } else {
        box.min.x *= scale.x;
        box.max.x *= scale.x;
      }
      if (scale.y < 0) {
        var minY = box.max.y * scale.y;
        var maxY = box.min.y * scale.y;
        box.min.y = minY;
        box.max.y = maxY;
      } else {
        box.min.y *= scale.y;
        box.max.y *= scale.y;
      }
      if (scale.z < 0) {
        var minZ = box.max.z * scale.z;
        var maxZ = box.min.z * scale.z;
        box.min.z = minZ;
        box.max.z = maxZ;
      } else {
        box.min.z *= scale.z;
        box.max.z *= scale.z;
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._childNodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var child = _step4.value;

          var cbox = child._updateBoundingBox();
          box = this._unionChildBoundingBox(box, cbox);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this._boundingBox = box;
      return box;
    }
  }, {
    key: '_unionBoundingBox',
    value: function _unionBoundingBox(box1, box2) {
      if (box1 === null) {
        return box2;
      }
      if (box2 === null) {
        return box1;
      }
      var min = new _SCNVector2.default();
      var max = new _SCNVector2.default();
      min.x = Math.min(box1.min.x, box2.min.x);
      min.y = Math.min(box1.min.y, box2.min.y);
      min.z = Math.min(box1.min.z, box2.min.z);
      max.x = Math.max(box1.max.x, box2.max.x);
      max.y = Math.max(box1.max.y, box2.max.y);
      max.z = Math.max(box1.max.z, box2.max.z);
      return { min: min, max: max };
    }
  }, {
    key: '_unionChildBoundingBox',
    value: function _unionChildBoundingBox(box, cbox) {
      var p = this._presentation ? this._presentation : this;
      var pos = p._position;
      var scale = p._scale;
      var min = new _SCNVector2.default((cbox.min.x + pos.x) * scale.x, (cbox.min.y + pos.y) * scale.y, (cbox.min.z + pos.z) * scale.z);
      var max = new _SCNVector2.default((cbox.max.x + pos.x) * scale.x, (cbox.max.y + pos.y) * scale.y, (cbox.max.z + pos.z) * scale.z);
      return this._unionBoundingBox(box, { min: min, max: max });
    }
  }, {
    key: '_updateTransform',
    value: function _updateTransform() {
      var m1 = _SCNMatrix2.default.matrixWithScale(this._scale);
      var m2 = m1.rotation(this._rotation);
      var m3 = m2.translation(this._position);
      this._transform = m3;
      this._transformUpToDate = true;
    }

    /**
     *
     * @access public
     * @returns {SCNNode} -
     */

  }, {
    key: 'copy',
    value: function copy() {
      var node = new SCNNode();
      node.name = this.name;
      node.light = this.light;
      node.camera = this.camera;
      node._geometry = this._geometry;
      node.morpher = this.morpher;
      node.skinner = this.skinner;
      node.categoryBitMask = this.categoryBitMask;
      node.isPaused = this.isPaused;
      node._presentation = this._presentation ? this._presentation.copy() : null;
      node._isPresentationInstance = this._isPresentationInstance;
      node.constraints = this.constraints ? this.constraints.slice(0) : null;
      node.isHidden = this.isHidden;
      node._opacity = this._opacity;
      node.renderingOrder = this.renderingOrder;
      node.castsShadow = this.castsShadow;
      node.movabilityHint = this.movabilityHint;
      node.filters = this.filters ? this.filters.slice() : null;
      node.rendererDelegate = this.rendererDelegate;
      node._physicsBody = this._physicsBody; // FIXME: copy
      node.physicsField = this.physicsField;
      node._particleSystems = this._particleSystems ? this._particleSystems.slice(0) : null;
      node._audioPlayers = this._audioPlayers;
      //node._hasActions = this._hasActions
      node._actions = new Map(this._actions);
      node._animations = this._animations.copy();
      node._boundingBox = this._boundingBox;
      //node._boundingSphere = this._boundingSphere

      node._position = new _SCNVector2.default(this._position.x, this._position.y, this._position.z);
      node._rotation = new _SCNVector4.default(this._rotation.x, this._rotation.y, this._rotation.z, this._rotation.w);
      node._scale = new _SCNVector2.default(this._scale.x, this._scale.y, this._scale.z);
      node._transformUpToDate = false;

      return node;
    }
  }, {
    key: '_copyTransformToPresentation',
    value: function _copyTransformToPresentation() {
      if (this._presentation === null) {
        return;
      }
      var p = this._presentation;
      p._position = this._position._copy();
      p._rotation = this._rotation._copy();
      p._scale = this._scale._copy();
    }
  }, {
    key: '_copyTransformToPresentationRecursive',
    value: function _copyTransformToPresentationRecursive() {
      var nodes = [this];
      while (nodes.length > 0) {
        var node = nodes.shift();
        node._copyTransformToPresentation();
        nodes.push.apply(nodes, _toConsumableArray(node._childNodes));
      }
    }
  }, {
    key: '_copyMaterialPropertiesToPresentation',
    value: function _copyMaterialPropertiesToPresentation() {
      var p = this._presentation;
      if (this._geometry) {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = this._geometry.materials[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var material = _step5.value;

            material._copyPresentationProperties();
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }
      p.opacity = this.opacity;
    }
  }, {
    key: 'valueForUndefinedKey',


    /**
     * Invoked by value(forKey:) when it finds no property corresponding to a given key.
     * @access public
     * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
     * @returns {?Object} - 
     * @desc Subclasses can override this method to return an alternate value for undefined keys. The default implementation raises an NSUndefinedKeyException.
     * @see https://developer.apple.com/documentation/objectivec/nsobject/1413457-value
     */
    value: function valueForUndefinedKey(key) {
      if (key.charAt(0) === '/') {
        var nodeID = key.substr(1);
        if (this._nodeID === nodeID) {
          return this;
        }
        var node = this._childNodeWithNodeIDRecursively(nodeID);
        if (node) {
          return node;
        }
        node = this.childNodeWithNameRecursively(nodeID);
        if (node) {
          return node;
        }
        var rootNode = this._rootNode;
        if (rootNode !== this) {
          node = rootNode._childNodeWithNodeIDRecursively(nodeID);
          if (node) {
            return node;
          }
          node = rootNode.childNodeWithNameRecursively(nodeID);
          if (node) {
            return node;
          }
        }
      }
      return _get(SCNNode.prototype.__proto__ || Object.getPrototypeOf(SCNNode.prototype), 'valueForUndefinedKey', this).call(this, key);
    }
  }, {
    key: 'valueForKeyPath',
    value: function valueForKeyPath(keyPath) {
      var usePresentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var target = usePresentation && this._presentation ? this._presentation : this;
      var paths = keyPath.split('.');
      var key = paths[0];
      var key2 = paths[1];

      if (key === 'position') {
        if (key2) {
          return target.position[key2];
        }
        return target.position;
      } else if (key === 'rotation') {
        if (key2) {
          return target.rotation[key2];
        }
        return target.rotation;
      } else if (key === 'scale') {
        if (key2) {
          return target.scale[key2];
        }
        return target.scale;
      } else if (key === 'eulerAngles') {
        if (key2) {
          return target.eulerAngles[key2];
        }
        return target.eulerAngles;
      } else if (key === 'orientation') {
        if (key2) {
          return target.orientation[key2];
        }
        return target.orientation;
      } else if (key === 'transform') {
        if (key2) {
          return target.transform[key2];
        }
        return target.transform;
      }
      return _get(SCNNode.prototype.__proto__ || Object.getPrototypeOf(SCNNode.prototype), 'valueForKeyPath', this).call(this, keyPath, usePresentation);
    }
  }, {
    key: 'setValueForKey',
    value: function setValueForKey(value, key) {
      // FIXME: check flags to decide to use a presentation node
      var target = this._presentation ? this._presentation : this;

      if (key === 'position') {
        target.position = value;
      } else if (key === 'rotation') {
        target.rotation = value;
      } else if (key === 'scale') {
        target.scale = value;
      } else if (key === 'eulerAngles') {
        target.eulerAngles = value;
      } else if (key === 'orientation') {
        target.orientation = value;
      } else if (key === 'transform') {
        target.transform = value;
      } else {
        _get(SCNNode.prototype.__proto__ || Object.getPrototypeOf(SCNNode.prototype), 'setValueForKey', this).call(this, value, key);
      }
    }
  }, {
    key: 'setValueForKeyPath',
    value: function setValueForKeyPath(value, keyPath) {
      var target = this._presentation ? this._presentation : this;

      var paths = keyPath.split('.');
      var key = paths.shift();
      var restPath = paths.join('.'
      //console.log(`SCNNode setValueForKeyPath ${this.name} ${key} ${restPath}`)
      );if (key === 'transform') {
        switch (restPath) {
          case 'rotation.x':
            target._rotation.x = value;
            target._transformUpToDate = false;
            return;
          case 'rotation.y':
            target._rotation.y = value;
            target._transformUpToDate = false;
            return;
          case 'rotation.z':
            target._rotation.z = value;
            target._transformUpToDate = false;
            return;
          case 'rotation':
            target._rotation.z = value;
            target._transformUpToDate = false;
            return;
          case 'quaternion':
            target.orientation = value;
            target._transformUpToDate = false;
            return;
          case 'scale.x':
            target._scale.x = value;
            target._transformUpToDate = false;
            return;
          case 'scale.y':
            target._scale.y = value;
            target._transformUpToDate = false;
            return;
          case 'scale.z':
            target._scale.z = value;
            target._transformUpToDate = false;
            return;
          case 'scale':
            {
              target._scale.x = value.x;
              target._scale.y = value.y;
              target._scale.z = value.z;
              target._transformUpToDate = false;
              return;
            }
          case 'translation.x':
            target._position.x = value;
            target._transformUpToDate = false;
            return;
          case 'translation.y':
            target._position.y = value;
            target._transformUpToDate = false;
            return;
          case 'translation.z':
            target._position.z = value;
            target._transformUpToDate = false;
            return;
          case 'translation':
            target._position.x = value.x;
            target._position.y = value.y;
            target._transformUpToDate = false;
            return;
          default:
          // do nothing
        }
      } else if (key === 'position') {
        if (restPath !== '') {
          target._position[restPath] = value;
        } else {
          target._position = value;
        }
        return;
      } else if (key === 'rotation') {
        if (restPath !== '') {
          target._rotation[restPath] = value;
        } else {
          target._rotation = value;
        }
        return;
      } else if (key === 'orientation') {
        if (restPath !== '') {
          var v = target.orientation;
          v[restPath] = value;
          target.orientation = v;
        } else {
          target.orientation = value;
        }
        return;
      } else if (key === 'eulerAngles') {
        if (restPath !== '') {
          var _v = target.eulerAngles;
          _v[restPath] = value;
          target.eulerAngles = _v;
        } else {
          target.eulerAngles = value;
        }
        return;
      } else if (key === 'scale') {
        if (restPath !== '') {
          target._scale[restPath] = value;
        } else {
          target._scale = value;
        }
        return;
      } else if (key === 'morpher') {
        if (target.morpher === null) {
          throw new Error('target morpher === null');
        }
        target.morpher.setValueForKeyPath(value, restPath);
        return;
      }
      // TODO: add other properties

      _get(SCNNode.prototype.__proto__ || Object.getPrototypeOf(SCNNode.prototype), 'setValueForKeyPath', this).call(this, value, keyPath);
    }

    /**
     * @access private
     * @returns {Ammo.btTransform} -
     * @desc call Ammo.destroy(transform) after using it.
     */

  }, {
    key: '_createBtTransform',
    value: function _createBtTransform() {
      //const transform = new Ammo.btTransform()
      //const pos = this.position.createBtVector3()
      //const rot = this.orientation.craeteBtQuaternion()
      //transform.setIdentity()
      //transform.setOrigin(pos)
      //transform.setRotation(rot)
      //Ammo.destroy(pos)
      //Ammo.destroy(rot)
      //return transform
    }
  }, {
    key: '_createBtCollisionShape',
    value: function _createBtCollisionShape() {
      //if(this._geometry === null){
      //  throw new Error('geometry is null')
      //}
      //return this._geometry._createBtCollisionShape()
    }
  }, {
    key: 'destory',
    value: function destory() {}
    //if(this.physicsBody !== null){
    //  this.physicsBody.destory()
    //  this.physicsBody = null
    //}
    //if(this._geometry !== null){
    //  // the geometry might be shared with other nodes...
    //  //this.geometry.destroy()
    //}


    /**
     * @access private
     * @returns {void}
     */

  }, {
    key: '_resetPromise',
    value: function _resetPromise() {
      this._loadedPromise = null;
    }

    /**
     * @access private
     * @returns {void}
     */

  }, {
    key: '_resetPromiseRecursively',
    value: function _resetPromiseRecursively() {
      this._resetPromise();
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this._childNodes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var child = _step6.value;

          child._resetPromiseRecursively();
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }

    /**
     * @access private
     * @returns {Promise} -
     */

  }, {
    key: '_getLoadedPromise',
    value: function _getLoadedPromise() {
      if (this._loadedPromise) {
        return this._loadedPromise;
      }

      var promises = [];
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this._childNodes[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var child = _step7.value;

          promises.push(child.didLoad);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      if (this._particleSystems) {
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = this._particleSystems[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var system = _step8.value;

            promises.push(system.didLoad);
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
      if (this._geometry) {
        promises.push(this._geometry.didLoad);
      }
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = this._audioPlayers[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var player = _step9.value;

          promises.push(player.didLoad);
        }
        //this._loadedPromise = Promise.all(promises)
        //return this._loadedPromise
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9.return) {
            _iterator9.return();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      return Promise.all(promises);
    }

    /**
     * @access public
     * @returns {Promise} -
     */

  }, {
    key: 'geometry',


    // Managing Node Attributes
    get: function get() {
      return this._geometry;
    },
    set: function set(newValue) {
      this._geometry = newValue;
      this._updateBoundingBox();
    }

    // Working With Node Animation

    /**
     * A node object representing the state of the node as it currently appears onscreen.
     * @type {SCNNode}
     * @desc When you use implicit animation (see SCNTransaction) to change a node’s properties, those node properties are set immediately to their target values, even though the animated node content appears to transition from the old property values to the new. During the animation SceneKit maintains a copy of the node, called the presentation node, whose properties reflect the transitory values determined by any in-flight animations currently affecting the node. The presentation node’s properties provide a close approximation to the version of the node that is currently displayed. SceneKit also uses the presentation node when computing the results of explicit animations, physics, and constraints.Do not modify the properties of the presentation node. (Attempting to do so results in undefined behavior.) Instead, you use the presentation node to read current animation values—for example, to create a new animation starting at those values. The presentation node has no parent or child nodes. To access animated properties of related nodes, use the node’s own parent and childNodes properties and the presentation property of each related node.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408030-presentation
     */

  }, {
    key: 'presentation',
    get: function get() {
      if (this._presentation === null && !this._isPresentationInstance) {
        this._createPresentation();
      }

      return this._presentation;
    }
  }, {
    key: 'transform',
    get: function get() {
      // FIXME: it should return the copy of _transform,
      //        but you should be able to change value with this statement:
      //          let node = new SCNNode()
      //          node.transform.m14 = 123
      //          console.log(node.transform.m14)   // '123'
      if (!this._transformUpToDate) {
        this._updateTransform();
      }
      return this._transform;
    },
    set: function set(newValue) {
      this._transform = newValue;
      this._position = this._transform.getTranslation();
      this._rotation = this._transform.getRotation();
      this._scale = this._transform.getScale();
      this._transformUpToDate = true;
    }

    /**
     * The world transform applied to the node.
     * @type {SCNMatrix4}
     * @desc A world transform is the node’s coordinate space transformation relative to the scene’s coordinate space. This transformation is the concatenation of the node’s transform property with that of its parent node, the parent’s parent, and so on up to the rootNode object of the scene.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407970-worldtransform
     */

  }, {
    key: 'worldTransform',
    get: function get() {
      /*
      if(this._parent === null){
        if(this._isPresentationInstance){
          return this._worldTransform
        }
        return this.transform
      }
      return this.transform.mult(this._parent.worldTransform)
      */
      return this._worldTransform;
    }
  }, {
    key: 'position',
    get: function get() {
      return this._position;
    },
    set: function set(newValue) {
      if (typeof newValue.x !== 'number' || typeof newValue.y !== 'number' || typeof newValue.z !== 'number') {
        throw new Error('error: SCNNode.position must have x, y, z values');
      }
      this._position.x = newValue.x;
      this._position.y = newValue.y;
      this._position.z = newValue.z;
      this._transformUpToDate = false;
      this._updateWorldTransform();
    }
  }, {
    key: 'rotation',
    get: function get() {
      return this._rotation;
    },
    set: function set(newValue) {
      if (typeof newValue.x !== 'number' || typeof newValue.y !== 'number' || typeof newValue.z !== 'number' || typeof newValue.w !== 'number') {
        throw new Error('error: SCNNode.rotation must have x, y, z, w values');
      }
      var oldValue = this._rotation._copy();
      this._rotation.x = newValue.x;
      this._rotation.y = newValue.y;
      this._rotation.z = newValue.z;
      this._rotation.w = newValue.w;
      this._transformUpToDate = false;
      this._updateWorldTransform();
      _SCNTransaction2.default._addChange(this, 'rotation', oldValue, newValue);
    }
  }, {
    key: 'scale',
    get: function get() {
      return this._scale;
    },
    set: function set(newValue) {
      if (typeof newValue.x !== 'number' || typeof newValue.y !== 'number' || typeof newValue.z !== 'number') {
        throw new Error('error: SCNNode.scale must have x, y, z values');
      }
      this._scale.x = newValue.x;
      this._scale.y = newValue.y;
      this._scale.z = newValue.z;
      this._transformUpToDate = false;
      this._updateWorldTransform();
    }

    /**
     * The node’s orientation, expressed as pitch, yaw, and roll angles, each in radians. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407980-eulerangles
     */

  }, {
    key: 'eulerAngles',
    get: function get() {
      /*
      const rot = this._rotation
      const euler = new SCNVector3()
      const sinW = Math.sin(rot.w)
      const cosWR = 1.0 - Math.cos(rot.w)
      const len2 = rot.x * rot.x + rot.y * rot.y + rot.z * rot.z
      if(len2 === 0){
        return euler
      }
      const r = 1.0 / Math.sqrt(len2)
      const x = rot.x * r
      const y = rot.y * r
      const z = rot.z * r
      const s = y * sinW - x * z * cosWR
       if(s > 0.998){
        // TODO: check SceneKit implementation
        euler.x = 0
        euler.y = -Math.PI * 0.5
        euler.z = -2.0 * Math.atan2(z * Math.sin(rot.w * 0.5), Math.cos(rot.w * 0.5))
      }else if(s < -0.998){
        // TODO: check SceneKit implementation
        euler.x = 0
        euler.y = Math.PI * 0.5
        euler.z = 2.0 * Math.atan2(z * Math.sin(rot.w * 0.5), Math.cos(rot.w * 0.5))
      }else{
        euler.x = Math.atan2(x * sinW + y * z * cosWR, 1 - (y * y + x * x) * cosWR)
        euler.y = Math.asin(s)
        euler.z = Math.atan2(z * sinW + x * y * cosWR, 1 - (z * z + y * y) * cosWR)
      }
       return euler
      */
      return this._rotation.rotationToEulerAngles();
    },
    set: function set(newValue) {
      this._rotation = newValue.eulerAnglesToRotation();
      this._transformUpToDate = false;
    }

    /**
     * The node’s orientation, expressed as a quaternion. Animatable.
     * @type {SCNQuaternion}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408048-orientation
     */

  }, {
    key: 'orientation',
    get: function get() {
      return this._rotation.rotationToQuat();
    },
    set: function set(newValue) {
      if (!(0, _InstanceOf3.default)(newValue, _SCNVector4.default)) {
        throw new Error('orientation must be SCNVector4');
      }

      this._rotation = newValue.quatToRotation();
      this._transformUpToDate = false;
    }

    /**
     * @access private
     * @returns {SCNVector4} -
     */

  }, {
    key: '_presentationWorldOrientation',
    get: function get() {
      if (this._parent === null) {
        return this.presentation.orientation;
      }
      return this._parent._presentationWorldOrientation.cross(this.presentation.orientation);
    }

    /**
     * @access private
     * @returns {SCNVector4} -
     */

  }, {
    key: '_worldOrientation',
    get: function get() {
      if (this._parent === null) {
        return this.orientation;
      }
      return this._parent._worldOrientation.cross(this.orientation);
    }

    /**
     * @access private
     * @returns {SCNVector4} -
     */

  }, {
    key: '_worldRotation',
    get: function get() {
      return this._worldOrientation.quatToRotation();
    }

    /**
     * @access private
     * @returns {SCNVector3} -
     */

  }, {
    key: '_presentationWorldTranslation',
    get: function get() {
      return this.presentation.worldTransform.getTranslation();
    }

    /**
     * @access private
     * @returns {SCNVector3} -
     */

  }, {
    key: '_worldTranslation',
    get: function get() {
      return this.worldTransform.getTranslation();
    }
  }, {
    key: 'worldPosition',
    get: function get() {
      return this.worldTransform.getTranslation();
    },
    set: function set(newValue) {
      var parentTransform = null;
      if (this._parent === null) {
        parentTransform = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);
      } else {
        parentTransform = this._parent.worldTransform;
      }
      var transform = (0, _SCNMatrix4MakeTranslation2.default)(newValue.x, newValue.y, newValue.z);
      var inv = parentTransform.invert();
      var newTransform = transform.mult(inv);

      this._transform.m41 = newTransform.m41;
      this._transform.m42 = newTransform.m42;
      this._transform.m43 = newTransform.m43;
      this.transform = this._transform;
    }

    /**
     * @access private
     * @returns {SCNVector3} -
     */

  }, {
    key: '_worldScale',
    get: function get() {}

    /**
     * The opacity value of the node. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1408010-opacity
     */

  }, {
    key: 'opacity',
    get: function get() {
      return this._opacity;
    },
    set: function set(newValue) {
      var oldValue = this._opacity;
      this._opacity = newValue;
      _SCNTransaction2.default._addChange(this, '_opacity', oldValue, newValue);
    }
  }, {
    key: '_rootNode',
    get: function get() {
      if (this._parent === null) {
        return this;
      }
      return this._parent._rootNode;
    }

    /**
     * The node’s parent in the scene graph hierarchy.
     * @type {?SCNNode}
     * @desc For a scene’s rootNode object, the value of this property is nil.
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407968-parent
     */

  }, {
    key: 'parent',
    get: function get() {
      return this._parent;
    }
    /**
     * An array of the node’s children in the scene graph hierarchy.
     * @type {SCNNode[]}
     * @see https://developer.apple.com/documentation/scenekit/scnnode/1407984-childnodes
     */

  }, {
    key: 'childNodes',
    get: function get() {
      return this._childNodes.slice(0);
    }
  }, {
    key: 'physicsBody',
    get: function get() {
      return this._physicsBody;
    },
    set: function set(newValue) {
      if (this._physicsBody) {
        this._physicsBody._node = null;
      }
      this._physicsBody = newValue;
      if (this._physicsBody) {
        this._physicsBody._node = this;
        this._physicsBody.resetTransform();
      }
    }
  }, {
    key: 'particleSystems',
    get: function get() {
      return this._particleSystems;
    }
  }, {
    key: 'audioPlayers',
    get: function get() {
      return this._audioPlayers.slice(0);
    }
  }, {
    key: 'worldFront',
    get: function get() {
      return _localFront.rotate(this.worldTransform);
    }

    /**
     * 
     * @type {SCNVector3}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867404-worldright
     */

  }, {
    key: 'worldRight',
    get: function get() {
      return _localRight.rotate(this.worldTransform);
    }

    /**
     * 
     * @type {SCNVector3}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867395-worldup
     */

  }, {
    key: 'worldUp',
    get: function get() {
      return _localUp.rotate(this.worldTransform);
    }

    /**
     * 
     * @type {SCNVector3}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867393-localfront
     */

  }, {
    key: 'hasActions',
    get: function get() {
      return this._actions.size > 0;
    }

    /**
     * Required. The list of keys for which the node has attached actions.
     * @type {string[]}
     * @desc Use this property to list actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523036-actionkeys
     */

  }, {
    key: 'actionKeys',
    get: function get() {
      var keys = [];
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = this._actions.keys()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var key = _step10.value;

          keys.push(key);
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10.return) {
            _iterator10.return();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }

      return keys;
    }
  }, {
    key: 'animationKeys',
    get: function get() {
      var keys = [];
      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = this._animations.keys()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var key = _step11.value;

          keys.push(key);
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11.return) {
            _iterator11.return();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }

      return keys;
    }
  }, {
    key: 'boundingBox',
    get: function get() {
      if (this._fixedBoundingBox) {
        return this._fixedBoundingBox;
      }
      this._updateBoundingBox();
      return this._boundingBox;
    },
    set: function set(newValue) {
      this._fixedBoundingBox = newValue;
    }

    /**
     * The center point and radius of the object’s bounding sphere.
     * @type {{center: SCNVector3, radius: number}}
     * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a node’s bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of node’s geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
     * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034707-boundingsphere
     */

  }, {
    key: 'boundingSphere',
    get: function get() {
      // TODO: calculate bounding sphere
      return { center: new _SCNVector2.default(), radius: 0 };
    }
  }, {
    key: 'viewTransform',
    get: function get() {
      return this.worldTransform.invert();
    }
  }, {
    key: 'projectionTransform',
    get: function get() {
      if (this.camera === null) {
        return null;
      }
      return this.camera.projectionTransform;
    }
  }, {
    key: 'viewProjectionTransform',
    get: function get() {
      if (this.camera === null) {
        return null;
      }
      var proj = this.camera.projectionTransform;
      var view = this.viewTransform;
      return view.mult(proj);
    }
  }, {
    key: 'lightViewProjectionTransform',
    get: function get() {
      if (this.light === null) {
        return null;
      }
      this.light._updateProjectionTransform();
      var proj = this.light._projectionTransform;
      var view = this.viewTransform;
      return view.mult(proj);
    }
  }, {
    key: 'shadowProjectionTransform',
    get: function get() {
      if (this.light === null) {
        return null;
      }
      var vp = this.lightViewProjectionTransform;
      var scale = (0, _SCNMatrix4MakeTranslation2.default)(1.0, 1.0, 0.0).scale(0.5, 0.5, 1.0 // [-1, 1] => [0, 1]
      );return vp.mult(scale);
    }
  }, {
    key: 'didLoad',
    get: function get() {
      return this._getLoadedPromise();
    }
  }], [{
    key: '_loadAnimationArray',
    value: function _loadAnimationArray(node, animations) {
      //console.log('_loadAnimationArray start')
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = Object.keys(animations)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var animName = _step12.value;

          var data = animations[animName];
          var animation = this._loadAnimationData(data, animName);
          node.addAnimationForKey(animation, animName);
        }
        //console.log('_loadAnimationArray done')
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }
    }
  }, {
    key: '_loadAnimationData',
    value: function _loadAnimationData(data, key) {
      //console.log(`_loadAnimationData ${key} start`)
      if (data.class === 'group') {
        return this._loadAnimationGroup(data);
      } else if (data.class === 'keyframe') {
        return this._loadKeyframeAnimation(data.animation, key);
      } else if (data.class === 'basic') {
        var keyPath = data.keyPath || key;
        return this._loadBasicAnimation(data.animation, keyPath);
      } else if (data.type === 'keyframedAnimation') {
        return this._loadKeyframeAnimation(data, key);
      }

      //console.error(`unknown animation class: ${data.class}, type: ${data.type}, key: ${key}`)
      throw new Error('unknown animation class: ' + data.class + ', type: ' + data.type + ', key: ' + key);
    }
  }, {
    key: '_loadAnimationGroup',
    value: function _loadAnimationGroup(animation) {
      var _this6 = this;

      //console.log('_loadAnimationGroup start')
      var group = new _CAAnimationGroup2.default();
      var data = animation.animation;
      group.isRemovedOnCompletion = Boolean(animation.removeOnCompletion
      // group.timingFunction
      // group.delegate
      );group.usesSceneTimeBase = Boolean(animation.usesSceneTimeBase);
      group.fadeInDuration = data.fadeInDuration;
      group.fadeOutDuration = data.fadeOutDuration;
      group.beginTime = data.beginTime;
      group.timeOffset = data.timeOffset;
      group.repeatCount = data.repeatCount;
      // group.repeatDuration
      group.duration = data.duration;
      group.speed = data.speed;
      group.autoreverses = data.autoreverses;
      var fillMode = [Constants.kCAFillModeRemoved, Constants.kCAFillModeForwards, Constants.kCAFillModeBackwards, Constants.kCAFillModeBoth];
      group.fillMode = fillMode[data.fillModeMask];
      // data.cumulative
      // data.additive
      // data.attributes
      data.channels.forEach(function (channel) {
        var keyPath = channel.targetPath.join('.'
        //console.error(`SCNNode animation group keyPath: ${keyPath}`)
        );var chAnim = _this6._loadAnimationData(channel.animation, keyPath);
        group.animations.push(chAnim);
      }
      //console.log('_loadAnimationGroup done')

      );return group;
    }
  }, {
    key: '_loadKeyframeAnimation',
    value: function _loadKeyframeAnimation(data, keyPath) {
      //console.log(`_loadKeyframeAnimation ${keyPath} start`)
      var anim = new _CAKeyframeAnimation2.default(keyPath);

      anim.isRemovedOnCompletion = Boolean(data.removeOnCompletion
      // anim.timingFunction
      // anim.delegate
      );anim.usesSceneTimeBase = Boolean(data.sceneTimeBased);
      anim.fadeInDuration = data.fadeInDuration;
      anim.fadeOutDuration = data.fadeOutDuration;
      anim.beginTime = data.beginTime;
      anim.timeOffset = data.timeOffset;
      anim.repeatCount = data.repeatCount;
      // anim.repeatDuration
      anim.duration = data.duration;
      anim.speed = data.speed;
      anim.autoreverses = data.autoreverses;
      var fillMode = [Constants.kCAFillModeRemoved, Constants.kCAFillModeForwards, Constants.kCAFillModeBackwards, Constants.kCAFillModeBoth];
      anim.fillMode = fillMode[data.fillModeMask];
      anim.isCumulative = Boolean(data.cumulative);
      anim.isAdditive = Boolean(data.additive
      // data.attributes

      );var keyframe = data.keyframeController;
      anim.values = this._loadData(keyframe, 'values'
      //anim.path
      );anim.keyTimes = this._loadData(keyframe, 'keytimes');
      switch (keyframe.interpolationMode) {
        case 0:
        default:
          //anim.timingFunctions =
          break;
      }
      anim.keyTimes = anim.keyTimes.map(function (keyTime) {
        return keyTime / anim.duration;
      });

      var calculationModes = [Constants.kCAAnimationLinear, Constants.kCAAnimationDiscrete, Constants.kCAAnimationPaced, Constants.kCAAnimationCubic, Constants.kCAAnimationCubicPaced];
      anim.calculationMode = calculationModes[keyframe.calculationMode];
      //anim.rotationMode
      //anim.tensionValues
      //anim.continuityValues
      //anim.biasValues

      //console.log(`_loadKeyframeAnimation ${keyPath} done`)

      return anim;
    }
  }, {
    key: '_loadBasicAnimation',
    value: function _loadBasicAnimation(data, keyPath) {
      //console.log(`_loadBasicAnimation ${keyPath} start`)
      var anim = new _CABasicAnimation2.default(keyPath);

      anim.isRemovedOnCompletion = Boolean(data.removeOnCompletion);
      anim.timingFunction = new _CAMediaTimingFunction2.default(data.timingFunction.c0, data.timingFunction.c1, data.timingFunction.c2, data.timingFunction.c3);
      // anim.delegate
      anim.usesSceneTimeBase = Boolean(data.sceneTimeBased);
      anim.fadeInDuration = data.fadeInDuration;
      anim.fadeOutDuration = data.fadeOutDuration;
      anim.beginTime = data.beginTime;
      anim.timeOffset = data.timeOffset;
      anim.repeatCount = data.repeatCount;
      // anim.repeatDuration
      anim.duration = data.duration;
      anim.speed = data.speed;
      anim.autoreverses = data.autoreverses;
      var fillMode = [Constants.kCAFillModeRemoved, Constants.kCAFillModeForwards, Constants.kCAFillModeBackwards, Constants.kCAFillModeBoth];
      anim.fillMode = fillMode[data.fillModeMask];
      anim.isCumulative = Boolean(data.cumulative);
      anim.isAdditive = Boolean(data.additive
      // data.attributes
      // data.baseType

      //console.log(`_loadBasicAnimation ${keyPath} done`)

      );return anim;
    }
  }, {
    key: '_loadActionArray',
    value: function _loadActionArray(node, actions) {
      //console.log('_loadActionArray start')
      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = Object.keys(actions)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var actName = _step13.value;

          var data = actions[actName];
          //const action = this._loadActionData(data, actName)
          //node.runActionForKey(action, actName)
          node.runActionForKey(data, actName);
        }
        //console.log('_loadAnimationArray done')
      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13.return) {
            _iterator13.return();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }
    }

    //static _loadActionData(data, key) {
    //  console.log(`_loadActionData ${key} start`)
    //}

  }, {
    key: '_loadData',
    value: function _loadData(data, key) {
      //console.log(`_loadData ${key} start`)

      var accessor = data[key].accessor;
      var components = accessor.componentsPerValue;
      var stride = accessor.stride;
      var offset = accessor.offset;
      var typeId = accessor.sourceTypeID;
      var padding = accessor.padding;
      var count = accessor.valuesCount;

      var sourceKey = key + '-data';
      var source = data[sourceKey];

      var result = [];
      var pos = offset;
      if (accessor.componentsType === 1) {
        // float
        for (var i = 0; i < count; i++) {
          result.push(source.readFloatBE(pos));
          pos += stride;
        }
      } else if (accessor.componentsType === 6) {
        // double
        for (var _i = 0; _i < count; _i++) {
          result.push(source.readDoubleBE(pos));
          pos += stride;
        }
      } else if (accessor.componentsType === 9) {
        // SCNVector3
        for (var _i2 = 0; _i2 < count; _i2++) {
          result.push(_SCNVector2.default._initWithData(source, pos, true));
          pos += stride;
        }
      } else if (accessor.componentsType === 10) {
        // SCNVector4
        for (var _i3 = 0; _i3 < count; _i3++) {
          result.push(_SCNVector4.default._initWithData(source, pos, true));
          pos += stride;
        }
      } else if (accessor.componentsType === 11) {
        // SCNMatrix4
        for (var _i4 = 0; _i4 < count; _i4++) {
          result.push(_SCNMatrix2.default._initWithData(source, pos, true));
          pos += stride;
        }
      } else if (accessor.componentsType === 13) {
        // SKColor
        for (var _i5 = 0; _i5 < count; _i5++) {
          result.push(_SKColor2.default._initWithData(source, pos, true));
          pos += stride;
        }
      } else {
        console.error('unknown accessor componentsType: ' + accessor.componentsType);
      }

      //console.log(`_loadData ${key} done`)

      return result;
    }

    /**
     * Constructor for JSExport compatibility
     * @access public
     * @returns {SCNNode} -
     */

  }, {
    key: 'node',
    value: function node() {
      return new SCNNode();
    }

    /**
     * Constructor for JSExport compatibility
     * @access public
     * @param {?SCNGeometry} [geometry] - The geometry to be attached.
     * @returns {SCNNode} -
     */

  }, {
    key: 'nodeWithGeometry',
    value: function nodeWithGeometry(geometry) {
      return new SCNNode(geometry);
    }
  }, {
    key: 'localFront',
    get: function get() {
      return _localFront;
    }

    /**
     * 
     * @type {SCNVector3}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867400-localright
     */

  }, {
    key: 'localRight',
    get: function get() {
      return _localRight;
    }

    /**
     * 
     * @type {SCNVector3}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnnode/2867386-localup
     */

  }, {
    key: 'localUp',
    get: function get() {
      return _localUp;
    }
  }]);

  return SCNNode;
}(_NSObject3.default);

exports.default = SCNNode;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*global Buffer*/

/**
 * A container for index data describing how vertices connect to define a three-dimensional object, or geometry.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scngeometryelement
 */
var SCNGeometryElement = function (_NSObject) {
  _inherits(SCNGeometryElement, _NSObject);

  _createClass(SCNGeometryElement, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        $constructor: function $constructor(propNames, propValues) {
          var element = new SCNGeometryElement(propValues.elementData, propValues.primitiveType, propValues.primitiveCount, propValues.bytesPerIndex);
          if (typeof propValues.maximumPointScreenSpaceRadius !== 'undefined') {
            element.maximumPointScreenSpaceRadius = propValues.maximumPointScreenSpaceRadius;
          }
          if (typeof propValues.minimumPointScreenSpaceRadius !== 'undefined') {
            element.minimumPointScreenSpaceRadius = propValues.minimumPointScreenSpaceRadius;
          }
          if (typeof propValues.ptSize !== 'undefined') {
            element.pointSize = propValues.ptSize;
          }

          return element;
        },
        primitiveType: ['integer', null],
        primitiveCount: ['integer', null],
        elementData: ['NSMutableData', null],
        bytesPerIndex: ['integer', null],
        primitiveRangeLocation: ['integer', null],
        primitiveRangeLength: ['integer', null],
        ptSize: ['float', null],
        indicesChannelCount: ['integer', null],
        interleavedIndicesChannels: ['integer', null],
        minimumPointScreenSpaceRadius: ['float', null],
        maximumPointScreenSpaceRadius: ['float', null]
      };
    }

    // Creating a Geometry Element

    /**
     * Creates a geometry element from the specified array of index values. 
     * @access public
     * @constructor
     * @param {number[]|Buffer} indices - An array of index values, each of which identifies a vertex in a geometry source.
     * @param {SCNGeometryPrimitiveType} primitiveType - The drawing primitive that connects vertices when rendering the geometry element. For possible values, see SCNGeometryPrimitiveType.
     * @param {?number} primitiveCount -
     * @param {number} [bytesPerIndex = 2] -
     * @desc SceneKit connects the vertices in the order specified by the indices array, arranged according to the primitiveType parameter.This initializer is equivalent to the init(data:primitiveType:primitiveCount:bytesPerIndex:) initializer, but does not require an intermediary Data object; instead, it automatically infers the necessary allocation size and bytesPerIndex values based on the contents of the indices array. To create a custom SCNGeometry object from the geometry element, use the init(sources:elements:) initializer.
     * @see https://developer.apple.com/documentation/scenekit/scngeometryelement/1523191-init
     */

  }]);

  function SCNGeometryElement(indices, primitiveType) {
    var primitiveCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var bytesPerIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;

    _classCallCheck(this, SCNGeometryElement);

    // Inspecting a Geometry Element

    var _this = _possibleConstructorReturn(this, (SCNGeometryElement.__proto__ || Object.getPrototypeOf(SCNGeometryElement)).call(this));

    _this._data = indices;
    if (indices instanceof Buffer) {
      var _data = [];
      var count = indices.length / bytesPerIndex;
      var _offset = 0;
      for (var i = 0; i < count; i++) {
        _data.push(indices.readUIntLE(_offset, bytesPerIndex));
        _offset += bytesPerIndex;
      }
      _this._data = _data;
    }

    _this._primitiveType = primitiveType;
    if (primitiveCount !== null) {
      _this._primitiveCount = primitiveCount;
    } else {
      switch (primitiveType) {
        case _SCNGeometryPrimitiveType2.default.triangles:
          _this._primitiveCount = _this._data.length / 3;
          break;
        case _SCNGeometryPrimitiveType2.default.triangleStrip:
          _this._primitiveCount = _this._data.length - 2;
          break;
        case _SCNGeometryPrimitiveType2.default.line:
          _this._primitiveCount = _this._data.length / 2;
          break;
        case _SCNGeometryPrimitiveType2.default.point:
          _this._primitiveCount = _this._data.length;
          break;
        case _SCNGeometryPrimitiveType2.default.polygon:
          _this._primitiveCount = _this._data.length / 2;
          break;
        default:
          throw new Error('unknown primitive type: ' + primitiveType);
      }
    }
    _this._bytesPerIndex = bytesPerIndex;

    /**
     * @type {TypedArray}
     * @access private
     */
    _this._glData = null;
    //console.log(`SCNGeometryElement: bytesPerIndex: ${bytesPerIndex}`)
    if (bytesPerIndex === 1) {
      _this._glData = new Uint8Array(_this._data);
    } else if (bytesPerIndex === 2) {
      _this._glData = new Uint16Array(_this._data);
    } else if (bytesPerIndex === 4) {
      _this._glData = new Uint32Array(_this._data);
    } else {
      throw new Error('unknown data size: ' + bytesPerIndex);
    }

    /**
     * @type {number}
     */
    _this.maximumPointScreenSpaceRadius = 0.0; // TODO: check the default value

    /**
     * @type {number}
     */
    _this.minimumPointScreenSpaceRadius = 0.0; // TODO: check the default value

    /**
     * @type {number}
     */
    _this.pointSize = 0.0; // TODO: check the default value

    /**
     * @type {NSRange}
     */
    _this.primitiveRange = null; // TODO: check the default value
    return _this;
  }

  /**
   * Creates a geometry element from the specified Model I/O submesh object.
   * @access public
   * @param {MDLSubmesh} mdlSubMesh - 
   * @returns {void}
   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLSubmesh class is a generic description of an index buffer to be used in rendering a 3D object, along with an assigned material. In SceneKit, materials are assigned to a geometry rather than to its elements, so importing a submesh as a geometry element does not import its material assignment. To import a Model I/O mesh along with its materials, use the SCNGeometry init(mdlMesh:) method.
   * @see https://developer.apple.com/documentation/scenekit/scngeometryelement/1419843-init
   */


  _createClass(SCNGeometryElement, [{
    key: 'initMdlSubmesh',
    value: function initMdlSubmesh(mdlSubMesh) {}

    // Inspecting a Geometry Element

    /**
     * The drawing primitive that connects vertices when rendering the geometry element.
     * @type {SCNGeometryPrimitiveType}
     * @desc For possible values, see SCNGeometryPrimitiveType.
     * @see https://developer.apple.com/documentation/scenekit/scngeometryelement/1522917-primitivetype
     */

  }, {
    key: '_createBuffer',
    value: function _createBuffer(context) {
      var gl = context;
      this._buffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._glData, gl.STATIC_DRAW);

      return this._buffer;
    }
  }, {
    key: 'copy',
    value: function copy() {
      var element = new SCNGeometryElement(this._data.slice(0), this._primitiveType, this._primitiveCount, this._bytesPerIndex);
      return element;
    }

    /**
     * @access private
     * @param {number} index -
     * @returns {number[]} -
     */

  }, {
    key: '_indexAt',
    value: function _indexAt(index) {
      if (index < 0 || index >= this.primitiveCount) {
        throw new Error('index out of range: ' + index + ' (0 - ' + (this.primitiveCount - 1) + ')');
      }

      var arr = [];
      var len = this._primitiveCount;
      if (this._primitiveType === _SCNGeometryPrimitiveType2.default.triangles) {
        var i = index * 3;
        return [this._data[i + 0], this._data[i + 1], this._data[i + 2]];
      } else if (this._primitiveType === _SCNGeometryPrimitiveType2.default.triangleStrip) {
        return [this._data[index + 0], this._data[index + 1], this._data[index + 2]];
      } else if (this._primitiveType === _SCNGeometryPrimitiveType2.default.line) {
        var _i = index * 2;
        return [this._data[_i + 0], this._data[_i + 1]];
      } else if (this._primitiveType === _SCNGeometryPrimitiveType2.default.point) {
        return [this._data[index]];
      } else if (this._primitiveType === _SCNGeometryPrimitiveType2.default.polygon) {
        return [this._data[0], this._data[index + 1], this._data[index + 2]];
      }

      throw new Error('unknown primitive type: ' + this._primitiveType);
    }
  }, {
    key: 'primitiveType',
    get: function get() {
      return this._primitiveType;
    }

    /**
     * The number of primitives in the element.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scngeometryelement/1523404-primitivecount
     */

  }, {
    key: 'primitiveCount',
    get: function get() {
      return this._primitiveCount;
    }

    /**
     * The data describing the geometry element.
     * @type {Data}
     * @desc An element’s data is an array of index values identifying vertices in a geometry source. SceneKit interprets the data as an array of unsigned integers, whose size is specified by the bytesPerIndex property.
     * @see https://developer.apple.com/documentation/scenekit/scngeometryelement/1523367-data
     */

  }, {
    key: 'data',
    get: function get() {
      return this._data;
    }

    /**
     * The number of bytes that represent each index value in the element’s data.
     * @type {number}
     * @desc An element’s data property holds an array of index values identifying vertices in a geometry source. SceneKit interprets the data as an array of unsigned integers, whose size is specified by the bytesPerIndex property.
     * @see https://developer.apple.com/documentation/scenekit/scngeometryelement/1522720-bytesperindex
     */

  }, {
    key: 'bytesPerIndex',
    get: function get() {
      return this._bytesPerIndex;
    }
  }]);

  return SCNGeometryElement;
}(_NSObject3.default);

exports.default = SCNGeometryElement;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21).Buffer))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A structure that contains the location and dimensions of a rectangle.
 * @access public
 * @see https://developer.apple.com/documentation/coregraphics/cgrect
 */
var CGRect = function () {
  // Creating Rectangle Values

  /**
   * Creates a rectangle with the specified origin and size.
   * @access public
   * @constructor
   * @param {CGPoint} origin - 
   * @param {CGSize} size - 
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454856-init
   */
  function CGRect(origin, size) {
    _classCallCheck(this, CGRect);

    // Basic Geometric Properties
    this.origin = origin.copy();
    this.size = size.copy();
  }

  // Special Values

  /**
   * The rectangle whose origin and size are both zero.
   * @type {CGRect}
   * @desc The zero rectangle is equivalent to one created by calling CGRect(x: 0, y: 0, width: 0, height: 0).
   * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455437-zero
   */


  _createClass(CGRect, [{
    key: 'applying',


    // Creating Derived Rectangles

    /**
     * Applies an affine transform to a rectangle.
     * @access public
     * @param {CGAffineTransform} t - The affine transform to apply to the rect parameter.
     * @returns {CGRect} - 
     * @desc Because affine transforms do not preserve rectangles in general, this function returns the smallest rectangle that contains the transformed corner points of the rect parameter. If the affine transform t consists solely of scaling and translation operations, then the returned rectangle coincides with the rectangle constructed from the four transformed corners.
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455875-applying
     */
    value: function applying(t) {
      return null;
    }

    /**
     * Returns a rectangle that is smaller or larger than the source rectangle, with the same center point.
     * @access public
     * @param {number} dx - The x-coordinate value to use for adjusting the source rectangle. To create an inset rectangle, specify a positive value. To create a larger, encompassing rectangle, specify a negative value.
     * @param {number} dy - The y-coordinate value to use for adjusting the source rectangle. To create an inset rectangle, specify a positive value. To create a larger, encompassing rectangle, specify a negative value.
     * @returns {CGRect} - 
     * @desc The rectangle is standardized and then the inset parameters are applied. If the resulting rectangle would have a negative height or width, a null rectangle is returned.
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454218-insetby
     */

  }, {
    key: 'insetBy',
    value: function insetBy(dx, dy) {
      var newX = this.minX + dx;
      var newY = this.minY + dy;
      var newWidth = this.size.width - dx * 2;
      var newHeight = this.size.height - dy * 2;
      return new CGRect(new _CGPoint2.default(newX, newY), new _CGSize2.default(newWidth, newHeight));
    }

    /**
     * Returns a rectangle with an origin that is offset from that of the source rectangle.
     * @access public
     * @param {number} dx - The offset value for the x-coordinate.
     * @param {number} dy - The offset value for the  y-coordinate.
     * @returns {CGRect} - 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454841-offsetby
     */

  }, {
    key: 'offsetBy',
    value: function offsetBy(dx, dy) {
      return new CGRect(new _CGPoint2.default(this.origin.x + dx, this.origin.y + dy), this.size);
    }

    /**
     * Returns the smallest rectangle that contains the two source rectangles.
     * @access public
     * @param {CGRect} r2 - Another rectangle to be combined with this rectangle.
     * @returns {CGRect} - 
     * @desc Both rectangles are standardized prior to calculating the union. If either of the rectangles is a null rectangle, a copy of the other rectangle is returned (resulting in a null rectangle if both rectangles are null). Otherwise a rectangle that completely contains the source rectangles is returned.
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455837-union
     */

  }, {
    key: 'union',
    value: function union(r2) {
      if (this.isNull && r2.isNull) {
        return new CGRect(new _CGPoint2.default(0, 0), null);
      } else if (this.isNull) {
        return r2.copy();
      } else if (r2.isNull) {
        return this.copy();
      }

      var minX = this.minX < r2.minX ? this.minX : r2.minX;
      var maxX = this.maxX > r2.maxX ? this.maxX : r2.maxX;
      var minY = this.minY < r2.minY ? this.minY : r2.minY;
      var maxY = this.maxY > r2.maxY ? this.maxY : r2.maxY;
      var width = maxX - minX;
      var height = maxY - minY;
      return new CGRect(new _CGPoint2.default(minX, minY), new _CGSize2.default(width, height));
    }

    /**
     * Returns the intersection of two rectangles.
     * @access public
     * @param {CGRect} r2 - Another rectangle to intersect with this rectangle.
     * @returns {CGRect} - 
     * @desc Both rectangles are standardized prior to calculating the intersection.
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455346-intersection
     */

  }, {
    key: 'intersection',
    value: function intersection(r2) {
      if (this.isNull || r2.isNull) {
        return new CGRect(new _CGPoint2.default(0, 0), null);
      }
      var minX = this.minX > r2.minX ? this.minX : r2.minX;
      var maxX = this.maxX < r2.maxX ? this.maxX : r2.maxX;
      var minY = this.minY > r2.minY ? this.minY : r2.minY;
      var maxY = this.maxY < r2.maxY ? this.maxY : r2.maxY;
      var width = maxX - minX;
      var height = maxY - minY;
      if (width < 0 || height < 0) {
        return new CGRect(new _CGPoint2.default(0, 0), null);
      }
      return new CGRect(new _CGPoint2.default(minX, minY), new _CGSize2.default(width, height));
    }

    /**
     * Creates two rectangles by dividing the original rectangle. 
     * @access public
     * @param {number} atDistance - A distance from the rectangle side specified in the fromEdge parameter, defining the line along which to divide the rectangle.
     * @param {CGRectEdge} fromEdge - The side of the rectangle from which to measure the atDistance parameter, defining the line along which to divide the rectangle.
     * @returns {{slice: CGRect, remainder: CGRect}} - 
     * @desc Together the fromEdge and atDistance parameters define a line (parallel to the specified edge of the rectangle and at the specified distance from that edge) that divides the rectangle into two component rectangles.
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/2299988-divided
     */

  }, {
    key: 'dividedFrom',
    value: function dividedFrom(atDistance, fromEdge) {
      return null;
    }
    /**
     * Returns a rectangle with a positive width and height.
     * @type {CGRect}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1456432-standardized
     */

  }, {
    key: 'intersects',


    // Checking Characteristics

    /**
     * Returns whether two rectangles intersect.
     * @access public
     * @param {CGRect} rect2 - The rectangle to test for intersection with this rectangle.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454747-intersects
     */
    value: function intersects(rect2) {
      var r = this.intersection(rect2);
      return this.width > 0 && this.height > 0;
    }

    /**
     * Returns whether a rectangle contains a specified point.
     * @access public
     * @param {CGPoint} point - The point to examine. 
     * @returns {boolean} - 
     * @desc A point is considered inside the rectangle if its coordinates lie inside the rectangle or on the minimum X or minimum Y edge.
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1456316-contains
     */

  }, {
    key: 'contains',
    value: function contains(point) {
      return point.x >= this.minX && point.x <= this.maxX && point.y >= this.minY && point.y <= this.maxY;
    }

    /**
     * Returns whether a rectangle has zero width or height, or is a null rectangle.
     * @type {boolean}
     * @desc An empty rectangle is either a null rectangle or a valid rectangle with zero height or width.
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454917-isempty
     */

  }, {
    key: 'initDictionaryRepresentation',


    // Alternate Representations

    /**
     * Creates a rectangle from a canonical dictionary representation. 
     * @access public
     * @param {Map} dict - A dictionary containing x, y, width, and height values for the rectangle to create, in the format used by the dictionaryRepresentation property.
     * @returns {void}
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/2427139-init
     */
    value: function initDictionaryRepresentation(dict) {
      // Basic Geometric Properties
      this.origin = dict.get('origin');
      this.size = dict.get('size');
    }

    /**
     * Returns a dictionary representation of the provided rectangle.
     * @type {Map}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455760-dictionaryrepresentation
     */

  }, {
    key: 'equalTo',


    // Comparing Rectangles

    /**
     * Returns whether two rectangles are equal in size and position.
     * @access public
     * @param {CGRect} rect2 - The rectangle to compare this rectangle with.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1456516-equalto
     */
    value: function equalTo(rect2) {
      if (this.origin === null || rect2.origin === null) {
        return false;
      }
      if (this.size === null || rect2.size === null) {
        return false;
      }

      return this.origin.equalTo(rect2.origin) && this.size.equalTo(rect2.size);
    }
  }, {
    key: 'zero',
    value: function zero() {
      return new CGRect(new _CGPoint2.default(0, 0), new CGRect(0, 0));
    }
  }, {
    key: 'add',
    value: function add(rect2) {
      return new CGRect(this.origin.add(rect2.origin), this.size.add(rect2.size));
    }
  }, {
    key: 'sub',
    value: function sub(rect2) {
      return new CGRect(this.origin.sub(rect2.origin), this.size.sub(rect2.size));
    }

    /**
     * @access public
     * @param {CGRect} r -
     * @param {number} rate -
     * @returns {CGRect} -
     */

  }, {
    key: 'lerp',
    value: function lerp(r, rate) {
      var origin = this.origin.lerp(r.origin, rate);
      var size = this.size.lerp(r.size, rate);
      return new CGRect(origin, size);
    }
  }, {
    key: 'copy',
    value: function copy() {
      return new CGRect(this.origin, this.size);
    }

    /**
     * @access public
     * @param {number} x -
     * @param {number} y -
     * @param {number} width -
     * @param {number} height -
     * @returns {CGRect} -
     */

  }, {
    key: 'height',


    // Basic Geometric Properties

    // Calculated Geometric Properties
    /**
     * Returns the height of a rectangle.
     * @type {number}
     * @desc Regardless of whether the height is stored in the CGRect data structure as a positive or negative number, this function returns the height as if the rectangle were standardized. That is, the result is never a negative number.
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455645-height
     */
    get: function get() {
      if (this.isNull) {
        return 0;
      }
      return Math.abs(this.size.height);
    }
    /**
     * Returns the width of a rectangle.
     * @type {number}
     * @desc Regardless of whether the width is stored in the CGRect data structure as a positive or negative number, this function returns the width as if the rectangle were standardized.  That is, the result is never a negative number.
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454758-width
     */

  }, {
    key: 'width',
    get: function get() {
      if (this.isNull) {
        return 0;
      }
      return Math.abs(this.size.width);
    }

    /**
     * Returns the smallest value for the x-coordinate of the rectangle.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455948-minx
     */

  }, {
    key: 'minX',
    get: function get() {
      if (this.size.width < 0) {
        return this.origin.x + this.size.width;
      }
      return this.origin.x;
    }

    /**
     * Returns the x- coordinate that establishes the center of a rectangle.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1456175-midx
     */

  }, {
    key: 'midX',
    get: function get() {
      return this.origin.x + this.size.width * 0.5;
    }

    /**
     * Returns the largest value of the x-coordinate for the rectangle.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454334-maxx
     */

  }, {
    key: 'maxX',
    get: function get() {
      if (this.size.width > 0) {
        return this.origin.x + this.size.width;
      }
      return this.origin.x;
    }

    /**
     * Returns the smallest value for the y-coordinate of the rectangle.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454832-miny
     */

  }, {
    key: 'minY',
    get: function get() {
      if (this.size.height < 0) {
        return this.origin.y + this.size.height;
      }
      return this.origin.y;
    }

    /**
     * Returns the y-coordinate that establishes the center of the rectangle.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1456550-midy
     */

  }, {
    key: 'midY',
    get: function get() {
      return this.origin.y + this.size.height * 0.5;
    }

    /**
     * Returns the largest value for the y-coordinate of the rectangle.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1454060-maxy
     */

  }, {
    key: 'maxY',
    get: function get() {
      if (this.size.height > 0) {
        return this.origin.y + this.size.height;
      }
      return this.origin.y;
    }
  }, {
    key: 'standardized',
    get: function get() {
      var r = this.copy();
      if (this.isNull) {
        return CGRect.zero;
      }
      if (this.width < 0) {
        r.origin.x = this.origin.x + this.width;
        r.size.width = -this.width;
      }
      if (this.height < 0) {
        r.origin.y = this.origin.y + this.height;
        r.size.height = -this.height;
      }
      return r;
    }

    /**
     * Returns the smallest rectangle that results from converting the source rectangle values to integers.
     * @type {CGRect}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1456348-integral
     */

  }, {
    key: 'integral',
    get: function get() {
      return null;
    }
  }, {
    key: 'isEmpty',
    get: function get() {
      return this.isNull || this.size.height === 0 || this.size.width === 0;
    }

    /**
     * Returns whether a rectangle is infinite.
     * @type {boolean}
     * @desc An infinite rectangle is one that has no defined bounds. Infinite rectangles can be created as output from a tiling filter. For example, the Core Image framework perspective tile filter creates an image whose extent is described by an infinite rectangle.
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455008-isinfinite
     */

  }, {
    key: 'isInfinite',
    get: function get() {
      return this.size.width === Infinity && this.size.height === Infinity;
    }

    /**
     * Returns whether the rectangle is equal to the null rectangle.
     * @type {boolean}
     * @desc A null rectangle is the equivalent of an empty set. For example, the result of intersecting two disjoint rectangles is a null rectangle. A null rectangle cannot be drawn and interacts with other rectangles in special ways.
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1455471-isnull
     */

  }, {
    key: 'isNull',
    get: function get() {
      return this.size === null;
    }
  }, {
    key: 'dictionaryRepresentation',
    get: function get() {
      var map = new Map();
      map.set('origin', this.origin);
      map.set('size', this.size);
      return map;
    }

    /**
     * 
     * @type {string}
     * @desc A textual representation of the rectangle's origin and size values. 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1645823-debugdescription
     */

  }, {
    key: 'debugDescription',
    get: function get() {
      if (this.size === null) {
        return '{null}';
      }
      var origin = this.origin ? this.origin.debugDescription() : '{null}';
      var size = this.size ? this.size.debugDescription() : '{null}';

      return '{origin:' + origin + ', size:' + size + '}';
    }

    /**
     * A representation of the rectangle's structure and display style for use in debugging. 
     * @type {Mirror}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1645833-custommirror
     */

  }, {
    key: 'customMirror',
    get: function get() {
      return null;
    }

    /**
     * A representation of the rectangle for use in Playgrounds. 
     * @type {PlaygroundQuickLook}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgrect/1645827-customplaygroundquicklook
     */

  }, {
    key: 'customPlaygroundQuickLook',
    get: function get() {
      return null;
    }
  }], [{
    key: 'rectWithXYWidthHeight',
    value: function rectWithXYWidthHeight(x, y, width, height) {
      var point = new _CGPoint2.default(x, y);
      var size = new _CGSize2.default(width, height);
      return new CGRect(point, size);
    }
  }, {
    key: 'zero',
    get: function get() {
      return new CGRect(new _CGPoint2.default(0, 0), new _CGSize2.default(0, 0));
    }
  }]);

  return CGRect;
}();

exports.default = CGRect;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNAnimatable from './SCNAnimatable'

/**
 * The abstract superclass for objects that automatically adjust the position, rotation, or scale of a node based on rules you define.
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @see https://developer.apple.com/documentation/scenekit/scnconstraint
 */
var SCNConstraint = function (_NSObject) {
  _inherits(SCNConstraint, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNConstraint() {
    _classCallCheck(this, SCNConstraint);

    // Tuning a Constraint’s Effect on Nodes

    /**
     * The influence of the constraint on the node’s transformation.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnconstraint/1468692-influencefactor
     */
    var _this = _possibleConstructorReturn(this, (SCNConstraint.__proto__ || Object.getPrototypeOf(SCNConstraint)).call(this));

    _this.influenceFactor = 0;

    return _this;
  }

  return SCNConstraint;
}(_NSObject3.default);

exports.default = SCNConstraint;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a matrix describing a translation transformation.
 * @access public
 * @param {number} tx - 
 * @param {number} ty - 
 * @param {number} tz - 
 * @returns {SCNMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409679-scnmatrix4maketranslation
 */
var SCNMatrix4MakeTranslation = function SCNMatrix4MakeTranslation(tx, ty, tz) {
  return new _SCNMatrix2.default(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
};

exports.default = SCNMatrix4MakeTranslation;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _CGRect = __webpack_require__(16);

var _CGRect2 = _interopRequireDefault(_CGRect);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import UIFocusItem from '../undefined/UIFocusItem'
//import SKScene from './SKScene'
//import SKAction from './SKAction'
//import SKPhysicsBody from './SKPhysicsBody'
//import GKPolygonObstacle from '../undefined/GKPolygonObstacle'
//import GKEntity from '../undefined/GKEntity'
//import NSMutableDictionary from '../undefined/NSMutableDictionary'
//import SKConstraint from './SKConstraint'
//import SKReachConstraints from './SKReachConstraints'
//import NSCoder from '../undefined/NSCoder'
//import SKAttributeValue from './SKAttributeValue'


/**
 * The SKNode class is the fundamental building block of most SpriteKit content. 
 * @access public
 * @extends {NSObject}
 * @implements {UIFocusItem}
 * @see https://developer.apple.com/documentation/spritekit/sknode
 */
var SKNode = function (_NSObject) {
  _inherits(SKNode, _NSObject);

  // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483097-init
   */
  function SKNode() {
    _classCallCheck(this, SKNode);

    // Inspecting the Node’s Position

    /**
     * The position of the node in its parent's coordinate system.
     * @type {CGPoint}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483101-position
     */
    var _this = _possibleConstructorReturn(this, (SKNode.__proto__ || Object.getPrototypeOf(SKNode)).call(this));

    _this.position = new _CGPoint2.default(0, 0);

    /**
     * The height of the node relative to its parent.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483107-zposition
     */
    _this.zPosition = 0.0;

    _this._frame = new _CGRect2.default(new _CGPoint2.default(0, 0), new _CGSize2.default(0, 0));

    // Setting a Node’s Scaling and Rotation

    /**
     * A scaling factor that multiplies the width of a node and its children.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483087-xscale
     */
    _this.xScale = 1.0;

    /**
     * A scaling factor that multiplies the height of a node and its children.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483046-yscale
     */
    _this.yScale = 1.0;

    /**
     * The Euler rotation about the z axis (in radians).
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483089-zrotation
     */
    _this.zRotation = 0.0;

    // Inspecting a Node’s Visibility

    /**
     * The transparency value applied to the node’s contents.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483023-alpha
     */
    _this.alpha = 1.0;

    /**
     * A Boolean value that determines whether a node and its descendants are rendered.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483048-ishidden
     */
    _this.isHidden = false;

    // Determining Whether a Node Supports User Interaction

    /**
     * A Boolean value that indicates whether the node receives touch events.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483109-isuserinteractionenabled
     */
    _this.isUserInteractionEnabled = false;

    // Working with Node Trees

    _this._children = [];
    _this._parent = null;
    _this._scene = null;

    // Naming Nodes

    /**
     * The node’s assignable name.
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483136-name
     */
    _this.name = null;

    // Running Actions

    /**
     * A speed modifier applied to all actions executed by a node and its descendants.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483036-speed
     */
    _this.speed = 1.0;

    /**
     * A Boolean value that determines whether actions on the node and its descendants are processed.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483113-ispaused
     */
    _this.isPaused = false;

    /**
     * @access private
     * @type {Map}
     */
    _this._actions = new Map();

    // Adding Physics to a Node

    /**
     * The physics body associated with the node.
     * @type {?SKPhysicsBody}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483117-physicsbody
     */
    _this.physicsBody = null;

    // Working with GameplayKit Entities

    /**
     * The GameplayKit entity this node represents.
     * @type {?GKEntity}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1640688-entity
     */
    //this.entity = null


    // Storing Custom Node Data

    /**
     * A dictionary containing arbitrary data.
     * @type {?NSMutableDictionary}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483121-userdata
     */
    _this.userData = null;

    // Constraining a Node’s Behavior Relative to Other Nodes

    /**
     * Specifies the list of constraints to apply to the node.
     * @type {?SKConstraint[]}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483124-constraints
     */
    _this.constraints = null;

    /**
     * Specifies the reach constraints to apply to the node when executing a reach action.
     * @type {?SKReachConstraints}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483019-reachconstraints
     */
    _this.reachConstraints = null;

    // Instance Properties

    /**
     * 
     * @type {?Object[]}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645045-accessibilitychildren
     */
    _this.accessibilityChildren = [];

    /**
     * 
     * @type {CGRect}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645044-accessibilityframe
     */
    _this.accessibilityFrame = new _CGRect2.default(new _CGPoint2.default(0, 0), new _CGSize2.default(0, 0));

    /**
     * 
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645041-accessibilityhelp
     */
    _this.accessibilityHelp = null;

    /**
     * 
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645039-accessibilitylabel
     */
    _this.accessibilityLabel = null;

    /**
     * 
     * @type {?Object}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645042-accessibilityparent
     */
    _this.accessibilityParent = null;

    /**
     * 
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645036-accessibilityrole
     */
    _this.accessibilityRole = 'AXImage';

    /**
     * 
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645035-accessibilityroledescription
     */
    _this.accessibilityRoleDescription = 'SKNode';

    /**
     * 
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645043-accessibilitysubrole
     */
    _this.accessibilitySubrole = null;

    /**
     * The values of each attribute associated with the node's attached shader. 
     * @type {Map<string, SKAttributeValue>}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1644181-attributevalues
     */
    _this.attributeValues = new Map();

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645038-isaccessibilityelement
     */
    _this.isAccessibilityElement = false;

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645037-isaccessibilityenabled
     */
    _this.isAccessibilityEnabled = false;

    /**
     * @type {SKNode}
     * @access private
     */
    _this.__presentation = null;

    _this._isPresentationInstance = false;
    _this._worldPosition = new _CGPoint2.default(0, 0);
    _this._worldZPosition = 0;
    _this._worldXScale = 1;
    _this._worldYScale = 1;
    _this._worldZRotation = 0;
    return _this;
  }

  /**
   * 
   * @access public
   * @param {NSCoder} aDecoder - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483142-init
   */
  //initWithCoder(aDecoder) {
  //}


  // Creating a New Node

  /**
   * Creates a new node by loading an archive file from the game’s main bundle.
   * @access public
   * @param {string} filename - The name of the file, without a file extension. The file must be in the app’s main bundle and have a .sks filename extension.
   * @returns {void}
   * @desc If you call this method on a subclass of the SKScene class and the object in the archive is an SKScene object, the returned object is initialized as if it is a member of the subclass. You use this behavior to create scene layouts in the Xcode Editor and provide custom behaviors in your subclass. 
   * @see https://developer.apple.com/documentation/spritekit/sknode/1483083-init
   */


  _createClass(SKNode, [{
    key: 'calculateAccumulatedFrame',


    // Inspecting the Node’s Position

    /**
     * Calculates a rectangle in the parent’s coordinate system that contains the content of the node and all of its descendants. 
     * @access public
     * @returns {CGRect} - 
     * @desc The frame takes into the account the cumulative effect of the xScale, yScale, and zRotation properties of each node in the subtree.Listing 1 shows how calculateAccumulatedFrame() can be used display the bounding box of a shape node. The child node, although smaller than its parent, is rotated by 30° so that its bounds extend beyond its parent's bounds. After childNode has been added to parentNode, a further shape node, boundingBoxNode, is created with its size based on the accumulated frame of parentNode.Listing 1 Displaying the accumulated frame of a shape nodelet parentNode = SKShapeNode(rectOf: CGSize(width: 500, height: 500))
    parentNode.lineWidth = 2
    parentNode.strokeColor = .blue
    parentNode.fillColor = .clear
       
    let childNode = SKShapeNode(rectOf: CGSize(width: 400, height: 400))
    childNode.strokeColor = .red
    childNode.fillColor = .clear
    childNode.zRotation = -CGFloat.pi / 6 // pi / 6 = 30°
       
    parentNode.addChild(childNode)
       
    let boundingBoxNode = SKShapeNode(rectOf: parentNode.calculateAccumulatedFrame().size)
    boundingBoxNode.lineWidth = 1
    boundingBoxNode.strokeColor = .black
    boundingBoxNode.fillColor = .clear
    boundingBoxNode.path = boundingBoxNode.path?.copy(dashingWithPhase: 0,
                                                    lengths: [10,10])
       
    parentNode.addChild(boundingBoxNode)
    Figure 1 shows the result of Listing 1 with parentNode rendered in blue, childNode rendered in red and the boundingBoxNode rendered with a dashed line. Figure 1 Displaying the accumulated frame of a shape nodeDisplaying the accumulated frame of a shape nodelet parentNode = SKShapeNode(rectOf: CGSize(width: 500, height: 500))
    parentNode.lineWidth = 2
    parentNode.strokeColor = .blue
    parentNode.fillColor = .clear
       
    let childNode = SKShapeNode(rectOf: CGSize(width: 400, height: 400))
    childNode.strokeColor = .red
    childNode.fillColor = .clear
    childNode.zRotation = -CGFloat.pi / 6 // pi / 6 = 30°
       
    parentNode.addChild(childNode)
       
    let boundingBoxNode = SKShapeNode(rectOf: parentNode.calculateAccumulatedFrame().size)
    boundingBoxNode.lineWidth = 1
    boundingBoxNode.strokeColor = .black
    boundingBoxNode.fillColor = .clear
    boundingBoxNode.path = boundingBoxNode.path?.copy(dashingWithPhase: 0,
                                                    lengths: [10,10])
       
    parentNode.addChild(boundingBoxNode)
    Displaying the accumulated frame of a shape node
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483066-calculateaccumulatedframe
     */
    value: function calculateAccumulatedFrame() {
      var r = this._frame.copy();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;

          r = r.union(child.calculateAccumulatedFrame());
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return r;
    }

    /**
     * A rectangle in the parent’s coordinate system that contains the node’s content, ignoring the node’s children.
     * @type {CGRect}
     * @desc The frame is the smallest rectangle that contains the node’s content, taking into account the node’s xScale, yScale, and zRotation properties. Not all nodes contain content of their own.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483026-frame
     */

  }, {
    key: 'setScale',


    // Setting a Node’s Scaling and Rotation

    /**
     * Sets the xScale and yScale properties of the node.
     * @access public
     * @param {number} scale - The new value to use for the node’s xScale and yScale properties.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483126-setscale
     */
    value: function setScale(scale) {
      this.xScale = scale;
      this.yScale = scale;
    }

    // Working with Node Trees

    /**
     * Adds a node to the end of the receiver’s list of child nodes.
     * @access public
     * @param {SKNode} node - The node to add. The node must not already have a parent.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483054-addchild
     */

  }, {
    key: 'addChild',
    value: function addChild(node) {
      if (this._children.indexOf(node) >= 0) {
        return;
      }
      node.removeFromParent();
      this._children.push(node);
      node._parent = this;
    }

    /**
     * Inserts a child into a specific position in the receiver’s list of child nodes.
     * @access public
     * @param {SKNode} node - The node to add. The node must not already have a parent.
     * @param {number} index - The position in the array to insert the node.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483062-insertchild
     */

  }, {
    key: 'insertChildAt',
    value: function insertChildAt(node, index) {
      if (this._children.indexOf(node) >= 0) {
        return;
      }
      node.removeFromParent();
      this._insertObjectInChildrenAtIndex(node, index);
      this._parent = this;
    }

    /**
     * Compares the parameter node to the receiving node.
     * @access public
     * @param {SKNode} node - The node to compare to the receiving node.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483078-isequal
     */

  }, {
    key: 'isEqualTo',
    value: function isEqualTo(node) {
      return false;
    }

    /**
     * Moves the node to a new parent node in the scene. 
     * @access public
     * @param {SKNode} parent - An SKNode object to move the receiver to. This node must be in the same scene as the node’s current parent.
     * @returns {void}
     * @desc The node maintains its current position in scene coordinates.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483021-move
     */

  }, {
    key: 'moveToParent',
    value: function moveToParent(parent) {
      parent.addChild(this);
    }

    /**
     * Removes the receiving node from its parent.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483119-removefromparent
     */

  }, {
    key: 'removeFromParent',
    value: function removeFromParent() {
      var parentNode = this._parent;
      if (parentNode === null) {
        return;
      }
      var index = parentNode._children.indexOf(this);
      if (index < 0) {
        return;
      }
      parentNode._removeObjectFromChildrenAtIndex(index);
    }

    /**
     * Removes all of the node’s children.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483040-removeallchildren
     */

  }, {
    key: 'removeAllChildren',
    value: function removeAllChildren() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var child = _step2.value;

          child.removeFromParent();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    /**
     * Removes a list of children from the receiving node.
     * @access public
     * @param {SKNode[]} nodes - An array of SKNode objects that are all children of the receiving node.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483091-removechildren
     */

  }, {
    key: 'removeChildrenIn',
    value: function removeChildrenIn(nodes) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var node = _step3.value;

          if (this._children.indexOf(node) >= 0) {
            node.removeFromParent();
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    /**
     *
     * @access private
     * @param {number} index -
     * @returns {void}
     */

  }, {
    key: '_removeObjectFromChildrenAtIndex',
    value: function _removeObjectFromChildrenAtIndex(index) {
      var arr = this._children.splice(index, 1);
      if (arr.length === 0) {
        return;
      }
      var obj = arr[0];

      obj._parent = null;
    }

    /**
     *
     * @access private
     * @param {SCNNode} object -
     * @param {number} index -
     * @returns {void}
     */

  }, {
    key: '_insertObjectInChildrenAtIndex',
    value: function _insertObjectInChildrenAtIndex(object, index) {
      var length = this._children.length;
      if (index > length) {
        throw new Error('SKNode.children out of index: ' + index + ' > ' + length);
      }
      this._children.splice(index, 0, object);
    }

    /**
     * Returns a Boolean value that indicates whether the node is a descendant of the target node.
     * @access public
     * @param {SKNode} parent - An SKNode object to test against.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483111-inparenthierarchy
     */

  }, {
    key: 'inParentHierarchy',
    value: function inParentHierarchy(parent) {
      return false;
    }
    /**
     * The node’s children.
     * @type {SKNode[]}
     * @desc The objects in this array are all SKNode objects.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483028-children
     */

  }, {
    key: 'childNodeWithName',


    // Naming Nodes

    /**
     * Searches the children of the receiving node for a node with a specific name.
     * @access public
     * @param {string} name - The name to search for. This may be either the literal name of the node or a customized search string. See Searching the Node Tree.
     * @returns {?SKNode} - 
     * @desc If more than one child share the same name, the first node discovered is returned.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483060-childnode
     */
    value: function childNodeWithName(name) {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var child = _step4.value;

          if (child.name === name) {
            return child;
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return null;
    }

    /**
     * Search the children of the receiving node to perform processing for nodes which share a name.
     * @access public
     * @param {string} name - The name to search for. This may be either the literal name of the node or a customized search string. See Searching the Node Tree.
     * @param {function(arg1: SKNode, arg2: UnsafeMutablePointer<ObjCBool>): void} block - A block to execute on nodes that match the name parameter. The block has the signature (node: SKNode, stop: UnsafeMutablePointer<ObjCBool>).
     * @returns {void}
     * @desc This method enumerates the child array in order, searching for nodes whose names match the search parameter. The block is called once for each node that matches the name parameter.The following code shows how you could enumerate through the child nodes of a scene with a name containing the string yellow. Each matching node is hidden until the enumeration finds a node that also contains the string triangle. When this node is reached, stop is set to true and the processing stops.Listing 1 Enumerating child nodesscene.enumerateChildNodes(withName: "*yellow*") {
      (node, stop) in
      
      node.run(SKAction.hide())
      
      if let name = node.name, name.contains("triangle") {
          stop.initialize(to: true)
      }
    }
    You can also search by class name using enumerateChildNodes(withName:using:). However, for custom classes, you need to specify the fully annotated class name (i.e. the project name followed by the class name). The following code shows a custom class, SpaceshipNode, based on SKSpriteNode, and created in a project named SpaceGame. The first search fails to return an instance of  SpaceshipNode added as a child of parentNode:Listing 2 Enumerating child nodesclass SpaceshipNode: SKSpriteNode {
    }
       
    let parentNode = SKNode()
    let childNode = SpaceshipNode()
    parentNode.addChild(childNode)
       
    parentNode.enumerateChildNodes(withName: "SpaceshipNode") {
      node, _ in
      // Unannotated name, returns no results 
    }
       
    parentNode.enumerateChildNodes(withName: "SpaceGame.SpaceshipNode") {
      node, _ in
      // Annotated name, successfully returns `childNode` 
    }
       
    parentNode.enumerateChildNodes(withName: "SKSpriteNode") {
      node, _ in
      // Superclass name, successfully returns `childNode` 
    }
    Enumerating child nodesscene.enumerateChildNodes(withName: "*yellow*") {
      (node, stop) in
      
      node.run(SKAction.hide())
      
      if let name = node.name, name.contains("triangle") {
          stop.initialize(to: true)
      }
    }
    Enumerating child nodesclass SpaceshipNode: SKSpriteNode {
    }
       
    let parentNode = SKNode()
    let childNode = SpaceshipNode()
    parentNode.addChild(childNode)
       
    parentNode.enumerateChildNodes(withName: "SpaceshipNode") {
      node, _ in
      // Unannotated name, returns no results 
    }
       
    parentNode.enumerateChildNodes(withName: "SpaceGame.SpaceshipNode") {
      node, _ in
      // Annotated name, successfully returns `childNode` 
    }
       
    parentNode.enumerateChildNodes(withName: "SKSpriteNode") {
      node, _ in
      // Superclass name, successfully returns `childNode` 
    }
      * @see https://developer.apple.com/documentation/spritekit/sknode/1483024-enumeratechildnodes
     */

  }, {
    key: 'enumerateChildNodesWithNameUsing',
    value: function enumerateChildNodesWithNameUsing(name, block) {}

    // Running Actions

    /**
     * Adds an action to the list of actions executed by the node.
     * @access public
     * @param {SKAction} action - The action to perform.
     * @returns {void}
     * @desc The new action is processed the next time the scene’s animation loop is processed.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483093-run
     */

  }, {
    key: 'run',
    value: function run(action) {
      this.runWithKey(action, Symbol());
    }

    /**
     * Adds an action to the list of actions executed by the node.
     * @access public
     * @param {SKAction} action - The action to perform.
     * @param {function(): void} block - A completion block called when the action completes.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483103-run
     */

  }, {
    key: 'runCompletion',
    value: function runCompletion(action, block) {
      this._runActionForKeyCompletionHandler(action, Symbol(), block);
    }

    /**
     * Adds an identifiable action to the list of actions executed by the node.
     * @access public
     * @param {SKAction} action - The action to perform.
     * @param {string} key - A unique key used to identify the action.
     * @returns {void}
     * @desc This method is identical to run(_:), but the action is stored so that it can be retrieved later. If an action using the same key is already running, it is removed before the new action is added.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483042-run
     */

  }, {
    key: 'runWithKey',
    value: function runWithKey(action, key) {
      this._runActionForKeyCompletionHandler(action, key, null);
    }
  }, {
    key: '_runActionForKeyCompletionHandler',
    value: function _runActionForKeyCompletionHandler(action, key, block) {
      var _key = key;
      if (typeof key === 'undefined' || key === null) {
        _key = Symbol();
      }
      var act = action.copy
      // FIXME: use current frame time
      ();act._actionStartTime = Date.now() * 0.001;
      act._completionHandler = block;
      this._actions.set(_key, act);
    }

    /**
     * Returns an action associated with a specific key.
     * @access public
     * @param {string} key - A string that uniquely identifies an action.
     * @returns {?SKAction} - 
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483138-action
     */

  }, {
    key: 'actionForKey',
    value: function actionForKey(key) {
      return this._actions.get(key);
    }

    /**
     * Returns a Boolean value that indicates whether the node is executing actions.
     * @access public
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483081-hasactions
     */

  }, {
    key: 'hasActions',
    value: function hasActions() {
      return this._actions.size > 0;
    }

    /**
     * Ends and removes all actions from the node.
     * @access public
     * @returns {void}
     * @desc When an action is removed from the node, any remaining animation the action would perform is skipped; however, previous changes are not reverted. It is possible that an action may make a final change to the scene when removed; if so, it is documented for the specific action in SKAction.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483030-removeallactions
     */

  }, {
    key: 'removeAllActions',
    value: function removeAllActions() {
      // TODO: stop actions
      this._actions.clear();
    }

    /**
     * Removes an action associated with a specific key.
     * @access public
     * @param {string} key - A string that uniquely identifies an action.
     * @returns {void}
     * @desc If an action is found that matches the key, it is removed from the node.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483076-removeaction
     */

  }, {
    key: 'removeActionForKey',
    value: function removeActionForKey(key) {
      // TODO: stop action
      this._actions.delete(key);
    }

    // Converting to and from the Node’s Coordinate System

    /**
     * Converts a point from the coordinate system of another node in the node tree to the coordinate system of this node.
     * @access public
     * @param {CGPoint} point - A point in the other node’s coordinate system.
     * @param {SKNode} node - Another node in the same node tree as this node.
     * @returns {CGPoint} - 
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483058-convert
     */

  }, {
    key: 'convertFrom',
    value: function convertFrom(point, node) {
      return null;
    }

    /**
     * Converts a point in this node’s coordinate system to the coordinate system of another node in the node tree.
     * @access public
     * @param {CGPoint} point - A point in this node’s coordinate system.
     * @param {SKNode} node - Another node in the same node tree as this node.
     * @returns {CGPoint} - 
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483056-convert
     */

  }, {
    key: 'convertTo',
    value: function convertTo(point, node) {
      return null;
    }

    // Determining If a Point Lies in a Node

    /**
     * Returns a Boolean value that indicates whether a point lies inside the parent’s coordinate system.
     * @access public
     * @param {CGPoint} p - A CGPoint to test against.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483044-contains
     */

  }, {
    key: 'contains',
    value: function contains(p) {
      return false;
    }

    /**
     * Returns the deepest visible descendant that intersects a point.
     * @access public
     * @param {CGPoint} p - A point in the node’s coordinate system.
     * @returns {SKNode} - 
     * @desc A point is considered to be in a node if it lies inside the rectangle returned by the calculateAccumulatedFrame() method.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483099-atpoint
     */

  }, {
    key: 'atPoint',
    value: function atPoint(p) {
      return null;
    }

    /**
     * Returns an array of all visible descendants that intersect a point.
     * @access public
     * @param {CGPoint} p - A point in the node’s coordinate system.
     * @returns {SKNode[]} - 
     * @desc A point is considered to be in a node if it lies inside the rectangle returned by the calculateAccumulatedFrame() method.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483072-nodes
     */

  }, {
    key: 'nodesAt',
    value: function nodesAt(p) {
      return null;
    }

    // Performing Node Intersections

    /**
     * Returns a Boolean value that indicates whether this node intersects the specified node.
     * @access public
     * @param {SKNode} node - Another node in the same node tree.
     * @returns {boolean} - 
     * @desc The two nodes are considered to intersect if their frames intersect. The children of both nodes are ignored in this test.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483140-intersects
     */

  }, {
    key: 'intersects',
    value: function intersects(node) {
      return false;
    }

    // Creating GameplayKit Obstacles from a Set of Nodes

    /**
     * Converts each node into an obstacle by transforming its bounds into the scene’s coordinate system.
     * @access public
     * @param {SKNode[]} nodes - An array of SKNode objects.
     * @returns {GKPolygonObstacle[]} - 
     * @desc Use the array of obstacles to create an obstacle graph (GKObstacleGraph) in GameplayKit. See GameplayKit and GameplayKit Programming Guide.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483132-obstacles
     */

  }, {
    key: 'accessibilityHitTest',


    // Instance Methods

    /**
     * 
     * @access public
     * @param {CGPoint} point - 
     * @returns {?Object} - 
     * @see https://developer.apple.com/documentation/spritekit/sknode/1645040-accessibilityhittest
     */
    value: function accessibilityHitTest(point) {
      return null;
    }

    /**
     * Sets an attribute value for an attached shader
     * @deprecated
     * @access public
     * @param {SKAttributeValue} value - An attribute value object containing the scalar or vector value to set in the attached shader. 
     * @param {string} key - The attribute name.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/sknode/1644180-setvalue
     */

  }, {
    key: 'setValueForAttribute',
    value: function setValueForAttribute(value, key) {
      this.attributeValues.set(key, value);
    }

    /**
     * The value of a shader attribute.
     * @deprecated
     * @access public
     * @param {string} key - The attribute name.
     * @returns {?SKAttributeValue} - 
     * @see https://developer.apple.com/documentation/spritekit/sknode/1644182-value
     */

  }, {
    key: 'valueForAttributeNamed',
    value: function valueForAttributeNamed(key) {
      return this.attributeValues.get(key);
    }

    /**
     * @type {SKNode}
     */

  }, {
    key: 'copy',


    /**
     *
     * @access public
     * @returns {SKNode} -
     */
    value: function copy() {
      var node = _get(SKNode.prototype.__proto__ || Object.getPrototypeOf(SKNode.prototype), 'copy', this).call(this);
      node._copyValue(this);
      return node;
    }
  }, {
    key: '_copyValue',
    value: function _copyValue(src) {
      this.position = src.position.copy();
      this.zPosition = src.zPosition;
      this._frame = src._frame;
      this.xScale = src.xScale;
      this.yScale = src.yScale;
      this.zRotation = src.zRotation;
      this.alpha = src.alpha;
      this.isHidden = src.isHidden;
      this.isUserInteractionEnabled = src.isUserInteractionEnabled;
      this.name = src.name;
      this.speed = src.speed;
      this.isPaused = src.isPaused;
      this._actions = new Map(src._actions);
      this.physicsBody = src.physicsBody;
      this.userData = src.userData;
      this.constraints = src.constraints;
      this.reachConstraints = src.reachConstraints;
      this.accessibilityChildren = src.accessibilityChildren;
      this.accessibilityFrame = src.accessibilityFrame.copy();
      this.accessibilityHelp = src.accessibilityHelp;
      this.accessibilityLabel = src.accessibilityLabel;
      this.accessibilityParent = src.accessibilityParent;
      this.accessibilityRole = src.accessibilityRole;
      this.accessibilityRoleDescription = src.accessibilityRoleDescription;
      this.accessibilitySubrole = src.accessibilitySubrole;
      this.attributeValues = new Map(src.attributeValues);
      this.isAccessibilityElement = src.isAccessibilityElement;
      this.isAccessibilityEnabled = src.isAccessibilityEnabled;
    }

    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @returns {void}
     */

  }, {
    key: '_render',
    value: function _render(gl) {
      // nothing to draw
    }
  }, {
    key: '_copyTransformToPresentation',
    value: function _copyTransformToPresentation() {
      if (this.__presentation === null) {
        return;
      }
      var p = this.__presentation;
      p.position = this.position;
      p.zPosition = this.zPosition;
      p.xScale = this.xScale;
      p.yScale = this.yScale;
      p.zRotation = this.zRotation;
    }
  }, {
    key: '_updateWorldTransform',
    value: function _updateWorldTransform() {
      var p = null;
      var pz = 0;
      if (this._parent === null) {
        p = new _CGPoint2.default(0, 0);
      } else {
        p = this._parent._worldPosition;
        pz = this._parent._worldZPosition;
      }
      this._worldPosition = this.position.add(p);
      this._worldZPosition = this.zPosition + pz;

      if (this._presentation) {
        var pp = null;
        var ppz = 0;
        var pxScale = 1;
        var pyScale = 1;
        if (this._parent === null) {
          pp = new _CGPoint2.default(0, 0);
        } else if (this._parent._presentation === null) {
          pp = this._parent._worldPosition;
          ppz = this._parent._worldZPosition;
          pxScale = this._parent._worldXScale;
          pyScale = this._parent._worldYScale;
        } else {
          pp = this._parent._presentation._worldPosition;
          ppz = this._parent._presentation._worldZPosition;
          pxScale = this._parent._presentation._worldXScale;
          pyScale = this._parent._presentation._worldYScale;
        }
        //this._presentation._worldPosition = this._presentation.position.add(pp)
        this._presentation._worldPosition.x = pp.x + this._presentation.position.x * pxScale;
        this._presentation._worldPosition.y = pp.y + this._presentation.position.y * pyScale;
        this._presentation._worldZPosition = this._presentation.zPosition + ppz;
        this._presentation._worldXScale = this._presentation.xScale * pxScale;
        this._presentation._worldYScale = this._presentation.yScale * pyScale;
      }

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this._children[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var child = _step5.value;

          child._updateWorldTransform();
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
  }, {
    key: 'frame',
    get: function get() {
      return this._frame;
    }
  }, {
    key: 'children',
    get: function get() {
      return this._children.slice(0);
    }
    /**
     * The node’s parent node.
     * @type {?SKNode}
     * @desc If the node is not in a node tree, the value is nil.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483080-parent
     */

  }, {
    key: 'parent',
    get: function get() {
      return this._parent;
    }

    /**
     * The scene node that contains the node.
     * @type {?SKScene}
     * @desc If the node is not embedded in a scene, the value is nil.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483064-scene
     */

  }, {
    key: 'scene',
    get: function get() {
      return this._scene;
    }
  }, {
    key: '_presentation',
    get: function get() {
      return this.__presentation;
    }
  }], [{
    key: 'nodeWithFileNamed',
    value: function nodeWithFileNamed(filename) {
      var node = new SKNode();
      return node;
    }
  }, {
    key: 'obstaclesFromNodeBounds',
    value: function obstaclesFromNodeBounds(nodes) {
      return null;
    }

    /**
     * Converts each node into an obstacle by transforming the node’s physics body shape into the scene’s coordinate system.
     * @access public
     * @param {SKNode[]} nodes - An array of SKNode objects.
     * @returns {GKPolygonObstacle[]} - 
     * @desc Use the array of obstacles to create an obstacle graph (GKObstacleGraph) in GameplayKit. See GameplayKit and GameplayKit Programming Guide.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483085-obstacles
     */

  }, {
    key: 'obstaclesFromNodePhysicsBodies',
    value: function obstaclesFromNodePhysicsBodies(nodes) {
      return null;
    }

    /**
     * Converts each node into an obstacle by first transforming the node’s texture into a physics shape and then converting that shape into the scene’s coordinate system.
     * @access public
     * @param {SKNode[]} sprites - An array of SKNode objects.
     * @param {number} accuracy - A floating point value between 0.001 and 1.0, inclusive. Higher values create a more precise (but more complex) representation of the obstacle.
     * @returns {GKPolygonObstacle[]} - 
     * @desc Use the array of obstacles to create an obstacle graph (GKObstacleGraph) in GameplayKit. See GameplayKit and GameplayKit Programming Guide.
     * @see https://developer.apple.com/documentation/spritekit/sknode/1483134-obstacles
     */

  }, {
    key: 'obstaclesFromSpriteTextures',
    value: function obstaclesFromSpriteTextures(sprites, accuracy) {
      return null;
    }
  }]);

  return SKNode;
}(_NSObject3.default);

exports.default = SKNode;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SKActionTimingMode = __webpack_require__(23);

var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

var _CGRect = __webpack_require__(16);

var _CGRect2 = _interopRequireDefault(_CGRect);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import CGVector from '../CoreGraphics/CGVector'

//import CGPath from '../CoreGraphics/CGPath'

//import SKTexture from './SKTexture'
//import SKWarpGeometry from './SKWarpGeometry'
//import SKNode from './SKNode'
//import SKActionTimingFunction from './SKActionTimingFunction'


/**
 * An object that is executed by an SKNode to change its structure or content.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/spritekit/skaction
 */
var SKAction = function (_NSObject) {
  _inherits(SKAction, _NSObject);

  // Creating Custom Actions

  /**
   * Creates an action of the given name from an action file with a new duration.
   * @access public
   * @constructor
   * @param {string} name - The name of the action.
   * @param {string} url - The URL of the file containing the action.
   * @param {number} sec - The duration of the action, in seconds.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417754-init
   */
  function SKAction(name, url, sec) {
    _classCallCheck(this, SKAction);

    // Inspecting an Action’s Animation Properties

    /**
     * A speed factor that modifies how fast an action runs.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417718-speed
     */
    var _this = _possibleConstructorReturn(this, (SKAction.__proto__ || Object.getPrototypeOf(SKAction)).call(this));

    _this._speed = 1.0;

    /**
     * The timing mode used to execute an action.
     * @type {SKActionTimingMode}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417807-timingmode
     */
    _this._timingMode = _SKActionTimingMode2.default.linear;

    /**
     * A block used to customize the timing function.
     * @type {SKActionTimingFunction}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417666-timingfunction
     */
    _this._timingFunction = null;

    /**
     * The duration required to complete an action.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417790-duration
     */
    _this._duration = 0;

    /**
     * @access private
     * @type {boolean}
     */
    _this._finished = false;

    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    _this._completionHandler = null;

    _this.__actionStartTime = null;
    return _this;
  }

  /**
   * A speed factor that modifies how fast an action runs.
   * @type {number}
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417718-speed
   */


  _createClass(SKAction, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SKAction} -
     */
    value: function copy() {
      var action = _get(SKAction.prototype.__proto__ || Object.getPrototypeOf(SKAction.prototype), 'copy', this).call(this);

      action._beginTime = this._beginTime;
      action._duration = this._duration;
      action._speed = this.speed;
      action._timingMode = this.timingMode;
      action._timingFunction = this.timingFunction;
      action._finished = this._finished;
      //action._isRunning = this._isRunning
      //action._pausedTime = this._pausedTime
      //action._completionHandler = this._completionHandler

      return action;
    }

    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAction',
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var t = this._getTime(time, needTimeConversion
      //this._handleEvents(obj, t)
      );
    }
  }, {
    key: '_getTime',
    value: function _getTime(time, needTimeConversion) {
      if (!needTimeConversion) {
        if (time >= 1.0 && !this._finished) {
          this._finished = true;
        }
        return time;
      }

      var baseTime = this._basetimeFromTime(time);
      if (this.timingFunction === null) {
        return baseTime;
      }

      return this.timingFunction._getValueAtTime(baseTime);
    }

    /**
     * convert parent time to base time
     * @access private
     * @param {number} time - parent time
     * @returns {number} - animation base time for the current frame (0-1 or null).
     */

  }, {
    key: '_basetimeFromTime',
    value: function _basetimeFromTime(time) {
      var activeTime = time - this._actionStartTime;
      return this._basetimeFromActivetime(activeTime);
    }

    /**
     * convert parent time to active time
     * @access private
     * @param {number} time - parent time
     * @returns {number} - animation active time for the current frame.
     */

  }, {
    key: '_activetimeFromTime',
    value: function _activetimeFromTime(time) {
      return time - this._actionStartTime;
    }

    /**
     * convert active time to base time
     * @access private
     * @param {number} time - active time
     * @returns {number} - animation base time for the current frame (0-1 or null).
     */

  }, {
    key: '_basetimeFromActivetime',
    value: function _basetimeFromActivetime(time) {
      var dt = time - this._beginTime;
      //let dt = time
      if (this.speed === 0) {
        return 0;
      }
      if (this._duration === 0) {
        return dt / Math.abs(this.speed);
      }
      var duration = this._duration / Math.abs(this.speed);
      if (duration === 0) {
        duration = 0.25;
      }

      if (dt >= duration) {
        // the action is over.
        if (!this._finished) {
          this._finished = true;
        }
      }

      return dt / duration;
    }

    /**
     * @access private
     * @param {Object} from -
     * @param {Object} to -
     * @param {number} t -
     * @returns {Object} -
     */

  }, {
    key: '_lerp',
    value: function _lerp(from, to, t) {
      if (t === null) {
        // the action is over.
        return to;
      }
      //if(from instanceof SCNVector4){
      //  // TODO: slerp for Quaternion
      //  return from.lerp(to, t)
      //}else if(from instanceof SCNVector3){
      //  return from.lerp(to, t)
      //}else if(from instanceof CGSize){
      if ((0, _InstanceOf3.default)(from, _CGSize2.default)) {
        return from._lerp(to, t);
      } else if ((0, _InstanceOf3.default)(from, _CGPoint2.default)) {
        return from._lerp(to, t);
      } else if ((0, _InstanceOf3.default)(from, _CGRect2.default)) {
        return from._lerp(to, t);
      } else if ((0, _InstanceOf3.default)(from, _SKColor2.default)) {
        return from._lerp(to, t);
      }
      return from + (to - from) * t;
    }

    /**
     * @access private
     * @param {Object} from -
     * @param {Object} to -
     * @param {number} t -
     * @returns {Object} -
     */
    //_slerp(from, to, t) {
    //  if(!(from instanceof SCNVector4)){
    //    throw new Error('SCNAction._slerp: object is not SCNVector4')
    //  }
    //  return from.slerp(to, t)
    //}

  }, {
    key: '_resetFinished',
    value: function _resetFinished() {
      this._finished = false;
    }

    /**
     * Creates an action of the given name from an action file.
     * @access public
     * @param {string} name - The name of the action.
     * @returns {SKAction} -
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417814-init
     */

  }, {
    key: 'reversed',


    // Reversing an Action

    /**
     * Creates an action that reverses the behavior of another action.
     * @access public
     * @returns {SKAction} - 
     * @desc This method always returns an action object; however, not all actions are reversible. When reversed, some actions return an object that either does nothing or that performs the same action as the original action. For details on how an action is reversed, see the description of the class method used to create that action.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417803-reversed
     */
    value: function reversed() {
      return null;
    }
  }, {
    key: 'speed',
    get: function get() {
      return this._speed;
    },
    set: function set(newValue) {
      this._speed = newValue;
    }

    /**
     * The timing mode used to execute an action.
     * @type {SKActionTimingMode}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417807-timingmode
     */

  }, {
    key: 'timingMode',
    get: function get() {
      return this._timingMode;
    },
    set: function set(newValue) {
      this._timingMode = newValue;
    }

    /**
     * A block used to customize the timing function.
     * @type {SKActionTimingFunction}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417666-timingfunction
     */

  }, {
    key: 'timingFunction',
    get: function get() {
      return this._timingFunction;
    },
    set: function set(newValue) {
      this._timingFunction = newValue;
    }

    /**
     * The duration required to complete an action.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417790-duration
     */

  }, {
    key: 'duration',
    get: function get() {
      return this._duration;
    },
    set: function set(newValue) {
      this._duration = newValue;
    }
  }, {
    key: '_actionStartTime',
    get: function get() {
      return this.__actionStartTime;
    },
    set: function set(newValue) {
      this.__actionStartTime = newValue;
    }
  }], [{
    key: 'actionWithName',
    value: function actionWithName(name) {
      return new SKAction(name, null, 0.25);
    }

    /**
     * Creates an action of the given name from an action file with a new duration.
     * @access public
     * @param {string} name - The name of the action.
     * @param {number} sec - The duration of the action.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417697-init
     */

  }, {
    key: 'actionWithNamedDuration',
    value: function actionWithNamedDuration(name, sec) {
      return new SKAction(name, null, sec);
    }

    /**
     * Creates an action of the given name from an action file.
     * @access public
     * @param {string} name - The name of the action.
     * @param {string} url - The URL of the file containing the action.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417680-init
     */

  }, {
    key: 'actionWithNamedFrom',
    value: function actionWithNamedFrom(name, url) {
      return new SKAction(name, url);
    }

    // Creating Actions That Move Nodes

    /**
     * Creates an action that moves a node relative to its current position.
     * @access public
     * @param {number} deltaX - The x-value, in points, to add to the node’s position.
     * @param {number} deltaY - The y-value, in points, to add to the node’s position.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code is executed:let negDelta = CGVector(dx: -deltaX, dy: -deltaY)
    let action = SKAction.moveBy(x: -deltaX, y: -deltaX, duration: sec)
    let negDelta = CGVector(dx: -deltaX, dy: -deltaY)
    let action = SKAction.moveBy(x: -deltaX, y: -deltaX, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417722-moveby
     */

  }, {
    key: 'moveByXYDuration',
    value: function moveByXYDuration(deltaX, deltaY, sec) {
      return null;
    }

    /**
     * Creates an action that moves a node relative to its current position.
     * @access public
     * @param {CGVector} delta - A vector that describes the change to apply to the node’s position.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code is executed:let negDelta = CGVector(dx: -deltaX, dy: -deltaY)
    let action = SKAction.move(by: negDelta, duration: sec)
    let negDelta = CGVector(dx: -deltaX, dy: -deltaY)
    let action = SKAction.move(by: negDelta, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417739-move
     */

  }, {
    key: 'moveByDuration',
    value: function moveByDuration(delta, sec) {
      return null;
    }

    /**
     * Creates an action that moves a node to a new position.
     * @access public
     * @param {CGPoint} location - The coordinates for the node’s new position.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is not reversible; the reverse of this action has the same duration but does not move the node.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417768-move
     */

  }, {
    key: 'moveToDuration',
    value: function moveToDuration(location, sec) {
      return null;
    }

    /**
     * Creates an action that moves the node along a relative path, orienting the node to the path.
     * @access public
     * @param {CGPath} path - A Core Graphics path whose coordinates are relative to the node’s current position.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc Calling this method is equivalent to calling the follow(_:asOffset:orientToPath:duration:) method, passing in true to both the offset and orient parameters.This action is reversible; the resulting action creates and then follows a reversed path with the same duration.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417822-follow
     */

  }, {
    key: 'followDuration',
    value: function followDuration(path, sec) {
      return null;
    }

    /**
     * Creates an action that moves the node along a relative path at a specified speed, orienting the node to the path.
     * @access public
     * @param {CGPath} path - A Core Graphics path whose coordinates are relative to the node’s current position.
     * @param {number} speed - The speed at which the node should move, in points per second.
     * @returns {SKAction} - 
     * @desc Calling this method is equivalent to calling the follow(_:asOffset:orientToPath:speed:) method, passing in true to both the offset and orient parameters.This action is reversible; the resulting action creates and then follows a reversed path with the same speed.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417786-follow
     */

  }, {
    key: 'follow',
    value: function follow(path, speed) {
      return null;
    }

    /**
     * Creates an action that moves the node along a path.
     * @access public
     * @param {CGPath} path - A path to follow.
     * @param {boolean} offset - If true, the points in the path are relative offsets to the node’s starting position. If false, the points in the node are absolute coordinate values.
     * @param {boolean} orient - If true, the node’s zRotation property animates so that the node turns to follow the path. If false, the zRotation property of the node is unchanged.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s position and zRotation properties are animated along the provided path.This action is reversible; the resulting action creates a reversed path and then follows it, with the same duration.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417662-follow
     */

  }, {
    key: 'followAsOffsetOrientToPathDuration',
    value: function followAsOffsetOrientToPathDuration(path, offset, orient, sec) {
      return null;
    }

    /**
     * Creates an action that moves the node at a specified speed along a path.
     * @access public
     * @param {CGPath} path - A path to follow.
     * @param {boolean} offset - If true, the points in the path are relative offsets to the node’s starting position. If false, the points in the node are absolute coordinate values.
     * @param {boolean} orient - If true, the node’s zRotation property animates so that the node turns to follow the path. If false, the zRotation property of the node is unchanged.
     * @param {number} speed - The speed at which the node should move, in points per second.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s position and zRotation properties are animated along the provided path. The duration of the action is determined by the length of the path and the speed of the node.This action is reversible; the resulting action creates a reversed path and then follows it, with the same speed.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417798-follow
     */

  }, {
    key: 'followAsOffsetOrientToPath',
    value: function followAsOffsetOrientToPath(path, offset, orient, speed) {
      return null;
    }

    // Creating Actions That Rotate Nodes

    /**
     * Creates an action that rotates the node by a relative value.
     * @access public
     * @param {number} radians - The amount to rotate the node, in radians.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s zRotation property animates to the new angle.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.rotate(byAngle: -radians, duration: sec)
    let action = SKAction.rotate(byAngle: -radians, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417805-rotate
     */

  }, {
    key: 'rotateByAngleDuration',
    value: function rotateByAngleDuration(radians, sec) {
      return null;
    }

    /**
     * Creates an action that rotates the node counterclockwise to an absolute angle.
     * @access public
     * @param {number} radians - The angle to rotate the node to, in radians.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s zRotation property is interpolated to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417668-rotate
     */

  }, {
    key: 'rotateToAngleDuration',
    value: function rotateToAngleDuration(radians, sec) {
      return null;
    }

    // Creating Actions That Change a Node’s Animation Speed

    /**
     * Creates an action that changes how fast the node executes actions by a relative value.
     * @access public
     * @param {number} speed - The amount to add to the node’s speed.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s speed property animates to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.speed(by: -speed, duration: sec)
    let action = SKAction.speed(by: -speed, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417690-speed
     */

  }, {
    key: 'speedByDuration',
    value: function speedByDuration(speed, sec) {
      return null;
    }

    /**
     * Creates an action that changes how fast the node executes actions.
     * @access public
     * @param {number} speed - The new value for the node’s speed.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s speed property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417684-speed
     */

  }, {
    key: 'speedToDuration',
    value: function speedToDuration(speed, sec) {
      return null;
    }

    // Creating Actions That Change a Node’s Scale

    /**
     * Creates an action that changes the x and y scale values of a node by a relative value.
     * @access public
     * @param {number} scale - The amount to add to the node’s x and y scale values.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s xScale and yScale properties are animated to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.scale(by: -scale, duration: sec)
    let action = SKAction.scale(by: -scale, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417741-scale
     */

  }, {
    key: 'scaleByDuration',
    value: function scaleByDuration(scale, sec) {
      return null;
    }

    /**
     * Creates an action that changes the x and y scale values of a node to achieve 
     * @access public
     * @param {CGSize} size - The new size of the node.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s xScale and yScale properties are animated to achieve the specified size in its parent's coordinate space. This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1643619-scale
     */

  }, {
    key: 'scaleToDuration',
    value: function scaleToDuration(size, sec) {
      return null;
    }

    /**
     * Creates an action that adds relative values to the x and y scale values of a node.
     * @access public
     * @param {number} xScale - The amount to add to the node’s x scale value.
     * @param {number} yScale - The amount to add to the node’s y scale value.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s xScale and yScale properties are animated to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)
    let action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417796-scalex
     */

  }, {
    key: 'scaleXByYDuration',
    value: function scaleXByYDuration(xScale, yScale, sec) {
      return null;
    }

    /**
     * Creates an action that changes the x and y scale values of a node.
     * @access public
     * @param {number} xScale - The new value for the node’s x scale value.
     * @param {number} yScale - The new value for the node’s y scale value.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s xScale and yScale properties are animated to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417728-scalex
     */

  }, {
    key: 'scaleXToYDuration',
    value: function scaleXToYDuration(xScale, yScale, sec) {
      return null;
    }

    /**
     * Creates an action that changes the x scale value of a node to a new value.
     * @access public
     * @param {number} scale - The new value for the node’s x scale value.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s xScale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417699-scalex
     */

  }, {
    key: 'scaleXToDuration',
    value: function scaleXToDuration(scale, sec) {
      return null;
    }

    /**
     * Creates an action that changes the y scale value of a node to a new value.
     * @access public
     * @param {number} scale - The new value for the node’s y scale value.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s yScale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417708-scaley
     */

  }, {
    key: 'scaleYToDuration',
    value: function scaleYToDuration(scale, sec) {
      return null;
    }

    // Creating Actions to Show or Hide a Node

    /**
     * Creates an action that makes a node visible.
     * @access public
     * @returns {SKAction} - 
     * @desc This action has an instantaneous duration. When the action executes, the node’s isHidden property is set to false.This action is reversible; the reversed action hides the node.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417660-unhide
     */

  }, {
    key: 'unhide',
    value: function unhide() {
      return null;
    }

    /**
     * Creates an action that hides a node.
     * @access public
     * @returns {SKAction} - 
     * @desc This action has an instantaneous duration. When the action executes, the node’s isHidden property is set to true.This action is reversible; the reversed action shows the node.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417704-hide
     */

  }, {
    key: 'hide',
    value: function hide() {
      return null;
    }

    // Creating Actions That Change a Node’s Transparency

    /**
     * Creates an action that changes the alpha value of the node to 1.0.
     * @access public
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s alpha property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeOut(withDuration: sec)
    let action = SKAction.fadeOut(withDuration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417818-fadein
     */

  }, {
    key: 'fadeInWithDuration',
    value: function fadeInWithDuration(sec) {
      return null;
    }

    /**
     * Creates an action that changes the alpha value of the node to 0.0.
     * @access public
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s alpha property animates from its current value to 0.0. This causes the node to disappear.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeIn(withDuration: sec)
    let action = SKAction.fadeIn(withDuration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417738-fadeout
     */

  }, {
    key: 'fadeOutWithDuration',
    value: function fadeOutWithDuration(sec) {
      return null;
    }

    /**
     * Creates an action that adjusts the alpha value of a node by a relative value.
     * @access public
     * @param {number} factor - The amount to add to the node’s alpha value.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s alpha property animates to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeAlpha(by: -factor, duration: sec)
    let action = SKAction.fadeAlpha(by: -factor, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417716-fadealpha
     */

  }, {
    key: 'fadeAlphaByDuration',
    value: function fadeAlphaByDuration(factor, sec) {
      return null;
    }

    /**
     * Creates an action that adjusts the alpha value of a node to a new value.
     * @access public
     * @param {number} alpha - The new value of the node’s alpha.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s alpha property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417673-fadealpha
     */

  }, {
    key: 'fadeAlphaToDuration',
    value: function fadeAlphaToDuration(alpha, sec) {
      return null;
    }

    // Creating Actions That Change a Sprite Node’s Content

    /**
     * Creates an action that adjusts the size of a sprite.
     * @access public
     * @param {number} width - The amount to add to the sprite’s width.
     * @param {number} height - The amount to add to the sprite’s height.
     * @param {number} duration - The duration of the animation.
     * @returns {SKAction} - 
     * @desc This action can only be executed by a SKSpriteNode object. When the action executes, the sprite’s size property animates to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.resize(byWidth: -width, height: -height, duration: sec)
    let action = SKAction.resize(byWidth: -width, height: -height, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417812-resize
     */

  }, {
    key: 'resizeByWidth',
    value: function resizeByWidth(width, height, duration) {
      return null;
    }

    /**
     * Creates an action that changes the height of a sprite to a new absolute value.
     * @access public
     * @param {number} height - The new height of the sprite.
     * @param {number} duration - The duration of the animation.
     * @returns {SKAction} - 
     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s size property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417825-resize
     */

  }, {
    key: 'resizeToHeight',
    value: function resizeToHeight(height, duration) {
      return null;
    }

    /**
     * Creates an action that changes the width of a sprite to a new absolute value.
     * @access public
     * @param {number} width - The new width of the sprite.
     * @param {number} duration - The duration of the animation.
     * @returns {SKAction} - 
     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s size property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417686-resize
     */

  }, {
    key: 'resizeToWidth',
    value: function resizeToWidth(width, duration) {
      return null;
    }

    /**
     * Creates an action that changes a sprite’s texture.
     * @access public
     * @param {SKTexture} texture - The new texture to use on the sprite.
     * @returns {SKAction} - 
     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s texture property changes immediately to the new texture.This action is not reversible; the reverse of this action does nothing.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417784-settexture
     */

  }, {
    key: 'setTexture',
    value: function setTexture(texture) {
      return null;
    }

    /**
     * Creates an action that animates changes to a sprite’s texture.
     * @access public
     * @param {SKTexture[]} textures - An array of textures to use when animating a sprite.
     * @param {number} sec - The duration, in seconds, that each texture is displayed. 
     * @returns {SKAction} - 
     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s texture property animates through the array of textures. The sprite’s texture property is changed to the next texture in the array. The action then pauses for the specified time before continuing. The action continues until it has finished animating through all of the textures in the array. The total duration of the action is the number of textures multiplied by the frame interval.This action is reversible; the resulting action animates through the same textures from last to first.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417828-animate
     */

  }, {
    key: 'animateWithTimePerFrame',
    value: function animateWithTimePerFrame(textures, sec) {
      return null;
    }

    /**
     * Creates an action that changes a sprite’s normal texture.
     * @access public
     * @param {SKTexture} texture - The new texture to use on the sprite.
     * @returns {SKAction} - 
     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s normalTexture property changes immediately to the new texture.This action is not reversible; the reverse of this action does nothing.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417706-setnormaltexture
     */

  }, {
    key: 'setNormalTexture',
    value: function setNormalTexture(texture) {
      return null;
    }

    /**
     * Creates an action that animates changes to a sprite’s normal texture.
     * @access public
     * @param {SKTexture[]} textures - An array of textures to use.
     * @param {number} sec - The amount of time that each texture is displayed.
     * @returns {SKAction} - 
     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s normalTexture property animates through the array of textures. The sprite’s normalTexture property is changed to the next texture in the array. The action then pauses for the specified time before continuing. The action continues until it has finished animating through all of the textures in the array. The total duration of the action is the number of textures multiplied by the frame interval.This action is reversible; the resulting action animates through the same textures from last to first.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417746-animate
     */

  }, {
    key: 'animateWithNormalTexturesTimePerFrame',
    value: function animateWithNormalTexturesTimePerFrame(textures, sec) {
      return null;
    }

    /**
     * Creates an animation that animates a sprite’s color and blend factor.
     * @access public
     * @param {CGColor} color - The new color for the sprite.
     * @param {number} colorBlendFactor - The new blend factor for the sprite.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprite’s color and colorBlendFactor properties are animated to their new values.This action is not reversible; the reverse of this action does nothing.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417678-colorize
     */

  }, {
    key: 'colorizeWithDuration',
    value: function colorizeWithDuration(color, colorBlendFactor, sec) {
      return null;
    }

    // Creating Physics Actions

    /**
     * Creates an action that applies a force to the center of gravity of a node’s physics body.
     * @access public
     * @param {CGVector} force - A vector that describes how much force is applied in each dimension. The force is measured in Newtons.
     * @param {number} sec - The duration over which the force is applied to the physics body.
     * @returns {SKAction} - 
     * @desc When the action executes, the force is applied continuously to the physics body for the duration of the action. This action accelerates the body without imparting any angular acceleration to it.This action is reversible; it applies an equal force in the opposite direction.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417782-applyforce
     */

  }, {
    key: 'applyForceDuration',
    value: function applyForceDuration(force, sec) {
      return null;
    }

    /**
     * Creates an action that applies a torque to an node’s physics body.
     * @access public
     * @param {number} torque - The amount of torque, in Newton-meters.
     * @param {number} sec - The duration over which the torque is applied to the physics body.
     * @returns {SKAction} - 
     * @desc When the action executes, the torque is applied continuously to the physics body for the duration of the action. This action generates an angular acceleration on the body without causing any linear acceleration.This action is reversible; it applies an equal torque in the opposite direction.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417756-applytorque
     */

  }, {
    key: 'applyTorqueDuration',
    value: function applyTorqueDuration(torque, sec) {
      return null;
    }

    /**
     * Creates an action that applies an force to a specific point on a node’s physics body.
     * @access public
     * @param {CGVector} force - A vector that describes how much force is applied in each dimension. The force is measured in Newtons.
     * @param {CGPoint} point - A point in scene coordinates that defines where the force is applied to the physics body.
     * @param {number} sec - The duration over which the force is applied to the physics body.
     * @returns {SKAction} - 
     * @desc When the action executes, the force is applied continuously to the physics body for the duration of the action. Because the force is applied to a specific point on the body, it may impart both linear acceleration and angular acceleration. This action is reversible; it applies an equal force in the opposite direction.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417823-applyforce
     */

  }, {
    key: 'applyForceAtDuration',
    value: function applyForceAtDuration(force, point, sec) {
      return null;
    }

    /**
     * Creates an action that applies an impulse to the center of gravity of a physics body.
     * @access public
     * @param {CGVector} impulse - A vector that describes how much momentum to impart to the body in each dimension over the duration of the action. The impulse is measured in Newton-seconds.
     * @param {number} sec - The duration over which the total impulse should be applied to the physics body.
     * @returns {SKAction} - 
     * @desc When the action executes, applies a constant force to the physics body for the duration of the action. The force is calculated by dividing the impulse strength by the duration of the action. For example, if an impulse of 1 Newton-second is applied to the physics body, and the the duration is 10 seconds, then a force of 0.1 Newtons is applied to the physics body.This action is reversible; it applies an equal impulse in the opposite direction.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417770-applyimpulse
     */

  }, {
    key: 'applyImpulseDuration',
    value: function applyImpulseDuration(impulse, sec) {
      return null;
    }

    /**
     * Creates an action that applies an angular impulse to a node’s physics body.
     * @access public
     * @param {number} impulse - The total impulse to apply to the physics body. The impulse is measured in Newton-seconds.
     * @param {number} sec - The number of seconds over which to apply the impulse. For example, if you specify a duration of four seconds, one quarter of the impulse will be applied each second.
     * @returns {SKAction} - 
     * @desc When the action executes, applies a constant torque to the physics body for the duration of the action. The torque is calculated by dividing the impulse strength by the duration of the action. This action affects the body’s angular velocity without changing the body’s linear velocity.This action is reversible; it applies an equal angular impulse in the opposite direction.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417775-applyangularimpulse
     */

  }, {
    key: 'applyAngularImpulseDuration',
    value: function applyAngularImpulseDuration(impulse, sec) {
      return null;
    }

    /**
     * Creates an action that applies an impulse to a specific point of a node’s physics body.
     * @access public
     * @param {CGVector} impulse - The total impulse to apply to the physics body. The impulse is measured in Newton-seconds.
     * @param {CGPoint} point - A point in scene coordinates that defines where the impulse was applied to the physics body.
     * @param {number} sec - A new action object.
     * @returns {SKAction} - 
     * @desc When the action executes, applies a constant force to the physics body for the duration of the action. The force is calculated by dividing the impulse strength by the duration of the action. For example, if an impulse of 1 Newton-second is applied to the physics body, and the the duration is 10 seconds, then a force of 0.1 Newtons is applied to the physics body. Because the force is applied to a specific point on the body, it may impart both linear acceleration and angular acceleration.This action is reversible; it applies an equal impulse in the opposite direction.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417732-applyimpulse
     */

  }, {
    key: 'applyImpulseAtDuration',
    value: function applyImpulseAtDuration(impulse, point, sec) {
      return null;
    }

    /**
     * Creates an action that changes the charge of a node’s physics body to a new value.
     * @access public
     * @param {number} v - The new charge of the physics body.
     * @param {number} duration - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the physics body’s charge property animates from its current value to its new value.This action is not reversible.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417752-changecharge
     */

  }, {
    key: 'changeChargeTo',
    value: function changeChargeTo(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes the charge of a node’s physics body by a relative value.
     * @access public
     * @param {number} v - The amount to add to the physics body’s charge.
     * @param {number} duration - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the physics body’s charge property animates from its current value to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeCharge(by: -v, duration: sec)
    let action = SKAction.changeCharge(by: -v, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417714-changecharge
     */

  }, {
    key: 'changeChargeBy',
    value: function changeChargeBy(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes the mass of a node’s physics body to a new value.
     * @access public
     * @param {number} v - The new mass of the physics body.
     * @param {number} duration - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the physics body’s mass property animates from its current value to its new value.This action is not reversible.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417780-changemass
     */

  }, {
    key: 'changeMassTo',
    value: function changeMassTo(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes the mass of a node’s physics body by a relative value.
     * @access public
     * @param {number} v - The amount to add to the physics body’s mass.
     * @param {number} duration - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the physics body’s mass property animates from its current value to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeMass(by: -v, duration: sec)
    let action = SKAction.changeMass(by: -v, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417710-changemass
     */

  }, {
    key: 'changeMassBy',
    value: function changeMassBy(v, duration) {
      return null;
    }

    /**
     * Creates an action that animates a change of a physics field’s strength.
     * @access public
     * @param {number} strength - The new strength for the field.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the field node’s strength property animates from its current value to its new value.This action is not reversible; the reverse of this action has the same duration but does not do anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417815-strength
     */

  }, {
    key: 'strengthToDuration',
    value: function strengthToDuration(strength, sec) {
      return null;
    }

    /**
     * Creates an action that animates a change of a physics field’s strength to a value relative to the existing value.
     * @access public
     * @param {number} strength - The value to add to the field.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the field node’s strength property animates from its current value to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.strength(by: -strength, duration: sec)
    let action = SKAction.strength(by: -strength, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417762-strength
     */

  }, {
    key: 'strengthByDuration',
    value: function strengthByDuration(strength, sec) {
      return null;
    }

    /**
     * Creates an action that animates a change of a physics field’s falloff.
     * @access public
     * @param {number} falloff - The new falloff for the field.
     * @param {number} sec - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action runs, the field node’s falloff property animates from its current value to its new value. This action is not reversible.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417758-falloff
     */

  }, {
    key: 'falloffToDuration',
    value: function falloffToDuration(falloff, sec) {
      return null;
    }

    /**
     * Creates an action that animates a change of a physics field’s falloff to a value relative to the existing value.
     * @access public
     * @param {number} falloff - The value to add to the falloff.
     * @param {number} sec - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the field node’s falloff property animates from its current value to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.falloff(by: -falloff, duration: sec)
    let action = SKAction.falloff(by: -falloff, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417766-falloff
     */

  }, {
    key: 'falloffByDuration',
    value: function falloffByDuration(falloff, sec) {
      return null;
    }

    // Creating Actions to Warp a Node

    /**
     * Creates an action to distort a node through a sequence of SKWarpGeometry objects.  
     * @access public
     * @param {SKWarpGeometry[]} warps - The sequence of warps to apply to the node.
     * @param {number[]} times - The times at which each warp distortion in the sequence should complete.
     * @returns {?SKAction} - 
     * @desc The numberOfColumns and numberOfRows in each geometry in the sequence should match.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1690937-animate
     */

  }, {
    key: 'animateWithWarps',
    value: function animateWithWarps(warps, times) {
      return null;
    }

    /**
     * Creates an action to distort a node based using an SKWarpGeometry object.  
     * @access public
     * @param {SKWarpGeometry} warp - The warp geometry to distort the node to.
     * @param {number} duration - The duration of the animation.
     * @returns {?SKAction} - 
     * @desc The numberOfColumns and numberOfRows in the node's current geometry should match those of the specified geometry.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1690951-warp
     */

  }, {
    key: 'warpTo',
    value: function warpTo(warp, duration) {
      return null;
    }

    // Creating Audio Actions

    /**
     * Creates an action that plays a sound.
     * @access public
     * @param {string} soundFile - The name of a sound file in the app’s bundle.
     * @param {boolean} wait - If true, the duration of this action is the same as the length of the audio playback. If false, the action is considered to have completed immediately.
     * @returns {SKAction} - 
     * @desc Use SKAction playSoundFileNamed:waitForCompletion: only for short incidentals. Use AVAudioPlayer for long running background music. This action is not reversible; the reversed action is identical to the original action.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417664-playsoundfilenamed
     */

  }, {
    key: 'playSoundFileNamedWaitForCompletion',
    value: function playSoundFileNamedWaitForCompletion(soundFile, wait) {
      return null;
    }

    /**
     * Creates an action that tells an audio node to start playback.
     * @access public
     * @returns {SKAction} - 
     * @desc This action may only be executed on an SKAudioNode object.This action is not reversible.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417730-play
     */

  }, {
    key: 'play',
    value: function play() {
      return null;
    }

    /**
     * Creates an action that tells an audio node to pause playback.
     * @access public
     * @returns {SKAction} - 
     * @desc This action may only be executed on an SKAudioNode object. The audio is paused, and if restarted, resumes at where it was paused.This action is not reversible.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417820-pause
     */

  }, {
    key: 'pause',
    value: function pause() {
      return null;
    }

    /**
     * Creates an action that tells an audio node to stop playback.
     * @access public
     * @returns {SKAction} - 
     * @desc This action may only be executed on an SKAudioNode object. The audio is stopped, and if restarted, begins at the beginning.This action is not reversible.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417794-stop
     */

  }, {
    key: 'stop',
    value: function stop() {
      return null;
    }

    /**
     * Creates an action that changes an audio node’s playback rate to a new value.
     * @access public
     * @param {number} v - The new value for the playback rate. A playback rate of 1.0 represents normal speed.
     * @param {number} duration - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the audio node’s playback rate animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is not reversible.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417808-changeplaybackrate
     */

  }, {
    key: 'changePlaybackRateTo',
    value: function changePlaybackRateTo(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes an audio node’s playback rate by a relative amount.
     * @access public
     * @param {number} v - The amount to change the playback rate by. A playback rate of 1.0 represents normal speed.
     * @param {number} duration - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the audio node’s playback rate animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changePlaybackRate(by: -v, duration: sec)
    let action = SKAction.changePlaybackRate(by: -v, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417670-changeplaybackrate
     */

  }, {
    key: 'changePlaybackRateBy',
    value: function changePlaybackRateBy(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes an audio node’s volume to a new value.
     * @access public
     * @param {number} v - The new value for the volume. The value should be between 0.0 (silence) and 1.0 (maximum value for source audio), inclusive. 
     * @param {number} duration - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the audio node’s volume animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is not reversible.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417682-changevolume
     */

  }, {
    key: 'changeVolumeTo',
    value: function changeVolumeTo(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes an audio node’s volume by a relative value.
     * @access public
     * @param {number} v - The amount to change the volume by. 
     * @param {number} duration - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the audio node’s volume animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeVolume(by: -v, duration: sec)
    let action = SKAction.changeVolume(by: -v, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417726-changevolume
     */

  }, {
    key: 'changeVolumeBy',
    value: function changeVolumeBy(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes an audio node’s obstruction to a new value.
     * @access public
     * @param {number} v - The new value for the obstruction, in decibels.
     * @param {number} duration - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the audio node’s obstruction animates from its current value to its new value. Passing this action a value of -100 yields the greatest reduction in volume. For more information, see AVAudio3DMixing.This action is not reversible.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1519718-changeobstruction
     */

  }, {
    key: 'changeObstructionTo',
    value: function changeObstructionTo(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes an audio node’s obstruction by a relative value.
     * @access public
     * @param {number} v - The amount to change the obstruction by, in decibels.
     * @param {number} duration - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the audio node’s obstruction animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeObstruction(by: -v, duration: sec)
    let action = SKAction.changeObstruction(by: -v, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1520346-changeobstruction
     */

  }, {
    key: 'changeObstructionBy',
    value: function changeObstructionBy(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes an audio node’s occlusion to a new value.
     * @access public
     * @param {number} v - The new value for the occlusion, in decibels.
     * @param {number} duration - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the audio node’s occlusion animates from its current value to its new value. Passing this action a value of -100 yields the greatest reduction in volume. For more information, see AVAudio3DMixing.This action is not reversible.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1520433-changeocclusion
     */

  }, {
    key: 'changeOcclusionTo',
    value: function changeOcclusionTo(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes an audio node’s occlusion by a relative value.
     * @access public
     * @param {number} v - The amount to change the occlusion by, in decibels.
     * @param {number} duration - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the audio node’s occlusion animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeOcclusion(by: -v, duration: sec)
    let action = SKAction.changeOcclusion(by: -v, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1520117-changeocclusion
     */

  }, {
    key: 'changeOcclusionBy',
    value: function changeOcclusionBy(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes an audio node’s reverb to a new value.
     * @access public
     * @param {number} v - The new value for the reverb. The value should be between 0.0 and 1.0, inclusive.
     * @param {number} duration - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the audio node’s reverb animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is not reversible.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1520320-changereverb
     */

  }, {
    key: 'changeReverbTo',
    value: function changeReverbTo(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes an audio node’s reverb by a relative value.
     * @access public
     * @param {number} v - The amount to change the reverb by.
     * @param {number} duration - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the audio node’s reverb animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeReverb(by: -v, duration: sec)
    let action = SKAction.changeReverb(by: -v, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1519568-changereverb
     */

  }, {
    key: 'changeReverbBy',
    value: function changeReverbBy(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes an audio node’s stereo panning to a new value.
     * @access public
     * @param {number} v - The new value for stereo panning. The value must between -1.0 (left channel only) and 1.0 (right channel only), inclusive.
     * @param {number} duration - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the audio node’s stereo panning animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is not reversible.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1519976-stereopan
     */

  }, {
    key: 'stereoPanTo',
    value: function stereoPanTo(v, duration) {
      return null;
    }

    /**
     * Creates an action that changes an audio node’s stereo panning by a relative value.
     * @access public
     * @param {number} v - The amount to change the stereo panning by. 
     * @param {number} duration - The duration of the animation, in seconds.
     * @returns {SKAction} - 
     * @desc When the action executes, the audio node’s stereo panning animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.stereoPan(by: -v, duration: sec)
    let action = SKAction.stereoPan(by: -v, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1519713-stereopan
     */

  }, {
    key: 'stereoPanBy',
    value: function stereoPanBy(v, duration) {
      return null;
    }

    // Removing Nodes from the Scene

    /**
     * Creates an action that removes the node from its parent.
     * @access public
     * @returns {SKAction} - 
     * @desc When the action executes, the node is immediately removed from its parent.This action is not reversible; the reverse of this action is the same action.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417748-removefromparent
     */

  }, {
    key: 'removeFromParent',
    value: function removeFromParent() {
      return null;
    }

    // Creating Actions That Perform Actions on a Node’s Child

    /**
     * Creates an action that runs an action on a named child object.
     * @access public
     * @param {SKAction} action - The action to execute.
     * @param {string} name - The name of a child object. See the name property on the SKNode object.
     * @returns {SKAction} - 
     * @desc This action has an instantaneous duration, although the action executed on the child may have a duration of its own. When the action executes, it looks up an appropriate child node and calls its run(_:) method, passing in the action to execute. This action is reversible; it tells the child to execute the reverse of the action specified by the action parameter.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417671-run
     */

  }, {
    key: 'runOnChildWithName',
    value: function runOnChildWithName(action, name) {
      return null;
    }

    // Creating Actions That Combine or Repeat Other Actions

    /**
     * Creates an action that runs a collection of actions in parallel.
     * @access public
     * @param {SKAction[]} actions - An array of SKAction objects.
     * @returns {SKAction} - 
     * @desc When the action executes, the actions that comprise the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the group’s duration, the action completes, then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417688-group
     */

  }, {
    key: 'group',
    value: function group(actions) {
      return null;
    }

    /**
     * Creates an action that runs a collection of actions sequentially.
     * @access public
     * @param {SKAction[]} actions - An array of SKAction objects.
     * @returns {SKAction} - 
     * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, if an action sequence is {1,2,3}, the reversed sequence would be {3R,2R,1R}.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417817-sequence
     */

  }, {
    key: 'sequence',
    value: function sequence(actions) {
      return null;
    }

    /**
     * Creates an action that repeats another action a specified number of times.
     * @access public
     * @param {SKAction} action - The action to execute.
     * @param {number} count - The number of times to execute the action.
     * @returns {SKAction} - 
     * @desc When the action executes, the associated action runs to completion and then repeats, until the count is reached.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417750-repeat
     */

  }, {
    key: 'repeat',
    value: function repeat(action, count) {
      return null;
    }

    /**
     * Creates an action that repeats another action forever.
     * @access public
     * @param {SKAction} action - The action to execute.
     * @returns {SKAction} - 
     * @desc When the action executes, the associated action runs to completion and then repeats.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.NoteThe action to be repeated must have a non-instantaneous duration.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417676-repeatforever
     */

  }, {
    key: 'repeatForever',
    value: function repeatForever(action) {
      return null;
    }

    // Creating an Action to Introduce a Delay into a Sequence

    /**
     * Creates an action that idles for a specified period of time.
     * @access public
     * @param {number} sec - The amount of time to wait.
     * @returns {SKAction} - 
     * @desc When the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417788-wait
     */

  }, {
    key: 'waitForDuration',
    value: function waitForDuration(sec) {
      return null;
    }

    /**
     * Creates an action that idles for a randomized period of time.
     * @access public
     * @param {number} sec - The average amount of time to wait.
     * @param {number} durationRange - The range of possible values for the duration.
     * @returns {SKAction} - 
     * @desc When the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417760-wait
     */

  }, {
    key: 'waitForDurationWithRange',
    value: function waitForDurationWithRange(sec, durationRange) {
      return null;
    }

    // Creating Actions to Perform Inverse Kinematic Calculations

    /**
     * Creates an action that performs an inverse kinematic reach.
     * @access public
     * @param {SKNode} node - The node whose position the current node should move closer to. 
     * @param {SKNode} root - The highest level ancestor of the target node that should be rotated.
     * @param {number} sec - The length of the animation.
     * @returns {SKAction} - 
     * @desc This action is typically used to implement character animation across a series of moving parts. When the action executes, it performs an inverse kinematic calculation to determine new rotation values for the target node and any of its ancestors up to and including the root node. Each node is rotated around its anchor point in an attempt to get the targeted node’s position closer to the intended destination. Each node’s rotation value is constrained by that node’s reachConstraints property. If the action cannot successfully reach the target position, it gets the node as close as it can to the target position.This action is not reversible; the reverse of this action is the same action.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417827-reach
     */

  }, {
    key: 'reachToRootNodeDuration',
    value: function reachToRootNodeDuration(node, root, sec) {
      return null;
    }

    /**
     * Creates an action that performs an inverse kinematic reach.
     * @access public
     * @param {CGPoint} position - The intended destination for the node, specified in the scene’s coordinate system. 
     * @param {SKNode} root - The highest level ancestor of the target node that should be rotated.
     * @param {number} velocity - The maximum speed at which the node should move.
     * @returns {SKAction} - 
     * @desc This action is typically used to implement character animation across a series of moving parts. When the action executes, it performs an inverse kinematic calculation to determine new rotation values for the target node and any of its ancestors up to and including the root node. Each node is rotated around its anchor point in an attempt to get the targeted node’s position closer to the intended destination. Each node’s rotation value is constrained by that node’s reachConstraints property. If the action cannot successfully reach the target position, it gets the node as close as it can to the target position.The duration of the action is calculated implicitly based on the speed of movement and the distance that the node needs to travel.This action is not reversible; the reverse of this action is the same action.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417720-reach
     */

  }, {
    key: 'reachToRootNode',
    value: function reachToRootNode(position, root, velocity) {
      return null;
    }

    /**
     * Creates an action that executes a block over a duration.
     * @access public
     * @param {number} seconds - The duration of the action, in seconds.
     * @param {function(arg1: SKNode, arg2: number): void} block - The block to run. The block takes the following parameters:nodeThe node on which the action is running.elapsedTimeThe amount of time that has passed in the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the block is called repeatedly until the action’s duration expires. The elapsed time is computed and passed to the block whenever the block is called.This action is not reversible; the reverse action executes the same block.The following code shows how you can create a custom action to update an attribute of an SKShader attached to a sprite node. let customAction = SKAction.customAction(withDuration: 2.0) {
      node, elapsedTime in
      
      if let node = node as? SKSpriteNode {
          node.setValue(SKAttributeValue(float: Float(elapsedTime)),
                                         forAttribute: "a_time")
      }
    }
    let customAction = SKAction.customAction(withDuration: 2.0) {
      node, elapsedTime in
      
      if let node = node as? SKSpriteNode {
          node.setValue(SKAttributeValue(float: Float(elapsedTime)),
                                         forAttribute: "a_time")
      }
    }
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417745-customaction
     */

  }, {
    key: 'customActionWithDurationActionBlock',
    value: function customActionWithDurationActionBlock(seconds, block) {
      return null;
    }

    /**
     * Creates an action that calls a method on an object.
     * @access public
     * @param {function} selector - The selector of the method to call.
     * @param {Object} target - The target object.
     * @returns {SKAction} - 
     * @desc The action object maintains a strong reference to the target object.When the action executes, the target object’s method is called. This action occurs instantaneously.This action is not reversible; the reverse of this action calls the selector again.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417764-perform
     */

  }, {
    key: 'performOnTarget',
    value: function performOnTarget(selector, target) {
      return null;
    }

    /**
     * Creates an action that executes a block.
     * @access public
     * @param {function(): void} block - The block to run.
     * @returns {SKAction} - 
     * @desc When the action executes, the block is called. This action takes place instantaneously.This action is not reversible; the reverse action executes the same block.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417692-run
     */

  }, {
    key: 'run',
    value: function run(block) {
      return null;
    }
  }]);

  return SKAction;
}(_NSObject3.default);

exports.default = SKAction;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(119)
var ieee754 = __webpack_require__(120)
var isArray = __webpack_require__(121)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(118)))

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * @access public
 * @extends {NSDictionary}
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNOrderedDictionary = function () {
  _createClass(SCNOrderedDictionary, null, [{
    key: 'initWithCoder',

    /**
     * @access public
     * @param {NSCoder} coder -
     * @returns {Object} -
     */
    value: function initWithCoder(coder) {
      var dict = new SCNOrderedDictionary();
      if (typeof coder._refObj['NS.objects'] !== 'undefined') {
        var keys = coder._refObj['NS.keys'];
        var objects = coder._refObj['NS.objects'];
        if (!Array.isArray(keys)) {
          throw new Error('NS.keys must be Array');
        }
        if (!Array.isArray(objects)) {
          throw new Error('NS.objects must be Array');
        }
        if (keys.length !== objects.length) {
          throw new Error('NS.keys.length !== NS.objects.length');
        }

        var keyCoder = coder.copy();
        keyCoder._refObj = keys;

        var objCoder = coder.copy();
        objCoder._refObj = objects;

        for (var i = 0; i < keys.length; i++) {
          var key = keyCoder.decodeObjectForKey(i);
          var obj = objCoder.decodeObjectForKey(i);
          dict._keys.push(key);
          dict._values.push(obj);
        }
      } else {
        for (var _i = 0;; _i++) {
          var objKey = 'NS.object.' + _i;
          var keyKey = 'NS.key.' + _i;
          if (typeof coder._refObj[objKey] === 'undefined') {
            break;
          }
          var _key = coder.decodeObjectForKey(keyKey);
          var _obj = coder.decodeObjectForKey(objKey);
          dict._keys.push(_key);
          dict._values.push(_obj);
        }
      }

      return dict;
    }
  }]);

  function SCNOrderedDictionary() {
    _classCallCheck(this, SCNOrderedDictionary);

    this._keys = [];
    this._values = [];
  }

  _createClass(SCNOrderedDictionary, [{
    key: 'copy',
    value: function copy() {
      var dict = new SCNOrderedDictionary();
      dict._keys = this._keys.slice(0);
      dict._values = this._values.slice(0);
      return dict;
    }
  }, {
    key: 'keys',
    value: function keys() {
      return this._keys.slice(0);
    }
  }, {
    key: 'dictionary',
    value: function dictionary() {
      var dict = {};
      var len = this._keys.length;
      for (var i = 0; i < len; i++) {
        dict[this._keys[i]] = this._values[i];
      }
      return dict;
    }
  }, {
    key: 'allValues',
    value: function allValues() {
      return this._values.slice(0);
    }
  }, {
    key: 'allKeys',
    value: function allKeys() {
      return this.keys();
    }
  }, {
    key: 'count',
    value: function count() {
      return this._keys.length;
    }
  }, {
    key: 'removeAllObjects',
    value: function removeAllObjects() {
      this._keys = [];
      this._values = [];
    }
  }, {
    key: 'removeObjectForKey',
    value: function removeObjectForKey(key) {
      var index = this._keys.indexOf(key);
      if (index < 0) {
        return;
      }
      this._keys.splice(index, 1);
      this._values.splice(index, 1);
    }
  }, {
    key: 'objectForKey',
    value: function objectForKey(key) {
      var index = this._keys.indexOf(key);
      if (index < 0) {
        return null;
      }
      return this._values[index];
    }
  }, {
    key: 'setObjectForKey',
    value: function setObjectForKey(object, key) {
      var index = this._keys.indexOf(key);
      if (index < 0) {
        index = this._keys.length;
        this._keys[index] = key;
      }
      this._values[index] = object;
    }
  }, {
    key: 'valueForKey',
    value: function valueForKey(key) {
      return this.objectForKey(key);
    }
  }, {
    key: 'setValueForKey',
    value: function setValueForKey(value, key) {
      this.setObjectForKey(value, key);
    }

    // extension for JavaScript

  }, {
    key: 'set',
    value: function set(key, object) {
      this.setObjectForKey(object, key);
    }
  }, {
    key: 'get',
    value: function get(key) {
      return this.objectForKey(key);
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.removeAllObjects();
    }
  }, {
    key: 'delete',
    value: function _delete(key) {
      this.removeObjectForKey(key);
    }
  }, {
    key: 'forEach',
    value: function forEach(func) {
      var len = this._keys.length;
      for (var i = 0; i < len; i++) {
        func(this._values[i], this._keys[i]);
      }
    }
  }]);

  return SCNOrderedDictionary;
}();

exports.default = SCNOrderedDictionary;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The modes that an action can use to adjust the apparent timing of the action.
 * @typedef {Object} SKActionTimingMode
 * @property {number} linear - Specifies linear pacing. Linear pacing causes an animation to occur evenly over its duration.
 * @property {number} easeIn - Specifies ease-in pacing. Ease-in pacing causes the animation to begin slowly and then speed up as it progresses.
 * @property {number} easeOut - Specifies ease-out pacing. Ease-out pacing causes the animation to begin quickly and then slow as it completes.
 * @property {number} easeInEaseOut - Specifies ease-in ease-out pacing. An ease-in ease-out animation begins slowly, accelerates through the middle of its duration, and then slows again before completing.
 * @see https://developer.apple.com/documentation/spritekit/skactiontimingmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SKActionTimingMode = {
  linear: 0,
  easeIn: 1,
  easeOut: 2,
  easeInEaseOut: 3
};

exports.default = SKActionTimingMode;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _constants = __webpack_require__(25);

var Constants = _interopRequireWildcard(_constants);

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import CAAction from './CAAction'
//import CAMediaTiming from './CAMediaTiming'
//import CAMediaTimingFunction from './CAMediaTimingFunction'
//import CAAnimationDelegate from './CAAnimationDelegate'
//import SCNAnimationEvent from '../SceneKit/SCNAnimationEvent'


/**
 * The abstract superclass for Core Animation animations. 
 * @access public
 * @extends {NSObject}
 * @implements {CAAction}
 * @implements {CAMediaTiming}
 * @see https://developer.apple.com/documentation/quartzcore/caanimation
 */
var CAAnimation = function (_NSObject) {
  _inherits(CAAnimation, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function CAAnimation() {
    _classCallCheck(this, CAAnimation);

    // Animation attributes

    /**
     * Determines if the animation is removed from the target layer’s animations upon completion.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1412458-isremovedoncompletion
     */
    var _this = _possibleConstructorReturn(this, (CAAnimation.__proto__ || Object.getPrototypeOf(CAAnimation)).call(this));

    _this.isRemovedOnCompletion = true;

    /**
     * An optional timing function defining the pacing of the animation.
     * @type {?CAMediaTimingFunction}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1412456-timingfunction
     */
    _this.timingFunction = null;

    // Getting and setting the delegate

    /**
     * Specifies the receiver’s delegate object.
     * @type {?CAAnimationDelegate}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1412490-delegate
     */
    _this.delegate = null;

    // Controlling SceneKit Animation Timing

    /**
     * For animations attached to SceneKit objects, a Boolean value that determines whether the animation is evaluated using the scene time or the system time.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1523819-usesscenetimebase
     */
    _this.usesSceneTimeBase = false;

    // Fading Between SceneKit Animations

    /**
     * For animations attached to SceneKit objects, the duration for transitioning into the animation’s effect as it beins.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1523370-fadeinduration
     */
    _this.fadeInDuration = 0;

    /**
     * For animations attached to SceneKit objects, the duration for transitioning out of the animation’s effect as it ends.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1522959-fadeoutduration
     */
    _this.fadeOutDuration = 0;

    // Attaching SceneKit Animation Events

    /**
     * For animations attached to SceneKit objects, a list of events attached to an animation.
     * @type {?SCNAnimationEvent[]}
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1523940-animationevents
     */
    _this.animationEvents = null;

    ///////////////////
    // CAMediaTiming //
    ///////////////////

    // Animation Start Time

    /**
     * Required. Specifies the begin time of the receiver in relation to its parent object, if applicable.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427654-begintime
     */
    _this.beginTime = 0;

    /**
     * Required. Specifies an additional time offset in active local time.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427650-timeoffset
     */
    _this.timeOffset = 0;

    // Repeating Animations

    /**
     * Required. Determines the number of times the animation will repeat.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427666-repeatcount
     */
    _this.repeatCount = 0;

    /**
     * Required. Determines how many seconds the animation will repeat for.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427643-repeatduration
     */
    _this.repeatDuration = 0;

    // Duration and Speed

    /**
     * Required. Specifies the basic duration of the animation, in seconds.
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427652-duration
     */
    _this.duration = 0;

    /**
     * Required. Specifies how time is mapped to receiver’s time space from the parent time space. 
     * @type {number}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427647-speed
     */
    _this.speed = 1;

    // Playback Modes

    /**
     * Required. Determines if the receiver plays in the reverse upon completion.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427645-autoreverses
     */
    _this.autoreverses = false;

    /**
     * Required. Determines if the receiver’s presentation is frozen or removed once its active duration has completed.
     * @type {string}
     * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427656-fillmode
     */
    _this.fillMode = Constants.kCAFillModeRemoved;

    _this._isFinished = false;

    _this._prevTime = null;
    _this._animationStartTime = null;
    return _this;
  }

  // Archiving properties

  /**
   * Specifies whether the value of the property for a given key is archived.
   * @access public
   * @param {string} key - The name of one of the receiver’s properties.
   * @returns {boolean} - 
   * @desc Called by the object's implementation of encodeWithCoder:. The object must implement keyed archiving. The default implementation returns true. 
   * @see https://developer.apple.com/documentation/quartzcore/caanimation/1412525-shouldarchivevalue
   */


  _createClass(CAAnimation, [{
    key: 'shouldArchiveValueForKey',
    value: function shouldArchiveValueForKey(key) {
      return false;
    }

    // Providing default values for properties

    /**
     * Specifies the default value of the property with the specified key. 
     * @access public
     * @param {string} key - The name of one of the receiver’s properties.
     * @returns {?Object} - 
     * @desc If this method returns nil a suitable “zero” default value for the property is provided, based on the declared type of the key. For example, if key is a CGSize object, a size of (0.0,0.0) is returned. For a CGRect an empty rectangle is returned. For CGAffineTransform and CATransform3D, the appropriate identity matrix is returned. Special ConsiderationsIf key is not a known for property of the class, the result of the method is undefined.
     * @see https://developer.apple.com/documentation/quartzcore/caanimation/1412530-defaultvalue
     */

  }, {
    key: 'copy',


    /**
     * @access public
     * @returns {CAAnimation} -
     */
    value: function copy() {
      var anim = _get(CAAnimation.prototype.__proto__ || Object.getPrototypeOf(CAAnimation.prototype), 'copy', this).call(this);

      anim.isRemovedOnCompletion = this.isRemovedOnCompletion;
      anim.timingFunction = this.timingFunction;
      anim.delegate = this.delegate;
      anim.usesSceneTimeBase = this.usesSceneTimeBase;
      anim.fadeInDuration = this.fadeInDuration;
      anim.fadeOutDuration = this.fadeOutDuration;
      anim.animationEvents = this.animationEvents ? this.animationEvents.slice(0) : null;
      anim.beginTime = this.beginTime;
      anim.timeOffset = this.timeOffset;
      anim.repeatCount = this.repeatCount;
      anim.repeatDuration = this.repeatDuration;
      anim.duration = this.duration;
      anim.speed = this.speed;
      anim.autoreverses = this.autoreverses;
      anim.fillMode = this.fillMode;

      return anim;
    }

    /*
    _copyValue(src) {
      console.log('CAAnimation._copyValue')
      this.isRemovedOnCompletion = src.isRemovedOnCompletion
      this.timingFunction = src.timingFunction
      this.delegate = src.delegate
      this.usesSceneTimeBase = src.usesSceneTimeBase
      this.fadeInDuration = src.fadeInDuration
      this.fadeOutDuration = src.fadeOutDuration
      this.animationEvents = src.animationEvents
      this.beginTime = src.beginTime
      this.timeOffset = src.timeOffset
      this.repeatCount = src.repeatCount
      this.repeatDuration = src.repeatDuration
      this.duration = src.duration
      this.speed = src.speed
      this.autoreverses = src.autoreverses
      this.fillMode = src.fillMode
    }
    */

    /**
     * apply animation to the given node.
     * @access private
     * @param {Object} obj - target object to apply this animation.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAnimation',
    value: function _applyAnimation(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var t = time;
      if (needTimeConversion) {
        var baseTime = this._basetimeFromTime(time);
        t = baseTime;
        if (this.timingFunction !== null) {
          t = this.timingFunction._getValueAtTime(baseTime);
        }
      }
      this._handleEvents(obj, t);
    }
  }, {
    key: '_handleEvents',
    value: function _handleEvents(obj, time) {
      var _this2 = this;

      if (this.animationEvents === null) {
        return;
      }
      var prevTime = this._prevTime;
      if (prevTime === null) {
        if (this.delegate && this.delegate.animationDidStart) {
          this.delegate.animationDidStart(this);
        }
        prevTime = time - 0.0000001;
      }
      this.animationEvents.forEach(function (event) {
        if (prevTime < event._time && event._time <= time) {
          if (event._eventBlock) {
            // FIXME: set playingBackward
            // SCNAnimationEventBlock(animation, animatedObject, playingBackward)
            event._eventBlock(_this2, obj, false);
          }
        }
      });
      this._prevTime = time;
    }

    /**
     * convert parent time to base time
     * @access private
     * @param {number} time - parent time
     * @returns {number} - animation base time for the current frame (0-1 or null).
     */

  }, {
    key: '_basetimeFromTime',
    value: function _basetimeFromTime(time) {
      var activeTime = time - this._animationStartTime;
      return this._basetimeFromActivetime(activeTime);
    }

    /**
     * convert active time to base time
     * @access private
     * @param {number} time - active time
     * @returns {number} - animation base time for the current frame (0-1 or null).
     */

  }, {
    key: '_basetimeFromActivetime',
    value: function _basetimeFromActivetime(time) {
      var beginTime = 0;
      if (this.beginTime > 0) {
        // FIXME: check usesSceneTimeBase value
        beginTime = this.beginTime - this._animationStartTime;
      }
      var dt = time - beginTime;
      if (dt < 0) {
        if (this.fillMode === Constants.kCAFillModeBackwards || this.fillMode === Constants.kCAFillModeBoth) {
          dt = 0;
        } else {
          // the animation hasn't started yet.
          return null;
        }
      }
      if (this.speed === 0) {
        return 0;
      }
      var oneLoopDuration = this.duration / Math.abs(this.speed);
      var duration = oneLoopDuration;
      if (duration === 0) {
        duration = 0.25;
      }

      var repeatCount = this.repeatCount;
      if (this.usesSceneTimeBase) {
        // FIXME: I don't know why, but if you set usesSceneTimeBase = true, it will animate repeatedly...
        repeatCount = Infinity;
      }

      if (this.repeatDuration > 0) {
        duration = this.repeatDuration;
      } else {
        if (repeatCount > 0) {
          duration *= repeatCount;
        }
        if (this.autoreverses) {
          oneLoopDuration *= 2.0;
          duration *= 2.0;
        }
      }

      if (dt > duration) {
        // the animation is over.
        if (!this._isFinished) {
          this._isFinished = true;
          if (this.delegate && this.delegate.animationDidStop) {
            this.delegate.animationDidStop(this, true);
          }
        }
        if (this.fillMode === Constants.kCAFillModeForwards || this.fillMode === Constants.kCAFillModeBoth) {
          dt = duration;
        } else {
          return null;
        }
      }

      var t = (dt + this.timeOffset) / oneLoopDuration;
      if (Math.abs(t) > 1) {
        t = t - Math.floor(t);
      }
      if (t < 0) {
        t = 1 + t;
      }
      if (this.autoreverses) {
        if (t <= 0.5) {
          return t * 2.0;
        }
        return (1 - t) * 2.0;
      }
      return t;
    }
  }], [{
    key: 'defaultValueForKey',
    value: function defaultValueForKey(key) {
      return null;
    }
  }]);

  return CAAnimation;
}(_NSObject3.default);

exports.default = CAAnimation;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*global exports*/

// 
exports.kCAFillModeRemoved = 'removed';
exports.kCAFillModeForwards = 'forwards';
exports.kCAFillModeBackwards = 'backwards';
exports.kCAFillModeBoth = 'both';

// 
exports.kCAMediaTimingFunctionLinear = 'linear';
exports.kCAMediaTimingFunctionEaseIn = 'easeIn';
exports.kCAMediaTimingFunctionEaseOut = 'easeOut';
exports.kCAMediaTimingFunctionEaseInEaseOut = 'easeInEaseOut';
exports.kCAMediaTimingFunctionDefault = 'default';

// Value calculation modes
exports.kCAAnimationLinear = 'linear';
exports.kCAAnimationDiscrete = 'discrete';
exports.kCAAnimationPaced = 'paced';
exports.kCAAnimationCubic = 'cubic';
exports.kCAAnimationCubicPaced = 'cubicPaced';

// Rotation Mode Values
exports.kCAAnimationRotateAuto = 'auto';
exports.kCAAnimationRotateAutoReverse = 'autoReverse';

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNFilterMode = __webpack_require__(82);

var _SCNFilterMode2 = _interopRequireDefault(_SCNFilterMode);

var _SCNMatrix4MakeTranslation = __webpack_require__(18);

var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

var _SCNOrderedDictionary = __webpack_require__(22);

var _SCNOrderedDictionary2 = _interopRequireDefault(_SCNOrderedDictionary);

var _SCNTransaction = __webpack_require__(35);

var _SCNTransaction2 = _interopRequireDefault(_SCNTransaction);

var _SCNWrapMode = __webpack_require__(83);

var _SCNWrapMode2 = _interopRequireDefault(_SCNWrapMode);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNAnimatable from './SCNAnimatable'

//import SCNMatrix4 from './SCNMatrix4'


/**
 * A container for the color or texture of one of a material’s visual properties. 
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty
 */
var SCNMaterialProperty = function (_NSObject) {
  _inherits(SCNMaterialProperty, _NSObject);

  _createClass(SCNMaterialProperty, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        color: ['NSColor', '_contents'],
        image: ['NSMutableDictionary', function (obj, dict, key, coder) {
          var path = '';
          if (typeof dict.path !== 'undefined') {
            path = dict.path;
          } else if (typeof dict.URL !== 'undefined') {
            path = dict.URL;
          }
          obj._loadContentsImage(path, coder._directoryPath);
        }],
        float: ['float', function (obj, value) {
          obj._contents = new _SKColor2.default(value, value, value, 1.0);
        }],
        intensity: 'float',
        // contentsTransform
        wrapS: 'integer',
        wrapT: 'integer',
        minificationFilter: 'integer',
        magnificationFilter: 'integer',
        mipFilter: 'integer',
        maxAnisotropy: 'float',
        mappingChannel: 'integer',
        borderColor: 'plist',

        propertyType: ['integer', null],
        parent: ['SCNMaterial', '_parent'],
        isCommonProfileProperty: ['boolean', null],
        sRGB: ['boolean', null],
        customSlotName: ['string', null]
      };
    }

    // Creating a Material Property

    /**
     * Creates a new material property object with the specified contents.
     * @access public
     * @constructor
     * @param {Object} contents - The visual contents of the material property—a color, image, or source of animated content. For details, see the discussion of the  contents property.
     * @desc Newly created SCNMaterial objects contain SCNMaterialProperty instances for all of their visual properties. To change a material’s visual properties, you modify those instances rather than creating new material property objects.You create new SCNMaterialProperty instances to provide textures for use with custom GLSL shaders—for details, see SCNShadable.
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395386-init
     */

  }]);

  function SCNMaterialProperty() {
    var contents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, SCNMaterialProperty);

    // Working with Material Property Contents

    /**
     * The visual contents of the material property—a color, image, or source of animated content. Animatable.
     * @access private
     * @type {?Object}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395372-contents
     */
    var _this = _possibleConstructorReturn(this, (SCNMaterialProperty.__proto__ || Object.getPrototypeOf(SCNMaterialProperty)).call(this));

    _this._contents = contents;

    /**
     * A number between 0.0 and 1.0 that modulates the effect of the material property. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395407-intensity
     */
    _this.intensity = 0;

    // Configuring Texture Mapping Attributes

    /**
     * The transformation applied to the material property’s visual contents. Animatable.
     * @type {SCNMatrix4}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395388-contentstransform
     */
    _this.contentsTransform = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0

    /**
     * The wrapping behavior for the S texture coordinate.
     * @type {SCNWrapMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395384-wraps
     */
    );_this.wrapS = _SCNWrapMode2.default.clamp;

    /**
     * The wrapping behavior for the T texture coordinate.
     * @type {SCNWrapMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395382-wrapt
     */
    _this.wrapT = _SCNWrapMode2.default.clamp;

    /**
     * Texture filtering for rendering the material property’s image contents at a size smaller than that of the original image.
     * @type {SCNFilterMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395390-minificationfilter
     */
    _this.minificationFilter = _SCNFilterMode2.default.linear;

    /**
     * Texture filtering for rendering the material property’s image contents at a size larger than that of the original image.
     * @type {SCNFilterMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395378-magnificationfilter
     */
    _this.magnificationFilter = _SCNFilterMode2.default.linear;

    /**
     * Texture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.
     * @type {SCNFilterMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395398-mipfilter
     */
    _this.mipFilter = _SCNFilterMode2.default.nearest;

    /**
     * The amount of anisotropic texture filtering to be used when rendering the material property’s image contents.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395402-maxanisotropy
     */
    _this.maxAnisotropy = 0;

    /**
     * The source of texture coordinates for mapping the material property’s image contents.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395405-mappingchannel
     */
    _this.mappingChannel = 0;

    /**
     * A color used to fill in areas of a material’s surface not covered by the material property’s image contents.
     * @type {?Object}
     * @deprecated
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395376-bordercolor
     */
    _this.borderColor = null;

    /**
     * @access private
     * @type {SCNMaterial}
     */
    _this._parent = null;

    ///////////////////
    // SCNAnimatable //
    ///////////////////

    /**
     * @access private
     * @type {Map}
     */
    _this._animations = new _SCNOrderedDictionary2.default();

    _this.__presentation = null;

    /**
     * @access private
     * @type {Promise}
     */
    _this._loadedPromise = null;
    return _this;
  }

  _createClass(SCNMaterialProperty, [{
    key: '_createPresentation',
    value: function _createPresentation() {
      if (this.__presentation === null) {
        this.__presentation = this.copy();
      }
    }
  }, {
    key: '_copyPresentation',
    value: function _copyPresentation() {
      // TODO: copy other properties
      this.__presentation._contents = this._contents;
    }
  }, {
    key: 'copy',


    /**
     *
     * @access public
     * @returns {SCNMaterialProperty} -
     */
    value: function copy() {
      var p = new SCNMaterialProperty();
      p._contents = this._contents; // TODO: copy
      p.intensity = this.intensity;
      p.contentsTransform = this.contentsTransform; // TODO: copy
      p.wrapS = this.wrapS;
      p.wrapT = this.wrapT;
      p.minificationFilter = this.minificationFilter;
      p.magnicifactionFilter = this.maginicifactionFilter;
      p.mipFilter = this.mipFilter;
      p.maxAnisotropy = this.maxAnisotropy;
      p.mappingChannel = this.mappingChannel;
      p.borderColor = this.borderColor; // TODO: copy
      //p._parent
      //p._animations
      //p._presentation

      return p;
    }
  }, {
    key: 'valueForKeyPath',
    value: function valueForKeyPath(keyPath) {
      var target = this.__presentation ? this.__presentation : this;

      // TODO: add other keys
      if (keyPath === 'contents') {
        return target._contents;
      }

      return _get(SCNMaterialProperty.prototype.__proto__ || Object.getPrototypeOf(SCNMaterialProperty.prototype), 'valueForKeyPath', this).call(this, keyPath);
    }
  }, {
    key: 'setValueForKeyPath',
    value: function setValueForKeyPath(value, keyPath) {
      var target = this.__presentation ? this.__presentation : this;

      // TODO: add other keys
      if (keyPath === 'contents') {
        target._contents = value;
      } else {
        _get(SCNMaterialProperty.prototype.__proto__ || Object.getPrototypeOf(SCNMaterialProperty.prototype), 'setValueForKeyPath', this).call(this, value, keyPath);
      }
    }

    /**
     * The visual contents of the material property—a color, image, or source of animated content. Animatable.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/scenekit/scnmaterialproperty/1395372-contents
     */

  }, {
    key: 'addAnimationForKey',


    ///////////////////
    // SCNAnimatable //
    ///////////////////

    // Managing Animations

    /**
     * Required. Adds an animation object for the specified key.
     * @access public
     * @param {CAAnimation} animation - The animation object to be added.
     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
     * @returns {void}
     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation
     */
    value: function addAnimationForKey(animation, key) {
      //console.log('SCNMaterialProperty addAnimationForKey')
      if (typeof key === 'undefined' || key === null) {
        key = Symbol();
      }
      var anim = animation.copy
      // FIXME: use current frame time
      ();anim._animationStartTime = Date.now() * 0.001;
      anim._prevTime = anim._animationStartTime - 0.0000001;

      this._animations.set(key, anim);
    }

    /**
     * Required. Returns the animation with the specified key.
     * @access public
     * @param {string} key - A string identifying a previously added animation.
     * @returns {?CAAnimation} - 
     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation
     */

  }, {
    key: 'animationForKey',
    value: function animationForKey(key) {
      return this._animations.get(key);
    }

    /**
     * Required. Removes all the animations currently attached to the object.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations
     */

  }, {
    key: 'removeAllAnimations',
    value: function removeAllAnimations() {
      this._animations.clear();
    }

    /**
     * Required. Removes the animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation to remove.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation
     */

  }, {
    key: 'removeAnimationForKey',
    value: function removeAnimationForKey(key) {
      this._animations.delete(key
      // TODO: reset values
      );
    }

    /**
     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
     * @access public
     * @param {string} key - A string identifying an attached animation to remove.
     * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
     * @returns {void}
     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation
     */

  }, {
    key: 'removeAnimationForKeyFadeOutDuration',
    value: function removeAnimationForKeyFadeOutDuration(key, duration) {}

    /**
     * Required. An array containing the keys of all animations currently attached to the object.
     * @type {string[]}
     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys
     */

  }, {
    key: 'pauseAnimationForKey',


    // Pausing and Resuming Animations

    /**
     * Required. Pauses the animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {void}
     * @desc This method has no effect if no animation is attached to the object with the specified key.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation
     */
    value: function pauseAnimationForKey(key) {}

    /**
     * Required. Resumes a previously paused animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {void}
     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation
     */

  }, {
    key: 'resumeAnimationForKey',
    value: function resumeAnimationForKey(key) {}

    /**
     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused
     */

  }, {
    key: 'isAnimationPausedForKey',
    value: function isAnimationPausedForKey(key) {
      return false;
    }

    // Instance Methods

    /**
     * Required. 
     * @access public
     * @param {number} speed - 
     * @param {string} key - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed
     */

  }, {
    key: 'setAnimationSpeedForKey',
    value: function setAnimationSpeedForKey(speed, key) {}

    /**
     * @access private
     * @param {WebGLContext} gl -
     * @returns {number} -
     */

  }, {
    key: '_wrapSFor',
    value: function _wrapSFor(gl) {
      switch (this.wrapS) {
        case _SCNWrapMode2.default.clamp:
          return gl.CLAMP_TO_EDGE; // FIXME: do not apply the texture out of 0-1
        case _SCNWrapMode2.default.repeat:
          return gl.REPEAT;
        case _SCNWrapMode2.default.clampToBorder:
          return gl.CLAMP_TO_EDGE;
        case _SCNWrapMode2.default.mirror:
          return gl.MIRRORED_REPEAT;
        default:
          throw new Error('unknown wrapS: ' + this.wrapS);
      }
    }

    /**
     * @access private
     * @param {WebGLContext} gl -
     * @returns {number} -
     */

  }, {
    key: '_wrapTFor',
    value: function _wrapTFor(gl) {
      switch (this.wrapT) {
        case _SCNWrapMode2.default.clamp:
          return gl.CLAMP_TO_EDGE; // FIXME: do not apply the texture out of 0-1
        case _SCNWrapMode2.default.repeat:
          return gl.REPEAT;
        case _SCNWrapMode2.default.clampToBorder:
          return gl.CLAMP_TO_EDGE;
        case _SCNWrapMode2.default.mirror:
          return gl.MIRRORED_REPEAT;
        default:
          throw new Error('unknown wrapT: ' + this.wrapT);
      }
    }

    /**
     * @access private
     * @param {WebGLContext} gl -
     * @returns {number} -
     */

  }, {
    key: '_minificationFilterFor',
    value: function _minificationFilterFor(gl) {
      switch (this.minificationFilter) {
        case _SCNFilterMode2.default.none:
        case _SCNFilterMode2.default.linear:
          {
            switch (this.mipFilter) {
              case _SCNFilterMode2.default.none:
                return gl.LINEAR;
              case _SCNFilterMode2.default.nearest:
                return gl.LINEAR_MIPMAP_NEAREST;
              case _SCNFilterMode2.default.linear:
                return gl.LINEAR_MIPMAP_LINEAR;
              default:
                throw new Error('unknown mipmapFilter: ' + this.mipmapFilter);
            }
          }
        case _SCNFilterMode2.default.nearest:
          {
            switch (this.mipFilter) {
              case _SCNFilterMode2.default.none:
                return gl.NEAREST;
              case _SCNFilterMode2.default.nearest:
                return gl.NEAREST_MIPMAP_NEAREST;
              case _SCNFilterMode2.default.linear:
                return gl.NEAREST_MIPMAP_LINEAR;
              default:
                throw new Error('unknown mipmapFilter: ' + this.mipmapFilter);
            }
          }
        default:
          throw new Error('unknown minificationFilter: ' + this.minificationFilter);
      }
    }

    /**
     * @access private
     * @param {WebGLContext} gl -
     * @returns {number} -
     */

  }, {
    key: '_magnificationFilterFor',
    value: function _magnificationFilterFor(gl) {
      switch (this.magnificationFilter) {
        case _SCNFilterMode2.default.none:
          return gl.LINEAR; // default value
        case _SCNFilterMode2.default.nearest:
          return gl.NEAREST;
        case _SCNFilterMode2.default.linear:
          return gl.LINEAR;
        default:
          throw new Error('unknown magnificationFilter: ' + this.magnificationFilter);
      }
    }

    /**
     * @access private
     * @param {string} path -
     * @param {string} dirPath -
     * @returns {Image} -
     */

  }, {
    key: '_loadContentsImage',
    value: function _loadContentsImage(path, dirPath) {
      var _this2 = this;

      var image = new Image();
      var __path = path;
      if (__path.indexOf('file:///') === 0) {
        __path = __path.slice(8);
      }
      // TODO: load OpenEXR File
      __path = __path.replace(/\.exr$/, '.png');

      this._loadedPromise = new Promise(function (resolve, reject) {
        var paths = __path.split('/');
        var pathCount = 1;
        var _path = dirPath + paths.slice(-pathCount).join('/');
        image.onload = function () {
          _this2._contents = image;
          resolve();
        };
        image.onerror = function () {
          pathCount += 1;
          if (pathCount > paths.length) {
            // try the root path
            image.onerror = function () {
              // give up
              reject();
              throw new Error('image ' + path + ' load error.');
            };
            image.src = __path;
          } else {
            // retry
            _path = dirPath + paths.slice(-pathCount).join('/');
            image.src = _path;
          }
        };
        image.src = _path;
      });
      return image;
    }

    /**
     * @access public
     * @returns {Float32Array} -
     */

  }, {
    key: 'float32Array',
    value: function float32Array() {
      var target = this.__presentation ? this.__presentation : this;
      if ((0, _InstanceOf3.default)(target._contents, _SKColor2.default)) {
        return target._contents.float32Array
        //return target._contents.srgbToLinear().float32Array()
        ();
      }
      return new Float32Array([1, 1, 1, 1]);
    }

    /**
     * @access private
     * @returns {Promise} -
     */

  }, {
    key: '_getLoadedPromise',
    value: function _getLoadedPromise() {
      if (this._loadedPromise) {
        return this._loadedPromise;
      }

      return Promise.resolve();
    }

    /**
     * @access public
     * @type {Promise} -
     */

  }, {
    key: '_presentation',
    get: function get() {
      if (this.__presentation === null) {
        return null;
      }
      return this.__presentation;
    }
  }, {
    key: 'contents',
    get: function get() {
      return this._contents;
    },
    set: function set(newValue) {
      var oldValue = this._contents;
      this._contents = newValue;
      _SCNTransaction2.default._addChange(this, 'contents', oldValue, newValue);
    }
  }, {
    key: 'animationKeys',
    get: function get() {
      var keys = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._animations.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          keys.push(key);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return keys;
    }
  }, {
    key: 'didLoad',
    get: function get() {
      return this._getLoadedPromise();
    }
  }]);

  return SCNMaterialProperty;
}(_NSObject3.default);

exports.default = SCNMaterialProperty;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The abstract superclass for joints, vehicle simulations, and other high-level behaviors that incorporate multiple physics bodies.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsbehavior
 */
var SCNPhysicsBehavior = function (_NSObject) {
  _inherits(SCNPhysicsBehavior, _NSObject);

  function SCNPhysicsBehavior() {
    _classCallCheck(this, SCNPhysicsBehavior);

    return _possibleConstructorReturn(this, (SCNPhysicsBehavior.__proto__ || Object.getPrototypeOf(SCNPhysicsBehavior)).apply(this, arguments));
  }

  return SCNPhysicsBehavior;
}(_NSObject3.default);

exports.default = SCNPhysicsBehavior;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The modes that describe how the source and destination pixel colors are used to calculate the new destination color.
 * @typedef {Object} SKBlendMode
 * @property {number} alpha - The source and destination colors are blended by multiplying the source alpha value.
 * @property {number} add - The source and destination colors are added together.
 * @property {number} subtract - The source color is subtracted from the destination color.
 * @property {number} multiply - The source color is multiplied by the destination color.
 * @property {number} multiplyX2 - The source color is multiplied by the destination color and then doubled.
 * @property {number} screen - The source color is added to the destination color times the inverted source color.
 * @property {number} replace - The source color replaces the destination color.
 * @see https://developer.apple.com/documentation/spritekit/skblendmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SKBlendMode = {
  alpha: 0,
  add: 1,
  subtract: 2,
  multiply: 3,
  multiplyX2: 4,
  screen: 5,
  replace: 6
};

exports.default = SKBlendMode;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _GCGamepad = __webpack_require__(63);

var _GCGamepad2 = _interopRequireDefault(_GCGamepad);

var _GCExtendedGamepad = __webpack_require__(65);

var _GCExtendedGamepad2 = _interopRequireDefault(_GCExtendedGamepad);

var _GCMicroGamepad = __webpack_require__(66);

var _GCMicroGamepad2 = _interopRequireDefault(_GCMicroGamepad);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import GCMotion from './GCMotion'
//import GCControllerPlayerIndex from './GCControllerPlayerIndex'

var navigator = {
  getGamepads: function getGamepads() {
    return [];
  }
};
if (typeof window !== 'undefined' && typeof window.navigator !== 'undefined') {
  navigator = window.navigator;
}

/**
 * @access private
 * @type {Map<number, GCController>}
 */
var _controllers = new Map();

/**
 * A representation of a physical game controller, connected to the device either physically or through a wireless connection.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gamecontroller/gccontroller
 */

var GCController = function (_NSObject) {
  _inherits(GCController, _NSObject);

  _createClass(GCController, null, [{
    key: 'getController',
    value: function getController(gamepad) {
      var pad = gamepad;
      if (gamepad.id === '') {
        // needs to refresh gamepad info
        pad = GCController._gamepadObjByIndex(gamepad.index);
        if (pad === null) {
          return null;
        }
      }

      var controller = _controllers.get(pad.id);
      if (controller) {
        return controller;
      }

      controller = new GCController();
      if (!pad) {
        return controller;
      }
      _controllers.set(pad.id, controller);

      controller._gamepadIndex = pad.index;
      controller._gamepadId = pad.id;
      controller._gamepad = new _GCGamepad2.default();
      controller._gamepad._controller = controller;
      if (gamepad.mapping === 'standard') {
        controller._extendedGamepad = new _GCExtendedGamepad2.default();
        controller._extendedGamepad._controller = controller;
      }

      return controller;
    }

    /**
     * constructor
     * @access public
     */

  }]);

  function GCController() {
    _classCallCheck(this, GCController);

    // Determining Which Profiles Are Supported by a Controller

    /**
     * @type {?GCGamepad}
     */
    var _this = _possibleConstructorReturn(this, (GCController.__proto__ || Object.getPrototypeOf(GCController)).call(this));

    _this._gamepad = null;

    /**
     * @type {?GCExtendedGamepad}
     */
    _this._extendedGamepad = null;

    /**
     * @type {?GCMicroGamepad}
     */
    _this._microGamepad = null;

    /**
     * @type {?GCMotion}
     */
    _this._motion = null;

    // Responding When a Controller Is Paused

    /**
     * A block called when the controller’s pause button is pressed.
     * @type {?function(arg1: GCController): void}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458852-controllerpausedhandler
     */
    _this.controllerPausedHandler = null;

    // Inspecting a Controller

    _this._isAttachedToDevice = false;
    _this._vendorName = null;

    // Assigning a Player Index

    /**
     * The player index assigned to the controller.
     * @type {GCControllerPlayerIndex}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458885-playerindex
     */
    _this.playerIndex = null;

    // Determining Which Dispatch Queue Notifications are Dispatched On

    /**
     * The dispatch queue to be used when the values of a game controller’s input values change.
     * @type {DispatchQueue}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458869-handlerqueue
     */
    _this.handlerQueue = null;

    _this._gamepadIndex = -1;
    _this._gamepadId = -1;

    _this._state = {
      buttons: [],
      pressed: [],
      axes: []
    };
    _this._updated = {
      buttons: [],
      pressed: [],
      axes: []
    };
    return _this;
  }

  _createClass(GCController, [{
    key: 'gamepad',


    // Determining Which Profiles Are Supported by a Controller

    /**
     * The gamepad profile.
     * @type {?GCGamepad}
     * @desc If the controller supports the gamepad profile, then this property holds a GCGamepad object. You use this object to access the input elements of the controller. If the controller does not support the gamepad profile, this property holds nil.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458860-gamepad
     */
    get: function get() {
      return this._gamepad;
    }

    /**
     * The extended gamepad profile.
     * @type {?GCExtendedGamepad}
     * @desc If the controller supports the extended gamepad profile, then this property holds a GCExtendedGamepad object. You use this object to access the input elements of the controller. If the controller does not support the extended gamepad profile, this property holds nil.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458883-extendedgamepad
     */

  }, {
    key: 'extendedGamepad',
    get: function get() {
      return this._extendedGamepad;
    }

    /**
     * The micro gamepad profile.
     * @type {?GCMicroGamepad}
     * @desc If the controller supports the micro gamepad profile, then this property holds a GCMicroGamepad object. You use this object to access the input elements of the controller. If the controller does not support the micro gamepad profile, this property holds nil.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1627772-microgamepad
     */

  }, {
    key: 'microGamepad',
    get: function get() {
      return this._microGamepad;
    }

    /**
     * The motion input profile.
     * @type {?GCMotion}
     * @desc If the controller supports the motion profile, then this property holds a GCMotion object. This profile is typically available when the controller is attached to a device that supports motion. You use this object to access the motion data of the controller. If the controller does not support the motion input profile, this property holds nil.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458884-motion
     */

  }, {
    key: 'motion',
    get: function get() {
      return this._motion;
    }

    // Inspecting a Controller

    /**
     * A Boolean property that indicates whether the controller is closely integrated with the device.
     * @type {boolean}
     * @desc If true, then the controller is attached to the device or is close enough to it for the player to interact simultaneously with the controller and the device. If false, then the controller is not guaranteed to be near the device.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458868-isattachedtodevice
     */

  }, {
    key: 'isAttachedToDevice',
    get: function get() {
      return this._isAttachedToDevice;
    }

    /**
     * The name of the vendor that manufactured the controller.
     * @type {?string}
     * @desc The value of this property may be nil and is not guaranteed to be unique.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458877-vendorname
     */

  }, {
    key: 'vendorName',
    get: function get() {
      return this._vendorName;
    }
  }, {
    key: 'gamepadObj',
    get: function get() {
      return GCController._gamepadObjById(this._gamepadId);
    }
  }], [{
    key: '_update',
    value: function _update() {
      _controllers.forEach(function (c, gamepadId) {
        var gamepad = GCController._gamepadObjById(gamepadId);
        if (!gamepad) {
          _controllers.delete(gamepadId);
          return;
        }
        var bLen = gamepad.buttons.length;
        for (var i = 0; i < bLen; i++) {
          var b = gamepad.buttons[i];
          c._updated.buttons[i] = false;
          if (c._state.buttons[i] !== b.value) {
            c._state.buttons[i] = b.value;
            c._updated.buttons[i] = true;
          }

          c._updated.pressed[i] = false;
          if (c._state.pressed[i] !== b.pressed) {
            c._state.pressed[i] = b.pressed;
            c._updated.pressed[i] = true;
          }
        }

        var aLen = gamepad.axes.length;
        for (var _i = 0; _i < aLen; _i++) {
          var value = gamepad.axes[_i];
          c._updated.axes[_i] = false;
          if (c._state.axes[_i] !== value) {
            c._state.axes[_i] = value;
            c._updated.axes[_i] = true;
          }
        }
      });

      _controllers.forEach(function (c, gamepadId) {
        if (c._gamepad) {
          c._gamepad._update();
        }
        if (c._extendedGamepad) {
          c._extendedGamepad._update();
        }
        if (c._microGamepad) {
          c._microGamepad._update();
        }
      });
    }

    // Discovering Controllers

    /**
     * Starts browsing for nearby controllers.
     * @access public
     * @param {?function(): void} [completionHandler = null] - A block to be called when browsing ends.
     * @returns {void}
     * @desc You should include a user interface in your game to allow the player to determine when controllers are discovered. When the user chooses to search for controllers, call this method. The device searches asynchronously for discoverable wireless controllers as well as controllers that are connected to iOS devices that have been placed in controller-forwarding mode. Whenever a new controller is connected, a GCControllerDidConnect notification is posted. When no more devices can be found or the discovery process times out, the completion handler is called.If this method is called multiple times, only the block associated with the last invocation is called when discovery times out.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458879-startwirelesscontrollerdiscovery
     */

  }, {
    key: 'startWirelessControllerDiscovery',
    value: function startWirelessControllerDiscovery() {
      var completionHandler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    }

    /**
     * Stops browsing for nearby controllers.
     * @access public
     * @returns {void}
     * @desc This method may be called at any time. If a search for new wireless controllers in progress, that search ends and its completion handler is called. 
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458854-stopwirelesscontrollerdiscovery
     */

  }, {
    key: 'stopWirelessControllerDiscovery',
    value: function stopWirelessControllerDiscovery() {}

    /**
     * The controllers connected to the device.
     * @access public
     * @returns {GCController[]} - 
     * @desc Whenever a controller is connected to or disconnected from the device, the array of controllers is updated and a notification is posted.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontroller/1458871-controllers
     */

  }, {
    key: 'controllers',
    value: function controllers() {
      return Array.from(_controllers.values());
    }
  }, {
    key: '_gamepadObjByIndexId',
    value: function _gamepadObjByIndexId(index, id) {
      var pad = GCController._gamepadObjByIndex(index);
      if (pad && pad.id === id) {
        return pad;
      }
      return null;
    }
  }, {
    key: '_gamepadObjByIndex',
    value: function _gamepadObjByIndex(index) {
      return navigator.getGamepads()[index];
    }
  }, {
    key: '_gamepadObjById',
    value: function _gamepadObjById(id) {
      var pads = navigator.getGamepads();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = pads[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pad = _step.value;

          if (pad && pad.id === id) {
            return pad;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }
  }]);

  return GCController;
}(_NSObject3.default);

exports.default = GCController;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GCControllerElement2 = __webpack_require__(31);

var _GCControllerElement3 = _interopRequireDefault(_GCControllerElement2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import GCControllerButtonValueChangedHandler from '../undefined/GCControllerButtonValueChangedHandler'

/**
 * A control element measuring a button press. 
 * @access public
 * @extends {GCControllerElement}
 * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerbuttoninput
 */
var GCControllerButtonInput = function (_GCControllerElement) {
  _inherits(GCControllerButtonInput, _GCControllerElement);

  /**
   * constructor
   * @access public
   * @returns {void}
   */
  function GCControllerButtonInput() {
    _classCallCheck(this, GCControllerButtonInput);

    // Reading the Button’s Value

    var _this = _possibleConstructorReturn(this, (GCControllerButtonInput.__proto__ || Object.getPrototypeOf(GCControllerButtonInput)).call(this));

    _this._isPressed = false;
    _this._value = 0;

    // Receiving Notifications When the Button’s Value Changes

    /**
     * A handler to be called when the button is pressed or released.
     * @type {?GCControllerButtonValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerbuttoninput/1522556-pressedchangedhandler
     */
    _this.pressedChangedHandler = null;

    /**
     * A handler to be called when the pressure on a button changes.
     * @type {?GCControllerButtonValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerbuttoninput/1522491-valuechangedhandler
     */
    _this.valueChangedHandler = null;

    return _this;
  }

  // Reading the Button’s Value

  /**
   * A Boolean value that indicates whether the button is pressed.
   * @type {boolean}
   * @desc 
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerbuttoninput/1522539-ispressed
   */


  _createClass(GCControllerButtonInput, [{
    key: 'isPressed',
    get: function get() {
      return this._isPressed;
    }

    /**
     * The level of pressure being applied to the button.
     * @type {number}
     * @desc If pressure is being applied to the button, then the isPressed property is true and this property indicates the amount of pressure being applied to the button. The pressure value is normalized to a number between 0.0 (minimum pressure) and 1.0 (maximum pressure).If no pressure is being applied to the button, then the isPressed property is false and this property holds a value of 0.0.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerbuttoninput/1522580-value
     */

  }, {
    key: 'value',
    get: function get() {
      return this._value;
    }
  }]);

  return GCControllerButtonInput;
}(_GCControllerElement3.default);

exports.default = GCControllerButtonInput;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An input associated with a physical control, such as a button or thumbstick.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerelement
 */
var GCControllerElement = function (_NSObject) {
  _inherits(GCControllerElement, _NSObject);

  /**
   * constructor
   * @access public
   */
  function GCControllerElement() {
    _classCallCheck(this, GCControllerElement);

    // Inspecting Element Properties

    var _this = _possibleConstructorReturn(this, (GCControllerElement.__proto__ || Object.getPrototypeOf(GCControllerElement)).call(this));

    _this._isAnalog = false;
    _this._collection = null;
    return _this;
  }

  // Inspecting Element Properties

  /**
   * Returns a Boolean value that indicates whether the element provides analog data.
   * @type {boolean}
   * @desc If the value is true, then the value properties defined by the element subclass can return a range (from minimum to maximum) of possible values. For example, this element might be a pressure-sensitive button or an axis of a thumb stick that allows for a range of physical movement. If the value is false, then the element’s value properties only provides discrete values, typically 0 if the element is off, and 1 if the element is on. 
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerelement/1522581-isanalog
   */


  _createClass(GCControllerElement, [{
    key: 'isAnalog',
    get: function get() {
      return this._isAnalog;
    }

    /**
     * Returns the element that this element is part of.
     * @type {?GCControllerElement}
     * @desc If the element is part of another element, this property holds the parent element. Otherwise, it holds nil.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerelement/1522575-collection
     */

  }, {
    key: 'collection',
    get: function get() {
      return this._collection;
    }
  }]);

  return GCControllerElement;
}(_NSObject3.default);

exports.default = GCControllerElement;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _GKEntity = __webpack_require__(71);

var _GKEntity2 = _interopRequireDefault(_GKEntity);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The abstract superclass for creating objects that add specific gameplay functionality to an entity.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gameplaykit/gkcomponent
 */
var GKComponent = function (_NSObject) {
  _inherits(GKComponent, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function GKComponent() {
    _classCallCheck(this, GKComponent);

    // Working with Entities

    /**
     * @access private
     * @type {GKEntity}
     */
    var _this = _possibleConstructorReturn(this, (GKComponent.__proto__ || Object.getPrototypeOf(GKComponent)).call(this));

    _this._entity = null;
    return _this;
  }

  // Performing Periodic Updates

  /**
   * Performs any custom periodic actions defined by the component subclass.
   * @access public
   * @param {number} seconds - The time step to use for any time-dependent actions performed by this method (typically, the elapsed time since the previous call to this method).
   * @returns {void}
   * @desc Override this method to implement per-frame logic specific to your component class. GameplayKit calls this method when you call the update(deltaTime:) method of the entity owning a component, or when you call the update(deltaTime:) method of a GKComponentSystem object that manages all components of a specific GKComponent subclass. Typically, you call one of those methods in response to a per-frame game loop method such as update(_:) (SpriteKit) or renderer(_:updateAtTime:) (SceneKit).
   * @see https://developer.apple.com/documentation/gameplaykit/gkcomponent/1501218-update
   */


  _createClass(GKComponent, [{
    key: 'updateDeltaTime',
    value: function updateDeltaTime(seconds) {}

    // Working with Entities

    /**
     * Notifies the component that it has been assigned to an entity.
     * @access public
     * @returns {void}
     * @desc Override this method in a component subclass if you need to perform game logic when the component is added to an entity. For example, if one component’s behavior depends on the presence of other components in the same entity, you can examine the entity’s components array in this method and take action accordingly.
     * @see https://developer.apple.com/documentation/gameplaykit/gkcomponent/1687601-didaddtoentity
     */

  }, {
    key: 'didAddToEntity',
    value: function didAddToEntity() {}

    /**
     * Notifies the component that it has been removed from an entity.
     * @access public
     * @returns {void}
     * @desc Override this method in a component subclass if you need to perform game logic when the component is removed from to an entity. For example, if one component’s behavior depends on the presence of other components in the same entity, you can examine the entity’s components array in this method and take action accordingly.
     * @see https://developer.apple.com/documentation/gameplaykit/gkcomponent/1640914-willremovefromentity
     */

  }, {
    key: 'willRemoveFromEntity',
    value: function willRemoveFromEntity() {}

    /**
     * The entity that owns this component.
     * @type {?GKEntity}
     * @desc Use this property in a component subclass to refer back to the owning entity and its attributes. An entity may be an instance either of the GKEntity class or of a custom subclass. In the latter case, a custom entity class can provide storage for state or resources accessed by multiple components.
     * @see https://developer.apple.com/documentation/gameplaykit/gkcomponent/1501250-entity
     */

  }, {
    key: 'entity',
    get: function get() {
      return this._entity;
    }
  }]);

  return GKComponent;
}(_NSObject3.default);

exports.default = GKComponent;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNBox = __webpack_require__(34);

var _SCNBox2 = _interopRequireDefault(_SCNBox);

var _SCNCapsule = __webpack_require__(49);

var _SCNCapsule2 = _interopRequireDefault(_SCNCapsule);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNHitTestResult = __webpack_require__(50);

var _SCNHitTestResult2 = _interopRequireDefault(_SCNHitTestResult);

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

var _SCNPhysicsBodyType = __webpack_require__(51);

var _SCNPhysicsBodyType2 = _interopRequireDefault(_SCNPhysicsBodyType);

var _SCNPhysicsContact = __webpack_require__(85);

var _SCNPhysicsContact2 = _interopRequireDefault(_SCNPhysicsContact);

var _SCNPhysicsShape = __webpack_require__(52);

var _SCNPhysicsShape2 = _interopRequireDefault(_SCNPhysicsShape);

var _SCNSphere = __webpack_require__(53);

var _SCNSphere2 = _interopRequireDefault(_SCNSphere);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNPhysicsBody from './SCNPhysicsBody'

//import SCNPhysicsBehavior from './SCNPhysicsBehavior'

//import SCNPhysicsContactDelegate from './SCNPhysicsContactDelegate'


//import _Ammo from '../third_party/ammo'

var _TestOption = {
  backfaceCulling: 'backfaceCulling',
  collisionBitMask: 'collisionBitMask',
  searchMode: 'results'
};

var _TestSearchMode = {
  all: 'all',
  any: 'any',
  closest: 'closest'

  /**
   * The global simulation of collisions, gravity, joints, and other physics effects in a scene.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld
   */
};
var SCNPhysicsWorld = function (_NSObject) {
  _inherits(SCNPhysicsWorld, _NSObject);

  _createClass(SCNPhysicsWorld, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        gravity: 'SCNVector3',
        speed: 'double',
        timeStep: 'double',
        scale: ['double', '_scale'],
        // _allBehaviors
        // contactDelegate
        scene: ['SCNScene', '_scene']
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNPhysicsWorld() {
    _classCallCheck(this, SCNPhysicsWorld);

    // Managing the Physics Simulation

    /**
     * A vector that specifies the gravitational acceleration applied to physics bodies in the physics world.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512855-gravity
     */
    var _this = _possibleConstructorReturn(this, (SCNPhysicsWorld.__proto__ || Object.getPrototypeOf(SCNPhysicsWorld)).call(this));

    _this.gravity = new _SCNVector2.default(0, 0, 0);

    /**
     * The rate at which the simulation executes.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512851-speed
     */
    _this.speed = 0;

    /**
     * The time interval between updates to the physics simulation.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512881-timestep
     */
    _this.timeStep = 0;

    /**
     * @access private
     * @type {number}
     */
    _this._scale = 1.0;

    // Registering Physics Behaviors

    _this._allBehaviors = [];

    // Detecting Contacts Between Physics Bodies

    /**
     * A delegate that is called when two physics bodies come in contact with each other.
     * @type {?SCNPhysicsContactDelegate}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512843-contactdelegate
     */
    _this.contactDelegate = null;

    //const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration()
    //const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration)
    //const overlappingPairCache = new Ammo.btDbvtBroadphase()
    //const solver = new Ammo.btSequentialImpulseConstraintSolver()
    //this._world = new Ammo.btDiscreteDynamicsWorld(
    //  dispatcher, overlappingPairCache, solver, collisionConfiguration
    //)

    _this._prevTime = null;

    /**
     * @access private
     * @type {SCNScene}
     */
    _this._scene = null;

    // for rayTest
    _this._renderer = null;
    return _this;
  }

  // Managing the Physics Simulation

  /**
   * Forces the physics engine to reevaluate possible collisions between physics bodies.
   * @access public
   * @returns {void}
   * @desc By default, SceneKit checks for collisions between physics bodies only once per simulation step. If you directly change the positions of any physics bodies outside of a SCNPhysicsContactDelegate method, call the updateCollisionPairs() method before using any of the methods listed in Searching for Physics Bodies Detecting Contacts Between Physics Bodies.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512877-updatecollisionpairs
   */


  _createClass(SCNPhysicsWorld, [{
    key: 'updateCollisionPairs',
    value: function updateCollisionPairs() {}

    // Registering Physics Behaviors

    /**
     * Adds a behavior to the physics world.
     * @access public
     * @param {SCNPhysicsBehavior} behavior - The behavior to be added.
     * @returns {void}
     * @desc Physics behaviors constrain or modify the effects of the physics simulation on sets of physics bodies. For example, the SCNPhysicsHingeJoint behavior causes two bodies to move as if connected by a hinge that pivots around a specific axis, and the SCNPhysicsVehicle behavior causes a body to roll like a car or other wheeled vehicle.To use a behavior in your scene, follow these steps:Create SCNPhysicsBody objects and attach them to each node that participates in the behavior.Create and configure a behavior object joining the physics bodies. See SCNPhysicsBehavior for a list of behavior classes.Call addBehavior(_:) on your scene’s physics world object to add the behavior to the physics simulation.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512839-addbehavior
     */

  }, {
    key: 'addBehavior',
    value: function addBehavior(behavior) {
      if (this._allBehaviors.indexOf(behavior) >= 0) {
        return;
      }
      this._allBehaviors.push(behavior);
    }

    /**
     * Removes a behavior from the physics world.
     * @access public
     * @param {SCNPhysicsBehavior} behavior - The behavior to be removed.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512870-removebehavior
     */

  }, {
    key: 'removeBehavior',
    value: function removeBehavior(behavior) {
      var index = this._allBehaviors.indexOf(behavior);
      if (index < 0) {
        return;
      }
      this._allBehaviors.splice(index, 1);
    }

    /**
     * Removes all behaviors affecting bodies in the physics world.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512849-removeallbehaviors
     */

  }, {
    key: 'removeAllBehaviors',
    value: function removeAllBehaviors() {
      this._allBehaviors = [];
    }

    /**
     * The list of behaviors affecting bodies in the physics world.
     * @type {SCNPhysicsBehavior[]}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512853-allbehaviors
     */

  }, {
    key: 'contactTestBetween',


    // Detecting Contacts Between Physics Bodies

    /**
     * Checks for contacts between two physics bodies.
     * @access public
     * @param {SCNPhysicsBody} bodyA - The first body (to test for contact with the second).
     * @param {SCNPhysicsBody} bodyB - The second body (to test for contact with the first).
     * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
     * @returns {SCNPhysicsContact[]} - 
     * @desc SceneKit sends messages to the physics world’s contactDelegate object only when collisions occur between bodies whose collisionBitMask and categoryBitMask properties overlap, and only for collisions between certain types of bodies. (For details, see SCNPhysicsBodyType.) Use this method to directly test for contacts between any two bodies at a time of your choosing. For example, to implement a game where the player character can pick up an item, you might call this method when the player presses the “pick up” button to see if the player character is in contact with the item to be picked up.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512875-contacttestbetween
     */
    value: function contactTestBetween(bodyA, bodyB) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      // FIXME: use physics library
      if ((bodyA.categoryBitMask & bodyB.contactTestBitMask) === 0) {
        return [];
      }
      if (!bodyA.physicsShape || !bodyB.physicsShape) {
        return [];
      }
      if (bodyA.type === _SCNPhysicsBodyType2.default.static && bodyB.type === _SCNPhysicsBodyType2.default.static) {
        return [];
      }
      if (bodyA._position.sub(bodyB._position).length() > bodyA._radius + bodyB._radius) {
        return [];
      }
      var shapeA = bodyA.physicsShape._shape;
      var shapeB = bodyB.physicsShape._shape;

      if (shapeA instanceof _SCNBox2.default && shapeB instanceof _SCNBox2.default) {
        return SCNPhysicsWorld._contactTestBetweenBoxes(bodyA, bodyB, options);
      } else if (shapeA instanceof _SCNBox2.default && shapeB instanceof _SCNSphere2.default) {
        return SCNPhysicsWorld._contactTestBetweenBoxAndSphere(bodyA, bodyB, options);
      } else if (shapeB instanceof _SCNBox2.default && shapeA instanceof _SCNSphere2.default) {
        return SCNPhysicsWorld._contactTestBetweenBoxAndSphere(bodyB, bodyA, options, true);
      } else if (shapeA instanceof _SCNSphere2.default && shapeB instanceof _SCNSphere2.default) {
        return SCNPhysicsWorld._contactTestBetweenSpheres(bodyA, bodyB, options);
      }
      return [];
    }

    /**
     * @access private
     * @param {SCNPhysicsBody} boxA -
     * @param {SCNPhysicsBody} boxB -
     * @param {Object} options -
     * @returns {SCNPhysicsContact[]} -
     */

  }, {
    key: 'contactTestWith',


    /**
     * Checks for contacts between one physics body and any other bodies in the physics world.
     * @access public
     * @param {SCNPhysicsBody} body - The body to test for contact.
     * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
     * @returns {SCNPhysicsContact[]} - 
     * @desc SceneKit sends messages to the physics world’s contactdelegate object only when collisions occur between bodies whose collisionBitMask and categoryBitMask properties overlap, and only for collisions between certain types of bodies. (For details, see SCNPhysicsBodyType.) Use this method to directly test for all contacts between one body and any other bodies at a time of your choosing. For example, to implement a game with a “wall jump” effect, you could call this method when the player presses the jump button to see if the player character is in contact with any walls.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512841-contacttest
     */
    value: function contactTestWith(body) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      return [];
    }

    // Searching for Physics Bodies

    /**
     * Searches for physics bodies along a line segment between two points in the physics world.
     * @access public
     * @param {SCNVector3} origin - An endpoint of the line segment to search, specified in the scene’s world coordinate system.
     * @param {SCNVector3} dest - The other endpoint of the line segment to search, specified in the scene’s world coordinate system.
     * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
     * @returns {SCNHitTestResult[]} - 
     * @desc Use this method to implement concepts such as line of sight in your app. For example, in a game you might implement behavior for an enemy character by searching for physics bodies along a line between the enemy character’s position and the player character’s position, as illustrated below:// Options: Look only for the closest object along line of sight,
    // and use the collision bitmask to avoid finding the enemy itself.
    NSDictionary *options = @{ SCNPhysicsTestSearchModeKey : SCNPhysicsTestSearchModeClosest,
                       SCNPhysicsTestCollisionBitMaskKey : @(kMyCategoryPlayer) };
    NSArray *results = [physicsWorld rayTestWithSegmentFromPoint:enemy.position
                                                       toPoint:player.position
                                                       options:options];
    if (results.firstObject.node == player) {
      // Enemy can see player: begin pursuit.
    } else {
      // Enemy cannot see player: remain idle.
    }
    // Options: Look only for the closest object along line of sight,
    // and use the collision bitmask to avoid finding the enemy itself.
    NSDictionary *options = @{ SCNPhysicsTestSearchModeKey : SCNPhysicsTestSearchModeClosest,
                       SCNPhysicsTestCollisionBitMaskKey : @(kMyCategoryPlayer) };
    NSArray *results = [physicsWorld rayTestWithSegmentFromPoint:enemy.position
                                                       toPoint:player.position
                                                       options:options];
    if (results.firstObject.node == player) {
      // Enemy can see player: begin pursuit.
    } else {
      // Enemy cannot see player: remain idle.
    }
      * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512857-raytestwithsegment
     */

  }, {
    key: 'rayTestWithSegmentFromTo',
    value: function rayTestWithSegmentFromTo(origin, dest) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var opt = options;
      if (Array.isArray(options)) {
        opt = new Map(options);
      } else if (options === null) {
        opt = new Map();
      }
      var results = [];

      var backfaceCulling = true;
      var collisionBitMask = -1;
      var searchMode = _TestSearchMode.any;
      if (opt.has(_TestOption.backfaceCulling)) {
        backfaceCulling = opt.get(_TestOption.backfaceCulling);
      }
      if (opt.has(_TestOption.collisionBitMask)) {
        collisionBitMask = opt.get(_TestOption.collisionBitMask);
      }
      if (opt.has(_TestOption.searchMode)) {
        searchMode = opt.get(_TestOption.searchMode);
      }

      //return this._renderer._physicsHitTestByGPU(origin, dest, opt)

      this._scene.rootNode.enumerateChildNodes(function (child) {
        if (child.presentation && child.presentation.physicsBody && child.presentation.physicsBody.categoryBitMask & collisionBitMask) {
          var hits = SCNPhysicsWorld._hitTestWithSegmentPhysicsNode(origin, dest, child.presentation);
          if (hits.length > 0) {
            // convert from child's coordinate to this node's coordinate
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = hits[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var h = _step.value;

                h._node = child;
                h._worldCoordinates = child.convertPositionTo(h._localCoordinates, null);
                h._worldNormal = child.convertPositionTo(h._localNormal, null);
                h._localCoordinates = child.convertPositionFrom(h._localCoordinates, child);
                h._localNormal = child.convertPositionFrom(h._localNormal, child);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            results.push.apply(results, _toConsumableArray(hits));
            if (searchMode === _TestSearchMode.any) {
              // stop searching
              return true;
            }
          }
        }
        return false;
      });
      if (results.length === 0) {
        return results;
      }

      var sortedResults = results.sort(function (a, b) {
        return a._distance - b._distance;
      });
      if (searchMode === _TestSearchMode.closest) {
        sortedResults = [sortedResults[0]];
      }

      return sortedResults;
    }

    /**
     * Searches for physics bodies in the space formed by moving a convex shape through the physics world.
     * @access public
     * @param {SCNPhysicsShape} shape - A physics shape. This shape must enclose a convex volume. For details on creating shapes that satisfy this requirement, see SCNPhysicsShape.
     * @param {SCNMatrix4} from - A transform matrix representing the initial position and orientation of the shape.
     * @param {SCNMatrix4} to - A transform matrix representing the final position and orientation of the shape.
     * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
     * @returns {SCNPhysicsContact[]} - 
     * @desc Use this method when it’s important to plan for (or avoid) collisions ahead of the physics simulation. For example, in a game you might plan maneuvers for a flying character to fit through the gaps between static bodies in the physics world, as illustrated below:// Look for potential collisions along the spaceship's current path.
    SCNMatrix4 current = spaceship.transform;
    SCNMatrix4 upAhead = SCNMatrix4Translate(current, 0, 0, LOOK_AHEAD_DISTANCE);
    NSArray *contacts = [physicsWorld convexSweepTestWithShape:spaceship.physicsBody.physicsShape
                                               fromTransform:current
                                                 toTransform:upAhead
                                                     options:nil];
    if (contacts.count == 0) {
      // Flight path looks okay.
    } else {
      // Flight path will cause a collision: look for another way around.
    }
    // Look for potential collisions along the spaceship's current path.
    SCNMatrix4 current = spaceship.transform;
    SCNMatrix4 upAhead = SCNMatrix4Translate(current, 0, 0, LOOK_AHEAD_DISTANCE);
    NSArray *contacts = [physicsWorld convexSweepTestWithShape:spaceship.physicsBody.physicsShape
                                               fromTransform:current
                                                 toTransform:upAhead
                                                     options:nil];
    if (contacts.count == 0) {
      // Flight path looks okay.
    } else {
      // Flight path will cause a collision: look for another way around.
    }
      * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld/1512859-convexsweeptest
     */

  }, {
    key: 'convexSweepTestWith',
    value: function convexSweepTestWith(shape, from, to) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      // TODO: implement
      return [];
    }

    // Structures

    /**
     * @type {Object} TestOption
     * @property {string} backfaceCulling The key for choosing whether to ignore back-facing polygons in physics shapes when searching for contacts.
     * @property {string} collisionBitMask The key for selecting which categories of physics bodies that SceneKit should test for contacts.
     * @property {string} searchMode The key for selecting the number and order of contacts to be tested.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld.testoption
     */

  }, {
    key: '_simulate',
    value: function _simulate(time) {
      // FIXME: use physics library
      //this._world.stepSimulation(1.0/60.0, 0)
      if (!this._renderer) {
        return;
      }

      var objects = this._renderer._createRenderingPhysicsNodeArray();
      var contacts = [];

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = objects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var obj = _step2.value;

          var body = obj.physicsBody;
          body._prevPosition = body._position;
          if (body.type === _SCNPhysicsBodyType2.default.kinematic) {
            body._resetTransform();
          } else if (body.type === _SCNPhysicsBodyType2.default.dynamic) {
            // TODO: move physics bodies
          }
          body._positionDiff = body._position.sub(body._prevPosition);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var staticType = _SCNPhysicsBodyType2.default.static;
      for (var i = 0; i < objects.length; i++) {
        var bodyA = objects[i].presentation.physicsBody;
        if (bodyA.physicsShape._sourceGeometry instanceof _SCNCapsule2.default) {
          contacts.push.apply(contacts, _toConsumableArray(SCNPhysicsWorld._capsuleTestWithObjects(bodyA, objects)));
        }
        for (var j = 0; j < objects.length; j++) {
          if (i === j) {
            continue;
          }
          var bodyB = objects[j].presentation.physicsBody;
          contacts.push.apply(contacts, _toConsumableArray(this.contactTestBetween(bodyA, bodyB)));
        }
      }

      if (this.contactDelegate) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = contacts[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var contact = _step3.value;

            if (this.contactDelegate.physicsWorldDidBegin) {
              this.contactDelegate.physicsWorldDidBegin(this, contact);
            }
          }
          // TODO: callback
          // this.contactDelegate.physicsWorldDidUpdate
          // this.contactDelegate.physicsWorldDidEnd
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = objects[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _obj = _step4.value;

          var _body = _obj.physicsBody;
          _body._prevPosition = _body._position;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }

    /**
     * @access private
     * @param {SCNPhysicsBody} body -
     * @param {SCNNode[]} objects -
     * @returns {SCNPhysicsContact[]} -
     */

  }, {
    key: 'allBehaviors',
    get: function get() {
      return this._allBehaviors.slice(0);
    }
  }], [{
    key: '_contactTestBetweenBoxes',
    value: function _contactTestBetweenBoxes(boxA, boxB, options) {
      var shapeA = boxA.physicsShape._shape;
      var shapeB = boxB.physicsShape._shape;

      var tb = boxB._transform.mult(boxA._invTransform);
      var nb1 = new _SCNVector2.default(tb.m11, tb.m12, tb.m13).normalize();
      var nb2 = new _SCNVector2.default(tb.m21, tb.m22, tb.m23).normalize();
      var nb3 = new _SCNVector2.default(tb.m31, tb.m32, tb.m33).normalize();
      var b1 = nb1.mul(shapeB.width * 0.5);
      var b2 = nb2.mul(shapeB.height * 0.5);
      var b3 = nb3.mul(shapeB.length * 0.5);
      var d = tb.getTranslation();

      var lax = shapeA.width * 0.5;
      var lay = shapeA.height * 0.5;
      var laz = shapeA.length * 0.5;

      // Ae1
      var rA = lax;
      var rB = Math.abs(b1.x) + Math.abs(b2.x) + Math.abs(b3.x);
      var L = Math.abs(d.x);
      if (L > rA + rB) {
        return [];
      }

      // Ae2
      rA = lay;
      rB = Math.abs(b1.y) + Math.abs(b2.y) + Math.abs(b3.y);
      L = Math.abs(d.y);
      if (L > rA + rB) {
        return [];
      }

      // Ae3
      rA = laz;
      rB = Math.abs(b1.z) + Math.abs(b2.z) + Math.abs(b3.z);
      L = Math.abs(d.z);
      if (L > rA + rB) {
        return [];
      }

      // Be1
      rA = Math.abs(nb1.x * lax) + Math.abs(nb1.y * lay) + Math.abs(nb1.z * laz);
      rB = b1.length();
      L = Math.abs(d.dot(nb1));
      if (L > rA + rB) {
        return [];
      }

      // Be2
      rA = Math.abs(nb2.x * lax) + Math.abs(nb2.y * lay) + Math.abs(nb2.z * laz);
      rB = b2.length();
      L = Math.abs(d.dot(nb2));
      if (L > rA + rB) {
        return [];
      }

      // Be3
      rA = Math.abs(nb3.x * lax) + Math.abs(nb3.y * lay) + Math.abs(nb3.z * laz);
      rB = b3.length();
      L = Math.abs(d.dot(nb3));
      if (L > rA + rB) {
        return [];
      }

      // C11
      var axis = new _SCNVector2.default(0, -nb1.z, nb1.y);
      rA = Math.abs(axis.y * lay) + Math.abs(axis.z * laz);
      rB = Math.abs(axis.dot(b2)) + Math.abs(axis.dot(b3));
      L = Math.abs(d.dot(axis));
      if (L > rA + rB) {
        return [];
      }

      // C12
      axis = new _SCNVector2.default(0, -nb2.z, nb2.y);
      rA = Math.abs(axis.y * lay) + Math.abs(axis.z * laz);
      rB = Math.abs(axis.dot(b3)) + Math.abs(axis.dot(b1));
      L = Math.abs(d.dot(axis));
      if (L > rA + rB) {
        return [];
      }

      // C13
      axis = new _SCNVector2.default(0, -nb3.z, nb3.y);
      rA = Math.abs(axis.y * lay) + Math.abs(axis.z * laz);
      rB = Math.abs(axis.dot(b1)) + Math.abs(axis.dot(b2));
      L = Math.abs(d.dot(axis));
      if (L > rA + rB) {
        return [];
      }

      // C21
      axis = new _SCNVector2.default(nb1.z, 0, -nb1.x);
      rA = Math.abs(axis.x * lax) + Math.abs(axis.z * laz);
      rB = Math.abs(axis.dot(b2)) + Math.abs(axis.dot(b3));
      L = Math.abs(d.dot(axis));
      if (L > rA + rB) {
        return [];
      }

      // C22
      axis = new _SCNVector2.default(nb2.z, 0, -nb2.x);
      rA = Math.abs(axis.x * lax) + Math.abs(axis.z * laz);
      rB = Math.abs(axis.dot(b3)) + Math.abs(axis.dot(b1));
      L = Math.abs(d.dot(axis));
      if (L > rA + rB) {
        return [];
      }

      // C23
      axis = new _SCNVector2.default(nb3.z, 0, -nb3.x);
      rA = Math.abs(axis.x * lax) + Math.abs(axis.z * laz);
      rB = Math.abs(axis.dot(b1)) + Math.abs(axis.dot(b2));
      L = Math.abs(d.dot(axis));
      if (L > rA + rB) {
        return [];
      }

      // C31
      axis = new _SCNVector2.default(-nb1.y, nb1.x, 0);
      rA = Math.abs(axis.x * lax) + Math.abs(axis.y * lay);
      rB = Math.abs(axis.dot(b2)) + Math.abs(axis.dot(b3));
      L = Math.abs(d.dot(axis));
      if (L > rA + rB) {
        return [];
      }

      // C32
      axis = new _SCNVector2.default(-nb2.y, nb2.x, 0);
      rA = Math.abs(axis.x * lax) + Math.abs(axis.y * lay);
      rB = Math.abs(axis.dot(b3)) + Math.abs(axis.dot(b1));
      L = Math.abs(d.dot(axis));
      if (L > rA + rB) {
        return [];
      }

      // C33
      axis = new _SCNVector2.default(-nb3.y, nb3.x, 0);
      rA = Math.abs(axis.x * lax) + Math.abs(axis.y * lay);
      rB = Math.abs(axis.dot(b1)) + Math.abs(axis.dot(b2));
      L = Math.abs(d.dot(axis));
      if (L > rA + rB) {
        return [];
      }

      var contact = new _SCNPhysicsContact2.default();
      contact._nodeA = boxA._node;
      contact._nodeB = boxB._node;
      contact._contactPoint = boxA._position.add(d.mul(0.5) // TODO: implement
      );contact._contactNormal = d.normalize // TODO: implement
      ();contact._penetrationDistance = 0; // TODO: implement

      return [contact];
    }

    /**
     * @access private
     * @param {SCNPhysicsBody} sphereA -
     * @param {SCNPhysicsBody} sphereB -
     * @param {Object} options -
     * @returns {SCNPhysicsContact[]} -
     */

  }, {
    key: '_contactTestBetweenSpheres',
    value: function _contactTestBetweenSpheres(sphereA, sphereB, options) {
      var shapeA = sphereA.physicsShape._shape;
      var shapeB = sphereB.physicsShape._shape;

      var posA = sphereA._position;
      var posB = sphereB._position;
      var radA = shapeA.radius;
      var radB = shapeB.radius;
      var vec = posA.sub(posB);
      var l = vec.length();
      if (l > radA + radB) {
        return [];
      }
      var contact = new _SCNPhysicsContact2.default();
      contact._nodeA = sphereA._node;
      contact._nodeB = sphereB._node;
      contact._contactPoint = posA.add(vec.mul((radA - radB + l) * 0.5));
      contact._contactNormal = vec.mul(-1).normalize();
      contact._penetrationDistance = radA + radB - l;
      return [contact];
    }

    /**
     * @access private
     * @param {SCNPhysicsBody} box -
     * @param {SCNPhysicsBody} sphere -
     * @param {Object} options -
     * @returns {SCNPhysicsContact[]} -
     */

  }, {
    key: '_contactTestBetweenBoxAndSphere',
    value: function _contactTestBetweenBoxAndSphere(box, sphere) {
      var reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var boxShape = box.physicsShape._shape;
      var sphereShape = sphere.physicsShape._shape;

      var size = new _SCNVector2.default();
      var transform = null;
      var spherePos = sphere._position.transform(box._invTransform);
      var v = new _SCNVector2.default();

      var w = boxShape.width * 0.5;
      var h = boxShape.height * 0.5;
      var l = boxShape.length * 0.5;
      if (Math.abs(spherePos.x) - w <= 0) {
        v.x = 0;
      } else {
        v.x = spherePos.x - w;
      }
      if (Math.abs(spherePos.y) - h <= 0) {
        v.y = 0;
      } else {
        v.y = spherePos.y - h;
      }
      if (Math.abs(spherePos.z) - l <= 0) {
        v.z = 0;
      } else {
        v.z = spherePos.z - l;
      }

      var d = v.length();
      if (d > sphereShape.radius) {
        return [];
      }

      var contact = new _SCNPhysicsContact2.default();
      if (reverse) {
        contact._nodeA = sphere._node;
        contact._nodeB = box._node;
      } else {
        contact._nodeA = box._node;
        contact._nodeB = sphere._node;
      }

      contact._contactPoint = v.transform(box._transform);
      contact._contactNormal = v.rotate(box._transform).normalize();
      if (reverse) {
        contact._contactNormal = contact._contactNormal.mul(-1);
      }
      contact._penetrationDistance = d - sphereShape.radius;
      return [contact];
    }
  }, {
    key: '_capsuleTestWithObjects',
    value: function _capsuleTestWithObjects(body, objects) {
      var result = [];

      var objs = objects.filter(function (obj) {
        var bodyB = obj.presentation.physicsBody;
        if (bodyB === body) {
          return false;
        }
        if (bodyB.physicsShape._type !== _SCNPhysicsShape2.default.ShapeType.concavePolyhedron) {
          return false;
        }
        if ((body.categoryBitMask & bodyB.contactTestBitMask) !== 0) {
          return true;
        }
        if ((bodyB.categoryBitMask & body.contactTestBitMask) !== 0) {
          return true;
        }
        return false;
      });
      if (objs.length === 0) {
        return result;
      }

      var bodyTransform = body._node._worldTransform;
      var capsule = body.physicsShape._sourceGeometry;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = objs[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var obj = _step5.value;

          if (!this._intersectsBoundingBox(body._node, obj)) {
            continue;
          }

          var contacts = this._contactTestCapsuleAndConcave(body._node, obj);
          result.push.apply(result, _toConsumableArray(contacts));
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return result;
    }

    /**
     *
     * @access private
     * @param {SCNNode} node1 -
     * @param {SCNNode} node2 -
     * @returns {boolean} -
     */

  }, {
    key: '_intersectsBoundingBox',
    value: function _intersectsBoundingBox(node1, node2) {
      var pos1 = node1._worldTranslation;
      var pos2 = node2._worldTranslation;
      var geo1 = node1.physicsBody.physicsShape._sourceGeometry;
      var geo2 = node2.physicsBody.physicsShape._sourceGeometry;
      if (!geo1 || !geo2) {
        return false;
      }
      var box1 = geo1.boundingBox;
      var box2 = geo2.boundingBox;
      if (box1.min.x + pos1.x > box2.max.x + pos2.x || box1.max.x + pos1.x < box2.min.x + pos2.x) {
        return false;
      }
      if (box1.min.y + pos1.y > box2.max.y + pos2.y || box1.max.y + pos1.y < box2.min.y + pos2.y) {
        return false;
      }
      if (box1.min.z + pos1.z > box2.max.z + pos2.z || box1.max.z + pos1.z < box2.min.z + pos2.z) {
        return false;
      }
      return true;
    }

    /**
     * @access private
     * @param {SCNNode} capNode - the node which has a capsule physicsShape
     * @param {SCNNode} conNode - the node which has a concave physicsShape
     * @returns {SCNPhysicsContact[]} -
     */

  }, {
    key: '_contactTestCapsuleAndConcave',
    value: function _contactTestCapsuleAndConcave(capNode, conNode) {
      var result = [];
      var capBody = capNode.physicsBody;
      var conBody = conNode.physicsBody;
      var capsule = capBody.physicsShape._sourceGeometry;
      var concave = conBody.physicsShape._sourceGeometry;
      var transform = capBody._transform.mult(conBody._invTransform);
      var capSize = capsule.capRadius;
      var capHeight = capsule.height * 0.5 - capSize;
      var capV = capBody._positionDiff.rotate(transform).normalize();
      var p0 = new _SCNVector2.default(0, capHeight, 0).transform(transform);
      var p1 = new _SCNVector2.default(0, -capHeight, 0).transform(transform);
      var elems = concave.geometryElements;
      var vert = concave.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = elems[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var elem = _step6.value;

          if (elem._primitiveType !== _SCNGeometryPrimitiveType2.default.triangles) {
            // TODO: support other primitive types.
            continue;
          }
          var edata = elem._data;
          var elen = elem._primitiveCount;
          var ind = 0;
          //console.warn(`    elen = ${elen}`)
          for (var i = 0; i < elen; i++) {
            var v0 = vert._scnVectorAt(edata[ind]);
            var v1 = vert._scnVectorAt(edata[ind + 1]);
            var v2 = vert._scnVectorAt(edata[ind + 2]);
            ind += 3;

            //const n = this._normalOfTriangle(v0, v1, v2)
            //if(n.dot(capV) >= 0){
            //  continue
            //}

            var contactInfo = this._capsuleTriangleContact(p0, p1, capSize, v0, v1, v2);
            if (contactInfo) {
              var contact = new _SCNPhysicsContact2.default();
              contact._nodeA = capNode;
              contact._nodeB = conNode;
              contact._contactPoint = contactInfo.point;
              contact._contactNormal = contactInfo.normal;
              contact._penetrationDistance = contactInfo.penetration;
              result.push(contact);
            }
          }
        }
        //console.warn(`    result length = ${result.length}`)
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return result;
    }

    // http://marupeke296.com/COL_3D_No27_CapsuleCapsule.html

    /**
     * 
     * @access private
     * @param {SCNVector3} p0 - position of an edge of the capsule (in the triangle's coordinate)
     * @param {SCNVector3} p1 - position of another edge of the capsule (in the triangle's coordinate)
     * @param {number} capSize - capsule radius
     * @param {SCNVector3} v0 - vertex position (in the triangle's coordinate)
     * @param {SCNVector3} v1 - vertex position (in the triangle's coordinate)
     * @param {SCNVector3} v2 - vertex position (in the triangle's coordinate)
     * @returns {?Object} -
     *    {SCNVector3} point -
     *    {SCNVector3} normal -
     *    {number} distance -
     */

  }, {
    key: '_capsuleTriangleContact',
    value: function _capsuleTriangleContact(p0, p1, capSize, v0, v1, v2) {
      var seg = p1.sub(p0);

      var segTri = this._segmentTriangleIntersection(p0, p1, v0, v1, v2);
      if (segTri.intersection) {
        var penetration = 0;
        if (segTri.d0 < 0) {
          penetration = capSize - segTri.d0;
        } else {
          penetration = capSize - segTri.d1;
        }
        return {
          point: segTri.intersection,
          normal: segTri.normal,
          distance: 0,
          penetration: penetration
        };
      }

      var d0 = this._segmentSegmentDist(p0, p1, v0, v1);
      var min = d0;

      var d1 = this._segmentSegmentDist(p0, p1, v1, v2);
      if (d1.distance < min.distance) {
        min = d1;
      }

      var d2 = this._segmentSegmentDist(p0, p1, v2, v0);
      if (d2.distance < min.distance) {
        min = d2;
      }

      var h0 = p0.add(segTri.normal.mul(-segTri.d0));
      if (this._pointIsInsideTriangle(h0, v0, v1, v2)) {
        if (Math.abs(segTri.d0) < min.distance) {
          min.distance = Math.abs(segTri.d0);
          min.nearestPos1 = h0;
        }
      }

      var h1 = p1.add(segTri.normal.mul(-segTri.d1));
      if (this._pointIsInsideTriangle(h1, v0, v1, v2)) {
        if (Math.abs(segTri.d1) < min.distance) {
          min.distance = Math.abs(segTri.d1);
          min.nearestPos1 = h1;
        }
      }

      if (min.distance < capSize) {
        return {
          point: min.nearestPos1,
          normal: segTri.normal,
          distance: 0,
          penetration: capSize - min.distance
        };
      }

      return null;
    }

    /**
     *
     * @access private
     * @param {SCNVector3} p0 - an edge of the segment
     * @param {SCNVector3} p1 - another edge of the segment
     * @param {SCNVector3} v0 - the first point of the vertex
     * @param {SCNVector3} v1 - the second point of the vertex
     * @param {SCNVector3} v2 - the third point of the vertex
     * @returns {Object} -
     *    {SCNVector3} normal - normal vector of the vertex
     *    {number} d0 - distance between p0 and the plane which contains the vertex
     *    {number} d1 - distance between p1 and the plane which contains the vertex
     *    {?SCNVector3} intersection - intersection point of the segment and the vertex
     */

  }, {
    key: '_segmentTriangleIntersection',
    value: function _segmentTriangleIntersection(p0, p1, v0, v1, v2) {
      var v0p0 = p0.sub(v0);
      var v0p1 = p1.sub(v0);
      var n = this._normalOfTriangle(v0, v1, v2);
      var d0 = v0p0.dot(n);
      var d1 = v0p1.dot(n);
      var result = { normal: n, d0: d0, d1: d1, intersection: null };
      if (d0 * d1 > 0) {
        return result;
      }
      var t = d0 / (d0 - d1);
      var h = v0p0.mul(1 - t).add(v0p1.mul(t)).add(v0);
      if (!this._pointIsInsideTriangle(h, v0, v1, v2)) {
        return result;
      }
      result.intersection = h;
      return result;
    }

    /**
     * 
     * @access private
     * @param {SCNVector3} p0 - the first point of the triangle
     * @param {SCNVector3} p1 - the second point of the triangle
     * @param {SCNVector3} p2 - the third point of the triangle
     * @returns {SCNVector3} - normal vector (normalized)
     */

  }, {
    key: '_normalOfTriangle',
    value: function _normalOfTriangle(p0, p1, p2) {
      var v1 = p1.sub(p0);
      var v2 = p2.sub(p0);
      return v1.cross(v2).normalize();
    }

    /**
     * 
     * @access private
     * @param {SCNVector3} p - point
     * @param {SCNVector3} p0 - the first point of the triangle
     * @param {SCNVector3} p1 - the second point of the triangle
     * @param {SCNVector3} p2 - the third point of the triangle
     * @returns {boolean} - true if the point is in the triangle.
     */

  }, {
    key: '_pointIsInsideTriangle',
    value: function _pointIsInsideTriangle(p, p0, p1, p2) {
      var n = this._normalOfTriangle(p0, p1, p2);
      var v0 = p1.sub(p0).cross(n).dot(p.sub(p0));
      var v1 = p2.sub(p1).cross(n).dot(p.sub(p1));
      var v2 = p0.sub(p2).cross(n).dot(p.sub(p2));

      if (v0 < 0 && v1 < 0 && v2 < 0) {
        return true;
      }
      if (v0 > 0 && v1 > 0 && v2 > 0) {
        return true;
      }
      return false;
    }

    /**
     * 
     * @access private
     * @param {SCNVector3} p - point
     * @param {SCNVector3} lp - a point on the line
     * @param {SCNVector3} lv - line vector
     * @returns {Object} -
     *    {number} coeff -
     *    {SCNVector3} nearestPos -
     *    {number} distance -
     */

  }, {
    key: '_pointLineDist',
    value: function _pointLineDist(p, lp, lv) {
      var len2 = lv.length2();
      var t = 0;
      if (len2 > 0) {
        t = lv.dot(p.sub(lp)) / len2;
      }
      var h = lp.add(lv.mul(t));
      var d = h.sub(p).length();
      return {
        coeff: t,
        nearestPos: h,
        distance: d
      };
    }

    /**
     *
     * @access private
     * @param {SCNVector3} p - point
     * @param {SCNVector3} s0 - an edge of the segment
     * @param {SCNVector3} s1 - another edge of the segment
     * @returns {Object} -
     *    {number} coeff -
     *    {SCNVector3} nearestPos -
     *    {number} distance -
     */

  }, {
    key: '_pointSegmentDist',
    value: function _pointSegmentDist(p, s0, s1) {
      var lv = s1.sub(s0);
      var plDist = this._pointLineDist(p, s0, lv);
      if (plDist.coeff < 0) {
        var d = s0.sub(p).length();
        return {
          coeff: plDist.coeff,
          nearestPos: s0,
          distance: d
        };
      } else if (plDist.coeff > 1) {
        var _d = s1.sub(p).length();
        return {
          coeff: plDist.coeff,
          nearestPos: s1,
          distance: _d
        };
      }
      return plDist;
    }

    /**
     *
     * @access private
     * @param {SCNVector3} p0 - a point on the first line
     * @param {SCNVector3} v0 - a line vector
     * @param {SCNVector3} p1 - a point on the second line
     * @param {SCNVector3} v1 - a line vector
     * @returns {Object} -
     *    {number} coeff0 -
     *    {SCNVector3} nearestPos0 - 
     *    {number} coeff1 -
     *    {SCNVector3} nearestPos1 -
     *    {number} distance -
     */

  }, {
    key: '_lineLineDist',
    value: function _lineLineDist(p0, v0, p1, v1) {
      if (this._isParallel(v0, v1)) {
        var plDist = this._pointLineDist(p0, p1, v1);
        return {
          coeff0: 0,
          nearestPos0: p0,
          coeff1: plDist.coeff,
          nearestPos1: plDist.nearestPos,
          distance: plDist.distance
        };
      }

      var v01 = v0.dot(v1);
      var v00 = v0.dot(v0);
      var v11 = v1.dot(v1);
      var p10 = p0.sub(p1);
      var coeff0 = (v01 * v1.dot(p10) - v11 * v0.dot(p10)) / (v00 * v11 - v01 * v01);
      var np0 = p0.add(v0.mul(coeff0));
      var coeff1 = v1.dot(np0.sub(p1)) / v11;
      var np1 = p1.add(v1.mul(coeff1));
      var d = np1.sub(np0).length();

      return {
        coeff0: coeff0,
        nearestPos0: np0,
        coeff1: coeff1,
        nearestPos1: np1,
        distance: d
      };
    }

    /**
     *
     * @access private
     * @param {SCNVector3} v0 - line vector
     * @param {SCNVector3} v1 - line vector
     * @returns {boolean} - true if the lines are parallel
     */

  }, {
    key: '_isParallel',
    value: function _isParallel(v0, v1) {
      var l = v0.cross(v1).length2();
      return l < 0.0000000000001;
    }

    /**
     * 
     * @access private
     * @param {number} -
     * @returns {number} -
     */

  }, {
    key: '_clamp',
    value: function _clamp(val) {
      if (val < 0) {
        return 0;
      }
      if (val > 1) {
        return 1;
      }
      return val;
    }

    /**
     *
     * @access private
     * @param {SCNVector3} s00 - an edge of the first segment
     * @param {SCNVector3} s01 - another edge of the first segment
     * @param {SCNVector3} s10 - an edge of the second segment
     * @param {SCNVector3} s11 - another edge of the second segment
     * @returns {Object} -
     *    {number} coeff0 -
     *    {SCNVector3} nearestPos0 -
     *    {number} coeff1 -
     *    {SCNVector3} nearestPos1 -
     *    {number} distance -
     */

  }, {
    key: '_segmentSegmentDist',
    value: function _segmentSegmentDist(s00, s01, s10, s11) {
      var v0 = s01.sub(s00);
      var v1 = s11.sub(s10);
      var dist = null;
      if (this._isParallel(v0, v1)) {
        dist = this._pointSegmentDist(s00, s10, s11);
        if (0.0 <= dist.coeff && dist.coeff <= 1.0) {
          return {
            coeff0: 0.0,
            nearestPos0: s00,
            coeff1: dist.coeff,
            nearestPos1: dist.nearestPos,
            distance: dist.distance
          };
        }
        dist.coeff0 = 0.0;
        dist.coeff1 = dist.coeff;
      } else {
        dist = this._lineLineDist(s00, v0, s10, v1);
        if (0.0 <= dist.coeff0 && dist.coeff0 <= 1.0 && 0.0 <= dist.coeff1 && dist.coeff1 <= 1.0) {
          return dist;
        }
      }

      var dist2 = dist;
      var t0 = this._clamp(dist.coeff0);
      if (t0 !== dist.coeff0) {
        var p0 = s00.add(v0.mul(t0));
        dist2 = this._pointSegmentDist(p0, s10, s11);
        if (0.0 <= dist2.coeff && dist2.coeff <= 1.0) {
          return {
            coeff0: t0,
            nearestPos0: p0,
            coeff1: dist2.coeff,
            nearestPos1: dist2.nearestPos,
            distance: dist2.distance
          };
        }
        dist2.coeff1 = dist2.coeff;
      }

      var t1 = this._clamp(dist2.coeff1);
      var p1 = s10.add(v1.mul(t1));
      var dist3 = this._pointSegmentDist(p1, s00, s01);
      if (0.0 <= dist3.coeff && dist3.coeff <= 1.0) {
        return {
          coeff0: dist3.coeff,
          nearestPos0: dist3.nearestPos,
          coeff1: t1,
          nearestPos1: p1,
          distance: dist3.distance
        };
      }

      var t = this._clamp(dist3.coeff);
      var p = s00.add(v0.mul(t));
      var d = p1.sub(p).length();
      return {
        coeff0: t,
        nearestPos0: p,
        coeff1: t1,
        nearestPos1: p1,
        distance: d
      };
    }

    /**
     * @access private
     * @param {SCNVector3} p0 - An endpoint of the line segment to test, specified in the world coordinate system.
     * @param {SCNVector3} p1 - The other endpoint of the line segment to test, specified in the world coordinate system.
     * @param {SCNNode} node -
     * @returns {SCNHitTestResult[]} -
     */

  }, {
    key: '_hitTestWithSegmentNode',
    value: function _hitTestWithSegmentNode(pointA, pointB, node) {
      var n = node;
      if (node.presentation && node.presentation.geometry) {
        n = node.presentation;
      }
      var geo = n.geometry;
      if (!geo) {
        return [];
      }

      var pA = n.convertPositionFrom(pointA, null);
      var pB = n.convertPositionFrom(pointB, null
      //if(this._segmentBoundingBoxIntersects(pA, pB, geo.boundingBox) !== null){
      );var r = this._segmentBoundingBoxIntersects(pA, pB, geo.boundingBox);
      if (r !== null) {
        console.error('segmentBoundingBoxIntersects: ' + r.near + ', ' + r.far);
        return this._hitTestWithSegmentGeometry(pA, pB, geo);
      }
      return [];
    }

    /**
     * @access private
     * @param {SCNVector3} p0 - An endpoint of the line segment to test, specified in the world coordinate system.
     * @param {SCNVector3} p1 - The other endpoint of the line segment to test, specified in the world coordinate system.
     * @param {SCNNode} node -
     * @returns {SCNHitTestResult[]} -
     */

  }, {
    key: '_hitTestWithSegmentPhysicsNode',
    value: function _hitTestWithSegmentPhysicsNode(pointA, pointB, node) {
      var n = node;
      if (node.presentation && node.presentation.physicsBody) {
        n = node.presentation;
      }

      var body = n.physicsBody;
      if (body === null) {
        return [];
      }
      var shape = body.physicsShape;
      if (shape === null) {
        return [];
      }
      var geo = shape._sourceGeometry;
      if (geo === null) {
        return [];
      }

      var pA = pointA.transform(body._invTransform);
      var pB = pointB.transform(body._invTransform);
      var r = this._segmentBoundingBoxIntersects(pA, pB, geo.boundingBox);
      if (r !== null) {
        return this._hitTestWithSegmentGeometry(pA, pB, geo);
      }
      return [];
    }

    /**
     * @access private
     * @param {SCNVector3} pointA -
     * @param {SCNVector3} pointB -
     * @param {Object} boundingBox -
     * @results {?Object} -
     */

  }, {
    key: '_segmentBoundingBoxIntersects',
    value: function _segmentBoundingBoxIntersects(pointA, pointB, boundingBox) {
      var v = pointB.sub(pointA);
      var r = this._lineBoundingBoxIntersects(pointA, v, boundingBox);
      if (r === null) {
        return null;
      }
      if (r.near > 1 || r.far < 0) {
        return null;
      }
      return r;
    }

    /**
     * @access private
     * @param {SCNVector3} p - a point on the line
     * @param {SCNVector3} v - line vector
     * @param {Object} boundingBox -
     * @returns {?Object} -
     */

  }, {
    key: '_lineBoundingBoxIntersects',
    value: function _lineBoundingBoxIntersects(p, v, boundingBox) {
      var epsilon = 0.000001;
      var odd = new _SCNVector2.default(1.0 / v.x, 1.0 / v.y, 1.0 / v.z);
      var bmin = boundingBox.min;
      var bmax = boundingBox.max;
      var t1 = bmin.sub(p).mulv(odd);
      var t2 = bmax.sub(p).mulv(odd);

      var near = -Infinity;
      var far = Infinity;

      if (Math.abs(v.x) < epsilon) {
        if (p.x < bmin.x || bmax.x < p.x) {
          return null;
        }
      } else if (t1.x < t2.x) {
        near = Math.max(near, t1.x);
        far = Math.min(far, t2.x);
      } else {
        near = Math.max(near, t2.x);
        far = Math.min(far, t1.x);
      }

      if (Math.abs(v.y) < epsilon) {
        if (p.y < bmin.y || bmax.y < p.y) {
          return null;
        }
      } else if (t1.y < t2.y) {
        near = Math.max(near, t1.y);
        far = Math.min(far, t2.y);
      } else {
        near = Math.max(near, t2.y);
        far = Math.min(far, t1.y);
      }

      if (Math.abs(v.z) < epsilon) {
        if (p.z < bmin.z || bmax.z < p.z) {
          return null;
        }
      } else if (t1.z < t2.z) {
        near = Math.max(near, t1.z);
        far = Math.min(far, t2.z);
      } else {
        near = Math.max(near, t2.z);
        far = Math.min(far, t1.z);
      }

      if (near > far) {
        return null;
      }

      return { near: near, far: far };
    }

    /**
     * @access private
     * @param {SCNVector3} p0 - An endpoint of the line segment to test, specified in the geometry's local coordinate system.
     * @param {SCNVector3} p1 - The other endpoint of the line segment to test, specified in the geometry's local coordinate system.
     * @param {SCNGeometry} geometry -
     * @returns {SCNHitTestResult[]} -
     */

  }, {
    key: '_hitTestWithSegmentGeometry',
    value: function _hitTestWithSegmentGeometry(pointA, pointB, geometry) {
      var results = [];
      var elems = geometry.geometryElements;
      var elemCount = elems.length;
      var vert = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
      for (var i = 0; i < elemCount; i++) {
        var elem = elems[i];
        if (elem._primitiveType !== _SCNGeometryPrimitiveType2.default.triangles) {
          // TODO: support other primitive types.
          continue;
        }
        var edata = elem._data;
        var elen = elem._primitiveCount;
        var ind = 0;
        for (var j = 0; j < elen; j++) {
          var v0 = vert._scnVectorAt(edata[ind]);
          var v1 = vert._scnVectorAt(edata[ind + 1]);
          var v2 = vert._scnVectorAt(edata[ind + 2]);
          ind += 3;

          var r = this._segmentTriangleIntersection(pointA, pointB, v0, v1, v2);
          if (r.intersection) {
            var result = new _SCNHitTestResult2.default();
            result._geometryIndex = i;
            result._faceIndex = j;
            result._localCoordinates = r.intersection;
            result._localNormal = r.normal;
            result._distance = r.intersection.sub(pointA).length();
            results.push(result);
          }
        }
      }
      return results;
    }
  }, {
    key: 'TestOption',
    get: function get() {
      return _TestOption;
    }
    /**
     * @type {Object} TestSearchMode
     * @property {string} all Searches should return all contacts matching the search parameters.
     * @property {string} any Searches should return only the first contact found regardless of its position relative to the search parameters.
     * @property {string} closest Searches should return only the closest contact to the beginning of the search.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsworld.testsearchmode
     */

  }, {
    key: 'TestSearchMode',
    get: function get() {
      return _TestSearchMode;
    }
  }]);

  return SCNPhysicsWorld;
}(_NSObject3.default);

exports.default = SCNPhysicsWorld;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNGeometry2 = __webpack_require__(9);

var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNGeometryElement = __webpack_require__(15);

var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scnbox
 */
var SCNBox = function (_SCNGeometry) {
  _inherits(SCNBox, _SCNGeometry);

  _createClass(SCNBox, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        $constructor: function $constructor(propNames, propValues) {
          var box = new SCNBox(propValues.boxwidth, propValues.boxheight, propValues.boxlength, propValues.boxchamferRadius);
          box.widthSegmentCount = propValues.boxwidthSegmentCount;
          box.heightSegmentCount = propValues.boxheightSegmentCount;
          box.lengthSegmentCount = propValues.boxlengthSegmentCount;
          box.chamferSegmentCount = propValues.boxchamferSegmentCount;
          box.name = propValues.name;
          // propValues.boxPrimitiveType
          box.materials = propValues.materials;
          box.tessellator = propValues.tessellator;
          box.wantsAdaptiveSubdivision = propValues.wantsAdaptiveSubdivision;
          box.subdivisionLevel = propValues.subdivisionLevel;

          return box;
        },
        name: ['string', null],
        boxwidth: ['float', null],
        boxheight: ['float', null],
        boxlength: ['float', null],
        boxwidthSegmentCount: ['integer', null],
        boxheightSegmentCount: ['integer', null],
        boxlengthSegmentCount: ['integer', null],
        boxchamferRadius: ['float', null],
        boxchamferSegmentCount: ['integer', null],
        boxprimitiveType: ['integer', null],
        materials: ['NSArray', null],
        tessellator: ['SCNGeometryTessellator', null],
        wantsAdaptiveSubdivision: ['boolean', null],
        subdivisionLevel: ['integer', null],
        subdivisionSettings: ['bytes', null]
      };
    }

    /**
     * Creates a box geometry with the specified width, height, length, and chamfer radius.
     * @access public
     * @constructor
     * @param {number} [width = 1.0] - The width of the box along the x-axis of its local coordinate space.
     * @param {number} [height = 1.0] - The height of the box along the y-axis of its local coordinate space.
     * @param {number} [length = 1.0] - The length of the box along the z-axis of its local coordinate space.
     * @param {number} [chamferRadius = 0.0] - The radius of curvature for the edges and corners of the box.
     * @desc The box is centered in its local coordinate system. For example, if you create a box whose width, height and length are all 10.0, it extends from -5.0 to 5.0 along in each of the x-, y-, and z-axes.
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1522620-init
     */

  }]);

  function SCNBox() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
    var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;
    var chamferRadius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.0;

    _classCallCheck(this, SCNBox);

    // Adjusting a Box’s Dimensions

    /**
     * The extent of the box along its x-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1523898-width
     */
    var _this = _possibleConstructorReturn(this, (SCNBox.__proto__ || Object.getPrototypeOf(SCNBox)).call(this, [], []));

    _this.width = width;

    /**
     * The extent of the box along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1522901-height
     */
    _this.height = height;

    /**
     * The extent of the box along its z-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1523514-length
     */
    _this.length = length;

    // Configuring Box Properties

    /**
     * The number of subdivisions in each face of the box along its x-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1523559-widthsegmentcount
     */
    _this.widthSegmentCount = 1;

    /**
     * The number of subdivisions in each face of the box along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1522869-heightsegmentcount
     */
    _this.heightSegmentCount = 1;

    /**
     * The number of subdivisions in each face of the box along its z-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1523721-lengthsegmentcount
     */
    _this.lengthSegmentCount = 1;

    // Adding Rounded Edges and Corners

    /**
     * The radius of curvature for the edges and corners of the box. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1523302-chamferradius
     */
    _this.chamferRadius = chamferRadius;

    /**
     * The number of line segments used to create each rounded edge of the box. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnbox/1522976-chamfersegmentcount
     */
    _this.chamferSegmentCount = 10;

    _this._createGeometry();
    _this.materials.push(new _SCNMaterial2.default());
    return _this;
  }

  _createClass(SCNBox, [{
    key: '_createGeometry',
    value: function _createGeometry() {
      var sourceData = [];
      var indexData = [];

      var left = -this.width * 0.5;
      var right = this.width * 0.5;
      var top = this.height * 0.5;
      var bottom = -this.height * 0.5;
      var front = this.length * 0.5;
      var back = -this.length * 0.5;

      // front
      sourceData.push(left, bottom, front // position
      );sourceData.push(0, 0, 1 // normal
      );sourceData.push(0, 1 // texcoord

      );sourceData.push(left, top, front);
      sourceData.push(0, 0, 1);
      sourceData.push(0, 0);

      sourceData.push(right, bottom, front);
      sourceData.push(0, 0, 1);
      sourceData.push(1, 1);

      sourceData.push(right, top, front);
      sourceData.push(0, 0, 1);
      sourceData.push(1, 0);

      indexData.push(0, 3, 1);
      indexData.push(0, 2, 3

      // right
      );sourceData.push(right, bottom, front);
      sourceData.push(1, 0, 0);
      sourceData.push(0, 1);

      sourceData.push(right, top, front);
      sourceData.push(1, 0, 0);
      sourceData.push(0, 0);

      sourceData.push(right, bottom, back);
      sourceData.push(1, 0, 0);
      sourceData.push(1, 1);

      sourceData.push(right, top, back);
      sourceData.push(1, 0, 0);
      sourceData.push(1, 0);

      indexData.push(4, 7, 5);
      indexData.push(4, 6, 7

      // back
      );sourceData.push(right, bottom, back);
      sourceData.push(0, 0, -1);
      sourceData.push(0, 1);

      sourceData.push(right, top, back);
      sourceData.push(0, 0, -1);
      sourceData.push(0, 0);

      sourceData.push(left, bottom, back);
      sourceData.push(0, 0, -1);
      sourceData.push(1, 1);

      sourceData.push(left, top, back);
      sourceData.push(0, 0, -1);
      sourceData.push(1, 0);

      indexData.push(8, 11, 9);
      indexData.push(8, 10, 11

      // left
      );sourceData.push(left, bottom, back);
      sourceData.push(-1, 0, 0);
      sourceData.push(0, 1);

      sourceData.push(left, top, back);
      sourceData.push(-1, 0, 0);
      sourceData.push(0, 0);

      sourceData.push(left, bottom, front);
      sourceData.push(-1, 0, 0);
      sourceData.push(1, 1);

      sourceData.push(left, top, front);
      sourceData.push(-1, 0, 0);
      sourceData.push(1, 0);

      indexData.push(12, 15, 13);
      indexData.push(12, 14, 15

      // top
      );sourceData.push(left, top, front);
      sourceData.push(0, 1, 0);
      sourceData.push(0, 1);

      sourceData.push(left, top, back);
      sourceData.push(0, 1, 0);
      sourceData.push(0, 0);

      sourceData.push(right, top, front);
      sourceData.push(0, 1, 0);
      sourceData.push(1, 1);

      sourceData.push(right, top, back);
      sourceData.push(0, 1, 0);
      sourceData.push(1, 0);

      indexData.push(16, 19, 17);
      indexData.push(16, 18, 19

      // bottom
      );sourceData.push(left, bottom, back);
      sourceData.push(0, -1, 0);
      sourceData.push(0, 1);

      sourceData.push(left, bottom, front);
      sourceData.push(0, -1, 0);
      sourceData.push(0, 0);

      sourceData.push(right, bottom, back);
      sourceData.push(0, -1, 0);
      sourceData.push(1, 1);

      sourceData.push(right, bottom, front);
      sourceData.push(0, -1, 0);
      sourceData.push(1, 0);

      indexData.push(20, 23, 21);
      indexData.push(20, 22, 23);

      var vertexSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.vertex, // semantic
      24, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      32 // sride
      );

      var normalSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.normal, // semantic
      24, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      12, // offset
      32 // stride
      );

      var texcoordSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.texcoord, // semantic
      24, // vectorCount
      true, // floatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      24, // offset
      32 // stride
      );

      var element = new _SCNGeometryElement2.default(indexData, _SCNGeometryPrimitiveType2.default.triangles);

      this._geometryElements = [element];
      this._geometrySources = [vertexSource, normalSource, texcoordSource];
      this.boundingBox = {
        min: new _SCNVector2.default(left, bottom, back),
        max: new _SCNVector2.default(right, top, front)
      };
    }
  }, {
    key: '_updateBoundingBoxForSkinner',
    value: function _updateBoundingBoxForSkinner() {
      var skinner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (skinner === null) {
        return this.boundingBox;
      }
      return _get(SCNBox.prototype.__proto__ || Object.getPrototypeOf(SCNBox.prototype), '_updateBoundingBoxForSkinner', this).call(this, skinner);
    }

    /**
     * @access private
     * @param {number[]} sourceData -
     * @param {number[]} indexData -
     * @param {SCNVector3} v1 - position 1
     * @param {SCNVector3} v2 - position 2
     * @param {SCNVector3} v3 - position 3
     * @param {SCNVector3} v4 - position 4
     * @param {number} s1 - segmentCount 1
     * @param {number} s2 - segmentCount 2
     * @returns {void}
     */

  }, {
    key: '_createFace',
    value: function _createFace(sourceData, indexData, v1, v2, v3, v4, s1, s2) {}

    /**
     * @access private
     * @returns {Ammo.btCollisionShape} -
     * @desc call Ammo.destroy(shape) after using it.
     */

  }, {
    key: '_createBtCollisionShape',
    value: function _createBtCollisionShape() {
      //const size = new Ammo.btVector3(this.width * 0.5, this.height * 0.5, this.length * 0.5)
      //const shape = new Ammo.btBoxShape(size)
      //Ammo.destroy(size)
      //return shape
    }
  }]);

  return SCNBox;
}(_SCNGeometry3.default);

exports.default = SCNBox;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _CABasicAnimation = __webpack_require__(45);

var _CABasicAnimation2 = _interopRequireDefault(_CABasicAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
//import CAMediaTimingFunction from '../QuartzCore/CAMediaTimingFunction'


//import SCNAnimationEvent from './SCNAnimationEvent'

var _transactions = [];
var _immediateMode = true;

var _Transaction = function _Transaction() {
  _classCallCheck(this, _Transaction);

  /**
   * @type {Object}
   */
  this._animations = [];

  /**
   * @type {number}
   */
  this._animationDuration = 0.0;

  /**
   * @type {?CAMediaTimingFunction}
   */
  this._animationTimingFunction = null;

  /**
   * @type {boolean}
   */
  this._disableActions = false;

  /**
   * @type {?function}
   */
  this._completionBlock = null;

  /**
   * @type {Map<string, Object>}
   */
  this._values = new Map();
};

var _automaticTransaction = new _Transaction();

/**
 * The SCNTransaction class defines SceneKit’s mechanism for batching scene graph modifications into atomic updates. You use SCNTransaction class methods to control the animation that results from changing animatable properties in the scene graph and to combine sets of changes into nested transactions.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scntransaction
 */

var SCNTransaction = function (_NSObject) {
  _inherits(SCNTransaction, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNTransaction() {
    _classCallCheck(this, SCNTransaction);

    var _this = _possibleConstructorReturn(this, (SCNTransaction.__proto__ || Object.getPrototypeOf(SCNTransaction)).call(this));

    throw new Error('do not create an instance of SCNTransaction');
    return _this;
  }

  // Creating and Committing Transactions

  /**
   * Begins a new transaction for the current thread.
   * @access public
   * @returns {void}
   * @desc The new transaction is nested within the thread’s current transaction, if there is one.The first time you modify the scene graph during a pass through the run loop, SceneKit automatically creates a transaction and makes it the current transaction. (SceneKit commits that transaction when the next iteration of the run loops begins.) If you call this method to create a custom transaction before modifying the scene graph, your custom transaction becomes the current transaction.
   * @see https://developer.apple.com/documentation/scenekit/scntransaction/1522820-begin
   */


  _createClass(SCNTransaction, null, [{
    key: 'begin',
    value: function begin() {
      var newTransaction = new _Transaction();
      newTransaction._disableActions = this._currentTransaction._disabledActions;
      _transactions.push(newTransaction);
    }

    /**
     * Commits all changes made during the current transaction.
     * @access public
     * @returns {void}
     * @desc If there is no current transaction, this method has no effect.
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523436-commit
     */

  }, {
    key: 'commit',
    value: function commit() {
      var transaction = _transactions.pop();
      if (transaction) {
        this._apply(transaction);
      }
    }

    /**
     * Applies all changes from the current automatic transaction.
     * @access public
     * @returns {void}
     * @desc SceneKit automatically calls this method at the end of each pass through the run loop, regardless of the run loop mode. If your app does not have a run loop, you must call this method explicitly.If the current transaction has any nested transactions that are still animating, SceneKit waits to commit the current transaction’s changes until those transactions complete.NoteIf possible, avoid calling flush() explicitly. By allowing flush() to execute during the run loop, your app achieves better performance, atomic screen updates are preserved, and transactions and animations that work from transaction to transaction continue to function.
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1522860-flush
     */

  }, {
    key: 'flush',
    value: function flush() {
      // TODO: wait nested transactions
      this._apply(_automaticTransaction);
    }
  }, {
    key: '_apply',
    value: function _apply(transaction) {
      if (transaction._disableActions || transaction._animationDuration === 0) {
        transaction._animations.forEach(function (anim) {
          anim.target.setValueForKeyPath(anim.newValue, anim.keyPath);
        });
        if (transaction._completionBlock) {
          transaction._completionBlock();
        }
      } else {
        var promises = [];
        transaction._animations.forEach(function (anim) {
          var promise = new Promise(function (resolve, reject) {
            var animation = new _CABasicAnimation2.default(anim.keyPath);
            animation.fromValue = anim.diff;
            animation.timingFunction = transaction._animationTimingFunction;
            animation.duration = transaction._animationDuration;
            animation.isAdditive = true;
            animation.isRemovedOnCompletion = true;
            animation.delegate = {
              animationDidStop: function animationDidStop(_anim, _finished) {
                if (_finished) {
                  anim.target.setValueForKeyPath(anim.newValue, anim.keyPath);
                  resolve(anim, animation);
                }
              }
            };
            anim.target.addAnimationForKey(animation, null);
          });
          promises.push(promise);
        });
        Promise.all(promises).then(function () {
          if (transaction._completionBlock) {
            transaction._completionBlock();
          }
        });
      }
    }

    // Overriding Animation Duration and Timing

    /**
     * Returns the duration, in seconds, of all animations within the current transaction.
     * @type {number}
     * @desc The default duration is zero for transactions automatically created by SceneKit, and 0.25 for animations you create using the begin() method.
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523888-animationduration
     */

  }, {
    key: 'lock',


    // Managing Concurrency

    /**
     * Attempts to acquire a recursive spinlock to ensure the validity of values you retrieve during the transaction.
     * @access public
     * @returns {void}
     * @desc SceneKit’s data model is thread-safe in that it ensures that internal data structures will not be corrupted by concurrent attempts to modify their contents from multiple threads. However, this model does not guarantee the validity of values you read from scene graph objects after returning them.For example, consider the following operation:_node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
    The intent of this line is to move a node by ten units. But if another thread modifies the node’s position property concurrently, the new position value could be unexpected. If your app modifies the scene graph from multiple threads, use a transaction lock to ensure that your modifications take effect as intended.[SCNTransaction lock];
    _node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
    [SCNTransaction unlock];
    If another thread currently holds a lock on the transaction, calling lock() has no effect._node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
    [SCNTransaction lock];
    _node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
    [SCNTransaction unlock];
      * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523078-lock
     */
    value: function lock() {
      throw new Error('lock() is not implemented');
    }

    /**
     * Relinquishes a previously acquired transaction lock.
     * @access public
     * @returns {void}
     * @desc See the lock() method for more details on transaction locking.
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523166-unlock
     */

  }, {
    key: 'unlock',
    value: function unlock() {
      throw new Error('unlock() is not implemented');
    }

    // Getting and Setting Transaction Properties

    /**
     * Associates an arbitrary object with the current transaction using the specified key.
     * @access public
     * @param {?Object} value - 
     * @param {string} key - A unique string identifying the object for later retrieval.
     * @returns {void}
     * @desc Nested transactions have nested data scope. Setting a value for a key associates it with the current transaction (or innermost nested transaction) only, and reading the value for a key searches through nested transactions (starting from the innermost).
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1524124-setvalue
     */

  }, {
    key: 'setValueForKey',
    value: function setValueForKey(value, key) {
      this._currentTransaction._values.set(key, value);
    }

    /**
     * Returns the object previously associated with the current transaction using the specified key.
     * @access public
     * @param {string} key - The unique string identifying an object previously associated with the transaction.
     * @returns {?Object} - 
     * @desc Nested transactions have nested data scope. Setting a value for a key associates it with the current transaction (or innermost nested transaction) only, but reading the value for a key searches through nested transactions (starting from the innermost).
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523919-value
     */

  }, {
    key: 'valueForKey',
    value: function valueForKey(key) {
      for (var i = _transactions.length - 1; i >= 0; i--) {
        var value = _transactions[i]._values.get(key);
        if (typeof value !== 'undefined') {
          return value;
        }
      }
      return _automaticTransaction._values.get(key);
    }

    /**
     * @access private
     * @returns {_Transaction} -
     */

  }, {
    key: '_addChange',


    /**
     * @access private
     * @param {Object} target -
     * @param {string} keyPath -
     * @param {Object|number} oldValue -
     * @param {Object|number} newValue -
     * @returns {void}
     */
    value: function _addChange(target, keyPath, oldValue, newValue) {
      if (this.immediateMode) {
        target.setValueForKeyPath(newValue, keyPath);
      } else {
        var diff = null;
        if (typeof newValue === 'number') {
          diff = oldValue - newValue;
        } else if (typeof newValue.sub !== 'undefined') {
          diff = oldValue.sub(newValue);
        } else {
          throw new Error('keyPath ' + keyPath + ' does not have sub function');
        }
        this._currentTransaction._animations.push({
          target: target,
          keyPath: keyPath,
          diff: diff,
          oldValue: oldValue,
          newValue: newValue
        });
      }
    }

    /**
     * @access public
     * @type {boolean}
     */

  }, {
    key: 'animationDuration',
    get: function get() {
      return this._currentTransaction._animationDuration;
    }

    /**
     * Returns the duration, in seconds, of all animations within the current transaction.
     * @type {number}
     * @param {number} newValue -
     * @desc The default duration is zero for transactions automatically created by SceneKit, and 0.25 for animations you create using the begin() method.
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523888-animationduration
     */
    ,
    set: function set(newValue) {
      this._currentTransaction._animationDuration = newValue;
    }

    /**
     * Returns the timing function that SceneKit uses for all animations within this transaction group. 
     * @type {?CAMediaTimingFunction}
     * @desc Media timing functions, also known as animation curves, define the relationship between the elapsed time of an animation and its effect on a property. For example, the kCAMediaTimingFunctionEaseInEaseOut function creates an effect that begins slowly, speeds up, and then finishes slowly.
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1522614-animationtimingfunction
     */

  }, {
    key: 'animationTimingFunction',
    get: function get() {
      return this._currentTransaction._animationTimingFunction;
    }

    /**
     * Returns the timing function that SceneKit uses for all animations within this transaction group. 
     * @type {?CAMediaTimingFunction}
     * @param {?CAMediaTimingFunction} newValue -
     * @desc Media timing functions, also known as animation curves, define the relationship between the elapsed time of an animation and its effect on a property. For example, the kCAMediaTimingFunctionEaseInEaseOut function creates an effect that begins slowly, speeds up, and then finishes slowly.
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1522614-animationtimingfunction
     */
    ,
    set: function set(newValue) {
      this._currentTransaction._animationTimingFunction = newValue;
    }

    // Temporarily Disabling Property Animations

    /**
     * Returns a Boolean value indicating whether changes to animatable properties during the transaction are implicitly animated.
     * @type {boolean}
     * @desc By default (when this property is false), any changes to animatable properties of objects in the scene graph implicitly create animations. (These animations may not be visible unless you use the animationDuration property to set a nonzero duration for the transaction.) Set this property to true to disable implicit animation during the transaction.Disabling animation applies to all property changes in the current transaction and any nested transactions within it. However, you can use this property again within a nested transaction to enable implicit animation for that transaction.
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1524238-disableactions
     */

  }, {
    key: 'disableActions',
    get: function get() {
      return this._currentTransaction._disableActions;
    }

    /**
     * Returns a Boolean value indicating whether changes to animatable properties during the transaction are implicitly animated.
     * @type {boolean}
     * @param {boolean} newValue -
     * @desc By default (when this property is false), any changes to animatable properties of objects in the scene graph implicitly create animations. (These animations may not be visible unless you use the animationDuration property to set a nonzero duration for the transaction.) Set this property to true to disable implicit animation during the transaction.Disabling animation applies to all property changes in the current transaction and any nested transactions within it. However, you can use this property again within a nested transaction to enable implicit animation for that transaction.
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1524238-disableactions
     */
    ,
    set: function set(newValue) {
      this._currentTransaction._disableActions = newValue;
    }

    // Getting and Setting Completion Block Objects

    /**
     * Returns the block previously associated with the current transaction.
     * @type {?function(): void}
     * @desc See setCompletionBlock(_:) for a description of the role of the completion block object.
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523660-completionblock
     */

  }, {
    key: 'completionBlock',
    get: function get() {
      return this._currentTransaction._completionBlock;
    }

    /**
     * Returns the block previously associated with the current transaction.
     * @type {?function(): void}
     * @param {?function(): void} newValue -
     * @desc See setCompletionBlock(_:) for a description of the role of the completion block object.
     * @see https://developer.apple.com/documentation/scenekit/scntransaction/1523660-completionblock
     */
    ,
    set: function set(newValue) {
      this._currentTransaction._completionBlock = newValue;
    }
  }, {
    key: '_currentTransaction',
    get: function get() {
      if (_transactions.length > 0) {
        return _transactions[_transactions.length - 1];
      }
      return _automaticTransaction;
    }
  }, {
    key: 'immediateMode',
    get: function get() {
      if (_transactions.length > 0) {
        return false;
      }
      return _immediateMode;
    }

    /**
     * @access public
     * @type {boolean}
     * @param {boolean} newValue -
     */
    ,
    set: function set(newValue) {
      _immediateMode = newValue;
    }
  }]);

  return SCNTransaction;
}(_NSObject3.default);

exports.default = SCNTransaction;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BinaryRequest = undefined;

var _AjaxRequest2 = __webpack_require__(54);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * BinaryRequest class
 * @access public
 */
var BinaryRequest = exports.BinaryRequest = function (_AjaxRequest) {
  _inherits(BinaryRequest, _AjaxRequest);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function BinaryRequest() {
    _classCallCheck(this, BinaryRequest);

    var _this = _possibleConstructorReturn(this, (BinaryRequest.__proto__ || Object.getPrototypeOf(BinaryRequest)).call(this));

    _this.defaultOptions.mimeType = 'text/plain; charset=x-user-defined';
    return _this;
  }

  return BinaryRequest;
}(_AjaxRequest2.AjaxRequest);

exports.default = new BinaryRequest();

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _NSObject = __webpack_require__(0);

var _NSObject2 = _interopRequireDefault(_NSObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ClassList = new Map();

var _classProperties = ['superclass', 'isSubclassOf', 'className'];
var _instanceProperties = ['isInstanceOf', 'className'];

_ClassList.registerClass = function (classObj, className) {
  //let className = classObj.className
  //const structInitializer = classObj._initWithData
  //if(typeof className === 'undefined'){
  //  if(typeof structInitializer === 'undefined'){
  //    // doesn't seem to be an instance of NSObject
  //    return
  //  }
  //  className = classObj.prototype.constructor.name
  //}
  classObj._className = className;

  // copy utility functions
  if (typeof classObj.superclass === 'undefined' && typeof classObj.prototype !== 'undefined') {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _classProperties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var name = _step.value;

        var org = Object.getOwnPropertyDescriptor(_NSObject2.default, name);
        Object.defineProperty(classObj, name, org);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _instanceProperties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _name = _step2.value;

        var _org = Object.getOwnPropertyDescriptor(_NSObject2.default.prototype, _name);
        Object.defineProperty(classObj.prototype, _name, _org);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  _ClassList.set(className, classObj);
};

exports.default = _ClassList;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GCControllerElement2 = __webpack_require__(31);

var _GCControllerElement3 = _interopRequireDefault(_GCControllerElement2);

var _GCControllerAxisInput = __webpack_require__(64);

var _GCControllerAxisInput2 = _interopRequireDefault(_GCControllerAxisInput);

var _GCControllerButtonInput = __webpack_require__(30);

var _GCControllerButtonInput2 = _interopRequireDefault(_GCControllerButtonInput);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import GCControllerDirectionPadValueChangedHandler from './GCControllerDirectionPadValueChangedHandler'


/**
 * A control element associated with a directional pad or a thumbstick.
 * @access public
 * @extends {GCControllerElement}
 * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad
 */
var GCControllerDirectionPad = function (_GCControllerElement) {
  _inherits(GCControllerDirectionPad, _GCControllerElement);

  /**
   * constructor
   * @access public
   */
  function GCControllerDirectionPad() {
    _classCallCheck(this, GCControllerDirectionPad);

    // Reading the Directional Pad as a Pair of Axes

    var _this = _possibleConstructorReturn(this, (GCControllerDirectionPad.__proto__ || Object.getPrototypeOf(GCControllerDirectionPad)).call(this));

    _this._xAxis = new _GCControllerAxisInput2.default();
    _this._yAxis = new _GCControllerAxisInput2.default();

    // Reading the Directional Pad as a Four Directional Buttons

    _this._up = new _GCControllerButtonInput2.default();
    _this._down = new _GCControllerButtonInput2.default();
    _this._left = new _GCControllerButtonInput2.default();
    _this._right = new _GCControllerButtonInput2.default();

    // Receiving Notifications When the Directional Pad’s Values Change

    /**
     * A handler to be called when the directional pad element changes values.
     * @type {?GCControllerDirectionPadValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462914-valuechangedhandler
     */
    _this.valueChangedHandler = null;
    return _this;
  }

  // Reading the Directional Pad as a Pair of Axes

  /**
   * The value of the directional pad along the horizontal axis (left and right).
   * @type {GCControllerAxisInput}
   * @desc 
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462930-xaxis
   */


  _createClass(GCControllerDirectionPad, [{
    key: 'xAxis',
    get: function get() {
      return this._xAxis;
    }

    /**
     * The value of the directional pad along the vertical axis (up and down).
     * @type {GCControllerAxisInput}
     * @desc 
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462926-yaxis
     */

  }, {
    key: 'yAxis',
    get: function get() {
      return this._yAxis;
    }

    // Reading the Directional Pad as a Four Directional Buttons

    /**
     * A measurement of how far up the directional pad has been moved.
     * @type {GCControllerButtonInput}
     * @desc The value of the up property is mutually exclusive with the value of the down property. This means that whenever the value of the up property is non-zero, the value of the down property is 0.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462918-up
     */

  }, {
    key: 'up',
    get: function get() {
      return this._up;
    }

    /**
     * A measurement of how far down the directional pad has been moved.
     * @type {GCControllerButtonInput}
     * @desc The value of the down property is mutually exclusive with the value of the up property. This means that whenever the value of the down property is non-zero, the value of the up property is 0.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462920-down
     */

  }, {
    key: 'down',
    get: function get() {
      return this._down;
    }

    /**
     * A measurement of how far left the directional pad has been moved.
     * @type {GCControllerButtonInput}
     * @desc The value of the left property is mutually exclusive with the value of the right property. This means that whenever the value of the left property is non-zero, the value of the right property is 0.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462924-left
     */

  }, {
    key: 'left',
    get: function get() {
      return this._left;
    }

    /**
     * A measurement of how far right the directional pad has been moved.
     * @type {GCControllerButtonInput}
     * @desc The value of the right property is mutually exclusive with the value of the left property. This means that whenever the value of the right property is non-zero, the value of the left property is 0.
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrollerdirectionpad/1462922-right
     */

  }, {
    key: 'right',
    get: function get() {
      return this._right;
    }
  }]);

  return GCControllerDirectionPad;
}(_GCControllerElement3.default);

exports.default = GCControllerDirectionPad;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _CGRect = __webpack_require__(16);

var _CGRect2 = _interopRequireDefault(_CGRect);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

var _CGVector = __webpack_require__(60);

var _CGVector2 = _interopRequireDefault(_CGVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _DecodingFailurePolicy = {
  raiseException: Symbol('raiseException'),
  setErrorAndReturn: Symbol('setErrorAndReturn')

  /**
   * The NSCoder abstract class declares the interface used by concrete subclasses to transfer objects and other values between memory and some other format. This capability provides the basis for archiving (where objects and data items are stored on disk) and distribution (where objects and data items are copied between different processes or threads). The concrete subclasses provided by Foundation for these purposes are NSArchiver, NSUnarchiver, NSKeyedArchiver, NSKeyedUnarchiver, and NSPortCoder. Concrete subclasses of NSCoder are referred to in general as coder classes, and instances of these classes as coder objects (or simply coders). A coder object that can only encode values is referred to as an encoder object, and one that can only decode values as a decoder object.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/foundation/nscoder
   */
};
var NSCoder = function (_NSObject) {
  _inherits(NSCoder, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function NSCoder() {
    _classCallCheck(this, NSCoder);

    // Inspecting a Coder

    var _this = _possibleConstructorReturn(this, (NSCoder.__proto__ || Object.getPrototypeOf(NSCoder)).call(this));

    _this._allowsKeyedCoding = false;

    // Secure Coding

    _this._requiresSecureCoding = false;
    _this._allowedClasses = null;

    // Getting Version Information

    _this._systemVersion = 0;

    // Instance Properties

    _this._decodingFailurePolicy = null;
    _this._error = null;
    return _this;
  }

  _createClass(NSCoder, [{
    key: 'containsValueForKey',


    // Inspecting a Coder

    /**
     * Returns a Boolean value that indicates whether an encoded value is available for a string.
     * @access public
     * @param {string} key - 
     * @returns {boolean} - 
     * @desc Subclasses must override this method if they perform keyed coding. The string is passed as key.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1416125-containsvalue
     */
    value: function containsValueForKey(key) {
      return false;
    }
    /**
     * A Boolean value that indicates whether the receiver supports keyed coding of objects.
     * @type {boolean}
     * @desc false by default. Concrete subclasses that support keyed coding, such as NSKeyedArchiver, need to override this property to return true.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1417541-allowskeyedcoding
     */

  }, {
    key: 'encodeArrayOfObjCTypeAt',


    // Encoding General Data

    /**
     * Encodes an array of count items, whose Objective-C type is given by itemType.
     * @access public
     * @param {UnsafePointer<Int8>} type - 
     * @param {number} count - 
     * @param {UnsafeRawPointer} array - 
     * @returns {void}
     * @desc The values are encoded from the buffer beginning at address. itemType must contain exactly one type code. NSCoder’s implementation invokes encodeValue(ofObjCType:at:) to encode the entire array of items. Subclasses that implement the encodeValue(ofObjCType:at:) method do not need to override this method.This method must be matched by a subsequent decodeArray(ofObjCType:count:at:) message.For information on creating an Objective-C type code suitable for itemType, see Type Encodings.Special ConsiderationsYou should not use this method to encode C arrays of Objective-C objects. See decodeArray(ofObjCType:count:at:) for more details.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1417865-encodearray
     */
    value: function encodeArrayOfObjCTypeAt(type, count, array) {}

    /**
     * Encodes the object objv and associates it with the string key.
     * @access public
     * @param {?Object} objv - 
     * @param {string} key - 
     * @returns {void}
     * @desc Subclasses must override this method to identify multiple encodings of objv and encode a reference to objv instead. For example, NSKeyedArchiver detects duplicate objects and encodes a reference to the original object rather than encode the same object twice.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1411568-encode
     */

  }, {
    key: 'encodeForKey',
    value: function encodeForKey(objv, key) {}

    /**
     * Can be overridden by subclasses to encode object so that a copy, rather than a proxy, is created upon decoding.
     * @access public
     * @param {?Object} anObject - 
     * @returns {void}
     * @desc NSCoder’s implementation simply invokes encode(_:).This method must be matched by a corresponding decodeObject() message.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1418225-encodebycopyobject
     */

  }, {
    key: 'encodeBycopyObject',
    value: function encodeBycopyObject(anObject) {}

    /**
     * Can be overridden by subclasses to encode object so that a proxy, rather than a copy, is created upon decoding.
     * @access public
     * @param {?Object} anObject - 
     * @returns {void}
     * @desc NSCoder’s implementation simply invokes encode(_:).This method must be matched by a corresponding decodeObject() message.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1416279-encodebyrefobject
     */

  }, {
    key: 'encodeByrefObject',
    value: function encodeByrefObject(anObject) {}

    /**
     * Encodes a buffer of data whose types are unspecified.
     * @access public
     * @param {?UnsafeRawPointer} byteaddr - 
     * @param {number} length - 
     * @returns {void}
     * @desc The buffer to be encoded begins at address, and its length in bytes is given by numBytes.This method must be matched by a corresponding decodeBytes(withReturnedLength:) message.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1411664-encodebytes
     */

  }, {
    key: 'encodeBytes',
    value: function encodeBytes(byteaddr, length) {}

    /**
     * Encodes a buffer of data, bytesp, whose length is specified by lenv, and associates it with the string key.
     * @access public
     * @param {?UnsafePointer<UInt8>} bytesp - 
     * @param {number} lenv - 
     * @param {string} key - 
     * @returns {void}
     * @desc Subclasses must override this method if they perform keyed coding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1413078-encodebytes
     */

  }, {
    key: 'encodeBytesLengthForKey',
    value: function encodeBytesLengthForKey(bytesp, lenv, key) {}

    /**
     * Can be overridden by subclasses to conditionally encode object, preserving common references to that object.
     * @access public
     * @param {?Object} object - 
     * @returns {void}
     * @desc In the overriding method, object should be encoded only if it’s unconditionally encoded elsewhere (with any other encode...Object: method).This method must be matched by a subsequent decodeObject() message. Upon decoding, if object was never encoded unconditionally, decodeObject returns nil in place of object. However, if object was encoded unconditionally, all references to object must be resolved.NSCoder’s implementation simply invokes encode(_:). 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1415196-encodeconditionalobject
     */

  }, {
    key: 'encodeConditionalObject',
    value: function encodeConditionalObject(object) {}

    /**
     * Conditionally encodes a reference to objv and associates it with the string key only if objv has been unconditionally encoded with encode(_:forKey:).
     * @access public
     * @param {?Object} objv - 
     * @param {string} key - 
     * @returns {void}
     * @desc Subclasses must override this method if they support keyed coding.The encoded object is decoded with the decodeObject(forKey:) method. If objv was never encoded unconditionally, decodeObject(forKey:) returns nil in place of objv.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1413918-encodeconditionalobject
     */

  }, {
    key: 'encodeConditionalObjectForKey',
    value: function encodeConditionalObjectForKey(objv, key) {}

    /**
     * Encodes size.
     * @access public
     * @param {CGSize} size - 
     * @returns {void}
     * @desc NSCoder’s implementation invokes encodeValue(ofObjCType:at:) to encode size.This method must be matched by a subsequent decodeSize() message.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1391291-encode
     */

  }, {
    key: 'encode',
    value: function encode(size) {}

    /**
     * Encodes intv and associates it with the string key.
     * @access public
     * @param {number} intv - 
     * @param {string} key - 
     * @returns {void}
     * @desc Subclasses must override this method if they perform keyed coding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1413906-encodecint
     */

  }, {
    key: 'encodeCIntForKey',
    value: function encodeCIntForKey(intv, key) {}

    /**
     * Encodes the property list aPropertyList.
     * @access public
     * @param {Object} aPropertyList - 
     * @returns {void}
     * @desc NSCoder’s implementation invokes encodeValue(ofObjCType:at:) to encode aPropertyList.This method must be matched by a subsequent decodePropertyList() message.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1410643-encodepropertylist
     */

  }, {
    key: 'encodePropertyList',
    value: function encodePropertyList(aPropertyList) {}

    /**
     * Can be overridden by subclasses to encode an interconnected group of Objective-C objects, starting with rootObject.
     * @access public
     * @param {Object} rootObject - 
     * @returns {void}
     * @desc NSCoder’s implementation simply invokes encode(_:).This method must be matched by a subsequent decodeObject() message.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1409439-encoderootobject
     */

  }, {
    key: 'encodeRootObject',
    value: function encodeRootObject(rootObject) {}

    /**
     * Must be overridden by subclasses to encode a single value residing at address, whose Objective-C type is given by valueType.
     * @access public
     * @param {UnsafePointer<Int8>} type - 
     * @param {UnsafeRawPointer} addr - 
     * @returns {void}
     * @desc  valueType must contain exactly one type code.This method must be matched by a subsequent decodeValue(ofObjCType:at:) message.For information on creating an Objective-C type code suitable for valueType, see Type Encodings.Special ConsiderationsYou should not use this method to encode of Objective-C objects. See decodeArray(ofObjCType:count:at:) for more details.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1414648-encodevalue
     */

  }, {
    key: 'encodeValueOfObjCTypeAt',
    value: function encodeValueOfObjCTypeAt(type, addr) {}

    // Decoding General Data

    /**
     * Decodes an array of count items, whose Objective-C type is given by itemType.
     * @access public
     * @param {UnsafePointer<Int8>} itemType - 
     * @param {number} count - 
     * @param {Object} array - 
     * @returns {void}
     * @desc The items are decoded into the buffer beginning at address, which must be large enough to contain them all. itemType must contain exactly one type code. NSCoder’s implementation invokes decodeValue(ofObjCType:at:) to decode the entire array of items.This method matches an encodeArray(ofObjCType:count:at:) message used during encoding.For information on creating an Objective-C type code suitable for itemType, see Type Encodings.Special ConsiderationsYou should not use this method to decode C arrays of Objective-C objects. For historical reasons, returned objects will have an additional ownership reference which you can only relinquish using CFRelease.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1408354-decodearray
     */

  }, {
    key: 'decodeArrayOfObjCTypeAt',
    value: function decodeArrayOfObjCTypeAt(itemType, count, array) {}

    /**
     * Decodes and returns a boolean value that was previously encoded with encode(_:forKey:) and associated with the string key.
     * @access public
     * @param {string} key - 
     * @returns {boolean} - 
     * @desc Subclasses must override this method if they perform keyed coding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1409293-decodebool
     */

  }, {
    key: 'decodeBoolForKey',
    value: function decodeBoolForKey(key) {
      return false;
    }

    /**
     * Decodes a buffer of data that was previously encoded with encodeBytes(_:length:forKey:) and associated with the string key.
     * @access public
     * @param {string} key - 
     * @param {?UnsafeMutablePointer<Int>} lengthp - 
     * @returns {?UnsafePointer<UInt8>} - 
     * @desc  The buffer’s length is returned by reference in lengthp. The returned bytes are immutable. Subclasses must override this method if they perform keyed coding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1411987-decodebytes
     */

  }, {
    key: 'decodeBytesForKeyReturnedLength',
    value: function decodeBytesForKeyReturnedLength(key, lengthp) {
      return null;
    }

    /**
     * Decodes a buffer of data whose types are unspecified.
     * @access public
     * @param {UnsafeMutablePointer<Int>} lengthp - 
     * @returns {?Object} - 
     * @desc NSCoder’s implementation invokes decodeValue(ofObjCType:at:) to decode the data as a series of bytes, which this method then places into a buffer and returns. The buffer’s length is returned by reference in numBytes. If you need the bytes beyond the scope of the current @autoreleasepool block, you must copy them.This method matches an encodeBytes(_:length:) message used during encoding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1415441-decodebytes
     */

  }, {
    key: 'decodeBytesWithReturnedLength',
    value: function decodeBytesWithReturnedLength(lengthp) {
      return null;
    }

    /**
     * Decodes and returns an NSData object that was previously encoded with encode(_:). Subclasses must override this method.
     * @access public
     * @returns {?Data} - 
     * @desc The implementation of your overriding method must match the implementation of your encode(_:) method. For example, a typical encode(_:) method encodes the number of bytes of data followed by the bytes themselves. Your override of this method must read the number of bytes, create an NSData object of the appropriate size, and decode the bytes into the new NSData object. 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1409876-decodedata
     */

  }, {
    key: 'decodeData',
    value: function decodeData() {
      return null;
    }

    /**
     * Decodes and returns a double value that was previously encoded with either encode(_:forKey:) or encode(_:forKey:) and associated with the string key.
     * @access public
     * @param {string} key - 
     * @returns {number} - 
     * @desc Subclasses must override this method if they perform keyed coding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1409374-decodedouble
     */

  }, {
    key: 'decodeDoubleForKey',
    value: function decodeDoubleForKey(key) {
      return 0;
    }

    /**
     * Decodes and returns a float value that was previously encoded with encode(_:forKey:) or encode(_:forKey:) and associated with the string key.
     * @access public
     * @param {string} key - 
     * @returns {number} - 
     * @desc If the value was encoded as a double, the extra precision is lost. If the encoded real value does not fit into a float, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1408104-decodefloat
     */

  }, {
    key: 'decodeFloatForKey',
    value: function decodeFloatForKey(key) {
      return 0;
    }

    /**
     * Decodes and returns an int value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
     * @access public
     * @param {string} key - 
     * @returns {number} - 
     * @desc If the encoded integer does not fit into the default integer size, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1411168-decodecint
     */

  }, {
    key: 'decodeCIntForKey',
    value: function decodeCIntForKey(key) {
      return 0;
    }

    /**
     * Decodes and returns an NSInteger value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
     * @access public
     * @param {string} key - 
     * @returns {number} - 
     * @desc If the encoded integer does not fit into the NSInteger size, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1409246-decodeinteger
     */

  }, {
    key: 'decodeIntegerForKey',
    value: function decodeIntegerForKey(key) {
      return 0;
    }

    /**
     * Decodes and returns a 32-bit integer value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
     * @access public
     * @param {string} key - 
     * @returns {number} - 
     * @desc If the encoded integer does not fit into a 32-bit integer, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1408918-decodeint32
     */

  }, {
    key: 'decodeInt32ForKey',
    value: function decodeInt32ForKey(key) {
      return 0;
    }

    /**
     * Decodes and returns a 64-bit integer value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
     * @access public
     * @param {string} key - 
     * @returns {Int64} - 
     * @desc Subclasses must override this method if they perform keyed coding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1407878-decodeint64
     */

  }, {
    key: 'decodeInt64ForKey',
    value: function decodeInt64ForKey(key) {
      return null;
    }

    /**
     * Decodes an Objective-C object that was previously encoded with any of the encode...Object: methods.
     * @access public
     * @returns {?Object} - 
     * @desc NSCoder’s implementation invokes decodeValue(ofObjCType:at:) to decode the object data.Subclasses may need to override this method if they override any of the corresponding encode...Object: methods. For example, if an object was encoded conditionally using the encodeConditionalObject(_:) method, this method needs to check whether the object had actually been encoded.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1414478-decodeobject
     */

  }, {
    key: 'decodeObject',
    value: function decodeObject() {
      return null;
    }

    /**
     * Decodes and returns an Objective-C object that was previously encoded with encode(_:forKey:) or encodeConditionalObject(_:forKey:) and associated with the string key.
     * @access public
     * @param {string} key - 
     * @returns {?Object} - 
     * @desc Subclasses must override this method if they perform keyed coding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1418185-decodeobject
     */

  }, {
    key: 'decodeObjectForKey',
    value: function decodeObjectForKey(key) {
      return null;
    }

    /**
     * Decodes and returns an NSPoint structure that was previously encoded with encode(_:).
     * @access public
     * @returns {CGPoint} - 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1391189-decodepoint
     */

  }, {
    key: 'decodePoint',
    value: function decodePoint() {
      return null;
    }

    /**
     * Decodes and returns an NSPoint structure that was previously encoded with encode(_:forKey:).
     * @access public
     * @param {string} key - 
     * @returns {CGPoint} - 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1391214-decodepoint
     */

  }, {
    key: 'decodePointForKey',
    value: function decodePointForKey(key) {
      return null;
    }

    /**
     * Decodes a property list that was previously encoded with encodePropertyList(_:).
     * @access public
     * @returns {?Object} - 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1411916-decodepropertylist
     */

  }, {
    key: 'decodePropertyList',
    value: function decodePropertyList() {
      return null;
    }

    /**
     * Decodes and returns an NSRect structure that was previously encoded with encode(_:).
     * @access public
     * @returns {CGRect} - 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1391269-decoderect
     */

  }, {
    key: 'decodeRect',
    value: function decodeRect() {
      return null;
    }

    /**
     * Decodes and returns an NSRect structure that was previously encoded with encode(_:forKey:).
     * @access public
     * @param {string} key - 
     * @returns {CGRect} - 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1391116-decoderect
     */

  }, {
    key: 'decodeRectForKey',
    value: function decodeRectForKey(key) {
      return null;
    }

    /**
     * Decodes and returns an NSSize structure that was previously encoded with encode(_:).
     * @access public
     * @returns {CGSize} - 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1391144-decodesize
     */

  }, {
    key: 'decodeSize',
    value: function decodeSize() {
      return null;
    }

    /**
     * Decodes and returns an NSSize structure that was previously encoded with encode(_:forKey:).
     * @access public
     * @param {string} key - 
     * @returns {CGSize} - 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1391253-decodesize
     */

  }, {
    key: 'decodeSizeForKey',
    value: function decodeSizeForKey(key) {
      return null;
    }

    /**
     * Decodes a single value, whose Objective-C type is given by valueType.
     * @access public
     * @param {UnsafePointer<Int8>} type - 
     * @param {Object} data - 
     * @returns {void}
     * @desc  valueType must contain exactly one type code, and the buffer specified by data must be large enough to hold the value corresponding to that type code. For information on creating an Objective-C type code suitable for valueType, see Type Encodings.Subclasses must override this method and provide an implementation to decode the value. In your overriding implementation, decode the value into the buffer beginning at data.This method matches an encodeValue(ofObjCType:at:) message used during encoding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1417159-decodevalue
     */

  }, {
    key: 'decodeValueOfObjCTypeAt',
    value: function decodeValueOfObjCTypeAt(type, data) {}

    /**
     * Returns a decoded property list for the specified key.
     * @access public
     * @param {string} key - The coder key.
     * @returns {?Object} - 
     * @desc This method calls decodeObjectOfClasses:forKey: with a set allowing only property list types.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1416284-decodepropertylist
     */

  }, {
    key: 'decodePropertyListForKey',
    value: function decodePropertyListForKey(key) {
      return null;
    }

    // Decoding Geometry-Based Data

    /**
     * Decodes and returns the CGPoint structure associated with the specified key in the receiver’s archive. 
     * @access public
     * @param {string} key - The key that identifies the point.
     * @returns {CGPoint} - 
     * @desc Use this method to decode a point that was previously encoded using the encode(_:forKey:) method.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1624523-decodecgpoint
     */

  }, {
    key: 'decodeCGPointForKey',
    value: function decodeCGPointForKey(key) {
      return null;
    }

    /**
     * Decodes and returns the CGRect structure associated with the specified key in the receiver’s archive. 
     * @access public
     * @param {string} key - The key that identifies the rectangle.
     * @returns {CGRect} - 
     * @desc Use this method to decode a rectangle that was previously encoded using the encode(_:forKey:) method.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1624522-decodecgrect
     */

  }, {
    key: 'decodeCGRectForKey',
    value: function decodeCGRectForKey(key) {
      return null;
    }

    /**
     * Decodes and returns the CGSize structure associated with the specified key in the receiver’s archive. 
     * @access public
     * @param {string} key - The key that identifies the size information.
     * @returns {CGSize} - 
     * @desc Use this method to decode size information that was previously encoded using the encode(_:forKey:) method.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1624519-decodecgsize
     */

  }, {
    key: 'decodeCGSizeForKey',
    value: function decodeCGSizeForKey(key) {
      return null;
    }

    /**
     * Decodes and returns the CGAffineTransform structure associated with the specified key in the receiver’s archive. 
     * @access public
     * @param {string} key - The key that identifies the affine transform.
     * @returns {CGAffineTransform} - 
     * @desc Use this method to decode size information that was previously encoded using the encode(_:forKey:) method.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1624478-decodecgaffinetransform
     */

  }, {
    key: 'decodeCGAffineTransformForKey',
    value: function decodeCGAffineTransformForKey(key) {
      return null;
    }

    /**
     * Decodes and returns the UIEdgeInsets structure associated with the specified key in the receiver’s archive. 
     * @access public
     * @param {string} key - The key that identifies the edge insets.
     * @returns {UIEdgeInsets} - 
     * @desc Use this method to decode size information that was previously encoded using the encode(_:forKey:) method.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1624492-decodeuiedgeinsets
     */

  }, {
    key: 'decodeUIEdgeInsetsForKey',
    value: function decodeUIEdgeInsetsForKey(key) {
      return null;
    }

    /**
     * Decodes and returns the UIOffset structure associated with the specified key in the receiver’s archive. 
     * @access public
     * @param {string} key - The key that identifies the offset.
     * @returns {UIOffset} - 
     * @desc Use this method to decode offset information that was previously encoded using the encode(_:forKey:) method.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1624507-decodeuioffset
     */

  }, {
    key: 'decodeUIOffsetForKey',
    value: function decodeUIOffsetForKey(key) {
      return null;
    }

    /**
     * Decodes and returns the CGVector data associated with the specified key in the coder’s archive.
     * @access public
     * @param {string} key - The key that identifies the vector.
     * @returns {CGVector} - 
     * @desc Use this method to decode vector information that was previously encoded using the encode(_:forKey:) method.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1624488-decodecgvector
     */

  }, {
    key: 'decodeCGVectorForKey',
    value: function decodeCGVectorForKey(key) {
      return null;
    }

    // Decoding Core Media Time Structures

    /**
     * Returns the CMTime structure associated with a given key.
     * @access public
     * @param {string} key - The key for a CMTime structure encoded in the receiver.
     * @returns {CMTime} - 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1389544-decodetime
     */

  }, {
    key: 'decodeTimeForKey',
    value: function decodeTimeForKey(key) {
      return null;
    }

    /**
     * Returns the CMTimeRange structure associated with a given key.
     * @access public
     * @param {string} key - The key for a CMTimeRange structure encoded in the receiver.
     * @returns {CMTimeRange} - 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1385718-decodetimerange
     */

  }, {
    key: 'decodeTimeRangeForKey',
    value: function decodeTimeRangeForKey(key) {
      return null;
    }

    /**
     * Returns the CMTimeMapping structure associated with a given key.
     * @access public
     * @param {string} key - The key for a CMTimeMapping structure encoded in the receiver.
     * @returns {CMTimeMapping} - 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1389860-decodetimemapping
     */

  }, {
    key: 'decodeTimeMappingForKey',
    value: function decodeTimeMappingForKey(key) {
      return null;
    }

    // Secure Coding
    /**
     * Boolean value that indicates whether the coder requires secure coding.
     * @type {boolean}
     * @desc true if this coder requires secure coding; false otherwise.Secure coders check a set of allowed classes before decoding objects, and all objects must implement the NSSecureCoding protocol.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1409845-requiressecurecoding
     */

  }, {
    key: 'versionForClassName',


    // Getting Version Information

    /**
     * This method is present for historical reasons and is not used with keyed archivers.
     * @access public
     * @param {string} className - 
     * @returns {number} - 
     * @desc The version number does apply not to NSKeyedArchiver/NSKeyedUnarchiver.  A keyed archiver does not encode class version numbers.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1417703-version
     */
    value: function versionForClassName(className) {
      return 0;
    }
    /**
     * The system version in effect for the archive.
     * @type {number}
     * @desc During encoding, the current version. During decoding, the version that was in effect when the data was encoded.Subclasses that implement decoding must override this property to return the system version of the data being decoded.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1413205-systemversion
     */

  }, {
    key: 'decodeObjectOfClassForKey',


    // Instance Methods

    /**
     * 
     * @access public
     * @param {DecodedObjectType.Type} cls - 
     * @param {string} key - 
     * @returns {NSCoding} - 
     * @see https://developer.apple.com/documentation/foundation/nscoder/2292924-decodeobject
     */
    value: function decodeObjectOfClassForKey(cls, key) {
      return null;
    }

    /**
     * 
     * @access public
     * @returns {void}
     * @throws {Error}
     * @see https://developer.apple.com/documentation/foundation/nscoder/1407699-decodetoplevelobject
     */

  }, {
    key: 'decodeTopLevelObject',
    value: function decodeTopLevelObject() {}

    /**
     * 
     * @access public
     * @param {string} key - 
     * @returns {void}
     * @throws {Error}
     * @see https://developer.apple.com/documentation/foundation/nscoder/2293311-decodetoplevelobject
     */

  }, {
    key: 'decodeTopLevelObjectForKey',
    value: function decodeTopLevelObjectForKey(key) {}

    /**
     * 
     * @access public
     * @param {?Object[]} classes - 
     * @param {string} key - 
     * @returns {void}
     * @throws {Error}
     * @see https://developer.apple.com/documentation/foundation/nscoder/2293221-decodetoplevelobject
     */

  }, {
    key: 'decodeTopLevelObjectOfForKey',
    value: function decodeTopLevelObjectOfForKey(classes, key) {}

    /**
     * 
     * @access public
     * @param {Error} error - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nscoder/1411455-failwitherror
     */

  }, {
    key: 'failWithError',
    value: function failWithError(error) {}
  }, {
    key: 'allowsKeyedCoding',
    get: function get() {
      return this._allowsKeyedCoding;
    }
  }, {
    key: 'requiresSecureCoding',
    get: function get() {
      return this._requiresSecureCoding;
    }
    /**
     * The set of coded classes allowed for secure coding.
     * @type {?Set<AnyHashable>}
     * @desc Secure coders check this set of allowed classes before decoding objects, and all objects must implement the NSSecureCoding protocol.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1412486-allowedclasses
     */

  }, {
    key: 'allowedClasses',
    get: function get() {
      return this._allowedClasses;
    }
  }, {
    key: 'systemVersion',
    get: function get() {
      return this._systemVersion;
    }

    // Instance Properties
    /**
     * 
     * @type {NSCoder.DecodingFailurePolicy}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1642984-decodingfailurepolicy
     */

  }, {
    key: 'decodingFailurePolicy',
    get: function get() {
      return this._decodingFailurePolicy;
    }

    /**
     * 
     * @type {?Error}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nscoder/1643263-error
     */

  }, {
    key: 'error',
    get: function get() {
      return this._error;
    }
  }], [{
    key: 'DecodingFailurePolicy',
    get: function get() {
      return _DecodingFailurePolicy;
    }
  }]);

  return NSCoder;
}(_NSObject3.default);

exports.default = NSCoder;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSObject}
 */
var NSData = function (_NSObject) {
  _inherits(NSData, _NSObject);

  function NSData() {
    _classCallCheck(this, NSData);

    return _possibleConstructorReturn(this, (NSData.__proto__ || Object.getPrototypeOf(NSData)).apply(this, arguments));
  }

  _createClass(NSData, null, [{
    key: 'initWithCoder',

    /**
     * @access public
     * @param {NSCoder} coder -
     * @returns {_Buffer} -
     */
    value: function initWithCoder(coder) {
      var data = coder.decodeBytesForKeyReturnedLength('NS.data', null);
      if (typeof data !== 'undefined') {
        return data;
      }
      var bytes = coder.decodeBytesForKeyReturnedLength('NS.bytes', null);
      if (typeof bytes !== 'undefined') {
        return bytes;
      }
      return null;
    }
  }]);

  return NSData;
}(_NSObject3.default);

exports.default = NSData;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSCoder2 = __webpack_require__(39);

var _NSCoder3 = _interopRequireDefault(_NSCoder2);

var _NSData = __webpack_require__(40);

var _NSData2 = _interopRequireDefault(_NSData);

var _File2 = __webpack_require__(42);

var _File3 = _interopRequireDefault(_File2);

var _FileReader2 = __webpack_require__(43);

var _FileReader3 = _interopRequireDefault(_FileReader2);

var _BinaryReader2 = __webpack_require__(69);

var _BinaryReader3 = _interopRequireDefault(_BinaryReader2);

var _ClassList2 = __webpack_require__(37);

var _ClassList3 = _interopRequireDefault(_ClassList2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*global Buffer*/

var _classForKey = new Map();
var _loadingSymbol = Symbol('loading');

var _UID = function () {
  function _UID(unarchiver, value) {
    _classCallCheck(this, _UID);

    this._unarchiver = unarchiver;
    this._value = value;
  }

  _createClass(_UID, [{
    key: 'value',
    get: function get() {
      return this._value;
    }
  }, {
    key: 'obj',
    get: function get() {
      return this._unarchiver._parsedObj.$objects[this._value];
    }
  }]);

  return _UID;
}();

/**
 * NSKeyedUnarchiver, a concrete subclass of NSCoder, defines methods for decoding a set of named objects (and scalar values) from a keyed archive. Such archives are produced by instances of the NSKeyedArchiver class.
 * @access public
 * @extends {NSCoder}
 * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver
 */


var NSKeyedUnarchiver = function (_NSCoder) {
  _inherits(NSKeyedUnarchiver, _NSCoder);

  // Initializing a Keyed Unarchiver

  /**
   * Initializes the receiver for decoding an archive previously encoded by NSKeyedArchiver.
   * @access public
   * @constructor
   * @param {Data} data - An archive previously encoded by NSKeyedArchiver.
   * @desc When you finish decoding data, you should invoke finishDecoding(). This method throws an exception if data is not a valid archive.
   * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1410862-init
   */
  function NSKeyedUnarchiver() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, NSKeyedUnarchiver);

    // Unarchiving Data

    /**
     * Indicates whether the receiver requires all unarchived classes to conform to NSSecureCoding.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1410824-requiressecurecoding
     */
    var _this = _possibleConstructorReturn(this, (NSKeyedUnarchiver.__proto__ || Object.getPrototypeOf(NSKeyedUnarchiver)).call(this));

    _this._requiresSecureCoding = false;

    // Managing the Delegate

    /**
     * The receiver’s delegate.
     * @type {?NSKeyedUnarchiverDelegate}
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1415688-delegate
     */
    _this.delegate = null;

    // Instance Properties

    /**
     * 
     * @type {NSCoder.DecodingFailurePolicy}
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1643164-decodingfailurepolicy
     */
    _this._decodingFailurePolicy = null;

    /**
     * @access private
     * @type {?_BinaryReader}
     */
    _this._reader = null;

    /**
     * @access private
     * @type {number}
     */
    _this._offsetSize = 0;

    /**
     * @access private
     * @type {number}
     */
    _this._objCount = 0;

    /**
     * @access private
     * @type {Object[]}
     */
    _this._offsetArray = [];

    /**
     * @access private
     * @type {Object}
     */
    _this._parsedObj = {};

    /**
     * @access private
     * @type {Object[]}
     */
    _this._dataObj = [];

    _this._resolveFunctions = [];

    /**
     * @access private
     * @type {string}
     */
    _this._filePath = null;

    /**
     * @access private
     * @type {?Object}
     */
    _this._refObj = null;

    /**
     * @access private
     * @type {boolean}
     */
    _this._decodingFinished = false;

    _this._promises = [];

    if (data !== null) {
      _this._reader = new _BinaryReader3.default(data, true, 'utf8');
      _this._checkHeader();
      _this._parsedObj = _this._parseBPlist();
    }
    return _this;
  }

  _createClass(NSKeyedUnarchiver, [{
    key: 'copy',
    value: function copy() {
      var coder = new NSKeyedUnarchiver();
      coder._requiresSecureCoding = this._requiresSecureCoding;
      coder.delegate = this.delegate;
      coder._decodingFailurePolicy = this._decodingFailurePolicy;
      coder._reader = this._reader;
      coder._offsetSize = this._offsetSize;
      coder._objCount = this._objCount;
      coder._offsetArray = this._offsetArray;
      coder._parsedObj = this._parsedObj;
      coder._dataObj = this._dataObj;
      coder._resolveFunctions = this._resolveFunctions;
      coder._filePath = this._filePath;
      coder._refObj = this._refObj;
      coder._decodingFinished = this._decodingFinished;
      return coder;
    }

    // Unarchiving Data

    /**
     * Decodes and returns the object graph previously encoded by NSKeyedArchiver and stored in a given NSData object.
     * @access public
     * @param {Buffer} data - An object graph previously encoded by NSKeyedArchiver.
     * @param {?string} path - 
     * @returns {?Object} - 
     * @desc This method raises an invalidArchiveOperationException if data is not a valid archive.
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1413894-unarchiveobject
     */

  }, {
    key: '_checkHeader',
    value: function _checkHeader() {
      this._reader.seek(0);
      var header = this._reader.readString(8);
      if (header !== 'bplist00') {
        throw new Error('unsupported file format: ' + header);
      }
    }
  }, {
    key: '_parseBPlist',
    value: function _parseBPlist() {
      var reader = this._reader;

      // read basic info
      reader.seek(-26);
      var dataLen = reader.length;
      var intSize = reader.readUnsignedByte();
      this._offsetSize = reader.readUnsignedByte();
      this._objCount = reader.readUnsignedLongLong();
      var topIndex = reader.readUnsignedLongLong();
      var tablePos = reader.readUnsignedLongLong

      //console.log(`dataLen: ${dataLen}`)
      //console.log(`intSize: ${intSize}`)
      //console.log(`offsetSize: ${this._offsetSize}`)
      //console.log(`objCount: ${this._objCount}`)
      //console.log(`topIndex: ${topIndex}`)
      //console.log(`tablePos: ${tablePos}`)

      ();this._offsetArray = [];
      var pos = tablePos;
      reader.seek(pos);
      var objCount = this._objCount;
      for (var i = 0; i < objCount; i++) {
        var offset = reader.readInteger(intSize);
        this._offsetArray.push(offset);
      }

      return this._parseObjAtIndex(topIndex);
    }
  }, {
    key: '_parseObjAtIndex',
    value: function _parseObjAtIndex(index) {
      return this._parseObj(this._offsetArray[index]);
    }
  }, {
    key: '_parseObj',
    value: function _parseObj() {
      var _this2 = this;

      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var signed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var reader = this._reader;
      if (offset !== null) {
        reader.seek(offset);
      }
      var type = reader.readUnsignedByte();
      var type1 = type & 0xF0;
      var type2 = type & 0x0F;
      //console.log(`parseObj: type: ${type1} ${type2}`)
      if (type1 === 0x00) {
        // null, boolean
        if (type2 === 0) {
          //console.log('   type: null')
          return null;
        } else if (type2 === 8) {
          //console.log('   type: boolean')
          return false;
        } else if (type2 === 9) {
          //console.log('   type: boolean')
          return true;
        }
      } else if (type1 === 0x10) {
        // Int
        var len = Math.pow(2, type2
        //console.log('   type: integer ' + len)
        );return reader.readInteger(len, signed);
      } else if (type1 === 0x20) {
        // Float
        var _len = Math.pow(2, type2);
        if (_len === 4) {
          //console.log('   type: float')
          return reader.readFloat();
        } else if (_len === 8) {
          //console.log('   type: double')
          return reader.readDouble();
        }
        throw new Error('unsupported float size: ' + _len);
      } else if (type1 === 0x30) {
        // Date
        //console.log('   type: Date')
      } else if (type1 === 0x40) {
        // Data
        var count = this._getDataSize(type2
        //console.log(`   type: Data: length: ${count}`)
        );return reader.readData(count);
      } else if (type1 === 0x50) {
        // ASCII
        var _count = this._getDataSize(type2
        //console.log('   type: ascii ' + count)
        );return reader.readString(_count, 'ascii');
      } else if (type1 === 0x60) {
        // UTF-16
        var _count2 = this._getDataSize(type2
        //console.log('   type: UTF-16 ' + count)
        );return reader.readString(_count2, 'utf16be' // Big Endian might not be supported...
        );
      } else if (type1 === 0x80) {
        // UID
        var uid = reader.readInteger(type2 + 1, false
        //console.log('   type: UID: ' + uid)
        );return new _UID(this, uid);
      } else if (type1 === 0xA0) {
        // Array
        var _count3 = this._getDataSize(type2
        //console.log('   type: array: ' + count)
        );var arrIndex = [];
        for (var i = 0; i < _count3; i++) {
          arrIndex.push(reader.readInteger(this._offsetSize, false));
        }
        var arr = arrIndex.map(function (index) {
          return _this2._parseObjAtIndex(index);
        }
        //console.log(`***arr.length: ${arr.length}`)
        );return arr;
      } else if (type1 === 0xC0) {
        // Set
        var _count4 = this._getDataSize(type2);
        var setIndex = [];
        for (var _i = 0; _i < _count4; _i++) {
          setIndex.push(reader.readInteger(this._offsetSize, false));
        }
        var _arr = setIndex.map(function (index) {
          return _this2._parseObjAtIndex(index);
        });
        return new Set(_arr);
      } else if (type1 === 0xD0) {
        // Dictionary
        //console.log('   type: dictionary')
        var _count5 = this._getDataSize(type2);
        var keyIndex = [];
        var valueIndex = [];
        for (var _i2 = 0; _i2 < _count5; _i2++) {
          keyIndex.push(reader.readInteger(this._offsetSize, false));
        }
        for (var _i3 = 0; _i3 < _count5; _i3++) {
          valueIndex.push(reader.readInteger(this._offsetSize, false));
        }
        var result = {};
        for (var _i4 = 0; _i4 < _count5; _i4++) {
          var key = this._parseObjAtIndex(keyIndex[_i4]
          //console.log('key: ' + key)
          );var val = this._parseObjAtIndex(valueIndex[_i4]
          //console.log('val: ' + val)
          );result[key] = val;
        }
        return result;
      }

      throw new Error('unknown data type: ' + type);
    }
  }, {
    key: '_getDataSize',
    value: function _getDataSize(type2) {
      var count = 0;
      if (type2 !== 0x0F) {
        count = type2;
      } else {
        count = this._parseObj(null, false);
        if (typeof count !== 'number') {
          throw new Error('data size must be int type');
        }
      }
      return count;
    }
  }, {
    key: '_parseClassAt',
    value: function _parseClassAt(index) {
      var _this3 = this;

      var obj = this._parsedObj.$objects[index];
      if (this._dataObj[index] === _loadingSymbol) {
        // it seems to be a reference loop; return Promise
        return new Promise(function (resolve, reject) {
          if (typeof _this3._resolveFunctions[index] === 'undefined') {
            _this3._resolveFunctions[index] = [];
          }
          _this3._resolveFunctions[index].push(resolve);
        });
      } else if (typeof this._dataObj[index] !== 'undefined') {
        return this._dataObj[index];
      }
      this._dataObj[index] = _loadingSymbol;
      var data = this._parseClass(obj);
      this._dataObj[index] = data;
      if (Array.isArray(this._resolveFunctions[index])) {
        this._resolveFunctions[index].forEach(function (resolve) {
          resolve(data);
        });
        delete this._resolveFunctions[index];
      }
      return data;
    }
  }, {
    key: '_parseClass',
    value: function _parseClass(obj) {
      var className = obj.$class.obj.$classname;
      //console.log(`parseClass ${className}`)
      var classObj = NSKeyedUnarchiver.classForClassName(className);
      if (classObj) {
        var unarchiver = this.copy();
        unarchiver._refObj = obj;
        return classObj.initWithCoder(unarchiver);
      }
      return null;
    }

    /**
     * @access private
     * @param {Object} obj -
     * @param {Object} classObj -
     * @returns {Object} -
     */

  }, {
    key: '_parseStruct',
    value: function _parseStruct(obj, classObj) {
      if (typeof classObj._initWithData !== 'function') {
        throw new Error(classObj.prototype.constructor.name + ' class doesn\'t have _initWithData function');
      }
      return classObj._initWithData(obj);
    }

    /**
     * Decodes and returns the object graph previously encoded by NSKeyedArchiver written to the file at a given path.
     * @access public
     * @param {string} path - A path to a file that contains an object graph previously encoded by NSKeyedArchiver.
     * @returns {Promise} - 
     * @desc This method raises an invalidArgumentException if the file at path does not contain a valid archive.
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1417153-unarchiveobject
     */

  }, {
    key: 'containsValueForKey',


    // Decoding Data

    /**
     * Returns a Boolean value that indicates whether the archive contains a value for a given key within the current decoding scope.
     * @access public
     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1413564-containsvalue
     */
    value: function containsValueForKey(key) {
      return typeof this._refObj[key] !== 'undefined';
    }

    /**
     * Decodes a Boolean value associated with a given key.
     * @access public
     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1413260-decodebool
     */

  }, {
    key: 'decodeBoolForKey',
    value: function decodeBoolForKey(key) {
      if (this._decodingFinished) {
        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
      }
      var value = this._getValueForKey(key);
      return Boolean(value);
    }

    /**
     * Decodes a stream of bytes associated with a given key.
     * @access public
     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
     * @param {?UnsafeMutablePointer<Int>} lengthp - Upon return, contains the number of bytes returned.
     * @returns {?UnsafePointer<UInt8>} - 
     * @desc The returned value is a pointer to a temporary buffer owned by the receiver. The buffer goes away with the unarchiver, not the containing autorelease pool block. You must copy the bytes into your own buffer if you need the data to persist beyond the life of the receiver.
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1418091-decodebytes
     */

  }, {
    key: 'decodeBytesForKeyReturnedLength',
    value: function decodeBytesForKeyReturnedLength(key, lengthp) {
      if (this._decodingFinished) {
        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
      }
      return this._getValueForKey(key);
    }

    /**
     * Decodes a double-precision floating-point value associated with a given key.
     * @access public
     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
     * @returns {number} - 
     * @desc If the archived value was encoded as single-precision, the type is coerced. 
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1414963-decodedouble
     */

  }, {
    key: 'decodeDoubleForKey',
    value: function decodeDoubleForKey(key) {
      if (this._decodingFinished) {
        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
      }
      return this._getValueForKey(key);
    }

    /**
     * Decodes a single-precision floating-point value associated with a given key.
     * @access public
     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
     * @returns {number} - 
     * @desc If the archived value was encoded as double precision, the type is coerced, loosing precision. If the archived value is too large for single precision, the method raises an NSRangeException. 
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1412252-decodefloat
     */

  }, {
    key: 'decodeFloatForKey',
    value: function decodeFloatForKey(key) {
      if (this._decodingFinished) {
        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
      }
      return this._getValueForKey(key);
    }

    /**
     * Decodes and returns an int value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
     * @access public
     * @param {string} key - 
     * @returns {number} - 
     * @desc If the encoded integer does not fit into the default integer size, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1411168-decodecint
     */

  }, {
    key: 'decodeCIntForKey',
    value: function decodeCIntForKey(key) {
      if (this._decodingFinished) {
        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
      }
      return this._getValueForKey(key);
    }

    /**
     * Decodes a 32-bit integer value associated with a given key.
     * @access public
     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
     * @returns {number} - 
     * @desc If the archived value was encoded with a different size but is still an integer, the type is coerced. If the archived value is too large to fit into a 32-bit integer, the method raises an NSRangeException. 
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1416327-decodeint32
     */

  }, {
    key: 'decodeInt32ForKey',
    value: function decodeInt32ForKey(key) {
      if (this._decodingFinished) {
        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
      }
      return this._getValueForKey(key);
    }

    /**
     * Decodes a 64-bit integer value associated with a given key.
     * @access public
     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
     * @returns {Int64} - 
     * @desc If the archived value was encoded with a different size but is still an integer, the type is coerced. 
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1413288-decodeint64
     */

  }, {
    key: 'decodeInt64ForKey',
    value: function decodeInt64ForKey(key) {
      if (this._decodingFinished) {
        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
      }
      return this._getValueForKey(key);
    }

    /**
     * Decodes and returns an object associated with a given key.
     * @access public
     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
     * @returns {?Object} - 
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1409082-decodeobject
     */

  }, {
    key: 'decodeObjectForKey',
    value: function decodeObjectForKey(key) {
      if (this._decodingFinished) {
        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
      }
      var parsedObj = this._refObj[key];
      if (typeof parsedObj === 'string') {
        return parsedObj;
      } else if (parsedObj instanceof _UID) {
        var obj = parsedObj.obj;
        if (typeof obj.$class !== 'undefined') {
          return this._parseClassAt(parsedObj.value);
        }
        return obj;
      }
      throw new Error('unknown data type for key ' + key + ': ' + parsedObj);
    }

    /**
     * Returns a decoded property list for the specified key.
     * @access public
     * @param {string} key - The coder key.
     * @returns {?Object} - 
     * @desc This method calls decodeObjectOfClasses:forKey: with a set allowing only property list types.
     * @see https://developer.apple.com/documentation/foundation/nscoder/1416284-decodepropertylist
     */

  }, {
    key: 'decodePropertyListForKey',
    value: function decodePropertyListForKey(key) {
      if (this._decodingFinished) {
        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
      }
      var parsedObj = this.decodeObjectForKey(key
      //console.log(`${key}: ${parsedObj.constructor.name}`)
      );if (!(parsedObj instanceof Buffer)) {
        throw new Error('propertylist of key ' + key + ' is not Buffer data');
      }
      //console.log(`***header: ${parsedObj.toString('ascii', 0, 8)}`)
      //console.log(`length: ${parsedObj.length}`)
      //for(let i=0; i<8; i++){
      //  console.log(`${i}: ${parsedObj.readUIntBE(i, 1)}`)
      //}
      return NSKeyedUnarchiver.unarchiveObjectWithData(parsedObj, this._filePath);
    }
  }, {
    key: 'decodeObjectOfTypeForKey',
    value: function decodeObjectOfTypeForKey(type, key) {
      if (this._decodingFinished) {
        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
      }
      var parsedObj = this._refObj[key];
      if (!(parsedObj instanceof Buffer)) {
        throw new Error('value is not Buffer data for key: ' + key);
      }
      return this._parseStruct(parsedObj, type);
    }
  }, {
    key: 'finishDecoding',


    /**
     * Tells the receiver that you are finished decoding objects.
     * @access public
     * @returns {void}
     * @desc Invoking this method allows the receiver to notify its delegate and to perform any final operations on the archive. Once this method is invoked, the receiver cannot decode any further values.
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1418233-finishdecoding
     */
    value: function finishDecoding() {
      this._decodingFinished = true;
    }

    // Managing Class Names

    /**
     * Adds a class translation mapping to the receiver whereby objects encoded with a given class name are decoded as instances of a given class instead.
     * @access public
     * @param {?Object} cls - The class with which to replace instances of the class named codedName.
     * @param {string} codedName - 
     * @returns {void}
     * @desc When decoding, the receiver’s translation map overrides any translation that may also be present in the class’s map (see setClass(_:forClassName:)).
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1414659-setclass
     */

  }, {
    key: '_getValueForKey',
    value: function _getValueForKey(key) {
      var value = this._refObj[key];
      if (value instanceof _UID) {
        return value.obj;
      }
      return value;
    }
  }, {
    key: '_fileName',
    get: function get() {
      if (this._filePath === null) {
        return null;
      }
      var paths = this._filePath.split('/');
      var fileName = paths.pop();
      return fileName;
    }
  }, {
    key: '_directoryPath',
    get: function get() {
      if (this._filePath === null) {
        return null;
      }
      var paths = this._filePath.split('/');
      var fileName = paths.pop();
      var directoryPath = paths.join('/') + '/';
      return directoryPath;
    }
  }], [{
    key: 'unarchiveObjectWithData',
    value: function unarchiveObjectWithData(data) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var unarchiver = new NSKeyedUnarchiver(data);
      unarchiver._filePath = path;
      var topObjIndex = unarchiver._parsedObj.$top.root.value;
      return unarchiver._parseClassAt(topObjIndex);
    }
  }, {
    key: '_getBufferOfFile',
    value: function _getBufferOfFile(path) {
      // TODO: use 'await' to return Buffer instead of Promise
      var promise = new Promise(function (resolve, reject) {
        var file = new _File3.default([], path);
        var reader = new _FileReader3.default();
        reader.onload = function () {
          var data = reader.result;
          resolve(data);
        };
        reader.onerror = function () {
          reject(reader.error);
        };
        reader.readAsBinaryString(file);
      });
      return promise;
    }
  }, {
    key: 'unarchiveObjectWithFile',
    value: function unarchiveObjectWithFile(path) {
      var promise = NSKeyedUnarchiver._getBufferOfFile(path).then(function (data) {
        return NSKeyedUnarchiver.unarchiveObjectWithData(data, path);
      });

      return promise;
    }
  }, {
    key: 'setClassForClassName',
    value: function setClassForClassName(cls, codedName) {
      _classForKey.set(codedName, cls);
    }

    /**
     * Returns the class from which the receiver instantiates an encoded object with a given class name.
     * @access public
     * @param {string} codedName - 
     * @returns {?Object} - 
     * @desc The class’s separate translation map is not searched.
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1412476-class
     */

  }, {
    key: 'classForClassName',
    value: function classForClassName(codedName) {
      var classObj = _classForKey.get(codedName);
      if (classObj) {
        return classObj;
      }
      return _ClassList3.default.get(codedName);
    }

    // Type Methods

    /**
     * 
     * @access public
     * @param {NSData} data - 
     * @param {string} path -
     * @returns {void}
     * @throws {Error}
     * @see https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1413622-unarchivetoplevelobjectwithdata
     */

  }, {
    key: 'unarchiveTopLevelObjectWithData',
    value: function unarchiveTopLevelObjectWithData(data) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      // what's different from unarchiveObjectWithData???
      return NSKeyedUnarchiver.unarchiveObjectWithData(data, path);
    }
  }]);

  return NSKeyedUnarchiver;
}(_NSCoder3.default);

exports.default = NSKeyedUnarchiver;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21).Buffer))

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*global File*/

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = File;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*global FileReader*/

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = FileReader;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GKComponent2 = __webpack_require__(32);

var _GKComponent3 = _interopRequireDefault(_GKComponent2);

var _GKBehavior = __webpack_require__(72);

var _GKBehavior2 = _interopRequireDefault(_GKBehavior);

var _GKAgentDelegate = __webpack_require__(74);

var _GKAgentDelegate2 = _interopRequireDefault(_GKAgentDelegate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A component that moves a game entity according to a set of goals and realistic constraints.
 * @access public
 * @extends {GKComponent}
 * @see https://developer.apple.com/documentation/gameplaykit/gkagent
 */
var GKAgent = function (_GKComponent) {
  _inherits(GKAgent, _GKComponent);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function GKAgent() {
    _classCallCheck(this, GKAgent);

    // Defining an Agent’s Behavior

    /**
     * A weighted collection of goals that influence the agent’s movement.
     * @type {?GKBehavior}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501272-behavior
     */
    var _this = _possibleConstructorReturn(this, (GKAgent.__proto__ || Object.getPrototypeOf(GKAgent)).call(this));

    _this.behavior = null;

    // Constraining an Agent’s Movement

    /**
     * The resistance of the agent to changes in speed or direction.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501080-mass
     */
    _this.mass = 0;

    /**
     * The upper limit to changes in the agent’s speed or direction.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501224-maxacceleration
     */
    _this.maxAcceleration = 0;

    /**
     * The agent’s maximum forward speed, in units per second.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501323-maxspeed
     */
    _this.maxSpeed = 0;

    /**
     * The agent’s radius.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501066-radius
     */
    _this.radius = 0;

    // Synchronizing an Agent’s Visual Representation

    /**
     * An object that prepares for or responds to updates in the agent simulation.
     * @type {?GKAgentDelegate}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501215-delegate
     */
    _this.delegate = null;

    // Managing an Agent’s Attributes

    /**
     * The agent’s current forward speed, in units per second.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent/1501038-speed
     */
    _this.speed = 0;
    return _this;
  }

  // GKAgentDelegate

  /**
   * Tells the delegate that an agent is about to perform its next simulation step.
   * @access public
   * @param {GKAgent} agent - The agent object that will perform its next simulation step.
   * @returns {void}
   * @desc Implement this method when you want to update the agent simulation with data from an external source, such as node position and orientation information updated by the SceneKit or SpriteKit physics engine. Set the position and rotation properties of the agent (as a GKAgent2D or GKAgent3D object) so that the next simulation step will take your changes to those properties into account.
   * @see https://developer.apple.com/documentation/gameplaykit/gkagentdelegate/1501232-agentwillupdate
   */


  _createClass(GKAgent, [{
    key: 'agentWillUpdate',
    value: function agentWillUpdate(agent) {}

    /**
     * Tells the delegate that an agent has just performed a simulation step.
     * @access public
     * @param {GKAgent} agent - The agent object that has just performed a simulation step.
     * @returns {void}
     * @desc Implement this method when you want to update a display based on the latest data from the agent simulation. Read the position and rotation properties of the agent (as a GKAgent2D or GKAgent3D object), then set the corresponding attributes of the object that provides the agent’s visual representation.
     * @see https://developer.apple.com/documentation/gameplaykit/gkagentdelegate/1501131-agentdidupdate
     */

  }, {
    key: 'agentDidUpdate',
    value: function agentDidUpdate(agent) {}
  }]);

  return GKAgent;
}(_GKComponent3.default);

exports.default = GKAgent;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CAPropertyAnimation2 = __webpack_require__(46);

var _CAPropertyAnimation3 = _interopRequireDefault(_CAPropertyAnimation2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An object that provides basic, single-keyframe animation capabilities for a layer property. 
 * @access public
 * @extends {CAPropertyAnimation}
 * @see https://developer.apple.com/documentation/quartzcore/cabasicanimation
 */
var CABasicAnimation = function (_CAPropertyAnimation) {
  _inherits(CABasicAnimation, _CAPropertyAnimation);

  /**
   * constructor
   * @access public
   * @param {?string} path -
   * @constructor
   */
  function CABasicAnimation(path) {
    _classCallCheck(this, CABasicAnimation);

    // Interpolation values

    /**
     * Defines the value the receiver uses to start interpolation.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/quartzcore/cabasicanimation/1412519-fromvalue
     */
    var _this = _possibleConstructorReturn(this, (CABasicAnimation.__proto__ || Object.getPrototypeOf(CABasicAnimation)).call(this, path));

    _this.fromValue = null;

    /**
     * Defines the value the receiver uses to end interpolation.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/quartzcore/cabasicanimation/1412523-tovalue
     */
    _this.toValue = null;

    /**
     * Defines the value the receiver uses to perform relative interpolation.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/quartzcore/cabasicanimation/1412445-byvalue
     */
    _this.byValue = null;

    _this._baseValue = null;
    return _this;
  }

  /**
   * @access public
   * @returns {CABasicAnimation} -
   */


  _createClass(CABasicAnimation, [{
    key: 'copy',
    value: function copy() {
      var anim = _get(CABasicAnimation.prototype.__proto__ || Object.getPrototypeOf(CABasicAnimation.prototype), 'copy', this).call(this);
      //anim._copyValue(this)

      anim.fromValue = this.fromValue;
      anim.toValue = this.toValue;
      anim.byValue = this.byValue;

      return anim;
    }

    /*
    _copyValue(src) {
      this.fromValue = src.fromValue
      this.toValue = src.toValue
      this.byValue = src.byValue
    }
    */

    /**
     * apply animation to the given node.
     * @access private
     * @param {Object} obj - target object to apply this animation.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAnimation',
    value: function _applyAnimation(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var t = time;
      if (needTimeConversion) {
        var baseTime = this._basetimeFromTime(time);
        if (baseTime === null) {
          return;
        }
        t = baseTime;
        if (this.timingFunction !== null) {
          t = this.timingFunction._getValueAtTime(baseTime);
        }
        if (t < 0) {
          t = 0;
        }
        if (t > 1) {
          t = 1;
        }
        //if(this.keyPath === 'rotation.w'){
        //  console.log(`time: ${time}, activeTime: ${time - this._animationStartTime}, baseTime: ${baseTime}, t: ${t}`)
        //}
      }

      var isObject = false;
      if (this._baseValue === null || this.isAdditive) {
        this._baseValue = obj.valueForKeyPath(this.keyPath, false);
      }
      if (typeof this._baseValue !== 'number' && this._baseValue !== null) {
        isObject = true;
      }

      var fromValue = 0;
      var toValue = 0;
      if (this.fromValue !== null && this.toValue !== null) {
        fromValue = this.fromValue;
        toValue = this.toValue;
      } else if (this.fromValue !== null && this.byValue !== null) {
        fromValue = this.fromValue;
        if (isObject) {
          toValue = this.fromValue.add(this.byValue);
        } else {
          toValue = this.fromValue + this.byValue;
        }
      } else if (this.byValue !== null && this.toValue !== null) {
        if (isObject) {
          fromValue = this.toValue.sub(this.byValue);
        } else {
          fromValue = this.toValue - this.byValue;
        }
        toValue = toValue;
      } else if (this.fromValue !== null) {
        fromValue = this.fromValue;
        if (this.isAdditive) {
          if (isObject) {
            toValue = this._baseValue.zero();
          } else {
            toValue = 0;
          }
        } else {
          toValue = this._baseValue;
        }
      } else if (this.toValue !== null) {
        if (this.isAdditive) {
          if (isObject) {
            fromValue = this._baseValue.zero();
          } else {
            fromValue = 0;
          }
        } else {
          fromValue = this._baseValue;
        }
        toValue = this.toValue;
      } else if (this.byValue !== null) {
        if (this.isAdditive) {
          if (isObject) {
            fromValue = this._baseValue.zero();
          } else {
            fromValue = 0;
          }
          toValue = this.byValue;
        } else {
          fromValue = this._baseValue;
          if (isObject) {
            toValue = this._baseValue.add(this.byValue);
          } else {
            toValue = this._baseValue + this.byValue;
          }
        }
      } else {
        // TODO: retain prevValue
        //value = this._lerp(prevValue, currentValue, t)
      }
      var value = this._lerp(fromValue, toValue, t

      //if(this.keyPath === 'rotation.w'){
      //  console.log(`from: ${fromValue}, to: ${toValue}, t: ${t}, value: ${value}`)
      //}

      );if (this.isAdditive) {
        if (isObject) {
          //value = value.add(obj.valueForKeyPath(this.keyPath))
          value = value.add(this._baseValue);
        } else {
          value += this._baseValue;
        }
      }

      //if(this.keyPath === 'rotation.w'){
      //  console.log(`value after: ${value}`)
      //}

      //console.log(`CABasicAnimation._applyAnimation: keyPath: ${this.keyPath}, time: ${time}, baseTime: ${baseTime}, t: ${t}, value: ${value}`)
      this._applyValue(obj, value);
      this._handleEvents(obj, t);
    }
  }]);

  return CABasicAnimation;
}(_CAPropertyAnimation3.default);

exports.default = CABasicAnimation;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CAAnimation2 = __webpack_require__(24);

var _CAAnimation3 = _interopRequireDefault(_CAAnimation2);

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

var _CGRect = __webpack_require__(16);

var _CGRect2 = _interopRequireDefault(_CGRect);

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

var _SCNVector = __webpack_require__(11);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _SCNVector3 = __webpack_require__(1);

var _SCNVector4 = _interopRequireDefault(_SCNVector3);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNQuaternion from '../SceneKit/SCNQuaternion'


/**
 * An abstract subclass of CAAnimation for creating animations that manipulate the value of layer properties. 
 * @access public
 * @extends {CAAnimation}
 * @see https://developer.apple.com/documentation/quartzcore/capropertyanimation
 */
var CAPropertyAnimation = function (_CAAnimation) {
  _inherits(CAPropertyAnimation, _CAAnimation);

  // Creating an Animation

  /**
   * Creates and returns an CAPropertyAnimation instance for the specified key path.
   * @access public
   * @constructor
   * @param {?string} path - 
   * @see https://developer.apple.com/documentation/quartzcore/capropertyanimation/1412534-init
   */
  function CAPropertyAnimation(path) {
    _classCallCheck(this, CAPropertyAnimation);

    // Animated Key Path

    /**
     * Specifies the key path the receiver animates.
     * @type {?string}
     * @see https://developer.apple.com/documentation/quartzcore/capropertyanimation/1412496-keypath
     */
    var _this = _possibleConstructorReturn(this, (CAPropertyAnimation.__proto__ || Object.getPrototypeOf(CAPropertyAnimation)).call(this));

    _this.keyPath = path;

    // Property Value Calculation Behavior

    /**
     * Determines if the value of the property is the value at the end of the previous repeat cycle, plus the value of the current repeat cycle.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/quartzcore/capropertyanimation/1412538-iscumulative
     */
    _this.isCumulative = false;

    /**
     * Determines if the value specified by the animation is added to the current render tree value to produce the new render tree value.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/quartzcore/capropertyanimation/1412493-isadditive
     */
    _this.isAdditive = false;

    /**
     * An optional value function that is applied to interpolated values.
     * @type {?CAValueFunction}
     * @see https://developer.apple.com/documentation/quartzcore/capropertyanimation/1412447-valuefunction
     */
    _this.valueFunction = null;

    _this._isMultiplicative = false;
    return _this;
  }

  /**
   * @access public
   * @returns {CAPropertyAnimation} -
   */


  _createClass(CAPropertyAnimation, [{
    key: 'copy',
    value: function copy() {
      var anim = _get(CAPropertyAnimation.prototype.__proto__ || Object.getPrototypeOf(CAPropertyAnimation.prototype), 'copy', this).call(this);
      //anim._copyValue(this)
      anim.keyPath = this.keyPath;
      anim.isCumulative = this.isCumulative;
      anim.isAdditive = this.isAdditive;
      anim.valueFunction = this.valueFunction;
      anim._isMultiplicative = this._isMultiplicative;

      return anim;
    }

    /*
    _copyValue(src) {
      console.log('CAPropertyAnimation._copyValue: ' + src.keyPath)
      this.keyPath = src.keyPath
      this.isCumulative = src.isCumulative
      this.isAdditive = src.isAdditive
      this.valueFunction = src.valueFunction
    }
    */

    /**
     * apply animation to the given node.
     * @access private
     * @param {Object} obj - target object to apply this animation.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAnimation',
    value: function _applyAnimation(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var t = time;
      if (needTimeConversion) {
        var baseTime = this._basetimeFromTime(time);
        t = baseTime;
        if (this.timingFunction !== null) {
          t = this.timingFunction._getValueAtTime(baseTime);
        }
      }

      var value = t;
      if (this.valueFunction !== null) {
        value = this.valueFunction._getValueAtTime(t);
      }
      value = this._calculateWithBaseValue(obj, value
      //console.log(`CAPropertyAnimation: obj: ${obj.name}, time: ${time}, keyPath: ${this.keyPath}, value: ${value}`)
      );this._applyValue(obj, value);
      this._handleEvents(obj, t);
    }
  }, {
    key: '_calculateWithBaseValue',
    value: function _calculateWithBaseValue(obj, value) {
      if (this.isAdditive) {
        var baseValue = obj.valueForKeyPath(this.keyPath);
        return this._addValues(baseValue, value);
      } else if (this._isMultiplicative) {
        var _baseValue = obj.valueForKeyPath(this.keyPath);
        return this._mulValues(_baseValue, value);
      }
      return value;
    }
  }, {
    key: '_applyValue',
    value: function _applyValue(obj, value) {
      obj.setValueForKeyPath(value, this.keyPath);
    }
  }, {
    key: '_addValues',
    value: function _addValues(v1, v2) {
      if (v1 instanceof Object) {
        return v1.add(v2);
      }
      return v1 + v2;
    }
  }, {
    key: '_mulValues',
    value: function _mulValues(v1, v2) {
      if (v1 instanceof Object) {
        return v1.mul(v2);
      }
      return v1 * v2;
    }
  }, {
    key: '_lerp',
    value: function _lerp(from, to, t) {
      if (t === null) {
        // the animation is over.
        return to;
      }
      if ((0, _InstanceOf3.default)(from, _SCNVector2.default)) {
        // TODO: slerp for Quaternion
        return from.lerp(to, t);
      } else if ((0, _InstanceOf3.default)(from, _SCNVector4.default)) {
        return from.lerp(to, t);
      } else if ((0, _InstanceOf3.default)(from, _SCNMatrix2.default)) {
        return from.lerp(to, t);
      } else if ((0, _InstanceOf3.default)(from, _CGSize2.default)) {
        // TODO: implement
      } else if ((0, _InstanceOf3.default)(from, _CGPoint2.default)) {
        // TODO: implement
      } else if ((0, _InstanceOf3.default)(from, _CGRect2.default)) {
        // TODO: implement
      } else if ((0, _InstanceOf3.default)(from, _SKColor2.default)) {
        return from._lerp(to, t);
      }
      return from + (to - from) * t;
    }
  }, {
    key: '_slerp',
    value: function _slerp(from, to, t) {
      if (!(0, _InstanceOf3.default)(from, _SCNVector2.default)) {
        throw new Error('CABasicAnimation._slerp: object is not SCNVector4');
      }
      return from.slerp(to, t);
    }
  }]);

  return CAPropertyAnimation;
}(_CAAnimation3.default);

exports.default = CAPropertyAnimation;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _constants = __webpack_require__(25);

var Constants = _interopRequireWildcard(_constants);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A function that defines the pacing of an animation as a timing curve. 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/quartzcore/camediatimingfunction
 */
var CAMediaTimingFunction = function (_NSObject) {
  _inherits(CAMediaTimingFunction, _NSObject);

  // Creating Timing Functions

  /**
   * Returns an initialized timing function modeled as a cubic Bézier curve using the specified control points.
   * @access public
   * @constructor
   * @param {number} c1x - A floating point number representing the x position of the c1 control point.
   * @param {number} c1y - A floating point number representing the y position of the c1 control point.
   * @param {number} c2x - A floating point number representing the x position of the c2 control point.
   * @param {number} c2y - A floating point number representing the y position of the c2 control point.
   * @desc The end points of the Bézier curve are automatically set to (0.0,0.0) and (1.0,1.0). The control points defining the Bézier curve are: [(0.0,0.0), (c1x,c1y), (c2x,c2y), (1.0,1.0)].
   * @see https://developer.apple.com/documentation/quartzcore/camediatimingfunction/1522235-init
   */
  function CAMediaTimingFunction(c1x, c1y, c2x, c2y) {
    _classCallCheck(this, CAMediaTimingFunction);

    var _this = _possibleConstructorReturn(this, (CAMediaTimingFunction.__proto__ || Object.getPrototypeOf(CAMediaTimingFunction)).call(this));

    _this._c1x = c1x;
    _this._c1y = c1y;
    _this._c2x = c2x;
    _this._c2y = c2y;
    return _this;
  }

  /**
   * Creates and returns a new instance of CAMediaTimingFunction configured with the predefined timing function specified by name.
   * @access public
   * @param {string} name - The timing function to use as specified in Predefined Timing Functions. 
   * @returns {CAMediaTimingFunction} -
   * @see https://developer.apple.com/documentation/quartzcore/camediatimingfunction/1521979-init
   */


  _createClass(CAMediaTimingFunction, [{
    key: 'getControlPointAtValues',


    // Accessing the Control Points

    /**
     * Returns the control point for the specified index.
     * @access public
     * @param {number} idx - 
     * @param {!UnsafeMutablePointer<Float>} ptr - A pointer to an array that, upon return, will contain the x and y values of the specified point.
     * @returns {void}
     * @desc The value of index must be between 0 and 3.
     * @see https://developer.apple.com/documentation/quartzcore/camediatimingfunction/1522057-getcontrolpoint
     */
    value: function getControlPointAtValues(idx, ptr) {}
  }, {
    key: '_getValueAtTime',
    value: function _getValueAtTime(time) {
      var t0 = 0;
      var t1 = 1;
      var t = 0.5;
      var r = 0;

      if (time <= 0) {
        return 0;
      } else if (time >= 1) {
        return 1;
      }

      for (var i = 0; i < 8; i++) {
        r = 1 - t;
        var tval = 3 * t * r * (this._c1x * r + this._c2x * t) + t * t * t;
        if (time > tval) {
          t0 = t;
        } else {
          t1 = t;
        }
        t = (t0 + t1) * 0.5;
      }
      r = 1 - t;
      var val = 3 * t * r * (this._c1y * r + this._c2y * t) + t * t * t;

      return val;
    }
  }], [{
    key: 'functionWithName',
    value: function functionWithName(name) {
      switch (name) {
        case Constants.kCAMediaTimingFunctionLinear:
          return new CAMediaTimingFunction(0.0, 0.0, 1.0, 1.0);
        case Constants.kCAMediaTimingFunctionEaseIn:
          return new CAMediaTimingFunction(0.42, 0.0, 1.0, 1.0);
        case Constants.kCAMediaTimingFunctionEaseOut:
          return new CAMediaTimingFunction(0.0, 0.0, 0.58, 1.0);
        case Constants.kCAMediaTimingFunctionEaseInEaseOut:
          return new CAMediaTimingFunction(0.42, 0.0, 0.58, 1.0);
        case Constants.kCAMediaTimingFunctionDefault:
          return new CAMediaTimingFunction(0.25, 0.1, 0.25, 1.0);
        default:
          throw new Error('CAMediaTimingFunction: unknown name: ' + name);
      }
    }

    /**
     * Returns an initialized timing function modeled as a cubic Bézier curve using the specified control points.
     * @access public
     * @param {number} c1x - A floating point number representing the x position of the c1 control point.
     * @param {number} c1y - A floating point number representing the y position of the c1 control point.
     * @param {number} c2x - A floating point number representing the x position of the c2 control point.
     * @param {number} c2y - A floating point number representing the y position of the c2 control point.
     * @returns {CAMediaTimingFunction} -
     * @desc The end points of the Bézier curve are automatically set to (0.0,0.0) and (1.0,1.0). The control points defining the Bézier curve are: [(0.0,0.0), (c1x,c1y), (c2x,c2y), (1.0,1.0)].
     * @see https://developer.apple.com/documentation/quartzcore/camediatimingfunction/1522235-init
     */

  }, {
    key: 'functionWithControlPoints',
    value: function functionWithControlPoints(c1x, c1y, c2x, c2y) {
      return new CAMediaTimingFunction(c1x, c1y, c2x, c2y);
    }
  }]);

  return CAMediaTimingFunction;
}(_NSObject3.default);

exports.default = CAMediaTimingFunction;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The modes SceneKit uses to determine which polygons to render in a surface, used by the cullMode property.
 * @typedef {Object} SCNCullMode
 * @property {number} back - 
 * @property {number} front - 
 * @see https://developer.apple.com/documentation/scenekit/scncullmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNCullMode = {
  back: 0,
  front: 1
};

exports.default = SCNCullMode;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SCNGeometry2 = __webpack_require__(9);

var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

var _SCNGeometryElement = __webpack_require__(15);

var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A right circular cylinder geometry whose ends are capped with hemispheres.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scncapsule
 */
var SCNCapsule = function (_SCNGeometry) {
  _inherits(SCNCapsule, _SCNGeometry);

  // Creating a Capsule

  /**
   * Creates a capsule geometry with the specified radius and height.
   * @access public
   * @constructor
   * @param {number} capRadius - The radius both of the capsule’s cylindrical body and of its hemispherical ends.
   * @param {number} height - The height of the capsule along the y-axis of its local coordinate space.
   * @desc The capsule is centered in its local coordinate system. For example, if you create a capsule whose cap radius is 5.0 and height is 20.0, it extends from -10.0 to 10.0 in the y-axis, and the circular cross section at the center of its body extends from -5.0 to 5.0 along the x- and z-axes.
   * @see https://developer.apple.com/documentation/scenekit/scncapsule/1523790-init
   */
  function SCNCapsule() {
    var capRadius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2.0;

    _classCallCheck(this, SCNCapsule);

    // Adjusting a Capsule’s Dimensions

    /**
     * The radius both of the capsule’s circular center cross section and of its hemispherical ends. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncapsule/1523926-capradius
     */
    var _this = _possibleConstructorReturn(this, (SCNCapsule.__proto__ || Object.getPrototypeOf(SCNCapsule)).call(this, [], []));

    _this.capRadius = capRadius;

    /**
     * The extent of the capsule along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncapsule/1522789-height
     */
    _this.height = height;

    // Adjusting Geometric Detail

    /**
     * The number of subdivisions around the lateral circumference of the capsule. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncapsule/1522735-radialsegmentcount
     */
    _this.radialSegmentCount = 24;

    /**
     * The number of subdivisions in the height of each hemispherical end of the capsule. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncapsule/1523561-capsegmentcount
     */
    _this.capSegmentCount = 48;

    /**
     * The number of subdivisions in the sides of the capsule along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncapsule/1523697-heightsegmentcount
     */
    _this.heightSegmentCount = 1;

    _this._createGeometry();
    _this.materials.push(new _SCNMaterial2.default());
    return _this;
  }

  _createClass(SCNCapsule, [{
    key: '_createGeometry',
    value: function _createGeometry() {
      var sourceData = [];
      var indexData = [];
      var vectorCount = (this.radialSegmentCount * 2 + 1) * (this.capSegmentCount + 4);
      //const primitiveCount = this.radialSegmentCount * this.capSegmentCount * 4

      var yNom = [];
      var ySin = [];
      for (var lat = 0; lat <= this.capSegmentCount; lat++) {
        yNom.push(-Math.cos(Math.PI * lat / this.capSegmentCount));
        ySin.push(Math.sin(Math.PI * lat / this.capSegmentCount));
      }

      var cylinderHeight = this.height - this.capRadius * 2;
      var hemiLen = this.capSegmentCount / 2;
      var rad2 = this.radialSegmentCount * 2;
      for (var lng = 0; lng <= rad2; lng++) {
        var x = -Math.sin(2.0 * Math.PI * lng / rad2);
        var z = -Math.cos(2.0 * Math.PI * lng / rad2);
        var tx = lng / rad2;
        var y = -cylinderHeight * 0.5;
        for (var _lat = 0; _lat <= hemiLen; _lat++) {
          var xNom = x * ySin[_lat];
          var zNom = z * ySin[_lat];

          // vertex
          sourceData.push(xNom * this.capRadius, y + yNom[_lat] * this.capRadius, zNom * this.capRadius

          // normal
          );sourceData.push(xNom, yNom[_lat], zNom

          // texcoord
          );sourceData.push(tx, 1.0 - 0.25 * _lat / hemiLen);

          if (_lat === hemiLen) {
            // put the same data again
            sourceData.push(xNom * this.capRadius, y + yNom[_lat] * this.capRadius, zNom * this.capRadius);
            sourceData.push(xNom, yNom[_lat], zNom);
            sourceData.push(tx, 1.0 - 0.25 * _lat / hemiLen);
          }
        }

        y = cylinderHeight * 0.5;
        for (var _lat2 = hemiLen; _lat2 <= this.capSegmentCount; _lat2++) {
          var _xNom = x * ySin[_lat2];
          var _zNom = z * ySin[_lat2];

          // vertex
          sourceData.push(_xNom * this.capRadius, y + yNom[_lat2] * this.capRadius, _zNom * this.capRadius

          // normal
          );sourceData.push(_xNom, yNom[_lat2], _zNom

          // texcoord
          );sourceData.push(tx, 0.50 - 0.25 * _lat2 / hemiLen);

          if (_lat2 === hemiLen) {
            // put the same data again
            sourceData.push(_xNom * this.capRadius, y + yNom[_lat2] * this.capRadius, _zNom * this.capRadius);
            sourceData.push(_xNom, yNom[_lat2], _zNom);
            sourceData.push(tx, 0.50 - 0.25 * _lat2 / hemiLen);
          }
        }
      }

      // index
      var capLen = this.capSegmentCount;
      var radLen = this.radialSegmentCount * 2 + 1;
      for (var i = 0; i < capLen; i++) {
        var index1 = i * (this.capSegmentCount + 4);
        var index2 = index1 + this.capSegmentCount + 5;

        indexData.push(index1, index2, index1 + 1);
        index1 += 1;
        for (var j = 0; j < radLen; j++) {
          if (Math.abs(j - this.radialSegmentCount) !== 1) {
            indexData.push(index1, index2 + 1, index1 + 1);
            indexData.push(index1, index2, index2 + 1);
          }
          index1 += 1;
          index2 += 1;
        }
        indexData.push(index1, index2, index2 + 1);
      }

      var vertexSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.vertex, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      32 // sride
      );

      var normalSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.normal, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      12, // offset
      32 // stride
      );

      var texcoordSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.texcoord, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      24, // offset
      32 // stride
      );

      var element = new _SCNGeometryElement2.default(indexData, _SCNGeometryPrimitiveType2.default.triangles);

      this._geometryElements = [element];
      this._geometrySources = [vertexSource, normalSource, texcoordSource];

      this.boundingBox = {
        min: new _SCNVector2.default(-this.capRadius, -this.height * 0.5, -this.capRadius),
        max: new _SCNVector2.default(this.capRadius, this.height * 0.5, this.capRadius)
      };
    }

    /**
     * @access private
     * @returns {Ammo.btCollisionShape} -
     * @desc call Ammo.destroy(shape) after using it.
     */

  }, {
    key: '_createBtCollisionShape',
    value: function _createBtCollisionShape() {}
    //const height = (this.height - this.capRadius) * 0.5
    //const shape = new Ammo.btCapsuleShape(this.capRadius, height)
    //return shape


    /**
     * The center point and radius of the object’s bounding sphere.
     * @type {Object}
     * @parameter {SCNVector3} _boundingSphere.center -
     * @parameter {number} _boundingSphere.radius -
     * @returns {Object} -
     * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a node’s bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of node’s geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
     * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034707-boundingsphere
     */

  }, {
    key: 'getBoundingSphere',
    value: function getBoundingSphere() {
      var c = new _SCNVector2.default(0, 0, 0);
      var r = this.height * 0.5;

      return { center: c, radius: r };
    }
  }, {
    key: '_updateBoundingBoxForSkinner',
    value: function _updateBoundingBoxForSkinner() {
      var skinner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (skinner === null) {
        return this.boundingBox;
      }
      return _get(SCNCapsule.prototype.__proto__ || Object.getPrototypeOf(SCNCapsule.prototype), '_updateBoundingBoxForSkinner', this).call(this, skinner);
    }
  }]);

  return SCNCapsule;
}(_SCNGeometry3.default);

exports.default = SCNCapsule;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNNode from './SCNNode'
//import SCNVector3 from './SCNVector3'
//import SCNMatrix4 from './SCNMatrix4'
//import CGPoint from '../CoreGraphics/CGPoint'

/**
 * Detailed information about a result from searching for elements of a scene located at a specified point, or along a specified line segment (or ray).
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnhittestresult
 */
var SCNHitTestResult = function (_NSObject) {
  _inherits(SCNHitTestResult, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNHitTestResult() {
    _classCallCheck(this, SCNHitTestResult);

    // Retrieving Information About a Hit-Test Result

    var _this = _possibleConstructorReturn(this, (SCNHitTestResult.__proto__ || Object.getPrototypeOf(SCNHitTestResult)).call(this));

    _this._node = null;
    _this._geometryIndex = 0;
    _this._faceIndex = 0;
    _this._localCoordinates = null;
    _this._worldCoordinates = null;
    _this._localNormal = null;
    _this._worldNormal = null;
    _this._modelTransform = null;

    _this._distance = null;

    // Instance Properties

    _this._boneNode = null;
    return _this;
  }

  // Retrieving Information About a Hit-Test Result

  /**
   * Returns the texture coordinates at the point of intersection for the specified texture mapping channel.
   * @access public
   * @param {number} channel - The index of the mapping channel in which to look up texture coordinates.
   * @returns {CGPoint} - 
   * @desc An SCNGeometry object can contain multiple sources of texture coordinates, or texture mapping channels. (With multiple channels, you can map texture images for different material properties in different ways.) To use the texture coordinates of a hit-test result, specify which texture coordinate source to look up coordinates in. For example, to add “scorch marks” to a game character hit by a laser, you might modify a texture image mapped to the multiply property of the geometry’s material. Use the mappingChannel index from that material property as the channel parameter when calling textureCoordinates(withMappingChannel:) to ensure that you modify the correct location in the texture image.
   * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1522771-texturecoordinates
   */


  _createClass(SCNHitTestResult, [{
    key: 'textureCoordinatesWithMappingChannel',
    value: function textureCoordinatesWithMappingChannel(channel) {
      return null;
    }

    /**
     * The node whose geometry intersects the search ray.
     * @type {SCNNode}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1523256-node
     */

  }, {
    key: 'node',
    get: function get() {
      return this._node;
    }

    /**
     * The index of the geometry element whose surface the search ray intersects.
     * @type {number}
     * @desc Every SCNGeometry object contains one or more SCNGeometryElement objects that define how its vertices connect to form a surface. This property provides the index of the geometry element intersecting the search ray. For more information about that geometry element, use the geometry’s geometryElement(at:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1522625-geometryindex
     */

  }, {
    key: 'geometryIndex',
    get: function get() {
      return this._geometryIndex;
    }

    /**
     * The index of the primitive in the geomety element intersected by the search ray.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1522888-faceindex
     */

  }, {
    key: 'faceIndex',
    get: function get() {
      return this._faceIndex;
    }

    /**
     * The point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.
     * @type {SCNVector3}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1523032-localcoordinates
     */

  }, {
    key: 'localCoordinates',
    get: function get() {
      return this._localCoordinates;
    }

    /**
     * The point of intersection between the geometry and the search ray, in the scene’s world coordinate system.
     * @type {SCNVector3}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1523058-worldcoordinates
     */

  }, {
    key: 'worldCoordinates',
    get: function get() {
      return this._worldCoordinates;
    }

    /**
     * The surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.
     * @type {SCNVector3}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1523953-localnormal
     */

  }, {
    key: 'localNormal',
    get: function get() {
      return this._localNormal;
    }

    /**
     * The surface normal vector at the point of intersection, in the scene’s world coordinate system.
     * @type {SCNVector3}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1524066-worldnormal
     */

  }, {
    key: 'worldNormal',
    get: function get() {
      return this._worldNormal;
    }

    /**
     * The world transform matrix of the node containing the intersection.
     * @type {SCNMatrix4}
     * @desc Use this matrix to transform vectors from the local coordinate space of the node whose geometry is intersected by the search ray to the scene’s world coordinate system.
     * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1523496-modeltransform
     */

  }, {
    key: 'modelTransform',
    get: function get() {
      return this._modelTransform;
    }

    // Instance Properties

    /**
     * 
     * @type {SCNNode}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnhittestresult/1823463-bonenode
     */

  }, {
    key: 'boneNode',
    get: function get() {
      return this._boneNode;
    }
  }]);

  return SCNHitTestResult;
}(_NSObject3.default);

exports.default = SCNHitTestResult;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Constants that determine how a physics body interacts with forces and other bodies, used by the type property and when creating a physics body.
 * @typedef {Object} SCNPhysicsBodyType
 * @property {number} static - A physics body that is unaffected by forces or collisions and cannot move.
 * @property {number} dynamic - A physics body that can be affected by forces and collisions.
 * @property {number} kinematic - A physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsbodytype
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNPhysicsBodyType = {
  static: 0,
  dynamic: 1,
  kinematic: 2
};

exports.default = SCNPhysicsBodyType;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNBox = __webpack_require__(34);

var _SCNBox2 = _interopRequireDefault(_SCNBox);

var _SCNCapsule = __webpack_require__(49);

var _SCNCapsule2 = _interopRequireDefault(_SCNCapsule);

var _SCNGeometry = __webpack_require__(9);

var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

var _SCNNode = __webpack_require__(14);

var _SCNNode2 = _interopRequireDefault(_SCNNode);

var _SCNSphere = __webpack_require__(53);

var _SCNSphere2 = _interopRequireDefault(_SCNSphere);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Option = {
  collisionMargin: 'SCNPhysicsShapeCollisionMarginKey',
  keepAsCompound: 'SCNPhysicsShapeKeepAsCompoundKey',
  scale: 'SCNPhysicsShapeScaleKey',
  type: 'SCNPhysicsShapeTypeKey'
};

var _ShapeType = {
  boundingBox: 'boundingBox',
  concavePolyhedron: 'concaveMesh',
  convexHull: 'convexHull'

  /**
   * An abstraction of a physics body’s solid volume for use in tuning or optimizing collision detection.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape
   */
};
var SCNPhysicsShape = function (_NSObject) {
  _inherits(SCNPhysicsShape, _NSObject);

  _createClass(SCNPhysicsShape, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        $constructor: function $constructor(propNames, propValues) {
          return new SCNPhysicsShape(propValues.referenceObject, propValues.options);
        },
        options: ['NSArray', null],
        referenceObject: ['NSObject', null]
      };
    }

    // Creating Physics Shapes

    /**
     * Creates a physics shape based on a geometry object.
     * @access public
     * @constructor
     * @param {SCNGeometry} geometry - A geometry object.
     * @param {?Map<SCNPhysicsShape.Option, Object>} [options = null] - A dictionary of options affecting the level of detail of the physics shape, or nil to use default options. For applicable keys and their possible values, see Shape Creation Options Keys.
     * @desc If you create a physics shape using one of the basic geometry classes (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule), SceneKit uses an idealized form of that geometry for the physics shape instead of using the geometry’s vertex data to simulate collisions. For example, if you create a physics shape from an SCNSphere object, SceneKit simulates collisions for any object that passes within the sphere’s radius. Because the idealized forms of simple geometries are computationally much simpler than the vertex data needed for displaying them, using basic geometries for physics shapes (or compound shapes created from basic geometries with the init(shapes:transforms:) method) often provides the best balance between simulation accuracy and performance. To use the newly created physics shape, create a physics body with the the init(type:shape:) method, or assign the shape to the physicsShape property of an existing body.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508897-init
     */

  }]);

  function SCNPhysicsShape(geometry) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, SCNPhysicsShape);

    var _this = _possibleConstructorReturn(this, (SCNPhysicsShape.__proto__ || Object.getPrototypeOf(SCNPhysicsShape)).call(this));

    var _options = options;
    if (Array.isArray(options)) {
      _options = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = options[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var arr = _step.value;

          _options[arr[0]] = arr[1];
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * @type {SCNGeometry}
     */
    _this._sourceGeometry = null;

    /**
     * @type {Object}
     */
    _this._options = _options;

    /**
     * @type {SCNMatrix4}
     */
    _this._transforms = null;

    /**
     * @type {SCNGeometry}
     */
    _this._shape = null;

    /**
     * @type {SCNVector3}
     */
    _this._center = new _SCNVector2.default(0, 0, 0);

    // Getting Information About a Shape
    _this._sourceObject = null;

    _this._setSourceObject(geometry);
    _this._createShape();
    return _this;
  }

  _createClass(SCNPhysicsShape, [{
    key: '_setSourceObject',
    value: function _setSourceObject(obj) {
      this._sourceObject = obj;
      if ((0, _InstanceOf3.default)(this._sourceObject, _SCNGeometry2.default)) {
        this._sourceGeometry = this._sourceObject;
      } else if ((0, _InstanceOf3.default)(this._sourceObject, _SCNNode2.default) && this._sourceObject.geometry) {
        // TODO: get geometries recursively
        this._sourceGeometry = this._sourceObject.geometry;
      } else {
        //throw new Error(`can't use it for source object: ${geometry.className}`)
      }
      if (!this._sourceGeometry) {
        //throw new Error('source geometry is null')
      }
    }
  }, {
    key: '_createShape',
    value: function _createShape() {
      if (!this._sourceGeometry) {
        //throw new Error('SCNPhysicsShape: must have a geometry')
        return;
      }

      //if(this._options && this._options.get(_Option.type) === _ShapeType.boundingBox){
      if (this._options && this._options[_Option.type] === _ShapeType.boundingBox) {
        this._createShapeAsBoundingBox();
      } else if ((0, _InstanceOf3.default)(this._sourceGeometry, _SCNCapsule2.default)) {
        // FIXME: do not convert to SCNBox
        this._createShapeAsBoundingBox();
      } else if ((0, _InstanceOf3.default)(this._sourceGeometry, _SCNBox2.default)) {
        this._createShapeAsBox();
      } else if ((0, _InstanceOf3.default)(this._sourceGeometry, _SCNSphere2.default)) {
        this._createShapeAsSphere
        //}else if(this._options && this._options.get(_Option.type) === _ShapeType.convecHull){
        ();
      } else if (this._options && this._options[_Option.type] === _ShapeType.concavePolyhedron) {
        // give up making a simple shape
        this._shape = this._sourceGeometry;
      } else {
        this._createShapeAsSphere();
      }
    }
  }, {
    key: '_createShapeAsBoundingBox',
    value: function _createShapeAsBoundingBox() {
      var boundingBox = this._sourceGeometry._updateBoundingBox();
      var width = boundingBox.max.x - boundingBox.min.x;
      var height = boundingBox.max.y - boundingBox.min.y;
      var length = boundingBox.max.z - boundingBox.min.z;
      var chamferRadius = 0;
      var box = new _SCNBox2.default(width, height, length, chamferRadius);
      this._shape = box;
      this._center = new _SCNVector2.default(boundingBox.min.x + width * 0.5, boundingBox.min.y + height * 0.5, boundingBox.min.z + length * 0.5);
    }
  }, {
    key: '_createShapeAsBox',
    value: function _createShapeAsBox() {
      // TODO: copy the geometry
      this._shape = this._sourceGeometry;
      this._center = new _SCNVector2.default(0, 0, 0);
    }
  }, {
    key: '_createShapeAsSphere',
    value: function _createShapeAsSphere() {
      if ((0, _InstanceOf3.default)(this._sourceGeometry, _SCNSphere2.default)) {
        // TODO: copy the geometry
        this._shape = this._sourceGeometry;
        this._center = new _SCNVector2.default(0, 0, 0);
        return;
      }
      var boundingSphere = this._sourceGeometry.getBoundingSphere();
      var sphere = new _SCNSphere2.default(boundingSphere.radius);
      this._shape = sphere;
      this._center = boundingSphere.center;
    }

    // Getting Information About a Shape

    /**
     * The object that was used to create the shape.
     * @type {Object}
     * @desc This property, along with the transforms and options properties, provides the information that was used to create the shape. You can use this information, for example, to draw editing or debugging UI in your scene.If the shape was created with the init(geometry:options:) method, the source object is an SCNGeometry object, and the options property contains the options affecting the shape’s construction from that geometry.If the shape was created with the init(node:options:) method, the source object is an SCNNode object, and the options property contains the options affecting the shape’s construction from that node.If the shape was created with the init(shapes:transforms:) method, the source object is an array of SCNPhysicsShape objects and the transforms property describes how those shapes combine to form a compound shape.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508888-sourceobject
     */

  }, {
    key: '_createBtCollisionShape',


    /**
     * @access private
     * @returns {Ammo.btCollisionShape} -
     * @desc call Ammo.destroy(shape) after using it.
     */
    value: function _createBtCollisionShape() {
      if (this._sourceObject === null) {
        throw new Error('_sourceObject is null');
      }
      return this._sourceObject._createBtCollisionShape();
    }
  }, {
    key: 'sourceObject',
    get: function get() {
      return this._sourceObject;
    }

    /**
     * The options dictionary that was used to create the shape.
     * @type {?Map<SCNPhysicsShape.Option, Object>}
     * @desc You provide this dictionary in the init(geometry:options:) or init(node:options:) method. Use this dictionary along with the sourceObject property to recover the information that was used to create the shape. If the shape was created with the init(shapes:transforms:) method, this property’s value is nil.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508904-options
     */

  }, {
    key: 'options',
    get: function get() {
      return this._options;
    }
  }, {
    key: '_type',
    get: function get() {
      if (!this._options) {
        return null;
      }
      return this._options[_Option.type];
    }

    /**
     * The array of transforms that was used to create a compound shape.
     * @type {?NSValue[]}
     * @desc You provide this array of NSValue objects, each containing an SCNMatrix4 value, in the init(shapes:transforms:) method to create a compound shape. Use this array along with the sourceObject property to recover the information that was used to create the shape. If the shape was created with the init(geometry:options:) or init(node:options:) method, this property's value is nil.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape/1508898-transforms
     */

  }, {
    key: 'transforms',
    get: function get() {
      return this._transforms;
    }

    // Structures

    /**
     * @type {Object} Option
     * @property {string} collisionMargin 
     * @property {string} keepAsCompound An option for selecting whether to create a group of independent shapes or combine them into a single shape.
     * @property {string} scale An option for selecting the scale factor of the shape relative to the local coordinate space of the node containing it.
     * @property {string} type An option for selecting the level of detail at which to create shapes from geometry.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape.option
     */

  }], [{
    key: 'Option',
    get: function get() {
      return _Option;
    }

    /**
     * @type {Object} ShapeType
     * @property {string} boundingBox The physics shape is the smallest box containing the geometry.
     * @property {string} concavePolyhedron The physics shape is a concave polyhedron closely following the surface of the geometry.
     * @property {string} convexHull The physics shape is a convex polyhedron roughly enclosing the geometry.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsshape.shapetype
     */

  }, {
    key: 'ShapeType',
    get: function get() {
      return _ShapeType;
    }
  }]);

  return SCNPhysicsShape;
}(_NSObject3.default);

exports.default = SCNPhysicsShape;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNGeometry2 = __webpack_require__(9);

var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

var _SCNGeometryElement = __webpack_require__(15);

var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A sphere (or ball or globe) geometry.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scnsphere
 */
var SCNSphere = function (_SCNGeometry) {
  _inherits(SCNSphere, _SCNGeometry);

  _createClass(SCNSphere, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        $constructor: function $constructor(propNames, propValues) {
          var sphere = new SCNSphere(propValues.sphereradius);
          sphere.isGeodesic = propValues.spheregeodesic;
          sphere.segmentCount = propValues.spheresegmentCount;
          sphere.name = propValues.name;
          sphere._sphereRadialSpan = propValues.sphereRadialSpan;
          sphere._isHemispheric = propValues.spherehemispheric;
          sphere._spherePrimitiveType = propValues.sphereprimitiveType;
          sphere.materials = propValues.materials;
          sphere.tessellator = propValues.tessellator;
          sphere.subdivisionLevel = propValues.subdivisionLevel;
          sphere.wantsAdaptiveSubdivision = propValues.wantsAdaptiveSubdivision;
          sphere._createGeometry();

          return sphere;
        },
        sphereradius: ['float', null],
        spheregeodesic: ['boolean', null],
        spheresegmentCount: ['integer', null],
        materials: ['NSArray', null],
        tessellator: ['SCNGeometryTessellator', null],
        wantsAdaptiveSubdivision: ['boolean', null],

        adaptiveSubdivision: ['boolean', null],
        name: ['string', null],
        sphereradialSpan: ['float', null],
        spherehemispheric: ['boolean', null],
        sphereprimitiveType: ['integer', null],
        subdivisionLevel: ['integer', null],
        subdivisionSettings: ['bytes', null]
      };
    }

    // Creating a Sphere

    /**
     * Creates a sphere geometry with the specified radius.
     * @access public
     * @constructor
     * @param {number} radius - The radius of the sphere in its local coordinate space.
     * @desc The sphere is centered in its local coordinate system. For example, if you create a sphere whose radius is 5.0, it extends from -5.0 to 5.0 along each of the the x, y, and z-axes.
     * @see https://developer.apple.com/documentation/scenekit/scnsphere/1522601-init
     */

  }]);

  function SCNSphere() {
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;

    _classCallCheck(this, SCNSphere);

    // Adjusting a Sphere’s Dimensions

    /**
     * The radius of the sphere. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnsphere/1523787-radius
     */
    var _this = _possibleConstructorReturn(this, (SCNSphere.__proto__ || Object.getPrototypeOf(SCNSphere)).call(this, [], []));

    _this.radius = radius;

    // Adjusting Geometric Detail

    /**
     * A Boolean value specifying whether SceneKit uses a geodesic polygon mesh to render the sphere.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnsphere/1523268-isgeodesic
     */
    _this.isGeodesic = false;

    /**
     * A number determining the detail of the polygon mesh SceneKit uses to render the sphere. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnsphere/1523912-segmentcount
     */
    _this.segmentCount = 24;

    _this._sphereRadialSpan = 0;
    _this._spherePrimitiveType = 0;
    _this._isHemispheric = false;

    _this._createGeometry();
    _this.materials.push(new _SCNMaterial2.default());
    return _this;
  }

  _createClass(SCNSphere, [{
    key: '_createGeometry',
    value: function _createGeometry() {
      var sourceData = [];
      var indexData = [];
      var vectorCount = (this.segmentCount + 1) * (this.segmentCount + 1);
      var primitiveCount = (this.segmentCount - 1) * this.segmentCount * 2;

      var yNom = [];
      var ySin = [];
      for (var lat = 0; lat <= this.segmentCount; lat++) {
        yNom.push(-Math.cos(Math.PI * lat / this.segmentCount));
        ySin.push(Math.sin(Math.PI * lat / this.segmentCount));
      }

      for (var lng = 0; lng <= this.segmentCount; lng++) {
        var x = -Math.sin(2.0 * Math.PI * lng / this.segmentCount);
        var z = -Math.cos(2.0 * Math.PI * lng / this.segmentCount);
        for (var _lat = 0; _lat <= this.segmentCount; _lat++) {
          var xNom = x * ySin[_lat];
          var zNom = z * ySin[_lat];

          // vertex
          sourceData.push(xNom * this.radius, yNom[_lat] * this.radius, zNom * this.radius

          // normal
          );sourceData.push(xNom, yNom[_lat], zNom

          // texcoord
          );sourceData.push(lng / this.segmentCount, 1.0 - _lat / this.segmentCount);
        }
      }

      for (var i = 0; i < this.segmentCount; i++) {
        var index1 = i * (this.segmentCount + 1);
        var index2 = index1 + this.segmentCount + 2;

        indexData.push(index1, index2, index1 + 1);
        index1 += 1;
        for (var j = 0; j < this.segmentCount - 2; j++) {
          indexData.push(index1, index2 + 1, index1 + 1);
          indexData.push(index1, index2, index2 + 1);
          index1 += 1;
          index2 += 1;
        }
        indexData.push(index1, index2, index2 + 1);
      }

      var vertexSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.vertex, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      32 // sride
      );

      var normalSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.normal, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      12, // offset
      32 // stride
      );

      var texcoordSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.texcoord, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      24, // offset
      32 // stride
      );

      var element = new _SCNGeometryElement2.default(indexData, _SCNGeometryPrimitiveType2.default.triangles);

      this._geometryElements = [element];
      this._geometrySources = [vertexSource, normalSource, texcoordSource];
      this.boundingBox = {
        min: new _SCNVector2.default(-this.radius, -this.radius, -this.radius),
        max: new _SCNVector2.default(this.radius, this.radius, this.radius)
      };
    }
  }, {
    key: '_updateBoundingBoxForSkinner',
    value: function _updateBoundingBoxForSkinner() {
      var skinner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (skinner === null) {
        return this.boundingBox;
      }
      return _get(SCNSphere.prototype.__proto__ || Object.getPrototypeOf(SCNSphere.prototype), '_updateBoundingBoxForSkinner', this).call(this, skinner);
    }
  }]);

  return SCNSphere;
}(_SCNGeometry3.default);

exports.default = SCNSphere;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * AjaxRequest class
 * @access public
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AjaxRequest = exports.AjaxRequest = function () {
  /**
   * constructor
   * @access public
   * @constructor
   */
  function AjaxRequest() {
    _classCallCheck(this, AjaxRequest);

    this.defaultOptions = {
      method: 'POST',
      async: true,
      data: null,
      user: null,
      password: null,
      mimeType: null,
      isJSONP: false,
      responseType: null,
      requestHeader: {}
    };

    this.jsonpScripts = [];
    this.jsonpCallbackPrefix = 'jsonpCallback_';
  }

  _createClass(AjaxRequest, [{
    key: 'get',
    value: function get(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      options.method = 'GET';
      return this.request(url, options);
    }
  }, {
    key: 'post',
    value: function post(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      options.method = 'POST';
      return this.request(url, options);
    }
  }, {
    key: 'jsonp',
    value: function jsonp(url) {
      var callbackParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'callback';
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var requestURL = url;
      var script = document.createElement('script');
      var callbackFuncName = this._getNewFuncName(this.jsonpCallbackPrefix);

      if (!options.data) {
        options.data = {};
      }
      options.data[callbackParam] = callbackFuncName;

      var queryArray = [];
      options.data.forEach(function (key, value) {
        queryArray.push(encodeURI(key) + '=' + encodeURI(value));
      });
      requestURL += '?' + queryArray.join('&');

      var promise = new Promise(function (resolve, reject) {
        window[callbackFuncName] = resolve;
        script.addEventListener('error', reject);
      }).catch(function (error) {
        delete window[callbackFuncName];
        document.head.removeChild(script);
        return Promise.reject(error);
      }).then(function (result) {
        delete window[callbackFuncName];
        document.head.removeChild(script);
        return Promise.resolve(result);
      });

      script.src = requestURL;
      document.head.appendChild(script);

      return promise;
    }
  }, {
    key: '_getNewFuncName',
    value: function _getNewFuncName() {
      var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

      // ESLint prefers for(;;) more than while(true)
      for (;;) {
        var funcName = prefix + Math.random().toString(16).slice(2);
        if (typeof window[funcName] === 'undefined') {
          return funcName;
        }
      }
    }
  }, {
    key: 'request',
    value: function request(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var requestURL = url;
      var method = typeof options.method === 'undefined' ? this.defaultOptions.method : options.method;
      var async = typeof options.async === 'undefined' ? this.defaultOptions.async : options.async;
      var data = this.defaultOptions.data;
      var user = typeof options.user === 'undefined' ? this.defaultOptions.user : options.user;
      var password = typeof options.password === 'undefined' ? this.defaultOptions.password : options.password;
      var mimeType = typeof options.mimeType === 'undefined' ? this.defaultOptions.mimeType : options.mimeType;
      var header = typeof options.requestHeader === 'undefined' ? this.defaultOptions.requestHeader : options.requestHeader;
      var isJSONP = typeof options.isJSONP === 'undefined' ? this.defaultOptions.isJSONP : options.isJSONP;
      var responseType = typeof options.responseType === 'undefined' ? this.defaultOptions.responseType : options.responseType;

      if (method !== 'POST' && method !== 'GET') {
        method = 'POST';
      }

      if (options.data) {
        var dataArray = [];
        if (options.data instanceof Map) {
          options.data.forEach(function (key, value) {
            dataArray.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
          });
        } else {
          Object.keys(options.data).forEach(function (key) {
            var value = options.data[key];
            dataArray.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
          });
        }

        if (method === 'POST') {
          data = dataArray.join('&').replace(/%20/g, '+');
        } else {
          requestURL += '?' + dataArray.join('&').replace(/%20/g, '+');
        }
      }

      if (method === 'POST' && typeof header['Content-Type'] === 'undefined') {
        header['Content-Type'] = 'application/x-www-form-urlencoded';
      }

      return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();

        if (mimeType) {
          xhr.overrideMimeType(mimeType);
        }
        if (responseType) {
          xhr.responseType = responseType;
        }

        if (user) {
          xhr.open(method, url, async, user, password);
        } else {
          xhr.open(method, url, async);
        }

        if (header) {
          for (var key in header) {
            // Reflect is not yet implemented...
            //if(Reflect.apply({}.hasOwnProperty, header, [key])){
            if ({}.hasOwnProperty.call(header, key)) {
              xhr.setRequestHeader(key, header[key]);
            }
          }
        }

        xhr.onload = function () {
          if (xhr.readyState === 4 && xhr.status === 200) {
            resolve(xhr.response);
          } else {
            reject(new Error(xhr.statusText));
          }
        };
        xhr.onerror = function () {
          reject(new Error(xhr.statusText));
        };
        xhr.send(data);
      });
    }
  }]);

  return AjaxRequest;
}();

exports.default = new AjaxRequest();

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

var _SKTextureFilteringMode = __webpack_require__(110);

var _SKTextureFilteringMode2 = _interopRequireDefault(_SKTextureFilteringMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import CGRect from '../CoreGraphics/CGRect'

//import GKNoiseMap from '../undefined/GKNoiseMap'


/**
 * A representation of an image for use in SpriteKit.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/spritekit/sktexture
 */
var SKTexture = function (_NSObject) {
  _inherits(SKTexture, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SKTexture() {
    _classCallCheck(this, SKTexture);

    // Inspecting a Texture’s Properties

    /**
     * The filtering mode used when the size of a sprite drawn with the texture is not drawn at the texture’s native size.
     * @type {SKTextureFilteringMode}
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1519659-filteringmode
     */
    var _this = _possibleConstructorReturn(this, (SKTexture.__proto__ || Object.getPrototypeOf(SKTexture)).call(this));

    _this.filteringMode = _SKTextureFilteringMode2.default.linear;

    /**
     * A Boolean value that indicates whether the texture attempts to generate mipmaps.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1519960-usesmipmaps
     */
    _this.usesMipmaps = false;

    // Instance Properties

    _this._customPlaygroundQuickLook = null;

    _this._image = null;
    _this._glTexture = null;

    _this._loadingImagePromise = null;
    return _this;
  }

  // Creating New Textures from Images

  /**
   * Create a new texture object from an image file stored in the app bundle.
   * @access public
   * @param {string} name - The name of the image file.
   * @returns {void}
   * @desc The new texture object is initialized with the name of the image file and then control returns immediately to your game. Sprite Kit loads and prepares the texture data when it is needed by your game.When loading the texture data, Sprite Kit searches the app bundle for an image file with the specified filename. If a matching image file cannot be found, Sprite Kit searches for the texture in any texture atlases stored in the app bundle. If the specified image does not exist anywhere in the bundle, Sprite Kit creates a placeholder texture image.
   * @see https://developer.apple.com/documentation/spritekit/sktexture/1520086-init
   */


  _createClass(SKTexture, [{
    key: 'applying',


    /**
     * Creates a new texture by applying a Core Image filter to an existing texture.
     * @access public
     * @param {CIFilter} filter - A Core Image filter that requires a single inputImage parameter and produces an outputImage parameter.
     * @returns {SKTexture} - 
     * @desc The image data is copied before control is returned to your game.
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1520388-applying
     */
    value: function applying(filter) {
      return null;
    }

    /**
     * Returns the texture’s image data as a Quartz 2D image.
     * @access public
     * @returns {CGImage} - 
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1519755-cgimage
     */

  }, {
    key: 'cgImage',
    value: function cgImage() {
      return this._image;
    }

    // Creating Textures from Raw Pixel Data

    /**
     * Creates a new texture from raw pixel data.
     * @access public
     * @param {Data} pixelData - An NSData object that holds the bitmap data. The pixels must be 32 bpp, 8bpc (unsigned integer) RGBA pixel data. The color components should have been already multiplied by the alpha value.
     * @param {CGSize} size - The size of the new texture in points.
     * @returns {void}
     * @desc The image data is copied before control is returned to your game.Creating textures from raw pixel data is useful if you have a CPU based routine for creating imagery. The following code shows how you can use init(data:size:) to create a texture containing random colors and a solid alpha. The bytes array is populated by iterating over the total number of pixels and adding four UInt8 values for the red, green, blue, and alpha channels.let width = 128
    let height = 128
    let bytes = stride(from: 0, to: width * height, by: 1).flatMap {
      _ in
      return [
          UInt8(drand48() * 255), // red
          UInt8(drand48() * 255), // green
          UInt8(drand48() * 255), // blue
          UInt8(255)              // alpha
      ]
    }
    let data = Data(bytes: bytes)
    let texture = SKTexture(data: data,
                          size: CGSize(width: width, height: height))
    let width = 128
    let height = 128
    let bytes = stride(from: 0, to: width * height, by: 1).flatMap {
      _ in
      return [
          UInt8(drand48() * 255), // red
          UInt8(drand48() * 255), // green
          UInt8(drand48() * 255), // blue
          UInt8(255)              // alpha
      ]
    }
    let data = Data(bytes: bytes)
    let texture = SKTexture(data: data,
                          size: CGSize(width: width, height: height))
      * @see https://developer.apple.com/documentation/spritekit/sktexture/1519962-init
     */

  }, {
    key: 'generatingNormalMap',


    // Creating Normal Map Textures

    /**
     * Creates a normal map texture by analyzing the contents of an existing texture.
     * @access public
     * @returns {SKTexture} - 
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1519687-generatingnormalmap
     */
    value: function generatingNormalMap() {
      return null;
    }

    /**
     * Creates a normal map texture by analyzing the contents of an existing texture.
     * @access public
     * @param {number} smoothness - A number between 0.0 and 1.0 indicating how much the texture should be smoothed before the normal map is generated. A value of 0.0 means that the texture is not smoothed at all before being processed.
     * @param {number} contrast - A value used to magnify the effect of the generated normal map. A value of 1.0 indicates no magnification is applied.
     * @returns {SKTexture} - 
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1520441-generatingnormalmap
     */

  }, {
    key: 'generatingNormalMapWithSmoothness',
    value: function generatingNormalMapWithSmoothness(smoothness, contrast) {
      return null;
    }

    // Creating Noise Textures

    /**
     * Creates a new texture whose contents are procedurally generated directional noise data.
     * @access public
     * @param {number} smoothness - A value that indicates how similar neighboring texels will be in the resulting texture. The value should be between 0.0 and 1.0. A value of 1.0 generates a smooth surface.
     * @param {CGSize} size - The size of the new texture in points.
     * @returns {void}
     * @desc The noise texture is tileable with itself. The RGB values stored in the texture can be used as directional (XYZ) data. The alpha values are also randomized and can be used as magnitude data, if desired.The following code creates three sprite nodes with textures generated by init(vectorNoiseWithSmoothness:size:) with smoothness values of 0.0, 0.5 and 1.0.let columWidth = scene.size.width / 3
    for i in 0...2 {
      
      let size = CGSize(width: ceil(columWidth),
                        height: 0.5 * scene.size.height)
      
      let smoothness = CGFloat(i) / 2
      
      let vectorTexture = SKTexture(vectorNoiseWithSmoothness: smoothness,
                                    size: size)
      
      let sprite = SKSpriteNode(texture: vectorTexture, size: size)
      
      sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),
                                y: 
    scene.size.height / 2)
       
      scene.addChild(sprite)
    }
    let columWidth = scene.size.width / 3
    for i in 0...2 {
      
      let size = CGSize(width: ceil(columWidth),
                        height: 0.5 * scene.size.height)
      
      let smoothness = CGFloat(i) / 2
      
      let vectorTexture = SKTexture(vectorNoiseWithSmoothness: smoothness,
                                    size: size)
      
      let sprite = SKSpriteNode(texture: vectorTexture, size: size)
      
      sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),
                                y: 
    scene.size.height / 2)
       
      scene.addChild(sprite)
    }
      * @see https://developer.apple.com/documentation/spritekit/sktexture/1520393-init
     */

  }, {
    key: 'size',


    // Inspecting a Texture’s Properties

    /**
     * The size of the texture.
     * @access public
     * @returns {CGSize} - 
     * @desc If the texture was created using an image file and that image file hasn’t been loaded, calling this method forces the texture data to be loaded from the file.
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1519772-size
     */
    value: function size() {
      if (this._image === null) {
        return new _CGSize2.default(0, 0);
      }
      return new _CGSize2.default(this._image.naturalWidth, this._image.naturalHeight);
    }

    /**
     * A rectangle that defines the portion of the texture used to render its image.
     * @access public
     * @returns {CGRect} - 
     * @desc The default value is a rectangle that covers the entire texture (0,0) - (1,1). You cannot set this value directly; to use only a portion of a texture, use the init(rect:in:) method to create a new texture.
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1519707-texturerect
     */

  }, {
    key: 'textureRect',
    value: function textureRect() {
      return null;
    }

    // Preloading the Texture Data

    /**
     * Load the texture data into memory, calling a completion handler after the task completes.
     * @access public
     * @param {function(): void} completionHandler - A block called after the texture data is loaded.
     * @returns {void}
     * @desc SpriteKit creates a background task to load the texture data from the associated file, then returns control to your game. After the texture data is loaded, your completion handler is called. Typically, you use this method when you want to guarantee that a particular texture is in memory before accessing it.If you need to preload multiple textures at once, use the preload(_:withCompletionHandler:) method instead.
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1520172-preload
     */

  }, {
    key: 'preload',
    value: function preload(completionHandler) {}

    /**
     * Load the texture data of multiple textures into memory.
     * @access public
     * @param {SKTexture[]} textures - An array of SKTexture objects.
     * @param {function(): void} completionHandler - A block called after all of the textures are loaded.
     * @returns {void}
     * @desc SpriteKit creates a background task that loads the texture data for all of the textures in the array, then returns control to your game. Your completion handler is called after all of the textures are loaded.
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1519817-preload
     */

  }, {
    key: '_loadImage',
    value: function _loadImage(path) {
      var _this2 = this;

      var image = new Image();
      this._loadingImagePromise = new Promise(function (resolve, reject) {
        if (path.indexOf('file:///') === 0) {
          var paths = path.slice(8).split('/');
          var pathCount = 1;
          var _path = paths.slice(-pathCount).join('/');
          image.onload = function () {
            console.info('image ' + _path + ' onload');
            _this2._image = image;
            resolve(_this2);
          };
          image.onerror = function () {
            pathCount += 1;
            if (pathCount > paths.length) {
              console.error('image ' + path + ' load error.');
              reject(_this2);
            } else {
              // retry
              console.info('image ' + _path + ' load error.');
              _path = paths.slice(-pathCount).join('/');
              console.info('try ' + _path);
              image.src = _path;
            }
          };
        } else {
          image.onload = function () {
            _this2._image = image;
            resolve(_this2);
          };
          image.onerror = function () {
            console.info('image ' + path + ' load error.');
            reject(_this2);
          };
          image.src = path;
        }
      });
    }
  }, {
    key: '_createTexture',
    value: function _createTexture(gl) {
      if (this._image === null) {
        return;
      }
      var texture = gl.createTexture();

      var canvas = document.createElement('canvas');
      canvas.width = this._image.naturalWidth;
      canvas.height = this._image.naturalHeight;
      canvas.getContext('2d').drawImage(this._image, 0, 0);

      gl.bindTexture(gl.TEXTURE_2D, texture
      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
      // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
      );gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._image.width, this._image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.bindTexture(gl.TEXTURE_2D, null);

      this._glTexture = texture;
    }
  }, {
    key: 'customPlaygroundQuickLook',


    // Instance Properties
    /**
     * 
     * @type {PlaygroundQuickLook}
     * @desc 
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1645801-customplaygroundquicklook
     */
    get: function get() {
      return this._customPlaygroundQuickLook;
    }
  }], [{
    key: 'textureWithImageNamed',
    value: function textureWithImageNamed(name) {
      var texture = new SKTexture();
      texture._loadImage(name);
      return texture;
    }

    /**
     * Create a new texture object from an image object.
     * @access public
     * @param {Image} image - An image.
     * @returns {void}
     * @desc The image data is copied before control is returned to your game.
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1520136-init
     */

  }, {
    key: 'textureWithImage',
    value: function textureWithImage(image) {
      var texture = new SKTexture();
      texture._image = image;
      this._loadingImagePromise = Promise.resolve(this);
      return texture;
    }

    /**
     * Create a new texture object from a Quartz 2D image.
     * @access public
     * @param {CGImage} image - A Quartz 2D image (CGImage) object. For more information, see Quartz 2D Programming Guide and CGImage.
     * @returns {void}
     * @desc The image data is copied before control is returned to your game.
     * @see https://developer.apple.com/documentation/spritekit/sktexture/1519576-init
     */

  }, {
    key: 'textureWithCgImage',
    value: function textureWithCgImage(image) {
      var texture = new SKTexture();
      texture._image = image;
      this._loadingImagePromise = Promise.resolve(this);
      return texture;
    }

    /**
     * Creates a new texture from a subset of an existing texture.
     * @access public
     * @param {CGRect} rect - A rectangle in the unit coordinate space that specifies the portion of the texture to use.
     * @param {SKTexture} texture - The texture to create the new texture from.
     * @returns {void}
     * @desc The returned texture object shares the same texture data as the original texture object, meaning that only one copy of the texture data is kept in memory.If you call this method on a texture that itself was created using this method, the original texture is used as the source instead. That is, the rectangle is considered to be in the source texture’s coordinate system. To do this, you should use the source texture's textureRect() rather than relying on hard coded {(0,0) (1,1)} as the coordinates.  Listing 1 shows how you can use the source texture's textureRect() to calculate the portion of the texture to use.Listing 1 Creating a texture from a portion of another texture.let originalTexture = SKTexture(imageNamed: "sourceImage.png")
    let rect = CGRect(origin: originalTexture.textureRect().origin,
                    size: CGSize(width: originalTexture.textureRect().midX,
                                 height: originalTexture.textureRect().midY))
    let croppedTexture = SKTexture(rect: rect,
                                 in: originalTexture)
    In the above example, if originalTexture had a size of (348.0, 282.0) and a textureRect() of {(0,0) (1,1)}, croppedTexture will have a size of (174.0, 141.0) and a textureRect() of {(0,0) (1,1)}. croppedTexture will be a copy of the bottom left quadrant of originalTexture.Creating a texture from a portion of another texture.let originalTexture = SKTexture(imageNamed: "sourceImage.png")
    let rect = CGRect(origin: originalTexture.textureRect().origin,
                    size: CGSize(width: originalTexture.textureRect().midX,
                                 height: originalTexture.textureRect().midY))
    let croppedTexture = SKTexture(rect: rect,
                                 in: originalTexture)
      * @see https://developer.apple.com/documentation/spritekit/sktexture/1520425-init
     */

  }, {
    key: 'textureWithRectIn',
    value: function textureWithRectIn(rect, texture) {
      var texutre = new SKTexture();
      return texture;
    }
  }, {
    key: 'textureWithDataSize',
    value: function textureWithDataSize(pixelData, size) {}
  }, {
    key: 'textureWithVectorNoiseWithSmoothness',
    value: function textureWithVectorNoiseWithSmoothness(smoothness, size) {}

    /**
     * Creates a new texture whose contents are procedurally generated colored noise data.
     * @access public
     * @param {number} smoothness - A value that indicates how similar neighboring texels will be in the resulting texture. The value should be between 0.0 and 1.0. A value of 1.0 generates a smooth surface.
     * @param {CGSize} size - The size of the new texture in points.
     * @param {boolean} grayscale - If true, all four components of each texel will have equal values. If false, all four values are completely randomized.
     * @returns {void}
     * @desc Unlike other textures produced by SpriteKit, the texels are not premultiplied by the alpha value. Your custom shaders should compensate for this as necessary.The following code creates three sprite nodes with textures generated by init(noiseWithSmoothness:size:grayscale:) with smoothness values of 0.0, 0.5 and 1.0.let columWidth = scene.size.width / 3
    for i in 0...2 {
      
      let size = CGSize(width: ceil(columWidth),
                        height: 0.5 * scene.size.height)
      
      let smoothness = CGFloat(i) / 2
      
      let noiseTexture = SKTexture(noiseWithSmoothness: smoothness,
                                    size: size,
                                    grayscale: false)
      
      let sprite = SKSpriteNode(texture: noiseTexture, size: size)
      
      sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),
                                y: scene.size.height / 2)
      
      scene.addChild(sprite)
    }
    let columWidth = scene.size.width / 3
    for i in 0...2 {
      
      let size = CGSize(width: ceil(columWidth),
                        height: 0.5 * scene.size.height)
      
      let smoothness = CGFloat(i) / 2
      
      let noiseTexture = SKTexture(noiseWithSmoothness: smoothness,
                                    size: size,
                                    grayscale: false)
      
      let sprite = SKSpriteNode(texture: noiseTexture, size: size)
      
      sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),
                                y: scene.size.height / 2)
      
      scene.addChild(sprite)
    }
      * @see https://developer.apple.com/documentation/spritekit/sktexture/1519971-init
     */

  }, {
    key: 'textureWithNoiseWithSmoothness',
    value: function textureWithNoiseWithSmoothness(smoothness, size, grayscale) {}
  }, {
    key: 'preloadWithCompletionHandler',
    value: function preloadWithCompletionHandler(textures, completionHandler) {}
  }]);

  return SKTexture;
}(_NSObject3.default);

exports.default = SKTexture;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AVAudioNode2 = __webpack_require__(57);

var _AVAudioNode3 = _interopRequireDefault(_AVAudioNode2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AVAudioMixerNode = function (_AVAudioNode) {
  _inherits(AVAudioMixerNode, _AVAudioNode);

  function AVAudioMixerNode() {
    _classCallCheck(this, AVAudioMixerNode);

    var _this = _possibleConstructorReturn(this, (AVAudioMixerNode.__proto__ || Object.getPrototypeOf(AVAudioMixerNode)).call(this));

    _this._gainNode = null;
    return _this;
  }

  _createClass(AVAudioMixerNode, [{
    key: 'volume',
    get: function get() {
      return this._gainNode.gain.value;
    },
    set: function set(newValue) {
      this._gainNode.gain.value = newValue;
    }
  }]);

  return AVAudioMixerNode;
}(_AVAudioNode3.default);

exports.default = AVAudioMixerNode;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import AVAudioFormat from './AVAudioFormat'
//import AVAudioNodeBus from './AVAudioNodeBus'
//import AVAudioFrameCount from './AVAudioFrameCount'
//import AVAudioNodeTapBlock from './AVAudioNodeTapBlock'
//import AVAudioTime from './AVAudioTime'
//import AUAudioUnit from './AUAudioUnit'

/**
 * The AVAudioNode class is an abstract class for an audio generation, processing, or I/O block.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/avfoundation/avaudionode
 */
var AVAudioNode = function (_NSObject) {
  _inherits(AVAudioNode, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function AVAudioNode() {
    _classCallCheck(this, AVAudioNode);

    // Configuring an Input Format Bus

    var _this = _possibleConstructorReturn(this, (AVAudioNode.__proto__ || Object.getPrototypeOf(AVAudioNode)).call(this));

    _this._numberOfInputs = 0;

    // Creating and Output Format Bus

    _this._numberOfOutputs = 0;

    // Getting the Audio Engine for the Node

    _this._engine = null;

    // Getting the Latest Node Render Time

    _this._lastRenderTime = null;

    // Instance Properties

    _this._auAudioUnit = null;
    _this._latency = 0;
    _this._outputPresentationLatency = 0;
    return _this;
  }

  // Configuring an Input Format Bus

  /**
   * Returns the input format for the specified bus.
   * @access public
   * @param {AVAudioNodeBus} bus - The bus.
   * @returns {AVAudioFormat} - 
   * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1390147-inputformat
   */


  _createClass(AVAudioNode, [{
    key: 'inputFormatForBus',
    value: function inputFormatForBus(bus) {
      return null;
    }

    /**
     * The name of an input bus.
     * @access public
     * @param {AVAudioNodeBus} bus - The input bus.
     * @returns {?string} - 
     * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1387710-name
     */

  }, {
    key: 'nameForInputBus',
    value: function nameForInputBus(bus) {
      return null;
    }
    /**
     * The number of input busses for the node.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1390585-numberofinputs
     */

  }, {
    key: 'outputFormatForBus',


    // Creating and Output Format Bus

    /**
     * Returns the output format for the specified bus.
     * @access public
     * @param {AVAudioNodeBus} bus - The bus.
     * @returns {AVAudioFormat} - 
     * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1389195-outputformat
     */
    value: function outputFormatForBus(bus) {
      return null;
    }

    /**
     * The name of the output bus.
     * @access public
     * @param {AVAudioNodeBus} bus - The output bus.
     * @returns {?string} - 
     * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1390811-name
     */

  }, {
    key: 'nameForOutputBus',
    value: function nameForOutputBus(bus) {
      return null;
    }
    /**
     * The number of output busses for the node.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1385916-numberofoutputs
     */

  }, {
    key: 'installTapOnBusBlock',


    // Installing and Removing An Audio Tap

    /**
     * Installs an audio tap on the bus to record. monitor, and observe the output of the node
     * @access public
     * @param {AVAudioNodeBus} bus - The node output bus to which to attach the tap.
     * @param {AVAudioFrameCount} bufferSize - The requested size of the incoming buffers. The implementation may choose another size.
     * @param {?AVAudioFormat} format - If non-nil, attempts to apply this as the format of the specified output bus.This should only be done when attaching to an output bus which is not connected to another node; an error will result otherwise. The tap and connection formats (if non-nil) on the specified bus should be identical. Otherwise, the latter operation will override any previously set format.For AVAudioOutputNode, tap format must be specified as nil.
     * @param {AVAudioNodeTapBlock} tapBlock - A block to be called with audio buffers. See AVAudioNodeTapBlock for the block parameters.
     * @returns {void}
     * @desc Only one tap may be installed on any bus. Taps may be safely installed and removed while the engine is running.AVAudioEngine *engine = [[AVAudioEngine alloc] init];
    AVAudioInputNode *input = [engine inputNode];
    AVAudioFormat *format = [input outputFormatForBus: 0];
    [input installTapOnBus: 0 bufferSize: 8192 format: format block: ^(AVAudioPCMBuffer *buf, AVAudioTime *when) {
    // ‘buf' contains audio captured from input node at time 'when'
    }];
    ....
    // start engine
    ImportantThe tapBlock may be invoked on a thread other than the main thread.AVAudioEngine *engine = [[AVAudioEngine alloc] init];
    AVAudioInputNode *input = [engine inputNode];
    AVAudioFormat *format = [input outputFormatForBus: 0];
    [input installTapOnBus: 0 bufferSize: 8192 format: format block: ^(AVAudioPCMBuffer *buf, AVAudioTime *when) {
    // ‘buf' contains audio captured from input node at time 'when'
    }];
    ....
    // start engine
      * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1387122-installtap
     */
    value: function installTapOnBusBlock(bus, bufferSize, format, tapBlock) {}

    /**
     * Removes an audio tap on a bus.
     * @access public
     * @param {AVAudioNodeBus} bus - The node output bus whose tap is to be removed.
     * @returns {void}
     * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1388717-removetap
     */

  }, {
    key: 'removeTapOnBus',
    value: function removeTapOnBus(bus) {}

    // Getting the Audio Engine for the Node
    /**
     * The audio engine of the node.
     * @type {?AVAudioEngine}
     * @desc Returns nil if the node is not attached to an audio engine.
     * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1386896-engine
     */

  }, {
    key: 'reset',


    // Reset the Audio Node

    /**
     * Clear a unit's previous processing state.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1385976-reset
     */
    value: function reset() {}

    // Instance Properties
    /**
     * 
     * @type {AUAudioUnit}
     * @desc 
     * @see https://developer.apple.com/documentation/avfoundation/avaudionode/2866396-auaudiounit
     */

  }, {
    key: 'numberOfInputs',
    get: function get() {
      return this._numberOfInputs;
    }
  }, {
    key: 'numberOfOutputs',
    get: function get() {
      return this._numberOfOutputs;
    }
  }, {
    key: 'engine',
    get: function get() {
      return this._engine;
    }

    // Getting the Latest Node Render Time
    /**
     * The time for which the node most recently rendered.
     * @type {?AVAudioTime}
     * @desc Return nil if the engine is not running or if the node is not connected to an input or output node.
     * @see https://developer.apple.com/documentation/avfoundation/avaudionode/1385978-lastrendertime
     */

  }, {
    key: 'lastRenderTime',
    get: function get() {
      return this._lastRenderTime;
    }
  }, {
    key: 'auAudioUnit',
    get: function get() {
      return this._auAudioUnit;
    }
    /**
     * 
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/avfoundation/avaudionode/2875482-latency
     */

  }, {
    key: 'latency',
    get: function get() {
      return this._latency;
    }
    /**
     * 
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/avfoundation/avaudionode/2875483-outputpresentationlatency
     */

  }, {
    key: 'outputPresentationLatency',
    get: function get() {
      return this._outputPresentationLatency;
    }
  }]);

  return AVAudioNode;
}(_NSObject3.default);

exports.default = AVAudioNode;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Styles for rendering the endpoint of a stroked line.
 * @typedef {Object} CGLineCap
 * @property {number} butt - A line with a squared-off end. Core Graphics draws the line to extend only to the exact endpoint of the path. This is the default.
 * @property {number} round - A line with a rounded end. Core Graphics draws the line to extend beyond the endpoint of the path. The line ends with a semicircular arc with a radius of 1/2 the line’s width, centered on the endpoint.
 * @property {number} square - A line with a squared-off end. Core Graphics extends the line beyond the endpoint of the path for a distance equal to half the line width.
 * @see https://developer.apple.com/documentation/coregraphics/cglinecap
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CGLineCap = {
  butt: 0,
  round: 1,
  square: 2
};

exports.default = CGLineCap;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Junction types for stroked lines.
 * @typedef {Object} CGLineJoin
 * @property {number} miter - 
 * @property {number} round - A join with a rounded end. Core Graphics draws the line to extend beyond the endpoint of the path. The line ends with a semicircular arc with a radius of 1/2 the line’s width, centered on the endpoint.
 * @property {number} bevel - A join with a squared-off end. Core Graphics draws the line to extend beyond the endpoint of the path, for a distance of 1/2 the line’s width.
 * @see https://developer.apple.com/documentation/coregraphics/cglinejoin
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CGLineJoin = {
  miter: 0,
  round: 1,
  bevel: 2
};

exports.default = CGLineJoin;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A structure that contains a two-dimensional vector.
 * @access public
 * @see https://developer.apple.com/documentation/coregraphics/cgvector
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CGVector = function () {

  // Initializers

  /**
   * Creates a vector with components specified as integer values.
   * @access public
   * @constructor
   * @param {number} dx - 
   * @param {number} dy - 
   * @see https://developer.apple.com/documentation/coregraphics/cgvector/1456249-init
   */
  function CGVector() {
    var dx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var dy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, CGVector);

    // Geometric Properties
    this._dx = dx;
    this._dy = dy;
  }

  // Special Values

  /**
   * The vector whose components are both zero.
   * @type {CGVector}
   * @desc 
   * @see https://developer.apple.com/documentation/coregraphics/cgvector/1454067-zero
   */


  _createClass(CGVector, [{
    key: 'zero',
    get: function get() {
      return new CGVector();
    }
  }]);

  return CGVector;
}();

exports.default = CGVector;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * DispatchObject is the base class for many dispatch types, including DispatchQueue, DispatchGroup, and DispatchSource. 
 * @access public
 * @see https://developer.apple.com/documentation/dispatch/dispatchobject
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DispatchObject = function () {

  /**
   * constructor
   * @access public
   * @constructor
   */
  function DispatchObject() {
    _classCallCheck(this, DispatchObject);
  }
  // nothing to do


  // Instance Methods

  /**
   * Activates the dispatch object.
   * @access public
   * @returns {void}
   * @desc Once a dispatch object has been activated, it cannot change its target queue.
   * @see https://developer.apple.com/documentation/dispatch/dispatchobject/1641002-activate
   */


  _createClass(DispatchObject, [{
    key: 'activate',
    value: function activate() {}

    /**
     * Resume the invocation of block objects on a dispatch object.
     * @access public
     * @returns {void}
     * @desc Calling this function decrements the suspension count of a suspended dispatch queue or dispatch event source object. While the count is greater than zero, the object remains suspended. When the suspension count returns to zero, any blocks submitted to the dispatch queue or any events observed by the dispatch source while suspended are delivered.With one exception, each call to resume() must balance a call to suspend(). New dispatch event source objects returned by dispatch_source_create(_:_:_:_:) have a suspension count of 1 and must be resumed before any events are delivered. This approach allows your application to fully configure the dispatch event source object prior to delivery of the first event. In all other cases, it is undefined to call resume() more times than suspend(), which would result in a negative suspension count.
     * @see https://developer.apple.com/documentation/dispatch/dispatchobject/1452929-resume
     */

  }, {
    key: 'resume',
    value: function resume() {}

    /**
     * Sets the target queue for the given object.
     * @access public
     * @param {?DispatchQueue} queue - The new target queue for the object. The queue is retained, and the previous one, if any, is released. This parameter cannot be NULL.
     * @returns {void}
     * @desc An object's target queue is responsible for processing the object. The target queue determines the queue on which the object's finalizer is invoked. In addition, modifying the target queue of some objects changes their behavior:Dispatch queues:A dispatch queue's priority is inherited from its target queue. Use the dispatch_get_global_queue(_:_:) function to obtain a suitable target queue of the desired priority.If you submit a block to a serial queue, and the serial queue’s target queue is a different serial queue, that block is not invoked concurrently with blocks submitted to the target queue or to any other queue with that same target queue.ImportantIf you modify the target queue for a queue, you must be careful to avoid creating cycles in the queue hierarchy.Dispatch sources:A dispatch source's target queue specifies where its event handler and cancellation handler blocks are submitted.Dispatch I/O channels:A dispatch I/O channel's target queue specifies where its I/O operations are executed. This may affect the priority of the resulting I/O operations. For example, if the channel's target queue's priority is set to DISPATCH_QUEUE_PRIORITY_BACKGROUND, then any I/O operations performed by read(offset:length:queue:ioHandler:) or write(offset:data:queue:ioHandler:) on that queue are throttled when there is I/O contention.
     * @see https://developer.apple.com/documentation/dispatch/dispatchobject/1452989-settarget
     */

  }, {
    key: 'setTarget',
    value: function setTarget(queue) {}

    /**
     * Suspends the invocation of block objects on a dispatch object.
     * @access public
     * @returns {void}
     * @desc By suspending a dispatch object, your application can temporarily prevent the execution of any blocks associated with that object. The suspension occurs after completion of any blocks running at the time of the call. Calling this function increments the suspension count of the object, and calling resume() decrements it. While the count is greater than zero, the object remains suspended, so you must balance each suspend() call with a matching resume() call.Any blocks submitted to a dispatch queue or events observed by a dispatch source are delivered once the object is resumed. 
     * @see https://developer.apple.com/documentation/dispatch/dispatchobject/1452801-suspend
     */

  }, {
    key: 'suspend',
    value: function suspend() {}
  }]);

  return DispatchObject;
}();

exports.default = DispatchObject;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Name = {
  AVAudioEngineConfigurationChange: Symbol(),
  AVAudioSessionInterruption: Symbol(),
  AVAudioSessionMediaServicesWereLost: Symbol(),
  AVAudioSessionMediaServicesWereReset: Symbol(),
  AVAudioSessionRouteChange: Symbol(),
  AVAudioSessionSilenceSecondaryAudioHint: Symbol(),
  AVAudioUnitComponentTagsDidChange: Symbol(),
  CKAccountChanged: Symbol(),
  CLKComplicationServerActiveComplicationsDidChange: Symbol(),
  CNContactStoreDidChange: Symbol(),
  EKEventStoreChanged: Symbol(),
  HKUserPreferencesDidChange: Symbol(),
  HMCharacteristicPropertySupportsEvent: Symbol(),
  NSBundleResourceRequestLowDiskSpace: Symbol(),
  NSCalendarDayChanged: Symbol(),
  NSDidBecomeSingleThreaded: Symbol(),
  NSExtensionHostDidBecomeActive: Symbol(),
  NSExtensionHostDidEnterBackground: Symbol(),
  NSExtensionHostWillEnterForeground: Symbol(),
  NSExtensionHostWillResignActive: Symbol(),
  NSFileHandleConnectionAccepted: Symbol(),
  NSFileHandleDataAvailable: Symbol(),
  NSFileHandleReadToEndOfFileCompletion: Symbol(),
  NSHTTPCookieManagerAcceptPolicyChanged: Symbol(),
  NSHTTPCookieManagerCookiesChanged: Symbol(),
  NSManagedObjectContextDidSave: Symbol(),
  NSManagedObjectContextObjectsDidChange: Symbol(),
  NSManagedObjectContextWillSave: Symbol(),
  NSMetadataQueryDidFinishGathering: Symbol(),
  NSMetadataQueryDidStartGathering: Symbol(),
  NSMetadataQueryDidUpdate: Symbol(),
  NSMetadataQueryGatheringProgress: Symbol(),
  NSPersistentStoreCoordinatorStoresDidChange: Symbol(),
  NSPersistentStoreCoordinatorStoresWillChange: Symbol(),
  NSPersistentStoreCoordinatorWillRemoveStore: Symbol(),
  NSProcessInfoPowerStateDidChange: Symbol(),
  NSSystemClockDidChange: Symbol(),
  NSSystemTimeZoneDidChange: Symbol(),
  NSThreadWillExit: Symbol(),
  NSURLCredentialStorageChanged: Symbol(),
  NSUbiquityIdentityDidChange: Symbol(),
  NSUndoManagerCheckpoint: Symbol(),
  NSUndoManagerDidCloseUndoGroup: Symbol(),
  NSUndoManagerDidOpenUndoGroup: Symbol(),
  NSUndoManagerDidRedoChange: Symbol(),
  NSUndoManagerDidUndoChange: Symbol(),
  NSUndoManagerWillCloseUndoGroup: Symbol(),
  NSUndoManagerWillRedoChange: Symbol(),
  NSUndoManagerWillUndoChange: Symbol(),
  NSWillBecomeMultiThreaded: Symbol(),
  PKPassLibraryDidChange: Symbol(),
  PKPassLibraryRemotePaymentPassesDidChange: Symbol(),
  UIAccessibilityAnnouncementDidFinish: Symbol(),
  UIAccessibilityElementFocused: Symbol(),
  WKAudioFilePlayerItemDidPlayToEndTime: Symbol(),
  WKAudioFilePlayerItemFailedToPlayToEndTime: Symbol(),
  WKAudioFilePlayerItemTimeJumped: Symbol(),
  ABPeoplePickerDisplayedPropertyDidChange: Symbol(),
  ABPeoplePickerGroupSelectionDidChange: Symbol(),
  ABPeoplePickerNameSelectionDidChange: Symbol(),
  ABPeoplePickerValueSelectionDidChange: Symbol(),
  ACAccountStoreDidChange: Symbol(),
  AVAssetChapterMetadataGroupsDidChange: Symbol(),
  AVAssetContainsFragmentsDidChange: Symbol(),
  AVAssetDurationDidChange: Symbol(),
  AVAssetMediaSelectionGroupsDidChange: Symbol(),
  AVAssetTrackSegmentsDidChange: Symbol(),
  AVAssetTrackTimeRangeDidChange: Symbol(),
  AVAssetTrackTrackAssociationsDidChange: Symbol(),
  AVAssetWasDefragmented: Symbol(),
  AVCaptureDeviceWasConnected: Symbol(),
  AVCaptureDeviceWasDisconnected: Symbol(),
  AVCaptureInputPortFormatDescriptionDidChange: Symbol(),
  AVCaptureSessionDidStartRunning: Symbol(),
  AVCaptureSessionDidStopRunning: Symbol(),
  AVCaptureSessionRuntimeError: Symbol(),
  AVFragmentedMovieContainsMovieFragmentsDidChange: Symbol(),
  AVFragmentedMovieDurationDidChange: Symbol(),
  AVFragmentedMovieTrackSegmentsDidChange: Symbol(),
  AVFragmentedMovieTrackTimeRangeDidChange: Symbol(),
  AVFragmentedMovieTrackTotalSampleDataLengthDidChange: Symbol(),
  AVFragmentedMovieWasDefragmented: Symbol(),
  AVPlayerItemDidPlayToEndTime: Symbol(),
  AVPlayerItemFailedToPlayToEndTime: Symbol(),
  AVPlayerItemNewAccessLogEntry: Symbol(),
  AVPlayerItemNewErrorLogEntry: Symbol(),
  AVPlayerItemPlaybackStalled: Symbol(),
  AVPlayerItemTimeJumped: Symbol(),
  AVSampleBufferDisplayLayerFailedToDecode: Symbol(),
  CWBSSIDDidChange: Symbol(),
  CWCountryCodeDidChange: Symbol(),
  CWLinkDidChange: Symbol(),
  CWLinkQualityDidChange: Symbol(),
  CWModeDidChange: Symbol(),
  CWPowerDidChange: Symbol(),
  CWSSIDDidChange: Symbol(),
  CWScanCacheDidUpdate: Symbol(),
  GCControllerDidConnect: Symbol(),
  GCControllerDidDisconnect: Symbol(),
  IKFilterBrowserFilterDoubleClick: Symbol(),
  IKFilterBrowserFilterSelected: Symbol(),
  IKFilterBrowserWillPreviewFilter: Symbol(),
  IOBluetoothHostControllerPoweredOff: Symbol(),
  IOBluetoothHostControllerPoweredOn: Symbol(),
  IOBluetoothL2CAPChannelPublished: Symbol(),
  IOBluetoothL2CAPChannelTerminated: Symbol(),
  MKAnnotationCalloutInfoDidChange: Symbol(),
  NEFilterConfigurationDidChange: Symbol(),
  NEVPNConfigurationChange: Symbol(),
  NEVPNStatusDidChange: Symbol(),
  announcementRequested: Symbol(),
  applicationActivated: Symbol(),
  applicationDeactivated: Symbol(),
  applicationHidden: Symbol(),
  applicationShown: Symbol(),
  created: Symbol(),
  drawerCreated: Symbol(),
  focusedUIElementChanged: Symbol(),
  focusedWindowChanged: Symbol(),
  helpTagCreated: Symbol(),
  layoutChanged: Symbol(),
  mainWindowChanged: Symbol(),
  moved: Symbol(),
  resized: Symbol(),
  rowCollapsed: Symbol(),
  rowCountChanged: Symbol(),
  rowExpanded: Symbol(),
  selectedCellsChanged: Symbol(),
  selectedChildrenChanged: Symbol(),
  selectedChildrenMoved: Symbol(),
  selectedColumnsChanged: Symbol(),
  selectedRowsChanged: Symbol(),
  selectedTextChanged: Symbol(),
  sheetCreated: Symbol(),
  titleChanged: Symbol(),
  uiElementDestroyed: Symbol(),
  unitsChanged: Symbol(),
  valueChanged: Symbol(),
  windowCreated: Symbol(),
  windowDeminiaturized: Symbol(),
  windowMiniaturized: Symbol(),
  windowMoved: Symbol(),
  windowResized: Symbol(),
  progressMarkNotification: Symbol(),
  antialiasThresholdChangedNotification: Symbol(),
  NSAppleEventManagerWillProcessFirstEvent: Symbol(),
  didBecomeActiveNotification: Symbol(),
  didChangeOcclusionStateNotification: Symbol(),
  didChangeScreenParametersNotification: Symbol(),
  didFinishLaunchingNotification: Symbol(),
  didFinishRestoringWindowsNotification: Symbol(),
  didHideNotification: Symbol(),
  didResignActiveNotification: Symbol(),
  didUnhideNotification: Symbol(),
  didUpdateNotification: Symbol(),
  willBecomeActiveNotification: Symbol(),
  willFinishLaunchingNotification: Symbol(),
  willHideNotification: Symbol(),
  willResignActiveNotification: Symbol(),
  willTerminateNotification: Symbol(),
  willUnhideNotification: Symbol(),
  willUpdateNotification: Symbol(),
  columnConfigurationDidChangeNotification: Symbol(),
  NSClassDescriptionNeededForClass: Symbol(),
  didChangeNotification: Symbol(),
  colorDidChangeNotification: Symbol(),
  selectionDidChangeNotification: Symbol(),
  selectionIsChangingNotification: Symbol(),
  willDismissNotification: Symbol(),
  willPopUpNotification: Symbol(),
  contextHelpModeDidActivateNotification: Symbol(),
  contextHelpModeDidDeactivateNotification: Symbol(),
  textDidBeginEditingNotification: Symbol(),
  textDidChangeNotification: Symbol(),
  textDidEndEditingNotification: Symbol(),
  currentControlTintDidChangeNotification: Symbol(),
  didCloseNotification: Symbol(),
  didOpenNotification: Symbol(),
  willCloseNotification: Symbol(),
  willOpenNotification: Symbol(),
  fontSetChangedNotification: Symbol(),
  registryDidChangeNotification: Symbol(),
  didAddItemNotification: Symbol(),
  didBeginTrackingNotification: Symbol(),
  didChangeItemNotification: Symbol(),
  didEndTrackingNotification: Symbol(),
  didRemoveItemNotification: Symbol(),
  didSendActionNotification: Symbol(),
  willSendActionNotification: Symbol(),
  columnDidMoveNotification: Symbol(),
  columnDidResizeNotification: Symbol(),
  itemDidCollapseNotification: Symbol(),
  itemDidExpandNotification: Symbol(),
  itemWillCollapseNotification: Symbol(),
  itemWillExpandNotification: Symbol(),
  NSPersistentStoreDidImportUbiquitousContentChanges: Symbol(),
  didShowNotification: Symbol(),
  willShowNotification: Symbol(),
  preferredScrollerStyleDidChangeNotification: Symbol(),
  rowsDidChangeNotification: Symbol(),
  colorSpaceDidChangeNotification: Symbol(),
  didEndLiveMagnifyNotification: Symbol(),
  didEndLiveScrollNotification: Symbol(),
  didLiveScrollNotification: Symbol(),
  willStartLiveMagnifyNotification: Symbol(),
  willStartLiveScrollNotification: Symbol(),
  didChangeAutomaticCapitalizationNotification: Symbol(),
  didChangeAutomaticDashSubstitutionNotification: Symbol(),
  didChangeAutomaticPeriodSubstitutionNotification: Symbol(),
  didChangeAutomaticQuoteSubstitutionNotification: Symbol(),
  didChangeAutomaticSpellingCorrectionNotification: Symbol(),
  didChangeAutomaticTextReplacementNotification: Symbol(),
  didResizeSubviewsNotification: Symbol(),
  willResizeSubviewsNotification: Symbol(),
  systemColorsDidChangeNotification: Symbol(),
  selectedAlternativeStringNotification: Symbol(),
  didBeginEditingNotification: Symbol(),
  didEndEditingNotification: Symbol(),
  keyboardSelectionDidChangeNotification: Symbol(),
  NSTextStorageDidProcessEditing: Symbol(),
  NSTextStorageWillProcessEditing: Symbol(),
  didChangeSelectionNotification: Symbol(),
  didChangeTypingAttributesNotification: Symbol(),
  willChangeNotifyingTextViewNotification: Symbol(),
  willAddItemNotification: Symbol(),
  boundsDidChangeNotification: Symbol(),
  didUpdateTrackingAreasNotification: Symbol(),
  frameDidChangeNotification: Symbol(),
  globalFrameDidChangeNotification: Symbol(),
  didBecomeKeyNotification: Symbol(),
  didBecomeMainNotification: Symbol(),
  didChangeBackingPropertiesNotification: Symbol(),
  didChangeScreenNotification: Symbol(),
  didChangeScreenProfileNotification: Symbol(),
  didDeminiaturizeNotification: Symbol(),
  didEndLiveResizeNotification: Symbol(),
  didEndSheetNotification: Symbol(),
  didEnterFullScreenNotification: Symbol(),
  didEnterVersionBrowserNotification: Symbol(),
  didExitFullScreenNotification: Symbol(),
  didExitVersionBrowserNotification: Symbol(),
  didExposeNotification: Symbol(),
  didMiniaturizeNotification: Symbol(),
  didMoveNotification: Symbol(),
  didResignKeyNotification: Symbol(),
  didResignMainNotification: Symbol(),
  didResizeNotification: Symbol(),
  willBeginSheetNotification: Symbol(),
  willEnterFullScreenNotification: Symbol(),
  willEnterVersionBrowserNotification: Symbol(),
  willExitFullScreenNotification: Symbol(),
  willExitVersionBrowserNotification: Symbol(),
  willMiniaturizeNotification: Symbol(),
  willMoveNotification: Symbol(),
  willStartLiveResizeNotification: Symbol(),
  accessibilityDisplayOptionsDidChangeNotification: Symbol(),
  activeSpaceDidChangeNotification: Symbol(),
  didActivateApplicationNotification: Symbol(),
  didChangeFileLabelsNotification: Symbol(),
  didDeactivateApplicationNotification: Symbol(),
  didHideApplicationNotification: Symbol(),
  didLaunchApplicationNotification: Symbol(),
  didMountNotification: Symbol(),
  didPerformFileOperationNotification: Symbol(),
  didRenameVolumeNotification: Symbol(),
  didTerminateApplicationNotification: Symbol(),
  didUnhideApplicationNotification: Symbol(),
  didUnmountNotification: Symbol(),
  didWakeNotification: Symbol(),
  screensDidSleepNotification: Symbol(),
  screensDidWakeNotification: Symbol(),
  sessionDidBecomeActiveNotification: Symbol(),
  sessionDidResignActiveNotification: Symbol(),
  willLaunchApplicationNotification: Symbol(),
  willPowerOffNotification: Symbol(),
  willSleepNotification: Symbol(),
  willUnmountNotification: Symbol(),
  PDFDocumentDidBeginFind: Symbol(),
  PDFDocumentDidBeginPageFind: Symbol(),
  PDFDocumentDidBeginPageWrite: Symbol(),
  PDFDocumentDidBeginWrite: Symbol(),
  PDFDocumentDidEndFind: Symbol(),
  PDFDocumentDidEndPageFind: Symbol(),
  PDFDocumentDidEndPageWrite: Symbol(),
  PDFDocumentDidEndWrite: Symbol(),
  PDFDocumentDidFindMatch: Symbol(),
  PDFDocumentDidUnlock: Symbol(),
  PDFThumbnailViewDocumentEdited: Symbol(),
  PDFViewAnnotationHit: Symbol(),
  PDFViewAnnotationWillHit: Symbol(),
  PDFViewChangedHistory: Symbol(),
  PDFViewCopyPermission: Symbol(),
  PDFViewDisplayBoxChanged: Symbol(),
  PDFViewDisplayModeChanged: Symbol(),
  PDFViewDocumentChanged: Symbol(),
  PDFViewPageChanged: Symbol(),
  PDFViewPrintPermission: Symbol(),
  PDFViewScaleChanged: Symbol(),
  PDFViewSelectionChanged: Symbol(),
  PDFViewVisiblePagesChanged: Symbol(),
  QCCompositionPickerPanelDidSelectComposition: Symbol(),
  QCCompositionPickerViewDidSelectComposition: Symbol(),
  QCCompositionRepositoryDidUpdate: Symbol(),
  QCViewDidStartRendering: Symbol(),
  QCViewDidStopRendering: Symbol(),
  WebHistoryAllItemsRemoved: Symbol(),
  WebHistoryItemChanged: Symbol(),
  WebHistoryItemsAdded: Symbol(),
  WebHistoryItemsRemoved: Symbol(),
  WebHistoryLoaded: Symbol(),
  WebHistorySaved: Symbol(),
  WebPreferencesChanged: Symbol(),
  WebViewDidBeginEditing: Symbol(),
  WebViewDidChange: Symbol(),
  WebViewDidChangeSelection: Symbol(),
  WebViewDidChangeTypingStyle: Symbol(),
  WebViewDidEndEditing: Symbol(),
  WebViewProgressEstimateChanged: Symbol(),
  WebViewProgressFinished: Symbol(),
  WebViewProgressStarted: Symbol(),
  abDatabaseChanged: Symbol(),
  abDatabaseChangedExternally: Symbol(),
  quartzFilterManagerDidAddFilter: Symbol(),
  quartzFilterManagerDidModifyFilter: Symbol(),
  quartzFilterManagerDidRemoveFilter: Symbol(),
  quartzFilterManagerDidSelectFilter: Symbol(),
  EAAccessoryDidConnect: Symbol(),
  EAAccessoryDidDisconnect: Symbol(),
  MPMovieDurationAvailable: Symbol(),
  MPMovieMediaTypesAvailable: Symbol(),
  MPMovieNaturalSizeAvailable: Symbol(),
  MPMoviePlayerDidEnterFullscreen: Symbol(),
  MPMoviePlayerDidExitFullscreen: Symbol(),
  MPMoviePlayerIsAirPlayVideoActiveDidChange: Symbol(),
  MPMoviePlayerLoadStateDidChange: Symbol(),
  MPMoviePlayerNowPlayingMovieDidChange: Symbol(),
  MPMoviePlayerPlaybackDidFinish: Symbol(),
  MPMoviePlayerPlaybackStateDidChange: Symbol(),
  MPMoviePlayerReadyForDisplayDidChange: Symbol(),
  MPMoviePlayerScalingModeDidChange: Symbol(),
  MPMoviePlayerThumbnailImageRequestDidFinish: Symbol(),
  MPMoviePlayerTimedMetadataUpdated: Symbol(),
  MPMoviePlayerWillEnterFullscreen: Symbol(),
  MPMoviePlayerWillExitFullscreen: Symbol(),
  MPMovieSourceTypeAvailable: Symbol(),
  SKCloudServiceCapabilitiesDidChange: Symbol(),
  SKStorefrontIdentifierDidChange: Symbol(),
  TVTopShelfItemsDidChange: Symbol(),
  UIAccessibilityAssistiveTouchStatusDidChange: Symbol(),
  UIAccessibilityBoldTextStatusDidChange: Symbol(),
  UIAccessibilityClosedCaptioningStatusDidChange: Symbol(),
  UIAccessibilityDarkerSystemColorsStatusDidChange: Symbol(),
  UIAccessibilityGrayscaleStatusDidChange: Symbol(),
  UIAccessibilityGuidedAccessStatusDidChange: Symbol(),
  UIAccessibilityHearingDevicePairedEarDidChange: Symbol(),
  UIAccessibilityInvertColorsStatusDidChange: Symbol(),
  UIAccessibilityMonoAudioStatusDidChange: Symbol(),
  UIAccessibilityReduceMotionStatusDidChange: Symbol(),
  UIAccessibilityReduceTransparencyStatusDidChange: Symbol(),
  UIAccessibilityShakeToUndoDidChange: Symbol(),
  UIAccessibilitySpeakScreenStatusDidChange: Symbol(),
  UIAccessibilitySpeakSelectionStatusDidChange: Symbol(),
  UIAccessibilitySwitchControlStatusDidChange: Symbol(),
  UIApplicationDidBecomeActive: Symbol(),
  UIApplicationDidEnterBackground: Symbol(),
  UIApplicationDidFinishLaunching: Symbol(),
  UIApplicationDidReceiveMemoryWarning: Symbol(),
  UIApplicationSignificantTimeChange: Symbol(),
  UIApplicationUserDidTakeScreenshot: Symbol(),
  UIApplicationWillEnterForeground: Symbol(),
  UIApplicationWillResignActive: Symbol(),
  UIApplicationWillTerminate: Symbol(),
  UIContentSizeCategoryDidChange: Symbol(),
  UIDeviceProximityStateDidChange: Symbol(),
  UIScreenBrightnessDidChange: Symbol(),
  UIScreenDidConnect: Symbol(),
  UIScreenDidDisconnect: Symbol(),
  UIScreenModeDidChange: Symbol(),
  UITableViewSelectionDidChange: Symbol(),
  UITextFieldTextDidBeginEditing: Symbol(),
  UITextFieldTextDidChange: Symbol(),
  UITextFieldTextDidEndEditing: Symbol(),
  UITextInputCurrentInputModeDidChange: Symbol(),
  UITextViewTextDidBeginEditing: Symbol(),
  UITextViewTextDidChange: Symbol(),
  UITextViewTextDidEndEditing: Symbol(),
  UIViewControllerShowDetailTargetDidChange: Symbol(),
  UIWindowDidBecomeHidden: Symbol(),
  UIWindowDidBecomeKey: Symbol(),
  UIWindowDidBecomeVisible: Symbol(),
  UIWindowDidResignKey: Symbol(),
  ALAssetsLibraryChanged: Symbol(),
  AVCaptureDeviceSubjectAreaDidChange: Symbol(),
  AVCaptureSessionInterruptionEnded: Symbol(),
  AVCaptureSessionWasInterrupted: Symbol(),
  CTRadioAccessTechnologyDidChange: Symbol(),
  MFMessageComposeViewControllerTextMessageAvailabilityDidChange: Symbol(),
  MPMediaLibraryDidChange: Symbol(),
  MPMediaPlaybackIsPreparedToPlayDidChange: Symbol(),
  MPMusicPlayerControllerNowPlayingItemDidChange: Symbol(),
  MPMusicPlayerControllerPlaybackStateDidChange: Symbol(),
  MPMusicPlayerControllerVolumeDidChange: Symbol(),
  MPVolumeViewWirelessRouteActiveDidChange: Symbol(),
  MPVolumeViewWirelessRoutesAvailableDidChange: Symbol(),
  NKIssueDownloadCompleted: Symbol(),
  UIApplicationBackgroundRefreshStatusDidChange: Symbol(),
  UIApplicationDidChangeStatusBarFrame: Symbol(),
  UIApplicationDidChangeStatusBarOrientation: Symbol(),
  UIApplicationWillChangeStatusBarFrame: Symbol(),
  UIApplicationWillChangeStatusBarOrientation: Symbol(),
  UIDeviceBatteryLevelDidChange: Symbol(),
  UIDeviceBatteryStateDidChange: Symbol(),
  UIDeviceOrientationDidChange: Symbol(),
  UIDocumentStateChanged: Symbol(),
  UIKeyboardDidChangeFrame: Symbol(),
  UIKeyboardDidHide: Symbol(),
  UIKeyboardDidShow: Symbol(),
  UIKeyboardWillChangeFrame: Symbol(),
  UIKeyboardWillHide: Symbol(),
  UIKeyboardWillShow: Symbol(),
  UIMenuControllerDidHideMenu: Symbol(),
  UIMenuControllerDidShowMenu: Symbol(),
  UIMenuControllerMenuFrameDidChange: Symbol(),
  UIMenuControllerWillHideMenu: Symbol(),
  UIMenuControllerWillShowMenu: Symbol(),
  UIPasteboardChanged: Symbol(),
  UIPasteboardRemoved: Symbol(),
  UIApplicationProtectedDataDidBecomeAvailable: Symbol(),
  UIApplicationProtectedDataWillBecomeUnavailable: Symbol(),
  didChangeAutomaticTextCompletionNotification: Symbol(),
  MPMusicPlayerControllerQueueDidChange: Symbol(),
  GKPlayerAuthenticationDidChangeNotificationName: Symbol(),
  GKPlayerDidChangeNotificationName: Symbol(),
  NEDNSProxyConfigurationDidChange: Symbol(),
  SKStorefrontCountryCodeDidChange: Symbol(),
  UIAccessibilityVoiceOverStatusDidChange: Symbol(),
  UIFocusDidUpdate: Symbol(),
  UIFocusMovementDidFail: Symbol()

  /**
   * An object containing information broadcast to registered observers that bridges to Notification; use NSNotification when you need reference semantics or other Foundation-specific behavior. 
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/foundation/nsnotification
   */
};
var NSNotification = function (_NSObject) {
  _inherits(NSNotification, _NSObject);

  _createClass(NSNotification, [{
    key: 'initCoder',


    // Creating Notifications

    /**
     * Initializes a notification with the data from an unarchiver.
     * @access public
     * @param {NSCoder} aDecoder - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsnotification/1412464-init
     */
    value: function initCoder(aDecoder) {}

    /**
     * Returns a new notification object with a specified name and object.
     * @access public
     * @param {NSNotification.Name} aName - The name for the new notification. May not be nil.
     * @param {?Object} anObject - The object for the new notification.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsnotification/1417440-init
     */

  }, {
    key: 'initNameObject',
    value: function initNameObject(aName, anObject) {}

    /**
     * Initializes a notification with a specified name, object, and user information.
     * @access public
     * @param {NSNotification.Name} name - 
     * @param {?Object} object - The object for the new notification.
     * @param {?Map<AnyHashable, Object>} [userInfo = null] - The user information dictionary for the new notification. May be nil.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsnotification/1415764-init
     */

  }]);

  function NSNotification(name, object) {
    var userInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, NSNotification);

    // Getting Notification Information

    var _this = _possibleConstructorReturn(this, (NSNotification.__proto__ || Object.getPrototypeOf(NSNotification)).call(this));

    _this._name = name;
    _this._object = object;
    _this._userInfo = userInfo;
    return _this;
  }

  // Getting Notification Information

  /**
   * The name of the notification.
   * @type {NSNotification.Name}
   * @desc Typically you use this property to find out what kind of notification you are dealing with when you receive a notification.Special ConsiderationsNotification names can be any string. To avoid name collisions, you might want to use a prefix that’s specific to your application.
   * @see https://developer.apple.com/documentation/foundation/nsnotification/1416472-name
   */


  _createClass(NSNotification, [{
    key: 'name',
    get: function get() {
      return this._name;
    }

    /**
     * The object associated with the notification.
     * @type {?Object}
     * @desc This is often the object that posted this notification. It may be nil.Typically you use this method to find out what object a notification applies to when you receive a notification.
     * @see https://developer.apple.com/documentation/foundation/nsnotification/1414469-object
     */

  }, {
    key: 'object',
    get: function get() {
      return this._object;
    }
    /**
     * The user information dictionary associated with the receiver.
     * @type {?Map<AnyHashable, Object>}
     * @desc May be nil.The user information dictionary stores any additional objects that objects receiving the notification might use.For example, in the Application Kit, NSControl objects post the NSControlTextDidChangeNotification whenever the field editor (an NSText object) changes text inside the NSControl. This notification provides the NSControl object as the notification's associated object. In order to provide access to the field editor, the NSControl object posting the notification adds the field editor to the notification's user information dictionary. Objects receiving the notification can access the field editor and the NSControl object posting the notification as follows:- (void)controlTextDidBeginEditing:(NSNotification *)notification
    {
      NSText *fieldEditor = [notification.userInfo
          objectForKey:@"NSFieldEditor"];               // the field editor
      NSControl *postingObject = notification.object;   // the object that posted the notification
      ...
    }
    - (void)controlTextDidBeginEditing:(NSNotification *)notification
    {
      NSText *fieldEditor = [notification.userInfo
          objectForKey:@"NSFieldEditor"];               // the field editor
      NSControl *postingObject = notification.object;   // the object that posted the notification
      ...
    }
      * @see https://developer.apple.com/documentation/foundation/nsnotification/1409222-userinfo
     */

  }, {
    key: 'userInfo',
    get: function get() {
      return this._userInfo;
    }

    // Structures
    /**
     * @type {Object} Name
     * @property {Symbol} AVAudioEngineConfigurationChange Posted when the audio engine configuration changes.
     * @property {Symbol} AVAudioSessionInterruption Posted when an audio interruption occurs.
     * @property {Symbol} AVAudioSessionMediaServicesWereLost Posted when the media server is terminated.
     * @property {Symbol} AVAudioSessionMediaServicesWereReset Posted when the media server restarts.
     * @property {Symbol} AVAudioSessionRouteChange Posted when the system’s audio route changes.
     * @property {Symbol} AVAudioSessionSilenceSecondaryAudioHint Posted when the primary audio from other applications starts and stops.
     * @property {Symbol} AVAudioUnitComponentTagsDidChange The component tags changed.
     * @property {Symbol} CKAccountChanged Notification posted when the status of the signed-in iCloud account may have changed.
     * @property {Symbol} CLKComplicationServerActiveComplicationsDidChange Posted went the set of active complications changes.
     * @property {Symbol} CNContactStoreDidChange Posted notifications when changes occur in another CNContactStore.
      * @property {Symbol} EKEventStoreChanged Posted whenever changes are made to the Calendar database, including adding, removing, and changing events or reminders. Individual changes are not described. When you receive this notification, you should refetch all EKEvent and EKReminder objects you have accessed, as they are considered stale. If you are actively editing an event and do not wish to refetch it unless it is absolutely necessary to do so, you can call the refresh method on it. If the method returns true, you do not need to refetch the event.
     * @property {Symbol} HKUserPreferencesDidChange Notifies observers whenever the user changes his or her preferred units.
     * @property {Symbol} HMCharacteristicPropertySupportsEvent The characteristic supports notifications using the event connection established by the controller. The event connection provides unidirectional communication from the accessory to the controller.
     * @property {Symbol} NSBundleResourceRequestLowDiskSpace Posted after the system detects that the amount of available disk space is getting low. The notification is posted to the default notification center.
     * @property {Symbol} NSCalendarDayChanged A notification that is posted whenever the calendar day of the system changes, as determined by the system calendar, locale, and time zone.
     * @property {Symbol} NSDidBecomeSingleThreaded Not implemented.
     * @property {Symbol} NSExtensionHostDidBecomeActive Posted when the extension’s host app moves from the inactive to the active state.
     * @property {Symbol} NSExtensionHostDidEnterBackground Posted when the extension’s host app begins running in the background.
     * @property {Symbol} NSExtensionHostWillEnterForeground Posted when the extension’s host app begins running in the foreground.
     * @property {Symbol} NSExtensionHostWillResignActive Posted when the extension’s host app moves from the active to the inactive state.
     * @property {Symbol} NSFileHandleConnectionAccepted This notification is posted when an NSFileHandle object establishes a socket connection between two processes, creates an NSFileHandle object for one end of the connection, and makes this object available to observers by putting it in the userInfo dictionary.
     * @property {Symbol} NSFileHandleDataAvailable This notification is posted when the file handle determines that data is currently available for reading in a file or at a communications channel.
     * @property {Symbol} NSFileHandleReadToEndOfFileCompletion This notification is posted when the file handle reads all data in the file or, if a communications channel, until the other process signals the end of data.
     * @property {Symbol} NSHTTPCookieManagerAcceptPolicyChanged This notification is posted when the acceptance policy of the NSHTTPCookieStorage instance has changed.
     * @property {Symbol} NSHTTPCookieManagerCookiesChanged This notification is posted when the cookies stored in the NSHTTPCookieStorage instance have changed.
     * @property {Symbol} NSManagedObjectContextDidSave A notification that the context completed a save.
     * @property {Symbol} NSManagedObjectContextObjectsDidChange A notification of changes made to managed objects associated with this context.
     * @property {Symbol} NSManagedObjectContextWillSave A notification that the context is about to save.
     * @property {Symbol} NSMetadataQueryDidFinishGathering Posted when the receiver has finished with the initial result-gathering phase of the query.
     * @property {Symbol} NSMetadataQueryDidStartGathering Posted when the receiver begins with the initial result-gathering phase of the query.
     * @property {Symbol} NSMetadataQueryDidUpdate Posted when the receiver’s results have changed during the live-update phase of the query.
     * @property {Symbol} NSMetadataQueryGatheringProgress Posted as the receiver is collecting results during the initial result-gathering phase of the query.
     * @property {Symbol} NSPersistentStoreCoordinatorStoresDidChange Posted whenever persistent stores are added to or removed from a persistent store coordinator, or when store UUIDs change.
     * @property {Symbol} NSPersistentStoreCoordinatorStoresWillChange Posted before the list of open persistent stores changes.
     * @property {Symbol} NSPersistentStoreCoordinatorWillRemoveStore Posted whenever a persistent store is removed from a persistent store coordinator.
     * @property {Symbol} NSProcessInfoPowerStateDidChange Posted when the power state (Low Power Mode is enabled or disabled) of an iOS device changes. 
     * @property {Symbol} NSSystemClockDidChange A notification posted whenever the system clock is changed. 
     * @property {Symbol} NSSystemTimeZoneDidChange A notification posted when the time zone changes.
     * @property {Symbol} NSThreadWillExit An NSThread object posts this notification when it receives the exit() message, before the thread exits. Observer methods invoked to receive this notification execute in the exiting thread, before it exits.
     * @property {Symbol} NSURLCredentialStorageChanged This notification is posted when the set of stored credentials changes.
     * @property {Symbol} NSUbiquityIdentityDidChange Sent after the iCloud (“ubiquity”) identity has changed.
     * @property {Symbol} NSUndoManagerCheckpoint Posted whenever an NSUndoManager object opens or closes an undo group (except when it opens a top-level group) and when checking the redo stack in canRedo. 
     * @property {Symbol} NSUndoManagerDidCloseUndoGroup Posted after an NSUndoManager object closes an undo group, which occurs in the implementation of the endUndoGrouping() method.
     * @property {Symbol} NSUndoManagerDidOpenUndoGroup Posted whenever an NSUndoManager object opens an undo group, which occurs in the implementation of the beginUndoGrouping() method. 
     * @property {Symbol} NSUndoManagerDidRedoChange Posted just after an NSUndoManager object performs a redo operation (redo()).
     * @property {Symbol} NSUndoManagerDidUndoChange Posted just after an NSUndoManager object performs an undo operation.
     * @property {Symbol} NSUndoManagerWillCloseUndoGroup Posted before an NSUndoManager object closes an undo group, which occurs in the implementation of the endUndoGrouping() method.
     * @property {Symbol} NSUndoManagerWillRedoChange Posted just before an NSUndoManager object performs a redo operation (redo()).
     * @property {Symbol} NSUndoManagerWillUndoChange Posted just before an NSUndoManager object performs an undo operation.
     * @property {Symbol} NSWillBecomeMultiThreaded Posted when the first thread is detached from the current thread. The NSThread class posts this notification at most once—the first time a thread is detached using detachNewThreadSelector(_:toTarget:with:) or the start() method. Subsequent invocations of those methods do not post this notification. Observers of this notification have their notification method invoked in the main thread, not the new thread. The observer notification methods always execute before the new thread begins executing.
     * @property {Symbol} PKPassLibraryDidChange Posted after the pass library has been changed.
     * @property {Symbol} PKPassLibraryRemotePaymentPassesDidChange Posted when an Apple Pay card is added to or removed from a device that is paired with the current iOS device (for example, Apple Watch). 
     * @property {Symbol} UIAccessibilityAnnouncementDidFinish Posted by UIKit when the system has finished reading an announcement.
     * @property {Symbol} UIAccessibilityElementFocused 
     * @property {Symbol} WKAudioFilePlayerItemDidPlayToEndTime Posted when the item has played successfully to its end time.
     * @property {Symbol} WKAudioFilePlayerItemFailedToPlayToEndTime Posted when the item failed to play to its end time.
     * @property {Symbol} WKAudioFilePlayerItemTimeJumped Posted when the item’s current time has changed discontinuously. 
     * @property {Symbol} ABPeoplePickerDisplayedPropertyDidChange Posted when the displayed property in the record list is changed.
     * @property {Symbol} ABPeoplePickerGroupSelectionDidChange Posted when the selection in the group list is changed.
     * @property {Symbol} ABPeoplePickerNameSelectionDidChange Posted when the selection in the name list is changed.
     * @property {Symbol} ABPeoplePickerValueSelectionDidChange Posted when the selection in a multivalue property is changed.
     * @property {Symbol} ACAccountStoreDidChange Posted when the accounts managed by this account store changed in the database. There is no userInfo dictionary associated with this notification.
     * @property {Symbol} AVAssetChapterMetadataGroupsDidChange 
     * @property {Symbol} AVAssetContainsFragmentsDidChange 
     * @property {Symbol} AVAssetDurationDidChange 
     * @property {Symbol} AVAssetMediaSelectionGroupsDidChange 
     * @property {Symbol} AVAssetTrackSegmentsDidChange 
     * @property {Symbol} AVAssetTrackTimeRangeDidChange 
     * @property {Symbol} AVAssetTrackTrackAssociationsDidChange 
     * @property {Symbol} AVAssetWasDefragmented 
     * @property {Symbol} AVCaptureDeviceWasConnected Posted when a new device becomes available.
     * @property {Symbol} AVCaptureDeviceWasDisconnected Posted when an existing device becomes unavailable.
     * @property {Symbol} AVCaptureInputPortFormatDescriptionDidChange Posted if the value of the capture input port’sformatDescription property changes.
     * @property {Symbol} AVCaptureSessionDidStartRunning Posted when a capture session starts.
     * @property {Symbol} AVCaptureSessionDidStopRunning Posted when a capture session stops.
     * @property {Symbol} AVCaptureSessionRuntimeError Posted if an error occurred during a capture session.
     * @property {Symbol} AVFragmentedMovieContainsMovieFragmentsDidChange 
     * @property {Symbol} AVFragmentedMovieDurationDidChange 
     * @property {Symbol} AVFragmentedMovieTrackSegmentsDidChange 
     * @property {Symbol} AVFragmentedMovieTrackTimeRangeDidChange 
     * @property {Symbol} AVFragmentedMovieTrackTotalSampleDataLengthDidChange 
     * @property {Symbol} AVFragmentedMovieWasDefragmented 
     * @property {Symbol} AVPlayerItemDidPlayToEndTime Posted when the item has played to its end time.
     * @property {Symbol} AVPlayerItemFailedToPlayToEndTime Posted when the item failed to play to its end time.
     * @property {Symbol} AVPlayerItemNewAccessLogEntry Posted when a new access log entry has been added.
     * @property {Symbol} AVPlayerItemNewErrorLogEntry Posted when a new error log entry has been added.
     * @property {Symbol} AVPlayerItemPlaybackStalled Posted when some media did not arrive in time to continue playback.
     * @property {Symbol} AVPlayerItemTimeJumped Posted when the item’s current time has changed discontinuously.
     * @property {Symbol} AVSampleBufferDisplayLayerFailedToDecode Posted when a buffer display layer failed to decode.
     * @property {Symbol} CWBSSIDDidChange 
     * @property {Symbol} CWCountryCodeDidChange 
     * @property {Symbol} CWLinkDidChange 
     * @property {Symbol} CWLinkQualityDidChange 
     * @property {Symbol} CWModeDidChange 
     * @property {Symbol} CWPowerDidChange 
     * @property {Symbol} CWSSIDDidChange 
     * @property {Symbol} CWScanCacheDidUpdate 
     * @property {Symbol} GCControllerDidConnect Posted immediately after a new controller is connected to the device.
     * @property {Symbol} GCControllerDidDisconnect Posted immediately after a controller is disconnected from the device.
     * @property {Symbol} IKFilterBrowserFilterDoubleClick Posted when the user double-clicks a filter in the filter browser. 
     * @property {Symbol} IKFilterBrowserFilterSelected Posted when the user clicks a filter name in the filter browser. 
     * @property {Symbol} IKFilterBrowserWillPreviewFilter Posted before showing a filter preview, allowing an application to set the parameters of a filter.
     * @property {Symbol} IOBluetoothHostControllerPoweredOff 
     * @property {Symbol} IOBluetoothHostControllerPoweredOn 
     * @property {Symbol} IOBluetoothL2CAPChannelPublished 
     * @property {Symbol} IOBluetoothL2CAPChannelTerminated 
     * @property {Symbol} MKAnnotationCalloutInfoDidChange Notifies observers that the title or subtitle information of an annotation object changed.
     * @property {Symbol} NEFilterConfigurationDidChange Posted after the filter configuration stored in the Network Extension preferences changes.
     * @property {Symbol} NEVPNConfigurationChange Posted after the VPN configuration stored in the Network Extension preferences changes.
     * @property {Symbol} NEVPNStatusDidChange Posted when the status of the VPN connection changes.
     * @property {Symbol} announcementRequested This notification is posted whenever an accessibility element needs to make an announcement to the user. This notification requires a userInfo dictionary with the key announcement and a localized string containing the announcement. To help an assistive app determine the importance of the announcement, add the appropriate priority to the userInfo dictionary.
     * @property {Symbol} applicationActivated This notification is posted after the app has been activated. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} applicationDeactivated This notification is posted after the app has been deactivated.  Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} applicationHidden This notification is posted after the app is hidden. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} applicationShown This notification is posted after the app is shown. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} created This notification is posted after an accessibility element is created. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} drawerCreated This notification is posted after a drawer appears. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} focusedUIElementChanged This notification is posted after an accessibility element gains focus. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} focusedWindowChanged This notification is posted after the key window changes. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} helpTagCreated This notification is posted after a help tag appears. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} layoutChanged This notification is posted after the UI changes in a way that requires the attention of an accessibility client. This notification should be accompanied by a userInfo dictionary with the key uiElements and an array containing the UI elements that have been added or changed. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} mainWindowChanged This notification is posted after the main window changes. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} moved This notification is posted after an accessibility element moves. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} resized This notification is posted after an accessibility element’s size changes. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} rowCollapsed This notification is posted after a row collapses. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} rowCountChanged This notification is posted after a row is added or deleted. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} rowExpanded This notification is posted after a row expands. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} selectedCellsChanged This notification is posted after one or more cells in a cell-based table are selected or deselected. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} selectedChildrenChanged This notification is posted after one or more child elements are selected or deselected. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} selectedChildrenMoved This notification is posted after the selected items in a layout area move. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} selectedColumnsChanged This notification is posted after one or more columns are selected or deselected. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} selectedRowsChanged This notification is posted after one or more rows are selected or deselected. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} selectedTextChanged This notification is posted after text is selected or deselected.  Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} sheetCreated This notification is posted after a sheet appears.  Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} titleChanged This notification is posted after an accessibility element’s title changes. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} uiElementDestroyed This notification is posted after an accessibility element is destroyed. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} unitsChanged This notification is posted after the units in a layout area change. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} valueChanged This notification is posted after an accessibility element’s value changes. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} windowCreated This notification is posted after a new window appears. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} windowDeminiaturized This notification is posted after a window is restored to full size from the Dock.  Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} windowMiniaturized This notification is posted after a window is put in the Dock. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} windowMoved This notification is posted after a window moves.  Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} windowResized This notification is posted after a window’s size changes. Post this notification using the NSAccessibilityPostNotification(_:_:) function instead of an NSNotificationCenter instance.
     * @property {Symbol} progressMarkNotification Posted when the current progress of a running animation reaches one of its progress marks.
     * @property {Symbol} antialiasThresholdChangedNotification Posted after the threshold for anti-aliasing changes.
     * @property {Symbol} NSAppleEventManagerWillProcessFirstEvent Posted by NSAppleEventManager before it first dispatches an Apple event. Your application can use this notification to avoid registering any Apple event handlers until the first time at which they may be needed.
     * @property {Symbol} didBecomeActiveNotification Posted immediately after the app becomes active.
     * @property {Symbol} didChangeOcclusionStateNotification Posted when the app’s occlusion state changes.
     * @property {Symbol} didChangeScreenParametersNotification Posted when the configuration of the displays attached to the computer is changed.
     * @property {Symbol} didFinishLaunchingNotification Posted at the end of the finishLaunching() method to indicate that the app has completed launching and is ready to run.
     * @property {Symbol} didFinishRestoringWindowsNotification Posted when the app is finished restoring windows.
     * @property {Symbol} didHideNotification Posted at the end of the hide(_:) method to indicate that the app is now hidden.
     * @property {Symbol} didResignActiveNotification Posted immediately after the app gives up its active status to another app.
     * @property {Symbol} didUnhideNotification Posted at the end of the unhideWithoutActivation() method to indicate that the app is now visible.
     * @property {Symbol} didUpdateNotification Posted at the end of the updateWindows() method to indicate that the app has finished updating its windows.
     * @property {Symbol} willBecomeActiveNotification Posted immediately before the app becomes active.
     * @property {Symbol} willFinishLaunchingNotification Posted at the start of the finishLaunching() method to indicate that the app has completed its initialization process and is about to finish launching.
     * @property {Symbol} willHideNotification Posted at the start of the hide(_:) method to indicate that the app is about to be hidden.
     * @property {Symbol} willResignActiveNotification Posted immediately before the app gives up its active status to another app.
     * @property {Symbol} willTerminateNotification Posted by the terminate(_:) method to indicate that the app will terminate.
     * @property {Symbol} willUnhideNotification Posted at the start of the unhideWithoutActivation() method to indicate that the app is about to become visible.
     * @property {Symbol} willUpdateNotification Posted at the start of the updateWindows() method to indicate that the app is about to update its windows.
     * @property {Symbol} columnConfigurationDidChangeNotification Notifies the delegate when the width of a browser column has changed.
     * @property {Symbol} NSClassDescriptionNeededForClass Posted by init(for:) when a class description cannot be found for a class.
     * @property {Symbol} didChangeNotification 
     * @property {Symbol} colorDidChangeNotification Posted when the color of the NSColorPanel is set, as when NSColorPanel is invoked.
     * @property {Symbol} selectionDidChangeNotification Posted after the pop-up list selection of the NSComboBox changes. 
     * @property {Symbol} selectionIsChangingNotification Posted whenever the pop-up list selection of the NSComboBox is changing. 
     * @property {Symbol} willDismissNotification Posted whenever the pop-up list of the NSComboBox is about to be dismissed.
     * @property {Symbol} willPopUpNotification Posted whenever the pop-up list of the NSComboBox is going to be displayed. 
     * @property {Symbol} contextHelpModeDidActivateNotification Posted when the application enters context-sensitive help mode. This typically happens when the user holds down the Help key.
     * @property {Symbol} contextHelpModeDidDeactivateNotification Posted when the application exits context-sensitive help mode. This happens when the user clicks the mouse button while the cursor is anywhere on the screen after displaying a context-sensitive help topic.
     * @property {Symbol} textDidBeginEditingNotification Sent when a control with editable cells begins an edit session. 
     * @property {Symbol} textDidChangeNotification Sent when the text in the receiving control changes. 
     * @property {Symbol} textDidEndEditingNotification Sent when a control with editable cells ends an editing session. 
     * @property {Symbol} currentControlTintDidChangeNotification Sent after the user changes control tint preference.
     * @property {Symbol} didCloseNotification Posted whenever the drawer is closed. 
     * @property {Symbol} didOpenNotification Posted whenever the drawer is opened. 
     * @property {Symbol} willCloseNotification Posted whenever the drawer is about to close. 
     * @property {Symbol} willOpenNotification Posted whenever the drawer is about to open.
     * @property {Symbol} didChangeNotification Posted whenever a font collection is changed.
     * @property {Symbol} fontSetChangedNotification Posted after the the currently-set font changes.
     * @property {Symbol} registryDidChangeNotification Posted whenever the NSImageRep class registry changes.
     * @property {Symbol} didAddItemNotification Posted after a menu item is added to the menu.
     * @property {Symbol} didBeginTrackingNotification Posted when menu tracking begins.
     * @property {Symbol} didChangeItemNotification Posted after a menu item in the menu changes appearance.
     * @property {Symbol} didEndTrackingNotification Posted when menu tracking ends, even if no action is sent.
     * @property {Symbol} didRemoveItemNotification Posted after a menu item is removed from the menu.
     * @property {Symbol} didSendActionNotification Posted just after the application dispatches a menu item’s action method to the menu item’s target.
     * @property {Symbol} willSendActionNotification Posted just before the application dispatches a menu item’s action method to the menu item’s target.
     * @property {Symbol} columnDidMoveNotification Posted whenever a column is moved by user action in an NSOutlineView object.
     * @property {Symbol} columnDidResizeNotification Posted whenever a column is resized in an NSOutlineView object.
     * @property {Symbol} itemDidCollapseNotification Posted whenever an item is collapsed in an NSOutlineView object.
     * @property {Symbol} itemDidExpandNotification Posted whenever an item is expanded in an NSOutlineView object.
     * @property {Symbol} itemWillCollapseNotification Posted before an item is collapsed (after the user clicks the arrow but before the item is collapsed).
     * @property {Symbol} itemWillExpandNotification Posted before an item is expanded (after the user clicks the arrow but before the item is collapsed).
     * @property {Symbol} selectionDidChangeNotification Posted after the outline view's selection changes.
     * @property {Symbol} selectionIsChangingNotification Posted as the outline view’s selection changes (while the mouse button is still down).
     * @property {Symbol} NSPersistentStoreDidImportUbiquitousContentChanges Posted after records are imported from the ubiquitous content store.
     * @property {Symbol} willPopUpNotification This notification is posted just before an pop-up menu is attached to its window frame.
     * @property {Symbol} willPopUpNotification Posted when an NSPopUpButton object receives a mouse-down event—that is, when the user is about to select an item from the menu.
     * @property {Symbol} didCloseNotification Sent after the popover has finished animating offscreen.
     * @property {Symbol} didShowNotification Sent after the popover has finished animating onscreen.
     * @property {Symbol} willCloseNotification Sent before the popover is closed.
     * @property {Symbol} willShowNotification Sent before the popover is shown.
     * @property {Symbol} preferredScrollerStyleDidChangeNotification Posted if the preferred scroller style changes.
     * @property {Symbol} rowsDidChangeNotification This notification is posted to the default notification center whenever the view's rows change.
     * @property {Symbol} colorSpaceDidChangeNotification Posted when the color space of the screen has changed.
     * @property {Symbol} didEndLiveMagnifyNotification Posted at the end of a magnify gesture.
     * @property {Symbol} didEndLiveScrollNotification Posted on the main thread at the end of live scroll tracking.
     * @property {Symbol} didLiveScrollNotification Posted on the main thread after changing the clipview bounds origin due to a user-initiated event.
     * @property {Symbol} willStartLiveMagnifyNotification Posted at the beginning of a magnify gesture.
     * @property {Symbol} willStartLiveScrollNotification Posted on the main thread at the beginning of user-initiated live scroll tracking (gesture scroll or scroller tracking, for example, thumb dragging).
     * @property {Symbol} didChangeAutomaticCapitalizationNotification 
     * @property {Symbol} didChangeAutomaticDashSubstitutionNotification 
     * @property {Symbol} didChangeAutomaticPeriodSubstitutionNotification 
     * @property {Symbol} didChangeAutomaticQuoteSubstitutionNotification 
     * @property {Symbol} didChangeAutomaticSpellingCorrectionNotification This notification is posted when the spell checker did change text using automatic spell checking correction. The are posted to the application’s default notification center.
     * @property {Symbol} didChangeAutomaticTextReplacementNotification Posted when the spell checker changed text using automatic text replacement.  This notification is posted to the app’s default notification center. 
     * @property {Symbol} didResizeSubviewsNotification Posted after an NSSplitView changes the sizes of some or all of its subviews. 
     * @property {Symbol} willResizeSubviewsNotification Posted before an NSSplitView changes the sizes of some or all of its subviews.
     * @property {Symbol} systemColorsDidChangeNotification Sent when the system colors have been changed (such as through a system control panel interface).
     * @property {Symbol} columnDidMoveNotification Posted whenever a column is moved by user action in an NSTableView object.
     * @property {Symbol} columnDidResizeNotification Posted whenever a column is resized in an NSTableView object.
     * @property {Symbol} selectionDidChangeNotification Posted after an NSTableView object's selection changes.
     * @property {Symbol} selectionIsChangingNotification Posted as an NSTableView object's selection changes (while the mouse button is still down).
     * @property {Symbol} selectedAlternativeStringNotification Posted when the user selects an alternate string.
     * @property {Symbol} didBeginEditingNotification Posted when an NSText object begins any operation that changes characters or formatting attributes.
     * @property {Symbol} didChangeNotification Posted after an NSText object performs any operation that changes characters or formatting attributes.
     * @property {Symbol} didEndEditingNotification Posted when focus leaves an NSText object, whether or not any operation has changed characters or formatting attributes.
     * @property {Symbol} keyboardSelectionDidChangeNotification Posted after the selected text input source changes.
     * @property {Symbol} NSTextStorageDidProcessEditing Posted after a text storage finishes processing edits in processEditing().
     * @property {Symbol} NSTextStorageWillProcessEditing Posted before a text storage finishes processing edits in processEditing().
     * @property {Symbol} didChangeSelectionNotification Posted when the selected range of characters changes.
     * @property {Symbol} didChangeTypingAttributesNotification Posted when there is a change in the typing attributes within a text view.
     * @property {Symbol} willChangeNotifyingTextViewNotification Posted when a new text view is established as the text view that sends notifications.
     * @property {Symbol} didRemoveItemNotification Posted after an item is removed from a toolbar.
     * @property {Symbol} willAddItemNotification Posted before a new item is added to the toolbar.
     * @property {Symbol} boundsDidChangeNotification Posted whenever the NSView’s bounds rectangle changes to a new value independently of the frame rectangle, but only when the view’s postsBoundsChangedNotifications property is true.  
     * @property {Symbol} didUpdateTrackingAreasNotification Posted whenever an NSView object recalculates its tracking areas.
     * @property {Symbol} frameDidChangeNotification Posted whenever the view’s frame rectangle changes to a new value, but only when the view’s postsFrameChangedNotifications property is true.
     * @property {Symbol} globalFrameDidChangeNotification Posted whenever an NSView object that has attached surfaces (that is, NSOpenGLContext objects) moves to a different screen, or other cases where the NSOpenGLContext object needs to be updated. 
     * @property {Symbol} didBecomeKeyNotification Posted whenever an NSWindow object becomes the key window.
     * @property {Symbol} didBecomeMainNotification Posted whenever an NSWindow object becomes the main window.
     * @property {Symbol} didChangeBackingPropertiesNotification Posted when the window backing properties change.
     * @property {Symbol} didChangeOcclusionStateNotification Posted when the window’s occlusion state changes.
     * @property {Symbol} didChangeScreenNotification Posted whenever a portion of an NSWindow object’s frame moves onto or off of a screen.
     * @property {Symbol} didChangeScreenProfileNotification Posted whenever the display profile for the screen containing the window changes.
     * @property {Symbol} didDeminiaturizeNotification Posted whenever an NSWindow object is deminimized.
     * @property {Symbol} didEndLiveResizeNotification Posted after the user resizes a window.
     * @property {Symbol} didEndSheetNotification Posted whenever an NSWindow object closes an attached sheet.
     * @property {Symbol} didEnterFullScreenNotification Posted when the window entered full screen mode.
     * @property {Symbol} didEnterVersionBrowserNotification Posted when the window will enter version browser mode.
     * @property {Symbol} didExitFullScreenNotification Posted when the window did exit full screen mode.
     * @property {Symbol} didExitVersionBrowserNotification Posted when the window did exit version browser mode.
     * @property {Symbol} didExposeNotification Posted whenever a portion of a nonretained NSWindow object is exposed, whether by being ordered in front of other windows or by other windows being removed from in front of it.
     * @property {Symbol} didMiniaturizeNotification Posted whenever an NSWindow object is minimized.
     * @property {Symbol} didMoveNotification Posted whenever an NSWindow object is moved.
     * @property {Symbol} didResignKeyNotification Posted whenever an NSWindow object resigns its status as key window.
     * @property {Symbol} didResignMainNotification Posted whenever an NSWindow object resigns its status as main window.
     * @property {Symbol} didResizeNotification Posted whenever an NSWindow object’s size changes.
     * @property {Symbol} didUpdateNotification Posted whenever an NSWindow object receives an update() message.
     * @property {Symbol} willBeginSheetNotification Posted whenever an NSWindow object is about to open a sheet.
     * @property {Symbol} willCloseNotification Posted whenever an NSWindow object is about to close.
     * @property {Symbol} willEnterFullScreenNotification Posted when the window will enter full screen mode.
     * @property {Symbol} willEnterVersionBrowserNotification Posted when the window will enter version browser mode.
     * @property {Symbol} willExitFullScreenNotification Posted when the window will exit full screen mode.
     * @property {Symbol} willExitVersionBrowserNotification Posted when the window will exit version browser mode.
     * @property {Symbol} willMiniaturizeNotification Posted whenever an NSWindow object is about to be minimized.
     * @property {Symbol} willMoveNotification Posted whenever an NSWindow object is about to move.
     * @property {Symbol} willStartLiveResizeNotification Posted before the user resizes a window.
     * @property {Symbol} accessibilityDisplayOptionsDidChangeNotification Posted when any of the accessibility display options change.
     * @property {Symbol} activeSpaceDidChangeNotification Posted when a Spaces change has occurred.
     * @property {Symbol} didActivateApplicationNotification Posted when the Finder is about to activate an app.
     * @property {Symbol} didChangeFileLabelsNotification Posted when the Finder file labels or colors change.
     * @property {Symbol} didDeactivateApplicationNotification Posted when the Finder deactivated an app.
     * @property {Symbol} didHideApplicationNotification Posted when the Finder hid an app.
     * @property {Symbol} didLaunchApplicationNotification Posted when a new app has started up.
     * @property {Symbol} didMountNotification Posted when a new device has been mounted.
     * @property {Symbol} didPerformFileOperationNotification Posted when a file operation has been performed in the receiving app.
     * @property {Symbol} didRenameVolumeNotification Posted when a volume changes its name and/or mount path.  These typically change simultaneously, in which case only one notification is posted.
     * @property {Symbol} didTerminateApplicationNotification Posted when an app finishes executing.
     * @property {Symbol} didUnhideApplicationNotification Posted when the Finder unhid an app.
     * @property {Symbol} didUnmountNotification Posted when the Finder did unmount a device.
     * @property {Symbol} didWakeNotification Posted when the machine wakes from sleep.
     * @property {Symbol} screensDidSleepNotification Posted when the machine’s screen goes to sleep.
     * @property {Symbol} screensDidWakeNotification Posted when the machine’s screens wake.
     * @property {Symbol} sessionDidBecomeActiveNotification Posted after a user session is switched in.
     * @property {Symbol} sessionDidResignActiveNotification Posted before a user session is switched out.
     * @property {Symbol} willLaunchApplicationNotification Posted when the Finder is about to launch an app.
     * @property {Symbol} willPowerOffNotification Posted when the user has requested a logout or that the machine be powered off.
     * @property {Symbol} willSleepNotification Posted before the machine goes to sleep.
     * @property {Symbol} willUnmountNotification Posted when the Finder is about to unmount a device.
     * @property {Symbol} PDFDocumentDidBeginFind Posted when the beginFindString(_:withOptions:) or findString(_:withOptions:) method begins finding.
     * @property {Symbol} PDFDocumentDidBeginPageFind Posted each time a find operation begins working on a new page of a document.
     * @property {Symbol} PDFDocumentDidBeginPageWrite Posted each time a write operation begins working on a page in a document.
     * @property {Symbol} PDFDocumentDidBeginWrite Posted each time a write operation begins working on a document.
     * @property {Symbol} PDFDocumentDidEndFind Posted when the beginFindString(_:withOptions:) or findString(_:withOptions:) method returns.
     * @property {Symbol} PDFDocumentDidEndPageFind Posted each time a find operation finishes working on a page in a document.
     * @property {Symbol} PDFDocumentDidEndPageWrite Posted each time a write operation finishes working on a page in a document.
     * @property {Symbol} PDFDocumentDidEndWrite Posted each time a write operation finishes working on a document.
     * @property {Symbol} PDFDocumentDidFindMatch Posted each time a string match is found in a document.
     * @property {Symbol} PDFDocumentDidUnlock Posted when a document unlocks after a unlock(withPassword:) message.
     * @property {Symbol} PDFThumbnailViewDocumentEdited 
     * @property {Symbol} PDFViewAnnotationHit Posted when the user clicks on an annotation. 
     * @property {Symbol} PDFViewAnnotationWillHit Posted before the user clicks an annotation.
     * @property {Symbol} PDFViewChangedHistory Posted when the page history changes.
     * @property {Symbol} PDFViewCopyPermission Posted when the user attempts to copy to the pasteboard without the appropriate permissions. 
     * @property {Symbol} PDFViewDisplayBoxChanged Posted when the display box has changed.
     * @property {Symbol} PDFViewDisplayModeChanged Posted when the display mode has changed.
     * @property {Symbol} PDFViewDocumentChanged Posted when a new document is associated with the view.
     * @property {Symbol} PDFViewPageChanged Posted when a new page becomes the current page.
     * @property {Symbol} PDFViewPrintPermission Posted when the user attempts to print without the appropriate permissions. 
     * @property {Symbol} PDFViewScaleChanged Posted when the scale factor changes. 
     * @property {Symbol} PDFViewSelectionChanged Posted when the current selection has changed.
     * @property {Symbol} PDFViewVisiblePagesChanged 
     * @property {Symbol} QCCompositionPickerPanelDidSelectComposition Posted when the user chooses a composition.
     * @property {Symbol} QCCompositionPickerViewDidSelectComposition Posted when the user selects a composition in the picker view.
     * @property {Symbol} QCCompositionRepositoryDidUpdate Posted whenever the list of compositions in the composition repository is updated.
     * @property {Symbol} QCViewDidStartRendering Posted when the view starts rendering.
     * @property {Symbol} QCViewDidStopRendering Posted when the view stops rendering.
     * @property {Symbol} WebHistoryAllItemsRemoved Posted when all history items have been removed from the web history.
     * @property {Symbol} WebHistoryItemChanged Posted by a WebHistoryItem object when the value of the history item’s title, alternate title, URL strings, or last visited interval changes.
     * @property {Symbol} WebHistoryItemsAdded Posted when history items have been added to a web history.
     * @property {Symbol} WebHistoryItemsRemoved Posted when items have been removed from the web history.
     * @property {Symbol} WebHistoryLoaded Posted when web history items have been loaded from a URL.
     * @property {Symbol} WebHistorySaved Posted when web history items have been saved to a URL.
     * @property {Symbol} WebPreferencesChanged Posted when the web preference settings are changed. 
     * @property {Symbol} WebViewDidBeginEditing Posted when a web view begins any operation that changes its contents in response to user editing.
     * @property {Symbol} WebViewDidChange Posted when a web view performs any operation that changes its contents in response to user editing.
     * @property {Symbol} WebViewDidChangeSelection Posted when a web view changes its typing selection.
     * @property {Symbol} WebViewDidChangeTypingStyle Posted when a web view changes its typing style.
     * @property {Symbol} WebViewDidEndEditing Posted when a web view ends any operation that changes its contents in response to user editing.
     * @property {Symbol} WebViewProgressEstimateChanged Posted by a WebView object when the estimated progress value of a load changes.
     * @property {Symbol} WebViewProgressFinished Posted by a WebView object when the load has finished.
     * @property {Symbol} WebViewProgressStarted Posted by a WebView object when a load begins, including a load that is initiated in a subframe.
     * @property {Symbol} abDatabaseChanged Posted when this process has changed the Address Book database.
     * @property {Symbol} abDatabaseChangedExternally Posted when a process other than the current one has changed the Address Book database.
     * @property {Symbol} quartzFilterManagerDidAddFilter 
     * @property {Symbol} quartzFilterManagerDidModifyFilter 
     * @property {Symbol} quartzFilterManagerDidRemoveFilter 
     * @property {Symbol} quartzFilterManagerDidSelectFilter 
     * @property {Symbol} EAAccessoryDidConnect Posted when an accessory becomes connected and available for your application to use.
     * @property {Symbol} EAAccessoryDidDisconnect Posted when an accessory is disconnected and no longer available for your application to use.
     * @property {Symbol} MPMovieDurationAvailable Posted when the duration of a movie has been determined. There is no userInfo dictionary.
     * @property {Symbol} MPMovieMediaTypesAvailable Posted when the available media types in a movie are determined. There is no userInfo dictionary.
     * @property {Symbol} MPMovieNaturalSizeAvailable Posted when the natural frame size of a movie is first determined or subsequently changes. There is no userInfo dictionary.
     * @property {Symbol} MPMoviePlayerDidEnterFullscreen Posted when a movie player has entered full-screen mode. There is no userInfo dictionary.
     * @property {Symbol} MPMoviePlayerDidExitFullscreen Posted when a movie player has exited full-screen mode. There is no userInfo dictionary.  
     * @property {Symbol} MPMoviePlayerIsAirPlayVideoActiveDidChange Posted when a movie player has started or ended playing a movie via AirPlay. There is no userInfo dictionary.
     * @property {Symbol} MPMoviePlayerLoadStateDidChange Posted when a movie player’s network buffering state has changed. There is no userInfo dictionary.
     * @property {Symbol} MPMoviePlayerNowPlayingMovieDidChange Posted when the currently playing movie has changed. There is no userInfo dictionary.
     * @property {Symbol} MPMoviePlayerPlaybackDidFinish Posted when a movie has finished playing. The userInfo dictionary of this notification contains the MPMoviePlayerPlaybackDidFinishReasonUserInfoKey key, which indicates the reason that playback finished. This notification is also sent when playback fails because of an error.
     * @property {Symbol} MPMoviePlayerPlaybackStateDidChange Posted when a movie player’s playback state has changed. There is no userInfo dictionary.
     * @property {Symbol} MPMoviePlayerReadyForDisplayDidChange Posted when the ready for display state changes.
     * @property {Symbol} MPMoviePlayerScalingModeDidChange Posted when the scaling mode of a movie player has changed. There is no userInfo dictionary.
     * @property {Symbol} MPMoviePlayerThumbnailImageRequestDidFinish Posted when a request to capture a thumbnail from a movie has finished whether the request succeeded or failed. Upon successful capture of a thumbnail, the userInfo dictionary contains values for the following keys:
     * @property {Symbol} MPMoviePlayerTimedMetadataUpdated Posted when new timed metadata arrives.
     * @property {Symbol} MPMoviePlayerWillEnterFullscreen Posted when a movie player is about to enter full-screen mode. The userInfo dictionary contains keys whose values describe the transition animation used to enter full-screen mode. See Fullscreen Notification Keys.
     * @property {Symbol} MPMoviePlayerWillExitFullscreen Posted when a movie player is about to exit full-screen mode. The userInfo dictionary contains keys whose values describe the transition animation used to exit full-screen mode. See Fullscreen Notification Keys.
     * @property {Symbol} MPMovieSourceTypeAvailable Posted when the source type of a movie was previously unknown and is newly available. There is no userInfo dictionary.
     * @property {Symbol} SKCloudServiceCapabilitiesDidChange Called when the capabilities associated with the music library on the device change.
     * @property {Symbol} SKStorefrontIdentifierDidChange Called when the storefront identifier associated with the device changes.
     * @property {Symbol} TVTopShelfItemsDidChange A notification to post when your app’s Top Shelf content has changed.
     * @property {Symbol} UIAccessibilityAssistiveTouchStatusDidChange 
     * @property {Symbol} UIAccessibilityBoldTextStatusDidChange Posted by UIKit when the system’s Bold Text setting has changed. 
     * @property {Symbol} UIAccessibilityClosedCaptioningStatusDidChange Posted by UIKit when the setting for closed captioning has changed.
     * @property {Symbol} UIAccessibilityDarkerSystemColorsStatusDidChange Posted by UIKit when the system’s Darken Colors setting has changed.
     * @property {Symbol} UIAccessibilityGrayscaleStatusDidChange Posted by UIKit when the system’s Grayscale setting has changed.
     * @property {Symbol} UIAccessibilityGuidedAccessStatusDidChange Posted by UIKit when a Guided Access session starts or ends.  
     * @property {Symbol} UIAccessibilityHearingDevicePairedEarDidChange 
     * @property {Symbol} UIAccessibilityInvertColorsStatusDidChange Posted by UIKit when the setting for inverted colors has changed.  
     * @property {Symbol} UIAccessibilityMonoAudioStatusDidChange Posted by UIKit when system audio changes from stereo to mono.
     * @property {Symbol} UIAccessibilityReduceMotionStatusDidChange Posted by UIKit when the system’s Reduce Motion setting has changed.
     * @property {Symbol} UIAccessibilityReduceTransparencyStatusDidChange Posted by UIKit when the system’s Reduce Transparency system setting has changed.
     * @property {Symbol} UIAccessibilityShakeToUndoDidChange 
     * @property {Symbol} UIAccessibilitySpeakScreenStatusDidChange Posted by UIKit when the system’s Speak Screen setting has changed.
     * @property {Symbol} UIAccessibilitySpeakSelectionStatusDidChange Posted by UIKit when the system’s Speak Selection setting has changed.
     * @property {Symbol} UIAccessibilitySwitchControlStatusDidChange Posted by UIKit when the system’s Switch Control setting has changed.
     * @property {Symbol} UIApplicationDidBecomeActive Posted when the app becomes active. 
     * @property {Symbol} UIApplicationDidEnterBackground Posted when the app enters the background.
     * @property {Symbol} UIApplicationDidFinishLaunching Posted immediately after the app finishes launching.
     * @property {Symbol} UIApplicationDidReceiveMemoryWarning Posted when the app receives a warning from the operating system about low memory availability.
     * @property {Symbol} UIApplicationSignificantTimeChange Posted when there is a significant change in time, for example, change to a new day (midnight), carrier time update, and change to or from daylight savings time.
     * @property {Symbol} UIApplicationUserDidTakeScreenshot Posted when the user presses the Home and Lock buttons to take a screenshot. 
     * @property {Symbol} UIApplicationWillEnterForeground Posted shortly before an app leaves the background state on its way to becoming the active app.
     * @property {Symbol} UIApplicationWillResignActive Posted when the app is no longer active and loses focus.
     * @property {Symbol} UIApplicationWillTerminate Posted when the app is about to terminate.
     * @property {Symbol} UIContentSizeCategoryDidChange Posted when the user changes the preferred content size setting. 
     * @property {Symbol} UIDeviceProximityStateDidChange Posted when the state of the proximity sensor changes.
     * @property {Symbol} UIScreenBrightnessDidChange This notification is posted when the brightness of a screen changes. The object of the notification is the UIScreen object whose brightness property changed. There is no userInfo dictionary. 
     * @property {Symbol} UIScreenDidConnect This notification is posted when a new screen is connected to the device. The object of the notification is the UIScreen object representing the new screen. There is no userInfo dictionary. 
     * @property {Symbol} UIScreenDidDisconnect This notification is posted when a screen is disconnected from the device. The object of the notification is the UIScreen object that represented the now disconnected screen. There is no userInfo dictionary. 
     * @property {Symbol} UIScreenModeDidChange This notification is posted when the current mode of a screen changes. The object of the notification is the UIScreen object whose currentMode property changed. There is no userInfo dictionary. 
     * @property {Symbol} UITableViewSelectionDidChange Posted when the selected row in the posting table view changes.
     * @property {Symbol} UITextFieldTextDidBeginEditing Notifies observers that an editing session began in a text field. The affected text field is stored in the object parameter of the notification. The userInfo dictionary is not used.
     * @property {Symbol} UITextFieldTextDidChange Notifies observers that the text in a text field changed. The affected text field is stored in the object parameter of the notification. 
     * @property {Symbol} UITextFieldTextDidEndEditing Notifies observers that the editing session ended for a text field. The affected text field is stored in the object parameter of the notification. The userInfo dictionary is not used.
     * @property {Symbol} UITextInputCurrentInputModeDidChange Posted when the current input mode changes.
     * @property {Symbol} UITextViewTextDidBeginEditing Notifies observers that an editing session began in a text view. The affected view is stored in the object parameter of the notification. The userInfo dictionary is not used.
     * @property {Symbol} UITextViewTextDidChange Notifies observers that the text in a text view changed. The affected view is stored in the object parameter of the notification. The userInfo dictionary is not used.
     * @property {Symbol} UITextViewTextDidEndEditing Notifies observers that the editing session ended for a text view. The affected view is stored in the object parameter of the notification. The userInfo dictionary is not used.
     * @property {Symbol} UIViewControllerShowDetailTargetDidChange Posted when a split view controller is expanded or collapsed.
     * @property {Symbol} UIWindowDidBecomeHidden Posted when an UIWindow object becomes hidden.
     * @property {Symbol} UIWindowDidBecomeKey Posted whenever a UIWindow object becomes the key window.
     * @property {Symbol} UIWindowDidBecomeVisible Posted when an UIWindow object becomes visible.
     * @property {Symbol} UIWindowDidResignKey Posted whenever a UIWindow object resigns its status as main window.
     * @property {Symbol} ALAssetsLibraryChanged Sent when the contents of the assets library have changed from under the app that is using the data.
     * @property {Symbol} AVCaptureDeviceSubjectAreaDidChange Posted when the instance of AVCaptureDevice has detected a substantial change to the video subject area.
     * @property {Symbol} AVCaptureSessionInterruptionEnded Posted if an interruption to a capture session finishes.
     * @property {Symbol} AVCaptureSessionWasInterrupted Posted if a capture session is interrupted.
     * @property {Symbol} CTRadioAccessTechnologyDidChange 
     * @property {Symbol} MFMessageComposeViewControllerTextMessageAvailabilityDidChange Posted when the value returned by the canSendText() class method has changed.
     * @property {Symbol} MPMediaLibraryDidChange Indicates the media library has changed.
     * @property {Symbol} MPMediaPlaybackIsPreparedToPlayDidChange Indicates that the prepared to play status of the media player has changed.
     * @property {Symbol} MPMusicPlayerControllerNowPlayingItemDidChange Posted when the currently playing media item has changed.
     * @property {Symbol} MPMusicPlayerControllerPlaybackStateDidChange Posted when the playback state has been changed programmatically or by user action.
     * @property {Symbol} MPMusicPlayerControllerVolumeDidChange Posted when the audio playback volume for the music player has changed.
     * @property {Symbol} MPVolumeViewWirelessRouteActiveDidChange Indicates the active wireless route changed.
     * @property {Symbol} MPVolumeViewWirelessRoutesAvailableDidChange Indicates the available wireless routes changed.
     * @property {Symbol} NKIssueDownloadCompleted Posted when all assets of the issue have been downloaded.
     * @property {Symbol} UIApplicationBackgroundRefreshStatusDidChange Posted when the app’s status for downloading content in the background changes.
     * @property {Symbol} UIApplicationDidChangeStatusBarFrame Posted when the frame of the status bar changes.
     * @property {Symbol} UIApplicationDidChangeStatusBarOrientation Posted when the orientation of the app’s user interface changes.
     * @property {Symbol} UIApplicationWillChangeStatusBarFrame Posted when the app is about to change the frame of the status bar.
     * @property {Symbol} UIApplicationWillChangeStatusBarOrientation Posted when the app is about to change the orientation of its interface.
     * @property {Symbol} UIDeviceBatteryLevelDidChange Posted when the battery level changes.
     * @property {Symbol} UIDeviceBatteryStateDidChange Posted when battery state changes.
     * @property {Symbol} UIDeviceOrientationDidChange Posted when the orientation of the device changes.
     * @property {Symbol} UIDocumentStateChanged Posted by the document object when there is a change in the state of the document.
     * @property {Symbol} UIKeyboardDidChangeFrame Posted immediately after a change in the keyboard’s frame.
     * @property {Symbol} UIKeyboardDidHide Posted immediately after the dismissal of the keyboard.
     * @property {Symbol} UIKeyboardDidShow Posted immediately after the display of the keyboard.
     * @property {Symbol} UIKeyboardWillChangeFrame Posted immediately prior to a change in the keyboard’s frame.
     * @property {Symbol} UIKeyboardWillHide Posted immediately prior to the dismissal of the keyboard.
     * @property {Symbol} UIKeyboardWillShow Posted immediately prior to the display of the keyboard.
     * @property {Symbol} UIMenuControllerDidHideMenu Posted by the menu controller just after it hides the menu.
     * @property {Symbol} UIMenuControllerDidShowMenu Posted by the menu controller just after it shows the menu.
     * @property {Symbol} UIMenuControllerMenuFrameDidChange Posted when the frame of a visible menu changes.
     * @property {Symbol} UIMenuControllerWillHideMenu Posted by the menu controller just before it hides the menu.
     * @property {Symbol} UIMenuControllerWillShowMenu Posted by the menu controller just before it shows the menu.
     * @property {Symbol} UIPasteboardChanged Posted by a pasteboard object when its contents change.
     * @property {Symbol} UIPasteboardRemoved Posted by a pasteboard object just before an app removes it.
     * @property {Symbol} UIApplicationProtectedDataDidBecomeAvailable Posted when the protected files become available for your code to access.
     * @property {Symbol} UIApplicationProtectedDataWillBecomeUnavailable Posted shortly before protected files are locked down and become inaccessible.
     * @property {Symbol} didChangeAutomaticTextCompletionNotification 
     * @property {Symbol} MPMusicPlayerControllerQueueDidChange Indicates the music player's queue changed.
     * @property {Symbol} GKPlayerAuthenticationDidChangeNotificationName Posted after the isAuthenticated property of the shared local player object changes. The object property for this notification is a GKLocalPlayer object. Passing nil provides standard Notification Center behavior which is to receive the notification for any object.
     * @property {Symbol} GKPlayerDidChangeNotificationName Posted when a player object’s data changes.
     * @property {Symbol} NEDNSProxyConfigurationDidChange 
     * @property {Symbol} SKStorefrontCountryCodeDidChange 
     * @property {Symbol} UIAccessibilityVoiceOverStatusDidChange 
     * @property {Symbol} UIFocusDidUpdate 
     * @property {Symbol} UIFocusMovementDidFail 
     * @property {Symbol} init 
     * @property {Symbol} initrawValue 
     * @property {Symbol} initnameobjectuserInfo Initializes a new notification.
     * @property {Symbol} Notification.Name An alias for a type used to represent the name of a notification.
     * @see https://developer.apple.com/documentation/foundation/nsnotification.name
     */

  }], [{
    key: 'Name',
    get: function get() {
      return _Name;
    }
  }]);

  return NSNotification;
}(_NSObject3.default);

exports.default = NSNotification;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _GCController = __webpack_require__(29);

var _GCController2 = _interopRequireDefault(_GCController);

var _GCControllerButtonInput = __webpack_require__(30);

var _GCControllerButtonInput2 = _interopRequireDefault(_GCControllerButtonInput);

var _GCControllerDirectionPad = __webpack_require__(38);

var _GCControllerDirectionPad2 = _interopRequireDefault(_GCControllerDirectionPad);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import GCGamepadValueChangedHandler from './GCGamepadValueChangedHandler'


//import GCGamepadSnapshot from './GCGamepadSnapshot'

var _defaultMapping = {
  A: 0,
  B: 1,
  X: 2,
  Y: 3,
  L1: 4,
  R1: 5,
  UP: 12,
  DOWN: 13,
  LEFT: 14,
  RIGHT: 15
};

if (typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Firefox') !== -1) {
  // Is this a bug or something?
  _defaultMapping.A = 1;
  _defaultMapping.B = 2;
  _defaultMapping.X = 0;
  _defaultMapping.Y = 3;
  _defaultMapping.UP = 14;
  _defaultMapping.DOWN = 15;
  _defaultMapping.LEFT = 16;
  _defaultMapping.RIGHT = 17;
}

/**
 * The standard set of gamepad controls. 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad
 */

var GCGamepad = function (_NSObject) {
  _inherits(GCGamepad, _NSObject);

  /**
   * constructor
   * @access public
   */
  function GCGamepad() {
    _classCallCheck(this, GCGamepad);

    // Determining the Controller That Owns This Profile

    var _this = _possibleConstructorReturn(this, (GCGamepad.__proto__ || Object.getPrototypeOf(GCGamepad)).call(this));

    _this._controller = null;

    // Determining When Any Element in the Profile Changes

    /**
     * A block called when any element in the profile changes.
     * @type {?GCGamepadValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497421-valuechangedhandler
     */
    _this.valueChangedHandler = null;

    // Reading Shoulder Button Inputs

    _this._leftShoulder = new _GCControllerButtonInput2.default();
    _this._rightShoulder = new _GCControllerButtonInput2.default();

    // Reading Directional Pad Inputs

    /**
     * @type {GCControllerDirectionPad}
     */
    _this._dpad = new _GCControllerDirectionPad2.default();

    // Reading Face Button Inputs

    _this._buttonA = new _GCControllerButtonInput2.default();
    _this._buttonB = new _GCControllerButtonInput2.default();
    _this._buttonX = new _GCControllerButtonInput2.default();
    _this._buttonY = new _GCControllerButtonInput2.default();

    _this._buttonMapping = new Map([[_this._leftShoulder, _defaultMapping.L1], [_this._rightShoulder, _defaultMapping.R1], [_this._buttonA, _defaultMapping.A], [_this._buttonB, _defaultMapping.B], [_this._buttonX, _defaultMapping.X], [_this._buttonY, _defaultMapping.Y]]);
    _this._dpadMapping = new Map([[_this._dpad._up, _defaultMapping.UP], [_this._dpad._down, _defaultMapping.DOWN], [_this._dpad._left, _defaultMapping.LEFT], [_this._dpad._right, _defaultMapping.RIGHT]]);
    return _this;
  }

  _createClass(GCGamepad, [{
    key: '_update',
    value: function _update() {
      var _this2 = this;

      this._buttonMapping.forEach(function (index, c) {
        c._value = _this2._controller._state.buttons[index];
        c._isPressed = _this2._controller._state.pressed[index];
      });
      this._dpadMapping.forEach(function (index, c) {
        c._value = _this2._controller._state.buttons[index];
        c._isPressed = _this2._controller._state.pressed[index];
      });
      this._dpad._xAxis._value = this._dpad._right._value - this._dpad._left._value;
      this._dpad._yAxis._value = this._dpad._down._value - this._dpad._up._value;

      this._buttonMapping.forEach(function (index, c) {
        if (c.pressedChangedHandler && _this2._controller._updated.pressed[index]) {
          c.pressedChangedHandler(c, c._value, c._isPressed);
        }
        if (_this2._controller._updated.buttons[index]) {
          if (c.valueChangedHandler) {
            c.valueChangedHandler(c, c._value, c._isPressed);
          }
          if (_this2.valueChangedHandler) {
            _this2.valueChangedHandler(_this2, c);
          }
        }
      });
      var dpadChanged = false;
      this._dpadMapping.forEach(function (index, c) {
        if (_this2._controller._updated.pressed[index]) {
          dpadChanged = true;
          if (c.pressedChangedHandler) {
            c.pressedChangedHandler(c, c._value, c._isPressed);
          }
        }
        if (_this2._controller._updated.buttons[index]) {
          dpadChanged = true;
          if (c.valueChangedHandler) {
            c.valueChangedHandler(c, c._value, c._isPressed);
          }
          if (_this2.valueChangedHandler) {
            _this2.valueChangedHandler(_this2, c);
          }
        }
      });
      if (dpadChanged) {
        if (this._dpad.valueChangedHandler) {
          this._dpad.valueChangedHandler(this._dpad, this._dpad._xAxis.value, this._dpad._yAxis.value);
        }
        if (this.valueChangedHandler) {
          this.valueChangedHandler(this, this._dpad);
        }
      }
    }
  }, {
    key: '_getValue',
    value: function _getValue(button) {
      var index = this._buttonMapping.get(button);
      if (typeof index === 'undefined') {
        index = this._dpadMapping.get(button);
      }
      if (typeof index === 'undefined') {
        return null;
      }

      return this._controller._state.buttons[index];
    }

    // Determining the Controller That Owns This Profile

    /**
     * The controller this profile is associated with.
     * @type {?GCController}
     * @desc 
     * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497428-controller
     */

  }, {
    key: 'saveSnapshot',


    // Saving a Snapshot

    /**
     * Saves a snapshot of all of the profile’s elements.
     * @access public
     * @returns {GCGamepadSnapshot} - 
     * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497415-savesnapshot
     */
    value: function saveSnapshot() {
      return null;
    }
  }, {
    key: 'controller',
    get: function get() {
      return this._controller;
    }

    // Reading Shoulder Button Inputs

    /**
     * The left shoulder button element.
     * @type {GCControllerButtonInput}
     * @desc The shoulder buttons in the gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497423-leftshoulder
     */

  }, {
    key: 'leftShoulder',
    get: function get() {
      return this._leftShoulder;
    }

    /**
     * The right shoulder button element.
     * @type {GCControllerButtonInput}
     * @desc The shoulder buttons in the gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497429-rightshoulder
     */

  }, {
    key: 'rightShoulder',
    get: function get() {
      return this._rightShoulder;
    }

    // Reading Directional Pad Inputs

    /**
     * The D-pad element.
     * @type {GCControllerDirectionPad}
     * @desc The directional pad in the gamepad profile is an analog control.
     * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497425-dpad
     */

  }, {
    key: 'dpad',
    get: function get() {
      return this._dpad;
    }

    // Reading Face Button Inputs

    /**
     * The bottom face button.
     * @type {GCControllerButtonInput}
     * @desc The face buttons in the gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497427-buttona
     */

  }, {
    key: 'buttonA',
    get: function get() {
      return this._buttonA;
    }

    /**
     * The right face button.
     * @type {GCControllerButtonInput}
     * @desc The face buttons in the gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497418-buttonb
     */

  }, {
    key: 'buttonB',
    get: function get() {
      return this._buttonB;
    }

    /**
     * The left face button.
     * @type {GCControllerButtonInput}
     * @desc The face buttons in the gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497417-buttonx
     */

  }, {
    key: 'buttonX',
    get: function get() {
      return this._buttonX;
    }

    /**
     * The top face button.
     * @type {GCControllerButtonInput}
     * @desc The face buttons in the gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcgamepad/1497431-buttony
     */

  }, {
    key: 'buttonY',
    get: function get() {
      return this._buttonY;
    }
  }]);

  return GCGamepad;
}(_NSObject3.default);

exports.default = GCGamepad;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GCControllerElement2 = __webpack_require__(31);

var _GCControllerElement3 = _interopRequireDefault(_GCControllerElement2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import GCControllerAxisValueChangedHandler from '../undefined/GCControllerAxisValueChangedHandler'

/**
 * A control element measuring movement along a particular axis.
 * @access public
 * @extends {GCControllerElement}
 * @see https://developer.apple.com/documentation/gamecontroller/gccontrolleraxisinput
 */
var GCControllerAxisInput = function (_GCControllerElement) {
  _inherits(GCControllerAxisInput, _GCControllerElement);

  /**
   * constructor
   * @access public
   */
  function GCControllerAxisInput() {
    _classCallCheck(this, GCControllerAxisInput);

    // Polling the Axis’ Value

    var _this = _possibleConstructorReturn(this, (GCControllerAxisInput.__proto__ || Object.getPrototypeOf(GCControllerAxisInput)).call(this));

    _this._value = 0;

    // Receiving Notifications When the Axis’ Value Changes

    /**
     * A handler to be called when the axis changes value.
     * @type {?GCControllerAxisValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gccontrolleraxisinput/1500221-valuechangedhandler
     */
    _this.valueChangedHandler = null;
    return _this;
  }

  // Polling the Axis’ Value

  /**
   * The current value of the axis.
   * @type {number}
   * @desc On a physical controller, it is common for a portion of the physical control’s moment to be ignored near its neutral position. This part of the control is known as its deadzone. The GCControllerAxisInput element handles the deadzone and other physical constraints of the hardware control and computes a normalized value. The value is in a range from -1 to 1.   If the value is 0, then the movement is in the deadzone. A non-zero value indicates the moment is outside of the deadzone. The value is normalized so that no values are lost because of the deadzone.
   * @see https://developer.apple.com/documentation/gamecontroller/gccontrolleraxisinput/1500224-value
   */


  _createClass(GCControllerAxisInput, [{
    key: 'value',
    get: function get() {
      return this._value;
    }
  }]);

  return GCControllerAxisInput;
}(_GCControllerElement3.default);

exports.default = GCControllerAxisInput;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _GCControllerButtonInput = __webpack_require__(30);

var _GCControllerButtonInput2 = _interopRequireDefault(_GCControllerButtonInput);

var _GCControllerDirectionPad = __webpack_require__(38);

var _GCControllerDirectionPad2 = _interopRequireDefault(_GCControllerDirectionPad);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import GCController from './GCController'
//import GCExtendedGamepadValueChangedHandler from './GCExtendedGamepadValueChangedHandler'


//import GCExtendedGamepadSnapshot from './GCExtendedGamepadSnapshot'

/**
 * The extended set of gamepad controls.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad
 */
var GCExtendedGamepad = function (_NSObject) {
  _inherits(GCExtendedGamepad, _NSObject);

  /**
   * constructor
   * @access public
   */
  function GCExtendedGamepad() {
    _classCallCheck(this, GCExtendedGamepad);

    // Determining the Controller That Owns This Profile

    var _this = _possibleConstructorReturn(this, (GCExtendedGamepad.__proto__ || Object.getPrototypeOf(GCExtendedGamepad)).call(this));

    _this._controller = null;

    // Determining When Any Element in the Profile Changes

    /**
     * A block called when any element in the profile changes values.
     * @type {?GCExtendedGamepadValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522464-valuechangedhandler
     */
    _this.valueChangedHandler = null;

    // Reading Shoulder Button Inputs

    _this._leftShoulder = new _GCControllerButtonInput2.default();
    _this._rightShoulder = new _GCControllerButtonInput2.default();

    // Reading Directional Pad Inputs

    _this._dpad = new _GCControllerDirectionPad2.default();

    // Reading Face Button Inputs

    _this._buttonA = new _GCControllerButtonInput2.default();
    _this._buttonB = new _GCControllerButtonInput2.default();
    _this._buttonX = new _GCControllerButtonInput2.default();
    _this._buttonY = new _GCControllerButtonInput2.default();

    // Reading Thumbstick Inputs

    _this._leftThumbstick = new _GCControllerDirectionPad2.default();
    _this._rightThumbstick = new _GCControllerDirectionPad2.default();

    // Reading Trigger Inputs

    _this._leftTrigger = new _GCControllerButtonInput2.default();
    _this._rightTrigger = new _GCControllerButtonInput2.default();
    return _this;
  }

  _createClass(GCExtendedGamepad, [{
    key: '_update',
    value: function _update() {}

    // Determining the Controller That Owns This Profile

    /**
     * The controller this profile is associated with.
     * @type {?GCController}
     * @desc 
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522427-controller
     */

  }, {
    key: 'saveSnapshot',


    // Saving a Snapshot

    /**
     * Saves a snapshot of all of the profile’s elements.
     * @access public
     * @returns {GCExtendedGamepadSnapshot} - 
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522447-savesnapshot
     */
    value: function saveSnapshot() {
      return null;
    }
  }, {
    key: 'controller',
    get: function get() {
      return this._controller;
    }

    // Reading Shoulder Button Inputs

    /**
     * The left shoulder button element.
     * @type {GCControllerButtonInput}
     * @desc The shoulder buttons in the extended gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522418-leftshoulder
     */

  }, {
    key: 'leftShoulder',
    get: function get() {
      return this._leftShoulder;
    }

    /**
     * The right shoulder button element.
     * @type {GCControllerButtonInput}
     * @desc The shoulder buttons in the extended gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522484-rightshoulder
     */

  }, {
    key: 'rightShoulder',
    get: function get() {
      return this._rightShoulder;
    }

    // Reading Directional Pad Inputs

    /**
     * The d-pad element.
     * @type {GCControllerDirectionPad}
     * @desc The directional pad in the extended gamepad profile is an analog control.
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522422-dpad
     */

  }, {
    key: 'dpad',
    get: function get() {
      return this._dpad;
    }

    // Reading Face Button Inputs

    /**
     * The bottom face button.
     * @type {GCControllerButtonInput}
     * @desc The face buttons in the extended gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522558-buttona
     */

  }, {
    key: 'buttonA',
    get: function get() {
      return this._buttonA;
    }

    /**
     * The right face button.
     * @type {GCControllerButtonInput}
     * @desc The face buttons in the extended gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522396-buttonb
     */

  }, {
    key: 'buttonB',
    get: function get() {
      return this._buttonB;
    }

    /**
     * The left face button.
     * @type {GCControllerButtonInput}
     * @desc The face buttons in the extended gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522567-buttonx
     */

  }, {
    key: 'buttonX',
    get: function get() {
      return this._buttonX;
    }

    /**
     * The top face button.
     * @type {GCControllerButtonInput}
     * @desc The face buttons in the extended gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522473-buttony
     */

  }, {
    key: 'buttonY',
    get: function get() {
      return this._buttonY;
    }

    // Reading Thumbstick Inputs

    /**
     * The left thumbstick element.
     * @type {GCControllerDirectionPad}
     * @desc The thumbsticks in the extended gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522564-leftthumbstick
     */

  }, {
    key: 'leftThumbstick',
    get: function get() {
      return this._leftThumbstick;
    }

    /**
     * The right thumbstick element.
     * @type {GCControllerDirectionPad}
     * @desc The thumbsticks in the extended gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522437-rightthumbstick
     */

  }, {
    key: 'rightThumbstick',
    get: function get() {
      return this._rightThumbstick;
    }

    // Reading Trigger Inputs

    /**
     * The left trigger element.
     * @type {GCControllerButtonInput}
     * @desc The triggers in the extended gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522569-lefttrigger
     */

  }, {
    key: 'leftTrigger',
    get: function get() {
      return this._leftTrigger;
    }

    /**
     * The right trigger element.
     * @type {GCControllerButtonInput}
     * @desc The triggers in the extended gamepad profile are analog buttons.
     * @see https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad/1522563-righttrigger
     */

  }, {
    key: 'rightTrigger',
    get: function get() {
      return this._rightTrigger;
    }
  }]);

  return GCExtendedGamepad;
}(_NSObject3.default);

exports.default = GCExtendedGamepad;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import GCController from './GCController'
//import GCMicroGamepadValueChangedHandler from './GCMicroGamepadValueChangedHandler'
//import GCControllerDirectionPad from './GCControllerDirectionPad'
//import GCControllerButtonInput from './GCControllerButtonInput'
//import GCMicroGamepadSnapshot from './GCMicroGamepadSnapshot'


/**
 * The controls provided by the Siri Remote.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad
 */
var GCMicroGamepad = function (_NSObject) {
  _inherits(GCMicroGamepad, _NSObject);

  /**
   * constructor
   * @access public
   */
  function GCMicroGamepad() {
    _classCallCheck(this, GCMicroGamepad);

    // Determining the Controller That Owns This Profile

    var _this = _possibleConstructorReturn(this, (GCMicroGamepad.__proto__ || Object.getPrototypeOf(GCMicroGamepad)).call(this));

    _this._controller = null;

    // Determining When Any Element in the Profile Changes

    /**
     * A block called when any element in the profile changes.
     * @type {?GCMicroGamepadValueChangedHandler}
     * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627758-valuechangedhandler
     */
    _this.valueChangedHandler = null;

    // Reading Directional Pad Inputs

    /**
     * A Boolean value that indicates whether the D-pad reports absolute or relative values.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627757-reportsabsolutedpadvalues
     */
    _this.reportsAbsoluteDpadValues = false;

    /**
     * A Boolean value that indicates whether the D-pad’s values are calculated relative to its current orientation.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627755-allowsrotation
     */
    _this.allowsRotation = false;

    _this._dpad = null;

    // Reading Face Button Inputs

    _this._buttonA = null;
    _this._buttonX = null;
    return _this;
  }

  // Determining the Controller That Owns This Profile
  /**
   * The controller this profile is associated with.
   * @type {?GCController}
   * @desc 
   * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627756-controller
   */


  _createClass(GCMicroGamepad, [{
    key: 'saveSnapshot',


    // Saving a Snapshot

    /**
     * Saves a snapshot of all of the profile’s elements.
     * @access public
     * @returns {GCMicroGamepadSnapshot} - 
     * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627754-savesnapshot
     */
    value: function saveSnapshot() {
      return null;
    }
  }, {
    key: 'controller',
    get: function get() {
      return this._controller;
    }

    // Reading Directional Pad Inputs
    /**
     * The D-pad element.
     * @type {GCControllerDirectionPad}
     * @desc The directional pad in the micro gamepad profile reports analog directional information.
     * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627763-dpad
     */

  }, {
    key: 'dpad',
    get: function get() {
      return this._dpad;
    }

    // Reading Face Button Inputs
    /**
     * The first button.
     * @type {GCControllerButtonInput}
     * @desc Button A is usually activated by a harder press on the touchpad. The button is always digital.
     * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627762-buttona
     */

  }, {
    key: 'buttonA',
    get: function get() {
      return this._buttonA;
    }
    /**
     * The secondary button.
     * @type {GCControllerButtonInput}
     * @desc The secondary button is always digital.
     * @see https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/1627759-buttonx
     */

  }, {
    key: 'buttonX',
    get: function get() {
      return this._buttonX;
    }
  }]);

  return GCMicroGamepad;
}(_NSObject3.default);

exports.default = GCMicroGamepad;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSObject}
 */
var NSArray = function (_NSObject) {
  _inherits(NSArray, _NSObject);

  function NSArray() {
    _classCallCheck(this, NSArray);

    return _possibleConstructorReturn(this, (NSArray.__proto__ || Object.getPrototypeOf(NSArray)).apply(this, arguments));
  }

  _createClass(NSArray, null, [{
    key: 'initWithCoder',

    /**
     * @access public
     * @param {NSCoder} coder -
     * @returns {Object[]} -
     */
    value: function initWithCoder(coder) {
      var arr = [];
      if (typeof coder._refObj['NS.objects'] !== 'undefined') {
        var objects = coder._refObj['NS.objects'];
        if (!Array.isArray(objects)) {
          throw new Error('NS.objects must be Array');
        }

        var objCoder = coder.copy();
        objCoder._refObj = objects;

        for (var i = 0; i < objects.length; i++) {
          var obj = objCoder.decodeObjectForKey(i);
          arr.push(obj);
        }
      } else {
        for (var _i = 0;; _i++) {
          var key = 'NS.object.' + _i;
          if (typeof coder._refObj[key] === 'undefined') {
            break;
          }
          var _obj = coder.decodeObjectForKey(key);
          arr.push(_obj);
        }
      }

      return arr;
    }
  }]);

  return NSArray;
}(_NSObject3.default);

exports.default = NSArray;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSObject}
 */
var NSDictionary = function (_NSObject) {
  _inherits(NSDictionary, _NSObject);

  function NSDictionary() {
    _classCallCheck(this, NSDictionary);

    return _possibleConstructorReturn(this, (NSDictionary.__proto__ || Object.getPrototypeOf(NSDictionary)).apply(this, arguments));
  }

  _createClass(NSDictionary, null, [{
    key: 'initWithCoder',

    /**
     * @access public
     * @param {NSCoder} coder -
     * @returns {Object} -
     */
    value: function initWithCoder(coder) {
      var dict = {};
      if (typeof coder._refObj['NS.objects'] !== 'undefined') {
        var keys = coder._refObj['NS.keys'];
        var objects = coder._refObj['NS.objects'];
        if (!Array.isArray(keys)) {
          throw new Error('NS.keys must be Array');
        }
        if (!Array.isArray(objects)) {
          throw new Error('NS.objects must be Array');
        }
        if (keys.length !== objects.length) {
          throw new Error('NS.keys.length !== NS.objects.length');
        }

        var keyCoder = coder.copy();
        keyCoder._refObj = keys;

        var objCoder = coder.copy();
        objCoder._refObj = objects;

        for (var i = 0; i < keys.length; i++) {
          var key = keyCoder.decodeObjectForKey(i);
          var obj = objCoder.decodeObjectForKey(i);
          dict[key] = obj;
        }
      } else {
        for (var _i = 0;; _i++) {
          var objKey = 'NS.object.' + _i;
          var keyKey = 'NS.key.' + _i;
          if (typeof coder._refObj[objKey] === 'undefined') {
            break;
          }
          var _key = coder.decodeObjectForKey(keyKey);
          var _obj = coder.decodeObjectForKey(objKey);
          dict[_key] = _obj;
        }
      }

      return dict;
    }
  }]);

  return NSDictionary;
}(_NSObject3.default);

exports.default = NSDictionary;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ecl = __webpack_require__(70);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*global Buffer*/

/**
 * BinaryReader class
 * @access public
 */
var _BinaryReader = function () {
  /**
   * constructor
   * @param {Buffer|ArrayBuffer} data - 
   * @param {boolean} bigEndian -
   * @param {string} encoding -
   * @constructor
   */
  function _BinaryReader(data) {
    var bigEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    _classCallCheck(this, _BinaryReader);

    /**
     * @access private
     * @type {number}
     */
    this._pos = 0;

    /**
     * @access private
     * @type {boolean}
     */
    this._eof = true;

    /**
     *
     * @access public
     * @type {Buffer}
     */
    this.buffer = null;

    if (data instanceof Buffer) {
      this.buffer = data;
    } else if (typeof data === 'string') {
      this.buffer = Buffer.from(data, 'binary');
    } else {
      this.buffer = Buffer.from(data);
    }

    /**
     *
     * @access public
     * @type {boolean}
     */
    this.bigEndian = bigEndian;

    /**
     *
     * @access public
     * @type {string}
     */
    this.encoding = encoding;
  }

  /**
   * @access public
   * @param {number} length - length of data to skip
   * @param {boolean} noAssert -
   * @returns {void}
   */


  _createClass(_BinaryReader, [{
    key: 'skip',
    value: function skip(length) {
      var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this._pos += length;
      if (!noAssert) {
        this._check();
      }
    }

    /**
     * @access public
     * @param {number} pos -
     * @returns {void}
     */

  }, {
    key: 'seek',
    value: function seek(pos) {
      if (pos < 0) {
        this._pos = this.buffer.length + pos;
      } else {
        this._pos = pos;
      }

      if (this._pos < 0) {
        this._pos = 0;
      } else if (this._pos > this.buffer.length) {
        this._pos = this.buffer.length;
      }
    }

    /**
     *
     * @access public
     * @param {number} length - length of data to read
     * @param {?string} [encoding = null] -
     * @returns {string} -
     */

  }, {
    key: 'readString',
    value: function readString(length) {
      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var start = this._pos;
      this._pos += length;
      var _encoding = encoding || this.encoding || 'sjis';
      //if(_Buffer.isEncoding(_encoding)){
      if (Buffer.isEncoding(_encoding)) {
        return this.buffer.toString(_encoding, start, this._pos);
      }

      var data = this.buffer.toString('binary', start, this._pos);
      return this._convert(data, _encoding);
    }

    /**
     *
     * @access public
     * @param {number} length - 
     * @param {boolean} signed -
     * @returns {number} -
     */

  }, {
    key: 'readInteger',
    value: function readInteger(length, signed) {
      var start = this._pos;
      this._pos += length;

      // big endian
      if (this.bigEndian) {
        if (signed) {
          return this.buffer.readIntBE(start, length);
        }
        return this.buffer.readUIntBE(start, length);
      }

      // little endian
      if (signed) {
        return this.buffer.readIntLE(start, length);
      }
      return this.buffer.readUIntLE(start, length);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readUnsignedByte',
    value: function readUnsignedByte() {
      return this.readInteger(1, false);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readUnsignedShort',
    value: function readUnsignedShort() {
      return this.readInteger(2, false);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readUnsignedInt',
    value: function readUnsignedInt() {
      return this.readInteger(4, false);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readUnsignedLongLong',
    value: function readUnsignedLongLong() {
      return this.readInteger(8, false);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readByte',
    value: function readByte() {
      return this.readInteger(1, true);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readShort',
    value: function readShort() {
      return this.readInteger(2, true);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readInt',
    value: function readInt() {
      return this.readInteger(4, true);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readLongLong',
    value: function readLongLong() {
      return this.readInteger(8, true);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readFloat',
    value: function readFloat() {
      var start = this._pos;
      this._pos += 4;
      if (this.bigEndian) {
        return this.buffer.readFloatBE(start);
      }

      return this.buffer.readFloatLE(start);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readDouble',
    value: function readDouble() {
      var start = this._pos;
      this._pos += 8;
      if (this.bigEndian) {
        return this.buffer.readDoubleBE(start);
      }

      return this.buffer.readDoubleLE(start);
    }

    /**
     *
     * @access public
     * @param {number} length -
     * @returns {Buffer} -
     */

  }, {
    key: 'readData',
    value: function readData(length) {
      var start = this._pos;
      this._pos += length;
      return this.buffer.slice(start, this._pos);
    }

    /**
     *
     * @access private
     * @returns {void}
     */

  }, {
    key: '_check',
    value: function _check() {
      if (this._pos >= this.buffer.length) {
        throw new Error('_BinaryReader: buffer out of range (' + this._pos + ' >= ' + this.buffer.length + ')');
      }
    }

    /**
     *
     * @access private
     * @param {number[]} data - length of data to convert
     * @param {?string} [encoding = null] -
     * @returns {string} -
     */

  }, {
    key: '_convert',
    value: function _convert(data, encoding) {
      var length = data.length;
      var escapeString = '';
      for (var i = 0; i < length; i++) {
        var charCode = data.charCodeAt(i);
        if (charCode === 0) {
          break;
        } else if (charCode < 16) {
          escapeString += '%0' + charCode.toString(16);
        } else {
          escapeString += '%' + charCode.toString(16);
        }
      }

      if (encoding === 'sjis') {
        return (0, _ecl.UnescapeSJIS)(escapeString);
      } else if (encoding === 'euc-jp') {
        return (0, _ecl.UnescapeEUCJP)(escapeString);
      } else if (encoding === 'jis-7') {
        return (0, _ecl.UnescapeJIS7)(escapeString);
      } else if (encoding === 'jis-8') {
        return (0, _ecl.UnescapeJIS8)(escapeString);
      } else if (encoding === 'unicode') {
        return (0, _ecl.UnescapeUnicode)(escapeString);
      } else if (encoding === 'utf7') {
        return (0, _ecl.UnescapeUTF7)(escapeString);
      } else if (encoding === 'utf-8') {
        return (0, _ecl.UnescapeUTF8)(escapeString);
      } else if (encoding === 'utf-16') {
        return (0, _ecl.UnescapeUTF16LE)(escapeString);
      }

      throw new Error('unsupported encoding: ' + encoding);
    }
  }, {
    key: 'getAvailableDataLength',
    value: function getAvailableDataLength() {
      return this.buffer.length - this._pos;
    }
  }, {
    key: 'length',
    get: function get() {
      return this.buffer.length;
    }
  }]);

  return _BinaryReader;
}();

exports.default = _BinaryReader;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21).Buffer))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
//
// Escape Codec Library: ecl.js (Ver.041208)
//
// Copyright (C) http://nurucom-archives.hp.infoseek.co.jp/digital/
//

var EscapeSJIS = function EscapeSJIS(str) {
	return str.replace(/[^*+.-9A-Z_a-z-]/g, function (s) {
		var c = s.charCodeAt(0),
		    m;
		return c < 128 ? (c < 16 ? "%0" : "%") + c.toString(16).toUpperCase() : 65376 < c && c < 65440 ? "%" + (c - 65216).toString(16).toUpperCase() : (c = JCT11280.indexOf(s)) < 0 ? "%81E" : "%" + ((m = ((c < 8272 ? c : c = JCT11280.lastIndexOf(s)) - (c %= 188)) / 188) < 31 ? m + 129 : m + 193).toString(16).toUpperCase() + (64 < (c += c < 63 ? 64 : 65) && c < 91 || 95 == c || 96 < c && c < 123 ? String.fromCharCode(c) : "%" + c.toString(16).toUpperCase());
	});
};

var UnescapeSJIS = function UnescapeSJIS(str) {
	return str.replace(/%(8[1-9A-F]|[9E][0-9A-F]|F[0-9A-C])(%[4-689A-F][0-9A-F]|%7[0-9A-E]|[@-~])|%([0-7][0-9A-F]|A[1-9A-F]|[B-D][0-9A-F])/ig, function (s) {
		var c = parseInt(s.substring(1, 3), 16),
		    l = s.length;
		return 3 == l ? String.fromCharCode(c < 160 ? c : c + 65216) : JCT11280.charAt((c < 160 ? c - 129 : c - 193) * 188 + (4 == l ? s.charCodeAt(3) - 64 : (c = parseInt(s.substring(4), 16)) < 127 ? c - 64 : c - 65));
	});
};

var EscapeEUCJP = function EscapeEUCJP(str) {
	return str.replace(/[^*+.-9A-Z_a-z-]/g, function (s) {
		var c = s.charCodeAt(0);
		return (c < 128 ? (c < 16 ? "%0" : "%") + c.toString(16) : 65376 < c && c < 65440 ? "%8E%" + (c - 65216).toString(16) : (c = JCT8836.indexOf(s)) < 0 ? "%A1%A6" : "%" + ((c - (c %= 94)) / 94 + 161).toString(16) + "%" + (c + 161).toString(16)).toUpperCase();
	});
};

var UnescapeEUCJP = function UnescapeEUCJP(str) {
	return str.replace(/(%A[1-9A-F]|%[B-E][0-9A-F]|%F[0-9A-E]){2}|%8E%(A[1-9A-F]|[B-D][0-9A-F])|%[0-7][0-9A-F]/ig, function (s) {
		var c = parseInt(s.substring(1), 16);
		return c < 161 ? String.fromCharCode(c < 128 ? c : parseInt(s.substring(4), 16) + 65216) : JCT8836.charAt((c - 161) * 94 + parseInt(s.substring(4), 16) - 161);
	});
};

var EscapeJIS7 = function EscapeJIS7(str) {
	var u = String.fromCharCode,
	    ri = u(92, 120, 48, 48, 45, 92, 120, 55, 70),
	    rj = u(65377, 45, 65439, 93, 43),
	    H = function H(c) {
		return 41 < c && c < 58 && 44 != c || 64 < c && c < 91 || 95 == c || 96 < c && c < 123 ? u(c) : "%" + c.toString(16).toUpperCase();
	},
	    I = function I(s) {
		var c = s.charCodeAt(0);
		return (c < 16 ? "%0" : "%") + c.toString(16).toUpperCase();
	},
	    rI = new RegExp();rI.compile("[^*+.-9A-Z_a-z-]", "g");
	return ("g" + str + "g").replace(RegExp("[" + ri + "]+", "g"), function (s) {
		return "%1B%28B" + s.replace(rI, I);
	}).replace(RegExp("[" + rj, "g"), function (s) {
		var c,
		    i = 0,
		    t = "%1B%28I";while (c = s.charCodeAt(i++)) {
			t += H(c - 65344);
		}return t;
	}).replace(RegExp("[^" + ri + rj, "g"), function (s) {
		var a,
		    c,
		    i = 0,
		    t = "%1B%24B";while (a = s.charAt(i++)) {
			t += (c = JCT8836.indexOf(a)) < 0 ? "%21%26" : H((c - (c %= 94)) / 94 + 33) + H(c + 33);
		}return t;
	}).slice(8, -1);
};

var UnescapeJIS7 = function UnescapeJIS7(str) {
	var i = 0,
	    p,
	    q,
	    s = "",
	    u = String.fromCharCode,
	    P = ("%28B" + str.replace(/%49/g, "I").replace(/%1B%24%4[02]|%1B%24@/ig, "%1B%24B")).split(/%1B/i),
	    I = function I(s) {
		return u(parseInt(s.substring(1), 16));
	},
	    J = function J(s) {
		return u((3 == s.length ? parseInt(s.substring(1), 16) : s.charCodeAt(0)) + 65344);
	},
	    K = function K(s) {
		var l = s.length;
		return JCT8836.charAt(4 < l ? (parseInt(s.substring(1), 16) - 33) * 94 + parseInt(s.substring(4), 16) - 33 : 2 < l ? (37 == (l = s.charCodeAt(0)) ? (parseInt(s.substring(1, 3), 16) - 33) * 94 + s.charCodeAt(3) : (l - 33) * 94 + parseInt(s.substring(2), 16)) - 33 : (s.charCodeAt(0) - 33) * 94 + s.charCodeAt(1) - 33);
	},
	    rI = new RegExp(),
	    rJ = new RegExp(),
	    rK = new RegExp();
	rI.compile("%[0-7][0-9A-F]", "ig");rJ.compile("(%2[1-9A-F]|%[3-5][0-9A-F])|[!-_]", "ig");
	rK.compile("(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E]){2}|(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])[!-~]|[!-~](%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])|[!-~]{2}", "ig");
	while (p = P[i++]) {
		s += "%24B" == (q = p.substring(0, 4)) ? p.substring(4).replace(rK, K) : "%28I" == q ? p.substring(4).replace(rJ, J) : p.replace(rI, I).substring(2);
	}return s;
};

var EscapeJIS8 = function EscapeJIS8(str) {
	var u = String.fromCharCode,
	    r = u(92, 120, 48, 48, 45, 92, 120, 55, 70, 65377, 45, 65439, 93, 43),
	    H = function H(c) {
		return 41 < c && c < 58 && 44 != c || 64 < c && c < 91 || 95 == c || 96 < c && c < 123 ? u(c) : "%" + c.toString(16).toUpperCase();
	},
	    I = function I(s) {
		var c = s.charCodeAt(0);
		return (c < 16 ? "%0" : "%") + (c < 128 ? c : c - 65216).toString(16).toUpperCase();
	},
	    rI = new RegExp();rI.compile("[^*+.-9A-Z_a-z-]", "g");
	return ("g" + str + "g").replace(RegExp("[" + r, "g"), function (s) {
		return "%1B%28B" + s.replace(rI, I);
	}).replace(RegExp("[^" + r, "g"), function (s) {
		var a,
		    c,
		    i = 0,
		    t = "%1B%24B";while (a = s.charAt(i++)) {
			t += (c = JCT8836.indexOf(a)) < 0 ? "%21%26" : H((c - (c %= 94)) / 94 + 33) + H(c + 33);
		}return t;
	}).slice(8, -1);
};

var UnescapeJIS8 = function UnescapeJIS8(str) {
	var i = 0,
	    p,
	    s = "",
	    P = ("%28B" + str.replace(/%1B%24%4[02]|%1B%24@/ig, "%1B%24B")).split(/%1B/i),
	    I = function I(s) {
		var c = parseInt(s.substring(1), 16);
		return String.fromCharCode(c < 128 ? c : c + 65216);
	},
	    K = function K(s) {
		var l = s.length;
		return JCT8836.charAt(4 < l ? (parseInt(s.substring(1), 16) - 33) * 94 + parseInt(s.substring(4), 16) - 33 : 2 < l ? (37 == (l = s.charCodeAt(0)) ? (parseInt(s.substring(1, 3), 16) - 33) * 94 + s.charCodeAt(3) : (l - 33) * 94 + parseInt(s.substring(2), 16)) - 33 : (s.charCodeAt(0) - 33) * 94 + s.charCodeAt(1) - 33);
	},
	    rI = new RegExp(),
	    rK = new RegExp();
	rI.compile("%([0-7][0-9A-F]|A[1-9A-F]|[B-D][0-9A-F])", "ig");
	rK.compile("(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E]){2}|(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])[!-~]|[!-~](%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])|[!-~]{2}", "ig");
	while (p = P[i++]) {
		s += "%24B" == p.substring(0, 4) ? p.substring(4).replace(rK, K) : p.replace(rI, I).substring(2);
	}return s;
};

var EscapeUnicode = function EscapeUnicode(str) {
	return str.replace(/[^*+.-9A-Z_a-z-]/g, function (s) {
		var c = s.charCodeAt(0);
		return (c < 16 ? "%0" : c < 256 ? "%" : c < 4096 ? "%u0" : "%u") + c.toString(16).toUpperCase();
	});
};

var UnescapeUnicode = function UnescapeUnicode(str) {
	return str.replace(/%u[0-9A-F]{4}|%[0-9A-F]{2}/ig, function (s) {
		return String.fromCharCode("0x" + s.substring(s.length / 3));
	});
};

var EscapeUTF7 = function EscapeUTF7(str) {
	var B = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),
	    E = function E(s) {
		var c = s.charCodeAt(0);
		return B[c >> 10] + B[c >> 4 & 63] + B[(c & 15) << 2 | (c = s.charCodeAt(1)) >> 14] + (0 <= c ? B[c >> 8 & 63] + B[c >> 2 & 63] + B[(c & 3) << 4 | (c = s.charCodeAt(2)) >> 12] + (0 <= c ? B[c >> 6 & 63] + B[c & 63] : "") : "");
	},
	    re = new RegExp();re.compile("[^+]{1,3}", "g");
	return (str + "g").replace(/[^*+.-9A-Z_a-z-]+[*+.-9A-Z_a-z-]|[+]/g, function (s) {
		if ("+" == s) return "+-";
		var l = s.length - 1,
		    w = s.charAt(l);
		return "+" + s.substring(0, l).replace(re, E) + ("+" == w ? "-+-" : "*" == w || "." == w || "_" == w ? w : "-" + w);
	}).slice(0, -1);
};

var UnescapeUTF7 = function UnescapeUTF7(str) {
	var i = 0,
	    B = {};
	while (i < 64) {
		B["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(i)] = i++;
	}return str.replace(RegExp("[+][+/-9A-Za-z]*-?", "g"), function (s) {
		if ("+-" == s) return "+";
		var b = B[s.charAt(1)],
		    c,
		    i = 1,
		    t = "";
		while (0 <= b) {
			if ((c = i & 7) < 6) c = c < 3 ? b << 10 | B[s.charAt(++i)] << 4 | (b = B[s.charAt(++i)]) >> 2 : (b & 3) << 14 | B[s.charAt(++i)] << 8 | B[s.charAt(++i)] << 2 | (b = B[s.charAt(++i)]) >> 4;else {
				c = (b & 15) << 12 | B[s.charAt(++i)] << 6 | B[s.charAt(++i)];b = B[s.charAt(++i)];
			}
			if (c) t += String.fromCharCode(c);
		}
		return t;
	});
};

var EscapeUTF8 = function EscapeUTF8(str) {
	return str.replace(/[^*+.-9A-Z_a-z-]/g, function (s) {
		var c = s.charCodeAt(0);
		return (c < 16 ? "%0" + c.toString(16) : c < 128 ? "%" + c.toString(16) : c < 2048 ? "%" + (c >> 6 | 192).toString(16) + "%" + (c & 63 | 128).toString(16) : "%" + (c >> 12 | 224).toString(16) + "%" + (c >> 6 & 63 | 128).toString(16) + "%" + (c & 63 | 128).toString(16)).toUpperCase();
	});
};

var UnescapeUTF8 = function UnescapeUTF8(str) {
	return str.replace(/%(E(0%[AB]|[1-CEF]%[89AB]|D%[89])[0-9A-F]|C[2-9A-F]|D[0-9A-F])%[89AB][0-9A-F]|%[0-7][0-9A-F]/ig, function (s) {
		var c = parseInt(s.substring(1), 16);
		return String.fromCharCode(c < 128 ? c : c < 224 ? (c & 31) << 6 | parseInt(s.substring(4), 16) & 63 : ((c & 15) << 6 | parseInt(s.substring(4), 16) & 63) << 6 | parseInt(s.substring(7), 16) & 63);
	});
};

var EscapeUTF16LE = function EscapeUTF16LE(str) {
	var H = function H(c) {
		return 41 < c && c < 58 && 44 != c || 64 < c && c < 91 || 95 == c || 96 < c && c < 123 ? String.fromCharCode(c) : (c < 16 ? "%0" : "%") + c.toString(16).toUpperCase();
	};
	return str.replace(/[^ ]| /g, function (s) {
		var c = s.charCodeAt(0);return H(c & 255) + H(c >> 8);
	});
};

var UnescapeUTF16LE = function UnescapeUTF16LE(str) {
	var u = String.fromCharCode,
	    b = u(92, 120, 48, 48, 45, 92, 120, 70, 70);
	return str.replace(/^%FF%FE/i, "").replace(RegExp("%[0-9A-F]{2}%[0-9A-F]{2}|%[0-9A-F]{2}[" + b + "]|[" + b + "]%[0-9A-F]{2}|[" + b + "]{2}", "ig"), function (s) {
		var l = s.length;
		return u(4 < l ? "0x" + s.substring(4, 6) + s.substring(1, 3) : 2 < l ? 37 == (l = s.charCodeAt(0)) ? parseInt(s.substring(1, 3), 16) | s.charCodeAt(3) << 8 : l | parseInt(s.substring(2), 16) << 8 : s.charCodeAt(0) | s.charCodeAt(1) << 8);
	});
};

var GetEscapeCodeType = function GetEscapeCodeType(str) {
	if (/%u[0-9A-F]{4}/i.test(str)) return "Unicode";
	if (/%([0-9A-DF][0-9A-F]%[8A]0%|E0%80|[0-7][0-9A-F]|C[01])%[8A]0|%00|%[7F]F/i.test(str)) return "UTF16LE";
	if (/%E[0-9A-F]%[8A]0%[8A]0|%[CD][0-9A-F]%[8A]0/i.test(str)) return "UTF8";
	if (/%F[DE]/i.test(str)) return (/%8[0-9A-D]|%9[0-9A-F]|%A0/i.test(str) ? "UTF16LE" : "EUCJP"
	);
	if (/%1B/i.test(str)) return (/%[A-D][0-9A-F]/i.test(str) ? "JIS8" : "JIS7"
	);
	var S = str.substring(0, 6143).replace(/%[0-9A-F]{2}|[^ ]| /ig, function (s) {
		return s.length < 3 ? "40" : s.substring(1);
	}),
	    c,
	    C,
	    i = 0,
	    T;
	while (0 <= (c = parseInt(S.substring(i, i += 2), 16)) && i < 4092) {
		if (128 <= c) {
			if ((C = parseInt(S.substring(i, i + 2), 16)) < 128) i += 2;else if (194 <= c && c < 240 && C < 192) {
				if (c < 224) {
					T = "UTF8";i += 2;continue;
				}
				if (2 == parseInt(S.charAt(i + 2), 16) >> 2) {
					T = "UTF8";i += 4;continue;
				}
			}
			if (142 == c && 161 <= C && C < 224) {
				if (!T) T = "EUCJP";if ("EUCJP" == T) continue;
			}
			if (c < 161) return "SJIS";
			if (c < 224 && !T) {
				if ((164 == c && C < 244 || 165 == c && C < 247) && 161 <= C) i += 2;else T = 224 <= C ? "EUCJP" : "SJIS";
			} else T = "EUCJP";
		}
	}return T ? T : "EUCJP";
};

var JCT11280 = Function('var a="zKV33~jZ4zN=~ji36XazM93y!{~k2y!o~k0ZlW6zN?3Wz3W?{EKzK[33[`y|;-~j^YOTz$!~kNy|L1$353~jV3zKk3~k-4P4zK_2+~jY4y!xYHR~jlz$_~jk4z$e3X5He<0y!wy|X3[:~l|VU[F3VZ056Hy!nz/m1XD61+1XY1E1=1y|bzKiz!H034zKj~mEz#c5ZA3-3X$1~mBz$$3~lyz#,4YN5~mEz#{ZKZ3V%7Y}!J3X-YEX_J(3~mAz =V;kE0/y|F3y!}~m>z/U~mI~j_2+~mA~jp2;~m@~k32;~m>V}2u~mEX#2x~mBy+x2242(~mBy,;2242(~may->2&XkG2;~mIy-_2&NXd2;~mGz,{4<6:.:B*B:XC4>6:.>B*BBXSA+A:X]E&E<~r#z+625z s2+zN=`HXI@YMXIAXZYUM8X4K/:Q!Z&33 3YWX[~mB`{zKt4z (zV/z 3zRw2%Wd39]S11z$PAXH5Xb;ZQWU1ZgWP%3~o@{Dgl#gd}T){Uo{y5_d{e@}C(} WU9|cB{w}bzvV|)[} H|zT}d||0~{]Q|(l{|x{iv{dw}(5}[Z|kuZ }cq{{y|ij}.I{idbof%cu^d}Rj^y|-M{ESYGYfYsZslS`?ZdYO__gLYRZ&fvb4oKfhSf^d<Yeasc1f&a=hnYG{QY{D`Bsa|u,}Dl|_Q{C%xK|Aq}C>|c#ryW=}eY{L+`)][YF_Ub^h4}[X|?r|u_ex}TL@YR]j{SrXgo*|Gv|rK}B#mu{R1}hs|dP{C7|^Qt3|@P{YVV |8&}#D}ef{e/{Rl|>Hni}R1{Z#{D[}CQlQ||E}[s{SG_+i8eplY[=[|ec[$YXn#`hcm}YR|{Ci(_[ql|?8p3]-}^t{wy}4la&pc|3e{Rp{LqiJ],] `kc(]@chYnrM`O^,ZLYhZB]ywyfGY~aex!_Qww{a!|)*lHrM{N+n&YYj~Z b c#e_[hZSon|rOt`}hBXa^i{lh|<0||r{KJ{kni)|x,|0auY{D!^Sce{w;|@S|cA}Xn{C1h${E]Z-XgZ*XPbp]^_qbH^e[`YM|a||+=]!Lc}]vdBc=j-YSZD]YmyYLYKZ9Z>Xcczc2{Yh}9Fc#Z.l{}(D{G{{mRhC|L3b#|xK[Bepj#ut`H[,{E9Yr}1b{[e]{ZFk7[ZYbZ0XL]}Ye[(`d}c!|*y`Dg=b;gR]Hm=hJho}R-[n}9;{N![7k_{UbmN]rf#pTe[x8}!Qcs_rs[m`|>N}^V})7{^r|/E}),}HH{OYe2{Skx)e<_.cj.cjoMhc^d}0uYZd!^J_@g,[[[?{i@][|3S}Yl3|!1|eZ|5IYw|1D}e7|Cv{OHbnx-`wvb[6[4} =g+k:{C:}ed{S]|2M]-}WZ|/q{LF|dYu^}Gs^c{Z=}h>|/i|{W]:|ip{N:|zt|S<{DH[p_tvD{N<[8Axo{X4a.^o^X>Yfa59`#ZBYgY~_t^9`jZHZn`>G[oajZ;X,i)Z.^~YJe ZiZF^{][[#Zt^|]Fjx]&_5dddW]P0C[-]}]d|y {C_jUql] |OpaA[Z{lp|rz}:Mu#]_Yf6{Ep?f5`$[6^D][^u[$[6^.Z8]]ePc2U/=]K^_+^M{q*|9tYuZ,s(dS{i=|bNbB{uG}0jZOa:[-]dYtu3]:]<{DJ_SZIqr_`l=Yt`gkTnXb3d@kiq0a`Z{|!B|}e}Ww{Sp,^Z|0>_Z}36|]A|-t}lt{R6pi|v8hPu#{C>YOZHYmg/Z4nicK[}hF_Bg|YRZ7c|crkzYZY}_iXcZ.|)U|L5{R~qi^Uga@Y[xb}&qdbd6h5|Btw[}c<{Ds53[Y7]?Z<|e0{L[ZK]mXKZ#Z2^tavf0`PE[OSOaP`4gi`qjdYMgys/?[nc,}EEb,eL]g[n{E_b/vcvgb.{kcwi`~v%|0:|iK{Jh_vf5lb}KL|(oi=LrzhhY_^@`zgf[~g)[J_0fk_V{T)}I_{D&_/d9W/|MU[)f$xW}?$xr4<{Lb{y4}&u{XJ|cm{Iu{jQ}CMkD{CX|7A}G~{kt)nB|d5|<-}WJ}@||d@|Iy}Ts|iL|/^|no|0;}L6{Pm]7}$zf:|r2}?C_k{R(}-w|`G{Gy[g]bVje=_0|PT{^Y^yjtT[[[l!Ye_`ZN]@[n_)j3nEgMa]YtYpZy].d-Y_cjb~Y~[nc~sCi3|zg}B0}do{O^{|$`_|D{}U&|0+{J3|8*]iayx{a{xJ_9|,c{Ee]QXlYb]$[%YMc*]w[aafe]aVYi[fZEii[xq2YQZHg]Y~h#|Y:thre^@^|_F^CbTbG_1^qf7{L-`VFx Zr|@EZ;gkZ@slgko`[e}T:{Cu^pddZ_`yav^Ea+[#ZBbSbO`elQfLui}.F|txYcbQ`XehcGe~fc^RlV{D_0ZAej[l&jShxG[ipB_=u:eU}3e8[=j|{D(}dO{Do[BYUZ0/]AYE]ALYhZcYlYP/^-^{Yt_1_-;YT`P4BZG=IOZ&]H[e]YYd[9^F[1YdZxZ?Z{Z<]Ba2[5Yb[0Z4l?]d_;_)a?YGEYiYv`_XmZs4ZjY^Zb]6gqGaX^9Y}dXZr[g|]Y}K aFZp^k^F]M`^{O1Ys]ZCgCv4|E>}8eb7}l`{L5[Z_faQ|c2}Fj}hw^#|Ng|B||w2|Sh{v+[G}aB|MY}A{|8o}X~{E8paZ:]i^Njq]new)`-Z>haounWhN}c#{DfZ|fK]KqGZ=:u|fqoqcv}2ssm}.r{]{nIfV{JW)[K|,Z{Uxc|]l_KdCb%]cfobya3`p}G^|LZiSC]U|(X|kBlVg[kNo({O:g:|-N|qT}9?{MBiL}Sq{`P|3a|u.{Uaq:{_o|^S}jX{Fob0`;|#y_@[V[K|cw[<_ }KU|0F}d3|et{Q7{LuZttsmf^kYZ`Af`}$x}U`|Ww}d]| >}K,r&|XI|*e{C/a-bmr1fId4[;b>tQ_:]hk{b-pMge]gfpo.|(w[jgV{EC1Z,YhaY^q,_G[c_g[J0YX]`[h^hYK^_Yib,` {i6vf@YM^hdOKZZn(jgZ>bzSDc^Z%[[o9[2=/YHZ(_/Gu_`*|8z{DUZxYt^vuvZjhi^lc&gUd4|<UiA`z]$b/Z?l}YI^jaHxe|;F}l${sQ}5g}hA|e4}?o{ih}Uz{C)jPe4]H^J[Eg[|AMZMlc}:,{iz}#*|gc{Iq|/:|zK{l&}#u|myd{{M&v~nV};L|(g|I]ogddb0xsd7^V})$uQ{HzazsgxtsO^l}F>ZB]r|{7{j@cU^{{CbiYoHlng]f+nQ[bkTn/}<-d9q {KXadZYo+n|l[|lc}V2{[a{S4Zam~Za^`{HH{xx_SvF|ak=c^[v^7_rYT`ld@]:_ub%[$[m](Shu}G2{E.ZU_L_R{tz`vj(f?^}hswz}GdZ}{S:h`aD|?W|`dgG|if{a8|J1{N,}-Ao3{H#{mfsP|[ bzn+}_Q{MT{u4kHcj_q`eZj[8o0jy{p7}C|[}l){MuYY{|Ff!Ykn3{rT|m,^R|,R}$~Ykgx{P!]>iXh6[l[/}Jgcg{JYZ.^qYfYIZl[gZ#Xj[Pc7YyZD^+Yt;4;`e8YyZVbQ7YzZxXja.7SYl[s]2^/Ha$[6ZGYrb%XiYdf2]H]kZkZ*ZQ[ZYS^HZXcCc%Z|[(bVZ]]:OJQ_DZCg<[,]%Zaa [g{C00HY[c%[ChyZ,Z_`PbXa+eh`^&jPi0a[ggvhlekL]w{Yp^v}[e{~;k%a&k^|nR_z_Qng}[E}*Wq:{k^{FJZpXRhmh3^p>de^=_7`|ZbaAZtdhZ?n4ZL]u`9ZNc3g%[6b=e.ZVfC[ZZ^^^hD{E(9c(kyZ=bb|Sq{k`|vmr>izlH[u|e`}49}Y%}FT{[z{Rk}Bz{TCc/lMiAqkf(m$hDc;qooi[}^o:c^|Qm}a_{mrZ(pA`,}<2sY| adf_%|}`}Y5U;}/4|D>|$X{jw{C<|F.hK|*A{MRZ8Zsm?imZm_?brYWZrYx`yVZc3a@f?aK^ojEd {bN}/3ZH]/$YZhm^&j 9|(S|b]mF}UI{q&aM]LcrZ5^.|[j`T_V_Gak}9J[ ZCZD|^h{N9{~&[6Zd{}B}2O|cv]K}3s}Uy|l,fihW{EG`j_QOp~Z$F^zexS`dcISfhZBXP|.vn|_HYQ|)9|cr]<`&Z6]m_(ZhPcSg>`Z]5`~1`0Xcb4k1{O!bz|CN_T{LR|a/gFcD|j<{Z._[f)mPc:1`WtIaT1cgYkZOaVZOYFrEe[}T$}Ch}mk{K-^@]fH{Hdi`c*Z&|Kt{if[C{Q;{xYB`dYIX:ZB[}]*[{{p9|4GYRh2ao{DS|V+[zd$`F[ZXKadb*A] Ys]Maif~a/Z2bmclb8{Jro_rz|x9cHojbZ{GzZx_)]:{wAayeDlx}<=`g{H1{l#}9i|)=|lP{Qq}.({La|!Y{i2EZfp=c*}Cc{EDvVB|;g}2t{W4av^Bn=]ri,|y?|3+}T*ckZ*{Ffr5e%|sB{lx^0]eZb]9[SgAjS_D|uHZx]dive[c.YPkcq/}db{EQh&hQ|eg}G!ljil|BO]X{Qr_GkGl~YiYWu=c3eb}29v3|D|}4i||.{Mv})V{SP1{FX}CZW6{cm|vO{pS|e#}A~|1i}81|Mw}es|5[}3w{C`h9aL]o{}p[G`>i%a1Z@`Ln2bD[$_h`}ZOjhdTrH{[j_:k~kv[Sdu]CtL}41{I |[[{]Zp$]XjxjHt_eThoa#h>sSt8|gK|TVi[Y{t=}Bs|b7Zpr%{gt|Yo{CS[/{iteva|cf^hgn}($_c^wmb^Wm+|55jrbF|{9^ q6{C&c+ZKdJkq_xOYqZYSYXYl`8]-cxZAq/b%b*_Vsa[/Ybjac/OaGZ4fza|a)gY{P?| I|Y |,pi1n7}9bm9ad|=d{aV|2@[(}B`d&|Uz}B}{`q|/H|!JkM{FU|CB|.{}Az}#P|lk}K{|2rk7{^8^?`/|k>|Ka{Sq}Gz}io{DxZh[yK_#}9<{TRdgc]`~Z>JYmYJ]|`!ZKZ]gUcx|^E[rZCd`f9oQ[NcD_$ZlZ;Zr}mX|=!|$6ZPZYtIo%fj}CpcN|B,{VDw~gb}@hZg`Q{LcmA[(bo`<|@$|o1|Ss}9Z_}tC|G`{F/|9nd}i=}V-{L8aaeST]daRbujh^xlpq8|}zs4bj[S`J|]?G{P#{rD{]I`OlH{Hm]VYuSYUbRc*6[j`8]pZ[bt_/^Jc*[<Z?YE|Xb|?_Z^Vcas]h{t9|Uwd)_(=0^6Zb{Nc} E[qZAeX[a]P^|_J>e8`W^j_Y}R{{Jp__]Ee#e:iWb9q_wKbujrbR}CY`,{mJ}gz{Q^{t~N|? gSga`V_||:#mi}3t|/I`X{N*|ct|2g{km}gi|{={jC}F;|E}{ZZjYf*frmu}8Tdroi{T[|+~}HG{cJ}DM{Lp{Ctd&}$hi3|FZ| m}Kr|38}^c|m_|Tr{Qv|36}?Up>|;S{DV{k_as}BK{P}}9p|t`jR{sAm4{D=b4pWa[}Xi{EjwEkI}3S|E?u=X0{jf} S|NM|JC{qo^3cm]-|JUx/{Cj{s>{Crt[UXuv|D~|j|d{YXZR}Aq}0r}(_{pJfi_z}0b|-vi)Z mFe,{f4|q`b{}^Z{HM{rbeHZ|^x_o|XM|L%|uFXm}@C_{{Hhp%a7|0p[Xp+^K}9U{bP}: tT}B|}+$|b2|[^|~h{FAby[`{}xgygrt~h1[li`c4vz|,7p~b(|mviN}^pg[{N/|g3|^0c,gE|f%|7N{q[|tc|TKA{LU}I@|AZp(}G-sz{F |qZ{}F|f-}RGn6{Z]_5})B}UJ{FFb2]4ZI@v=k,]t_Dg5Bj]Z-]L]vrpdvdGlk|gF}G]|IW}Y0[G| /bo|Te^,_B}#n^^{QHYI[?hxg{[`]D^IYRYTb&kJ[cri[g_9]Ud~^_]<p@_e_XdNm-^/|5)|h_{J;{kacVopf!q;asqd}n)|.m|bf{QW|U)}b+{tL|w``N|to{t ZO|T]jF}CB|0Q{e5Zw|k |We}5:{HO{tPwf_uajjBfX}-V_C_{{r~gg|Ude;s+}KNXH}! `K}eW{Upwbk%ogaW}9EYN}YY|&v|SL{C3[5s.]Y]I]u{M6{pYZ`^,`ZbCYR[1mNg>rsk0Ym[jrE]RYiZTr*YJ{Ge|%-lf|y(`=[t}E6{k!|3)}Zk} ][G{E~cF{u3U.rJ|a9p#o#ZE|?|{sYc#vv{E=|LC}cu{N8`/`3`9rt[4|He{cq|iSYxY`}V |(Q|t4{C?]k_Vlvk)BZ^r<{CL}#h}R+[<|i=}X|{KAo]|W<`K{NW|Zx}#;|fe{IMr<|K~tJ_x}AyLZ?{GvbLnRgN}X&{H7|x~}Jm{]-| GpNu0}.ok>|c4{PYisrDZ|fwh9|hfo@{H~XSbO]Odv]%`N]b1Y]]|eIZ}_-ZA]aj,>eFn+j[aQ_+]h[J_m_g]%_wf.`%k1e#Z?{CvYu_B^|gk`Xfh^M3`afGZ-Z|[m{L}|k3cp[it ^>YUi~d>{T*}YJ{Q5{Jxa$hg|%4`}|LAgvb }G}{P=|<;Ux{_skR{cV|-*|s-{Mp|XP|$G|_J}c6cM{_=_D|*9^$ec{V;|4S{qO|w_|.7}d0|/D}e}|0G{Dq]Kdp{}dfDi>}B%{Gd|nl}lf{C-{y}|ANZr}#={T~|-(}c&{pI|ft{lsVP}){|@u}!W|bcmB{d?|iW|:dxj{PSkO|Hl]Li:}VYk@|2={fnWt{M3`cZ6|)}|Xj}BYa?vo{e4|L7|B7{L7|1W|lvYO}W8nJ|$Vih|{T{d*_1|:-n2dblk``fT{Ky|-%}m!|Xy|-a{Pz}[l{kFjz|iH}9N{WE{x,|jz}R {P|{D)c=nX|Kq|si}Ge{sh|[X{RF{t`|jsr*fYf,rK|/9}$}}Nf{y!1|<Std}4Wez{W${Fd_/^O[ooqaw_z[L`Nbv[;l7V[ii3_PeM}.h^viqYjZ*j1}+3{bt{DR[;UG}3Og,rS{JO{qw{d<_zbAh<R[1_r`iZTbv^^a}c{iEgQZ<exZFg.^Rb+`Uj{a+{z<[~r!]`[[|rZYR|?F|qppp]L|-d|}K}YZUM|=Y|ktm*}F]{D;g{uI|7kg^}%?Z%ca{N[_<q4xC]i|PqZC]n}.bDrnh0Wq{tr|OMn6tM|!6|T`{O`|>!]ji+]_bTeU}Tq|ds}n|{Gm{z,f)}&s{DPYJ`%{CGd5v4tvb*hUh~bf]z`jajiFqAii]bfy^U{Or|m+{I)cS|.9k:e3`^|xN}@Dnlis`B|Qo{`W|>||kA}Y}{ERYuYx`%[exd`]|OyiHtb}HofUYbFo![5|+]gD{NIZR|Go}.T{rh^4]S|C9_}xO^i`vfQ}C)bK{TL}cQ|79iu}9a];sj{P.o!f[Y]pM``Jda^Wc9ZarteBZClxtM{LW}l9|a.mU}KX}4@{I+f1}37|8u}9c|v${xGlz}jP{Dd1}e:}31}%3X$|22i<v+r@~mf{sN{C67G97855F4YL5}8f{DT|xy{sO{DXB334@55J1)4.G9A#JDYtXTYM4, YQD9;XbXm9SX]IB^4UN=Xn<5(;(F3YW@XkH-X_VM[DYM:5XP!T&Y`6|,^{IS-*D.H>:LXjYQ0I3XhAF:9:(==.F*3F1189K/7163D,:@|e2{LS36D4hq{Lw/84443@4.933:0307::6D7}&l{Mx657;89;,K5678H&93D(H<&<>0B90X^I;}Ag1{P%3A+>><975}[S{PZE453?4|T2{Q+5187;>447:81{C=hL6{Me^:=7ii{R=.=F<81;48?|h8}Uh{SE|,VxL{ST,7?9Y_5Xk3A#:$%YSYdXeKXOD8+TXh7(@>(YdXYHXl9J6X_5IXaL0N?3YK7Xh!1?XgYz9YEXhXaYPXhC3X`-YLY_XfVf[EGXZ5L8BXL9YHX]SYTXjLXdJ: YcXbQXg1PX]Yx4|Jr{Ys4.8YU+XIY`0N,<H%-H;:0@,74/:8546I=9177154870UC]d<C3HXl7ALYzXFXWP<<?E!88E5@03YYXJ?YJ@6YxX-YdXhYG|9o{`iXjY_>YVXe>AYFX[/(I@0841?):-B=14337:8=|14{c&93788|di{cW-0>0<097/A;N{FqYpugAFT%X/Yo3Yn,#=XlCYHYNX[Xk3YN:YRT4?)-YH%A5XlYF3C1=NWyY}>:74-C673<69545v {iT85YED=64=.F4..9878/D4378?48B3:7:7/1VX[f4{D,{l<5E75{dAbRB-8-@+;DBF/$ZfW8S<4YhXA.(5@*11YV8./S95C/0R-A4AXQYI7?68167B95HA1*<M3?1/@;/=54XbYP36}lc{qzSS38:19?,/39193574/66878Yw1X-87E6=;964X`T734:>86>1/=0;(I-1::7ALYGXhF+Xk[@W%TYbX7)KXdYEXi,H-XhYMRXfYK?XgXj.9HX_SX]YL1XmYJ>Y}WwIXiI-3-GXcYyXUYJ$X`Vs[7;XnYEZ;XF! 3;%8;PXX(N3Y[)Xi1YE&/ :;74YQ6X`33C;-(>Xm0(TYF/!YGXg8 9L5P01YPXO-5%C|qd{{/K/E6,=0144:361:955;6443@?B7*7:F89&F35YaX-CYf,XiFYRXE_e{}sF 0*7XRYPYfXa5YXXY8Xf8Y~XmA[9VjYj*#YMXIYOXk,HHX40YxYMXU8OXe;YFXLYuPXP?EB[QV0CXfY{:9XV[FWE0D6X^YVP*$4%OXiYQ(|xp|%c3{}V`1>Y`XH00:8/M6XhQ1:;3414|TE|&o@1*=81G8<3}6<|(f6>>>5-5:8;093B^3U*+*^*UT30XgYU&7*O1953)5@E78--F7YF*B&0:%P68W9Zn5974J9::3}Vk|-,C)=)1AJ4+<3YGXfY[XQXmT1M-XcYTYZXCYZXEYXXMYN,17>XIG*SaS|/eYJXbI?XdNZ+WRYP<F:R PXf;0Xg`$|1GX9YdXjLYxWX!ZIXGYaXNYm6X9YMX?9EXmZ&XZ#XQ>YeXRXfAY[4 ;0X!Zz0XdN$XhYL XIY^XGNXUYS/1YFXhYk.TXn4DXjB{jg|4DEX]:XcZMW=A.+QYL<LKXc[vV$+&PX*Z3XMYIXUQ:ZvW< YSXFZ,XBYeXMM)?Xa XiZ4/EXcP3%}&-|6~:1(-+YT$@XIYRBC<}&,|7aJ6}bp|8)K1|Xg|8C}[T|8Q.89;-964I38361<=/;883651467<7:>?1:.}le|:Z=39;1Y^)?:J=?XfLXbXi=Q0YVYOXaXiLXmJXO5?.SFXiCYW}-;|=u&D-X`N0X^,YzYRXO(QX_YW9`I|>hZ:N&X)DQXP@YH#XmNXi$YWX^=!G6YbYdX>XjY|XlX^XdYkX>YnXUXPYF)FXT[EVTMYmYJXmYSXmNXi#GXmT3X8HOX[ZiXN]IU2>8YdX1YbX<YfWuZ8XSXcZU%0;1XnXkZ_WTG,XZYX5YSX Yp 05G?XcYW(IXg6K/XlYP4XnI @XnO1W4Zp-9C@%QDYX+OYeX9>--YSXkD.YR%Q/Yo YUX].Xi<HYEZ2WdCE6YMXa7F)=,D>-@9/8@5=?7164;35387?N<618=6>7D+C50<6B03J0{Hj|N9$D,9I-,.KB3}m |NzE0::/81YqXjMXl7YG; [.W=Z0X4XQY]:MXiR,XgM?9$9>:?E;YE77VS[Y564760391?14941:0=:8B:;/1DXjFA-564=0B3XlH1+D85:0Q!B#:-6&N/:9<-R3/7Xn<*3J4.H:+334B.=>30H.;3833/76464665755:/83H6633:=;.>5645}&E|Y)?1/YG-,93&N3AE@5 <L1-G/8A0D858/30>8<549=@B8] V0[uVQYlXeD(P#ID&7T&7;Xi0;7T-$YE)E=1:E1GR):--0YI7=E<}n9|aT6783A>D7&4YG7=391W;Zx<5+>F#J39}o/|cc;6=A050EQXg8A1-}D-|d^5548083563695D?-.YOXd37I$@LYLWeYlX<Yd+YR A$;3-4YQ-9XmA0!9/XLY_YT(=5XdDI>YJ5XP1ZAW{9>X_6R(XhYO65&J%DA)C-!B:97#A9;@?F;&;(9=11/=657/H,<8}bz|j^5446>.L+&Y^8Xb6?(CYOXb*YF(8X`FYR(XPYVXmPQ%&DD(XmZXW??YOXZXfCYJ79,O)XnYF7K0!QXmXi4IYFRXS,6<%-:YO(+:-3Q!1E1:W,Zo}Am|n~;3580534*?3Zc4=9334361693:30C<6/717:<1/;>59&:4}6!|rS36=1?75<8}[B|s809983579I.A.>84758=108564741H*9E{L{|u%YQ<%6XfH.YUXe4YL@,>N}Tv|ve*G0X)Z;/)3@A74(4P&A1X:YVH97;,754*A66:1 D739E3553545558E4?-?K17/770843XAYf838A7K%N!YW4.$T19Z`WJ*0XdYJXTYOXNZ 1XaN1A+I&Xi.Xk3Z3GB&5%WhZ1+5#Y[X<4YMXhQYoQXVXbYQ8XSYUX4YXBXWDMG0WxZA[8V+Z8X;D],Va$%YeX?FXfX[XeYf<X:Z[WsYz8X_Y]%XmQ(!7BXIZFX]&YE3F$(1XgYgYE& +[+W!<YMYFXc;+PXCYI9YrWxGXY9DY[!GXiI7::)OC;*$.>N*HA@{C|}&k=:<TB83X`3YL+G4XiK]i}(fYK<=5$.FYE%4*5*H*6XkCYL=*6Xi6!Yi1KXR4YHXbC8Xj,B9ZbWx/XbYON#5B}Ue}+QKXnF1&YV5XmYQ0!*3IXBYb71?1B75XmF;0B976;H/RXU:YZX;BG-NXj;XjI>A#D3B636N;,*%<D:0;YRXY973H5)-4FXOYf0:0;/7759774;7;:/855:543L43<?6=E,.A4:C=L)%4YV!1(YE/4YF+ F3%;S;&JC:%/?YEXJ4GXf/YS-EXEYW,9;E}X$}547EXiK=51-?71C%?57;5>463553Zg90;6447?<>4:9.7538XgN{|!}9K/E&3-:D+YE1)YE/3;37/:05}n<}:UX8Yj4Yt864@JYK..G=.(A Q3%6K>3(P3#AYE$-6H/456*C=.XHY[#S.<780191;057C)=6HXj?955B:K1 E>-B/9,;5.!L?:0>/.@//:;7833YZ56<4:YE=/:7Z_WGC%3I6>XkC*&NA16X=Yz2$X:Y^&J48<99k8}CyB-61<18K946YO4{|N}E)YIB9K0L>4=46<1K0+R;6-=1883:478;4,S+3YJX`GJXh.Yp+Xm6MXcYpX(>7Yo,/:X=Z;Xi0YTYHXjYmXiXj;*;I-8S6N#XgY}.3XfYGO3C/$XjL$*NYX,1 6;YH&<XkK9C#I74.>}Hd`A748X[T450[n75<4439:18A107>|ET}Rf<1;14876/Yb983E<5.YNXd4149>,S=/4E/<306443G/06}0&}UkYSXFYF=44=-5095=88;63844,9E6644{PL}WA8:>)7+>763>>0/B3A545CCnT}Xm|dv}Xq1L/YNXk/H8;;.R63351YY747@15YE4J8;46;.38.>4A369.=-83,;Ye3?:3@YE.4-+N353;/;@(X[YYD>@/05-I*@.:551741Yf5>6A443<3535;.58/86=D4753442$635D1>0359NQ @73:3:>><Xn?;43C14 ?Y|X611YG1&<+,4<*,YLXl<1/AIXjF*N89A4Z576K1XbJ5YF.ZOWN.YGXO/YQ01:4G38Xl1;KI0YFXB=R<7;D/,/4>;$I,YGXm94@O35Yz66695385.>:6A#5}W7n^4336:4157597434433<3|XA}m`>=D>:4A.337370?-6Q96{`E|4A}C`|Qs{Mk|J+~r>|o,wHv>Vw}!c{H!|Gb|*Ca5}J||,U{t+{CN[!M65YXOY_*B,Y[Z9XaX[QYJYLXPYuZ%XcZ8LY[SYPYKZM<LMYG9OYqSQYM~[e{UJXmQYyZM_)>YjN1~[f3{aXFY|Yk:48YdH^NZ0|T){jVFYTZNFY^YTYN~[h{nPYMYn3I]`EYUYsYIZEYJ7Yw)YnXPQYH+Z.ZAZY]^Z1Y`YSZFZyGYHXLYG 8Yd#4~[i|+)YH9D?Y^F~Y7|-eYxZ^WHYdYfZQ~[j|3>~[k|3oYmYqY^XYYO=Z*4[]Z/OYLXhZ1YLZIXgYIHYEYK,<Y`YEXIGZI[3YOYcB4SZ!YHZ*&Y{Xi3~[l|JSY`Zz?Z,~[m|O=Yi>??XnYWXmYS617YVYIHZ(Z4[~L4/=~[n|Yu{P)|];YOHHZ}~[o33|a>~[r|aE]DH~[s|e$Zz~[t|kZFY~XhYXZB[`Y}~[u|{SZ&OYkYQYuZ2Zf8D~[v}% ~[w3},Q[X]+YGYeYPIS~[y}4aZ!YN^!6PZ*~[z}?E~[{3}CnZ=~[}}EdDZz/9A3(3S<,YR8.D=*XgYPYcXN3Z5 4)~[~}JW=$Yu.XX~] }KDX`PXdZ4XfYpTJLY[F5]X~[2Yp}U+DZJ::<446[m@~]#3}]1~]%}^LZwZQ5Z`/OT<Yh^ -~]&}jx[ ~m<z!%2+~ly4VY-~o>}p62yz!%2+Xf2+~ly4VY-zQ`z (=] 2z~o2",C={" ":0,"!":1},c=34,i=2,p,s="",u=String.fromCharCode,t=u(12539);while(++c<127)C[u(c)]=c^39&&c^92?i++:0;i=0;while(0<=(c=C[a.charAt(i++)]))if(16==c)if((c=C[a.charAt(i++)])<87){if(86==c)c=1879;while(c--)s+=u(++p)}else s+=s.substr(8272,360);else if(c<86)s+=u(p+=c<51?c-16:(c-55)*92+C[a.charAt(i++)]);else if((c=((c-86)*92+C[a.charAt(i++)])*92+C[a.charAt(i++)])<49152)s+=u(p=c<40960?c:c|57344);else{c&=511;while(c--)s+=t;p=12539}return s')();

var JCT8836 = JCT11280.substring(0, 8836);

exports.EscapeSJIS = EscapeSJIS;
exports.UnescapeSJIS = UnescapeSJIS;
exports.EscapeEUCJP = EscapeEUCJP;
exports.UnescapeEUCJP = UnescapeEUCJP;
exports.EscapeJIS7 = EscapeJIS7;
exports.UnescapeJIS7 = UnescapeJIS7;
exports.EscapeJIS8 = EscapeJIS8;
exports.UnescapeJIS8 = UnescapeJIS8;
exports.EscapeUnicode = EscapeUnicode;
exports.UnescapeUnicode = UnescapeUnicode;
exports.EscapeUTF7 = EscapeUTF7;
exports.UnescapeUTF7 = UnescapeUTF7;
exports.EscapeUTF8 = EscapeUTF8;
exports.UnescapeUTF8 = UnescapeUTF8;
exports.EscapeUTF16LE = EscapeUTF16LE;
exports.UnescapeUTF16LE = UnescapeUTF16LE;
exports.GetEscapeCodeType = GetEscapeCodeType;
exports.JCT11280 = JCT11280;
exports.JCT8836 = JCT8836;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _GKComponent = __webpack_require__(32);

var _GKComponent2 = _interopRequireDefault(_GKComponent);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An object relevant to gameplay, with functionality entirely provided by a collection of component objects. 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gameplaykit/gkentity
 */
var GKEntity = function (_NSObject) {
  _inherits(GKEntity, _NSObject);

  // Creating an Entity

  /**
   * Initializes a new entity object.
   * @access public
   * @constructor
   * @desc If you create a GKEntity subclass and define any additional initializers, you must delegate to this initializer. You do not need to subclass GKEntity to use Entity-Component architecture—generally, you should create a custom entity class only when you need a place to store state or resources that are shared by multiple components.
   * @see https://developer.apple.com/documentation/gameplaykit/gkentity/1501143-init
   */
  function GKEntity() {
    _classCallCheck(this, GKEntity);

    // Managing an Entity’s List of Components

    var _this = _possibleConstructorReturn(this, (GKEntity.__proto__ || Object.getPrototypeOf(GKEntity)).call(this));

    _this._components = [];
    return _this;
  }

  // Managing an Entity’s List of Components

  /**
   * Adds a component to the entity.
   * @access public
   * @param {GKComponent} component - An instance of a GKComponent subclass.
   * @returns {void}
   * @desc You create components by subclassing GKEntity to implement reusable behavior. Then, use this method to incorporate the behavior of a component class into that entity. An entity’s components list never has more than one instance of any component class—if the entity already contains a component of the same class as the component parameter, calling this method will replace that component.
   * @see https://developer.apple.com/documentation/gameplaykit/gkentity/1501312-addcomponent
   */


  _createClass(GKEntity, [{
    key: 'addComponent',
    value: function addComponent(component) {
      if (this._components.indexOf(component) < 0) {
        this._components.push(component);
        component._entity = this;
        component.didAddToEntity();
      }
    }

    /**
     * The entity’s list of components.
     * @type {GKComponent[]}
     * @desc 
     * @see https://developer.apple.com/documentation/gameplaykit/gkentity/1501182-components
     */

  }, {
    key: 'updateDeltaTime',


    // Performing Periodic Updates

    /**
     * Performs periodic updates for each of the entity’s components.
     * @access public
     * @param {number} seconds - The time step to use for any time-dependent actions performed by this method (typically, the elapsed time since the previous call to this method).
     * @returns {void}
     * @desc At runtime, an entity/component-based game needs to dispatch periodic logic—from an update/render loop method such as update(_:) (SpriteKit) or renderer(_:updateAtTime:) (SceneKit), or a CADisplayLink (iOS) or CVDisplayLink (macOS) timer in a custom rendering engine—to each of its components, so that each can perform component-specific update logic.The GKEntity update(deltaTime:) method is one of the two options GameplayKit provides for dispatching updates—this option is easy to implement in games with small numbers of entities and components. Call this method for each entity in your game, and each entity will in turn call the update(deltaTime:) method for each of its components.The other option is to dispatch updates per-component, rather than per-entity, using a GKComponentSystem object. Using a component system allows you to update all components of a specific component class in a deterministic order, without needing to traverse your game’s object graph and update each entity.NoteIf a component owned by an entity is a member of a component system, calling the entity’s update(deltaTime:) method will not update that component.
     * @see https://developer.apple.com/documentation/gameplaykit/gkentity/1501228-update
     */
    value: function updateDeltaTime(seconds) {}

    // Instance Methods

    /**
     * 
     * @access public
     * @param {ComponentType.Type} componentClass - 
     * @returns {GKComponent} - 
     * @see https://developer.apple.com/documentation/gameplaykit/gkentity/2300466-component
     */

  }, {
    key: 'componentOfType',
    value: function componentOfType(componentClass) {
      return this._components.find(function (component) {
        return (0, _InstanceOf3.default)(component, componentClass);
      });
    }

    /**
     * 
     * @access public
     * @param {ComponentType.Type} componentClass - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/gameplaykit/gkentity/2300467-removecomponent
     */

  }, {
    key: 'removeComponentOfType',
    value: function removeComponentOfType(componentClass) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var component = _step.value;

          if ((0, _InstanceOf3.default)(component, componentClass)) {
            component.willRemoveFromEntity();

            var index = this._components.indexOf(component);
            if (index >= 0) {
              this._components.splice(index);
              component._entity = null;
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'components',
    get: function get() {
      return this._components.slice();
    }
  }]);

  return GKEntity;
}(_NSObject3.default);

exports.default = GKEntity;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _GKGoal = __webpack_require__(73);

var _GKGoal2 = _interopRequireDefault(_GKGoal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A set of goals that together influence the movement of an agent.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior
 */
var GKBehavior = function (_NSObject) {
  _inherits(GKBehavior, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function GKBehavior() {
    _classCallCheck(this, GKBehavior);

    // Managing a Behavior’s Set of Goals

    /**
     * @access private
     * @type {GKGoal[]}
     */
    var _this = _possibleConstructorReturn(this, (GKBehavior.__proto__ || Object.getPrototypeOf(GKBehavior)).call(this));

    _this._goals = [];

    /**
     * @access private
     * @type {number[]}
     */
    _this._weights = [];
    return _this;
  }

  // Creating a Behavior

  /**
   * Creates a behavior with a single goal.
   * @access public
   * @param {GKGoal} goal - A goal object.
   * @param {number} weight - A weight to be applied to the goal’s influence on an agent’s speed and direction.
   * @returns {GKBehavior}
   * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388733-init
   */


  _createClass(GKBehavior, [{
    key: 'setWeightFor',


    // Managing a Behavior’s Set of Goals

    /**
     * Sets the weight for the specified goal’s influence on agents, adding that goal to the behavior if not already present.
     * @access public
     * @param {number} weight - A weight to be applied to the goal’s influence on an agent’s speed and direction.
     * @param {GKGoal} goal - A goal object.
     * @returns {void}
     * @desc When an agent evaluates its behavior, it examines each goal and calculates the change in direction and speed necessary to move toward fulfilling that goal (within the limits of the current time step and the agent’s maximum speed and turn rate). The agent then combines these influences to determine the total change in direction and speed for the current time step. To modulate the effects of multiple goals in a behavior, use this method to increase or decrease the relative influence of each.You can use this method to vary the behaviors in your game in response to player actions or other events. For example, an enemy agent’s behavior may combine pursuing the player (init(toInterceptAgent:maxPredictionTime:)) with a bit of wandering (init(toWander:)) to make its movement appear natural. When the enemy has not yet sighted the player, you might reduce the weight of the pursue goal to zero; when the player attacks the enemy, you might increase the weight of the wander goal for a short time to make the enemy act dazed.
     * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388731-setweight
     */
    value: function setWeightFor(weight, goal) {
      var index = this._goals.indexOf(goal);
      if (index >= 0) {
        this._weights[index] = weight;
      }
    }

    /**
     * Returns the weight for the specified goal’s influence on agents.
     * @access public
     * @param {GKGoal} goal - A goal already included in the behavior’s set of goals.
     * @returns {number} - 
     * @desc When an agent evaluates its behavior, it examines each goal and calculates the change in direction and speed necessary to move toward fulfilling that goal (within the limits of the current time step and the agent’s maximum speed and turn rate). The agent then combines these influences to determine the total change in direction and speed for the current time step. Weights modulate the effects of multiple goals in a behavior.
     * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388729-weight
     */

  }, {
    key: 'weightFor',
    value: function weightFor(goal) {
      var index = this._goals.indexOf(goal);
      if (index >= 0) {
        return this._weights[index];
      }
      return 0;
    }

    /**
     * Removes the specified goal from the behavior.
     * @access public
     * @param {GKGoal} goal - A goal object.
     * @returns {void}
     * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388714-remove
     */

  }, {
    key: 'remove',
    value: function remove(goal) {
      var index = this._goals.indexOf(goal);
      if (index >= 0) {
        this._goals.splice(index, 1);
        this._weights.splice(index, 1);
      }
    }

    /**
     * Removes all goals from the behavior.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388716-removeallgoals
     */

  }, {
    key: 'removeAllGoals',
    value: function removeAllGoals() {
      this._goals = [];
      this._weights = [];
    }

    /**
     * The number of goals in the behavior.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388721-goalcount
     */

  }, {
    key: 'subscript',


    // Working with Goals Using Subscript Syntax

    /**
     * Returns the weight associated with the goal specified by subscript syntax.
     * @access public
     * @param {GKGoal} goal - A goal already included in the behavior’s set of goals.
     * @returns {NSNumber! { get set }} - 
     * @desc This method is equivalent to the weight(for:) method, but allows access using subscript syntax.
     * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388723-subscript
     */
    value: function subscript(goal) {
      return null;
    }
  }, {
    key: 'goalCount',
    get: function get() {
      return this._goals.length;
    }
  }], [{
    key: 'behaviorWithGoalWeight',
    value: function behaviorWithGoalWeight(goal, weight) {
      var behavior = new GKBehavior();
      behavior._goals.push(goal);
      behavior._weights.push(weight);
      return behavior;
    }

    /**
     * Creates a behavior with the specified goals.
     * @access public
     * @param {GKGoal[]} goals - An array of goal objects.
     * @returns {GKBehavior} - A new behavior object. To assign a set of goals to an agent, use its behavior property.
     * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388725-init
     */

  }, {
    key: 'behaviorWithGoals',
    value: function behaviorWithGoals(goals) {
      var _behavior$_goals;

      var behavior = new GKBehavior();
      (_behavior$_goals = behavior._goals).push.apply(_behavior$_goals, _toConsumableArray(goals));
      for (var i = 0; i < goals.length; i++) {
        behavior._weights.push(1);
      }
      return behavior;
    }

    /**
     * Creates a behavior with the specified goals and weights.
     * @access public
     * @param {GKGoal[]} goals - An array of goal objects.
     * @param {number[]} weights - An array of numbers, each the weight to be applied to the goal at the corresponding index in the goals array.
     * @returns {GKBehavior} -
     * @see https://developer.apple.com/documentation/gameplaykit/gkbehavior/1388727-init
     */

  }, {
    key: 'behaviorWithGoalsAndWeights',
    value: function behaviorWithGoalsAndWeights(goals, weights) {
      var _behavior$_goals2, _behavior$_weights;

      var behavior = new GKBehavior();
      (_behavior$_goals2 = behavior._goals).push.apply(_behavior$_goals2, _toConsumableArray(goals));
      (_behavior$_weights = behavior._weights).push.apply(_behavior$_weights, _toConsumableArray(weights));
      return behavior;
    }
  }]);

  return GKBehavior;
}(_NSObject3.default);

exports.default = GKBehavior;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import GKAgent from './GKAgent'
//import GKObstacle from './GKObstacle'
//import GKPath from './GKPath'

// TODO: check values from NSKeyedArchiver output.
var _GKGoalType = {
  none: 0,
  seek: 1,
  flee: 2,
  reach: 3,
  wander: 4,
  avoid: 5,
  intercept: 6,
  separate: 7,
  align: 8,
  cohere: 9,
  stay: 10,
  follow: 11

  /**
   * An influence that motivates the movement of one or more agents.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal
   */
};
var GKGoal = function (_NSObject) {
  _inherits(GKGoal, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function GKGoal() {
    _classCallCheck(this, GKGoal);

    /**
     * @access private
     * @type {_GKGoalType}
     */
    var _this = _possibleConstructorReturn(this, (GKGoal.__proto__ || Object.getPrototypeOf(GKGoal)).call(this));

    _this._type = 0;

    /**
     * @access private
     * @type {GKPath}
     */
    _this._path = null;

    /**
     * @access private
     * @type {GKObstacle[]}
     */
    _this._obstacles = [];

    /**
     * @access private
     * @type {GKAgent[]}
     */
    _this._agents = [];

    /**
     * @access pricate
     * @type {number}
     */
    _this._time = 0;

    /**
     * @access pricate
     * @type {number}
     */
    _this._angle = 0;

    /**
     * @access pricate
     * @type {number}
     */
    _this._distance = 0;

    /**
     * @access pricate
     * @type {number}
     */
    _this._speed = 0;

    /**
     * @access pricate
     * @type {boolean}
     */
    _this._forward = true;
    return _this;
  }

  // Creating Goals for General Movement Behavior

  /**
   * Creates a goal whose effect is to move an agent toward the current position of the specified other agent.
   * @access public
   * @param {GKAgent} agent - An agent whose position affected agents will attempt to move toward.
   * @returns {GKGoal} -
   * @desc This goal is similar to one produced by the init(toInterceptAgent:maxPredictionTime:) method with a maxPredictionTime parameter of zero. Affected agents will attempt to move toward the target agent, but without taking the target’s movement into account.You can also use this goal when you want an agent to move toward a target point, such as the current mouse or touch location. Create another agent that remains stationary at the target point (that is, has no velocity and no goals), and use that agent as the parameter when creating a goal with this method.
   * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501217-init
   */


  _createClass(GKGoal, null, [{
    key: 'goalToSeekAgent',
    value: function goalToSeekAgent(agent) {
      var goal = new GKGoal();

      goal._type = _GKGoalType.seek;
      goal._agents.push(agent);

      return goal;
    }

    /**
     * Creates a goal whose effect is to move an agent away from the current position of the specified other agent.
     * @access public
     * @param {GKAgent} agent - An agent whose position affected agents will attempt to move away from.
     * @returns {GKGoal} -
     * @desc This goal is similar to one produced by the init(toAvoid:maxPredictionTime:) method with a single agent and a maxPredictionTime parameter of zero. Affected agents will attempt to move away from the target agent, but without taking the target’s movement into account.You can also use this goal when you want an agent to move away from a target point, such as the current mouse or touch location. Create another agent that remains stationary at the target point (that is, has no velocity and no goals), and use that agent as the parameter when creating a goal with this method.
     * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501248-init
     */

  }, {
    key: 'goalToFleeAgent',
    value: function goalToFleeAgent(agent) {
      var goal = new GKGoal();

      goal._type = _GKGoalType.flee;
      goal._agents.push(agent);

      return goal;
    }

    /**
     * Creates a goal whose effect is to accelerate or decelerate an agent until it reaches the specified speed.
     * @access public
     * @param {number} targetSpeed - The speed for affected agents to reach.
     * @returns {GKGoal} -
     * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501070-init
     */

  }, {
    key: 'goalToReachTargetSpeed',
    value: function goalToReachTargetSpeed(targetSpeed) {
      var goal = new GKGoal();

      goal._type = _GKGoalType.reach;
      goal._speed = targetSpeed;

      return goal;
    }

    /**
     * Creates a goal whose effect is to make an agent wander aimlessly, moving forward and turning at random.
     * @access public
     * @param {number} speed - The forward speed for affected agents to maintain while turning at random.
     * @returns {GKGoal} -
     * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501052-init
     */

  }, {
    key: 'goalToWander',
    value: function goalToWander(speed) {
      var goal = new GKGoal();

      goal._type = _GKGoalType.wander;
      goal._speed = speed;

      return goal;
    }

    // Creating Goals for Avoidance and Interception Behavior

    /**
     * Creates a goal whose effect is to make an agent avoid colliding with the specified static obstacles.
     * @access public
     * @param {GKObstacle[]} obstacles - The static obstacles with which to avoid collisions.
     * @param {number} maxPredictionTime - The amount of time during which to predict collisions.
     * @returns {GKGoal} -
     * @desc The maxPredictionTime parameter controls how far in the future a predicted collision must be in order for the agent to take action to avoid it. For example, if this parameter has a low value, an agents speeding toward an obstacle will not swerve or slow until a collision is imminent (and depending on the properties of that agent, it might not be able to move quickly enough to avoid colliding). If this parameter has a high value, the agent will change course leisurely, well before colliding.
     * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501098-init
     */

  }, {
    key: 'goalToAvoid',
    value: function goalToAvoid(obstacles, maxPredictionTime) {
      var _goal$_obstacles;

      var goal = new GKGoal();

      goal._type = _GKGoalType.avoid;
      (_goal$_obstacles = goal._obstacles).push.apply(_goal$_obstacles, _toConsumableArray(obstacles));
      goal._time = maxPredictionTime;

      return goal;
    }

    /**
     * Creates a goal whose effect is to make an agent pursue the specified other agent, taking into account the target’s movement.
     * @access public
     * @param {GKAgent} target - An agent whose position affected agents will attempt to move toward.
     * @param {number} maxPredictionTime - The amount of time for which to predict the target agent’s movement.
     * @returns {GKGoal} -
     * @desc The maxPredictionTime parameter controls how far in the future the agent will plan to intercept its target. A larger value causes an affected agent to pursue its quarry more efficently, catching up with the target’s motion using fewer course corrections. A smaller value causes an affected agent to more closely follow the target’s current position despite the target’s current speed (and depending on the properties of the affected agent, it might not be able to move quickly enough to catch its target).
     * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501219-init
     */

  }, {
    key: 'goalToInterceptAgent',
    value: function goalToInterceptAgent(target, maxPredictionTime) {
      var _goal$_agents;

      var goal = new GKGoal();

      goal._type = _GKGoalType.intercept;
      (_goal$_agents = goal._agents).push.apply(_goal$_agents, _toConsumableArray(target));
      goal._time = maxPredictionTime;

      return goal;
    }

    // Creating Goals for Flocking Behavior

    /**
     * Creates a goal whose effect is to make an agent maintain the specified distance from other agents in a specified group.
     * @access public
     * @param {GKAgent[]} agents - The agents from whom to maintain distance.
     * @param {number} maxDistance - The maximum distance from other agents required for this goal to take effect.
     * @param {number} maxAngle - The maximum angle, in radians, between an affected agent’s velocity and the direction toward the other agents required for this goal to take effect.
     * @returns {GKGoal} -
     * @desc The agents array can safely include the agent(s) affected by the goal—an agent pursuing this goal will ignore itself in the array. Therefore, you can use a single goal created with this method to cause an entire group of agents to mutually avoid one another.Changing the maxDistance parameter determines the minimum distance between agents in the group. Changing the maxAngle parameter determines how tightly an agent will turn to maintain separation from the group.You can combine separation, alignment, and cohesion goals to produce “flocking” behaviors in which a group of agents move together.
     * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501049-init
     */

  }, {
    key: 'goalToSeparateFrom',
    value: function goalToSeparateFrom(agents, maxDistance, maxAngle) {
      var _goal$_agents2;

      var goal = new GKGoal();

      goal._type = _GKGoalType.separate;
      (_goal$_agents2 = goal._agents).push.apply(_goal$_agents2, _toConsumableArray(agents));
      goal._distance = maxDistance;
      goal._angle = maxAngle;

      return goal;
    }

    /**
     * Creates a goal whose effect is to make an agent align its orientation with that of other agents in a specified group.
     * @access public
     * @param {GKAgent[]} agents - The agents with whom to maintain alignment.
     * @param {number} maxDistance - The maximum distance from other agents required for this goal to take effect.
     * @param {number} maxAngle - The maximum angle, in radians, between an affected agent’s velocity and the direction toward the other agents required for this goal to take effect.
     * @returns {GKGoal} -
     * @desc The agents array can safely include the agent(s) affected by the goal—an agent pursuing this goal will ignore itself in the array. Therefore, you can use a single goal created with this method to cause an entire group of agents to mutually align with one another.Changing the maxDistance parameter determines the minimum distance between agents in the group. Changing the maxAngle parameter determines how tightly an agent will turn to maintain alignment with the group.You can combine separation, alignment, and cohesion goals to produce “flocking” behaviors in which a group of agents move together.
     * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501134-init
     */

  }, {
    key: 'goalToAlignWith',
    value: function goalToAlignWith(agents, maxDistance, maxAngle) {
      var _goal$_agents3;

      var goal = new GKGoal();

      goal._type = _GKGoalType.align;
      (_goal$_agents3 = goal._agents).push.apply(_goal$_agents3, _toConsumableArray(agents));
      goal._distance = maxDistance;
      goal._angle = maxAngle;

      return goal;
    }

    /**
     * Creates a goal whose effect is to make an agent stay near the other agents in a specified group.
     * @access public
     * @param {GKAgent[]} agents - The agents with whom to stay close.
     * @param {number} maxDistance - The maximum distance from other agents required for this goal to take effect.
     * @param {number} maxAngle - The maximum angle, in radians, between an affected agent’s velocity and the direction toward the other agents required for this goal to take effect.
     * @returns {GKGoal} -
     * @desc The agents array can safely include the agent(s) affected by the goal—an agent pursuing this goal will ignore itself in the array. Therefore, you can use a single goal created with this method to cause an entire group of agents to mutually stay near one another.Changing the maxDistance parameter determines how close to one another agents need to be in order for them to form a group. Changing the maxAngle parameter determines how tightly an agent will turn to maintain cohesion in the group.You can combine separation, alignment, and cohesion goals to produce “flocking” behaviors in which a group of agents move together.
     * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501170-init
     */

  }, {
    key: 'goalToCohereWith',
    value: function goalToCohereWith(agents, maxDistance, maxAngle) {
      var _goal$_agents4;

      var goal = new GKGoal();

      goal._type = _GKGoalType.cohere;
      (_goal$_agents4 = goal._agents).push.apply(_goal$_agents4, _toConsumableArray(agents));
      goal._distance = maxDistance;
      goal._angle = maxAngle;

      return goal;
    }

    // Creating Goals for Path-Following Behavior

    /**
     * Creates a goal whose effect is to maintain an agent’s position within the specified path.
     * @access public
     * @param {GKPath} path - A path object.
     * @param {number} maxPredictionTime - The amount of time for which to predict an affected agent’s movement.
     * @returns {GKGoal} -
     * @desc This goal uses the shape and the radius property of the specified path to define the boundaries of an area for the agent to stay in. If an affected agent is outside that area, the agent will move into that area; if the agent is already in that area, this goal will not motivate the agent to move further.The maxPredictionTime parameter determines how far ahead of time the agent will predict its own movement to fulfill this goal. For example, with a larger value, an agent moving toward the path will begin to slow gradually so as to stop gently within the path’s radius. With a smaller value, the agent will attempt to stop more abruptly as it reaches the path (and depending on its properties, it might not be able to stop quickly enough to avoid overshooting).
     * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501166-init
     */

  }, {
    key: 'goalToStayOn',
    value: function goalToStayOn(path, maxPredictionTime) {
      var goal = new GKGoal();

      goal._type = _GKGoalType.stay;
      goal._path = path;
      goal._time = maxPredictionTime;

      return goal;
    }

    /**
     * Creates a goal whose effect is to both maintain position on and traverse the specified path.
     * @access public
     * @param {GKPath} path - A path object.
     * @param {number} maxPredictionTime - The amount of time for which to predict an affected agent’s movement.
     * @param {boolean} forward - true to traverse in the order the path’s verties are defined; false to traverse the path in the opposite order.
     * @returns {GKGoal} -
     * @desc This goal uses the shape and the radius property of the specified path to define the agent’s desired movement. The agent first attempts to reach a location near the path’s start point (or end point if the forward parameter is false), to a tolerance determined by the path’s radius. Then, the agent attemps to move toward the next point in the path, again with a tolerance determined by the path’s radius. This sequence continues until the path terminates, or repeats indefinitely if the path’s isCyclical property is true.The maxPredictionTime parameter determines how far ahead of time the agent will predict its own movement to fulfill this goal. For example, with a larger value, an agent moving toward the path will begin to slow gradually so as to stop gently within the path’s radius. With a smaller value, the agent will attempt to stop more abruptly as it reaches the path (and depending on its properties, it might not be able to stop quickly enough to avoid overshooting).
     * @see https://developer.apple.com/documentation/gameplaykit/gkgoal/1501095-init
     */

  }, {
    key: 'goalToFollow',
    value: function goalToFollow(path, maxPredictionTime, forward) {
      var goal = new GKGoal();

      goal._type = _GKGoalType.follow;
      goal._path = path;
      goal._time = maxPredictionTime;
      goal._foward = forward;

      return goal;
    }
  }]);

  return GKGoal;
}(_NSObject3.default);

exports.default = GKGoal;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GKAgent = __webpack_require__(44);

var _GKAgent2 = _interopRequireDefault(_GKAgent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Implement this protocol to synchronize the state of an agent with its visual representation in your game.
 * @interface
 * @see https://developer.apple.com/documentation/gameplaykit/gkagentdelegate
 */
var GKAgentDelegate = function () {
  function GKAgentDelegate() {
    _classCallCheck(this, GKAgentDelegate);
  }

  _createClass(GKAgentDelegate, [{
    key: 'agentWillUpdate',


    /**
     * constructor
     * @access public
     * @constructor
     */
    //constructor() {
    //}

    // Synchronizing with Agents

    /**
     * Tells the delegate that an agent is about to perform its next simulation step.
     * @access public
     * @param {GKAgent} agent - The agent object that will perform its next simulation step.
     * @returns {void}
     * @desc Implement this method when you want to update the agent simulation with data from an external source, such as node position and orientation information updated by the SceneKit or SpriteKit physics engine. Set the position and rotation properties of the agent (as a GKAgent2D or GKAgent3D object) so that the next simulation step will take your changes to those properties into account.
     * @see https://developer.apple.com/documentation/gameplaykit/gkagentdelegate/1501232-agentwillupdate
     */
    value: function agentWillUpdate(agent) {}

    /**
     * Tells the delegate that an agent has just performed a simulation step.
     * @access public
     * @param {GKAgent} agent - The agent object that has just performed a simulation step.
     * @returns {void}
     * @desc Implement this method when you want to update a display based on the latest data from the agent simulation. Read the position and rotation properties of the agent (as a GKAgent2D or GKAgent3D object), then set the corresponding attributes of the object that provides the agent’s visual representation.
     * @see https://developer.apple.com/documentation/gameplaykit/gkagentdelegate/1501131-agentdidupdate
     */

  }, {
    key: 'agentDidUpdate',
    value: function agentDidUpdate(agent) {}
  }]);

  return GKAgentDelegate;
}();

exports.default = GKAgentDelegate;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The partitioning mode used by the tessellator to derive the number and spacing of segments used to subdivide a corresponding edge.
 * @typedef {Object} MTLTessellationPartitionMode
 * @property {number} pow2 - 
 * @property {number} integer - 
 * @property {number} fractionalOdd - 
 * @property {number} fractionalEven - 
 * @see https://developer.apple.com/documentation/metal/mtltessellationpartitionmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var MTLTessellationPartitionMode = {
  pow2: 0,
  integer: 1,
  fractionalOdd: 2,
  fractionalEven: 3
};

exports.default = MTLTessellationPartitionMode;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CAAnimation2 = __webpack_require__(24);

var _CAAnimation3 = _interopRequireDefault(_CAAnimation2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An object that allows multiple animations to be grouped and run concurrently. 
 * @access public
 * @extends {CAAnimation}
 * @see https://developer.apple.com/documentation/quartzcore/caanimationgroup
 */
var CAAnimationGroup = function (_CAAnimation) {
  _inherits(CAAnimationGroup, _CAAnimation);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function CAAnimationGroup() {
    _classCallCheck(this, CAAnimationGroup);

    // Grouped animations

    /**
     * An array of CAAnimation objects to be evaluated in the time space of the receiver.
     * @type {?CAAnimation[]}
     * @see https://developer.apple.com/documentation/quartzcore/caanimationgroup/1412516-animations
     */
    var _this = _possibleConstructorReturn(this, (CAAnimationGroup.__proto__ || Object.getPrototypeOf(CAAnimationGroup)).call(this));

    _this.animations = [];
    return _this;
  }

  /**
   * apply animation to the given node.
   * @access private
   * @param {Object} obj - target object to apply this animation.
   * @param {number} time - active time
   * @param {boolean} [needTimeConversion = true] -
   * @returns {void}
   */


  _createClass(CAAnimationGroup, [{
    key: '_applyAnimation',
    value: function _applyAnimation(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var t = time;
      if (needTimeConversion) {
        var baseTime = this._basetimeFromTime(time);
        t = baseTime;
        if (this.timingFunction !== null) {
          t = this.timingFunction._getValueAtTime(baseTime);
        }
        //console.log(`time ${time} activeTime ${time - this._animationStartTime} baseTime ${baseTime}`)
      }

      this.animations.forEach(function (animation) {
        animation._applyAnimation(obj, t, false);
      });
      this._handleEvents(obj, t);
    }

    /**
     * @access public
     * @returns {CAAnimationGroup} -
     */

  }, {
    key: 'copy',
    value: function copy() {
      //console.log('CAAnimationGroup.copy')
      var anim = _get(CAAnimationGroup.prototype.__proto__ || Object.getPrototypeOf(CAAnimationGroup.prototype), 'copy', this).call(this);

      anim.animations = this.animations.slice();

      return anim;
    }

    /*
    _copyValue(src) {
      console.log('CAAnimationGroup._copyValue')
      //super._copyValue(src)
      this.animations = src.animations.slice()
    }
    */

  }]);

  return CAAnimationGroup;
}(_CAAnimation3.default);

exports.default = CAAnimationGroup;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CAPropertyAnimation2 = __webpack_require__(46);

var _CAPropertyAnimation3 = _interopRequireDefault(_CAPropertyAnimation2);

var _constants = __webpack_require__(25);

var Constants = _interopRequireWildcard(_constants);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import CGPath from '../CoreGraphics/CGPath'
//import CAMediaTimingFunction from './CAMediaTimingFunction'


/**
 * An object that provides keyframe animation capabilities for a layer object. 
 * @access public
 * @extends {CAPropertyAnimation}
 * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation
 */
var CAKeyframeAnimation = function (_CAPropertyAnimation) {
  _inherits(CAKeyframeAnimation, _CAPropertyAnimation);

  // Creating an Animation

  /**
   * Creates and returns an CAKeyframeAnimation instance for the specified key path.
   * @access public
   * @constructor
   * @param {?string} path - 
   */
  function CAKeyframeAnimation(path) {
    _classCallCheck(this, CAKeyframeAnimation);

    // Providing keyframe values

    /**
     * An array of objects that specify the keyframe values to use for the animation.
     * @type {?Object[]}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412498-values
     */
    var _this = _possibleConstructorReturn(this, (CAKeyframeAnimation.__proto__ || Object.getPrototypeOf(CAKeyframeAnimation)).call(this, path));

    _this.values = null;

    /**
     * The path for a point-based property to follow.
     * @type {?CGPath}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412474-path
     */
    _this.path = null;

    // Keyframe timing

    /**
     * An optional array of NSNumber objects that define the time at which to apply a given keyframe segment.
     * @type {?number[]}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412522-keytimes
     */
    _this.keyTimes = null;

    /**
     * An optional array of CAMediaTimingFunction objects that define the pacing for each keyframe segment.
     * @type {?CAMediaTimingFunction[]}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412465-timingfunctions
     */
    _this.timingFunctions = null;

    /**
     * Specifies how intermediate keyframe values are calculated by the receiver.
     * @type {string}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412500-calculationmode
     */
    _this.calculationMode = Constants.kCAAnimationLinear;

    // Rotation Mode Attribute

    /**
     * Determines whether objects animating along the path rotate to match the path tangent.
     * @type {?string}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412454-rotationmode
     */
    _this.rotationMode = null;

    // Cubic Mode Attributes

    /**
     * An array of NSNumber objects that define the tightness of the curve. 
     * @type {?number[]}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412475-tensionvalues
     */
    _this.tensionValues = null;

    /**
     * An array of NSNumber objects that define the sharpness of the timing curve’s corners.
     * @type {?number[]}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412491-continuityvalues
     */
    _this.continuityValues = null;

    /**
     * An array of NSNumber objects that define the position of the curve relative to a control point.
     * @type {?number[]}
     * @see https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/1412485-biasvalues
     */
    _this.biasValues = null;

    /**
     * @access private
     * @type {number}
     */
    _this._indexCache = 0;
    return _this;
  }

  /**
   * @access public
   * @returns {CAKeyframeAnimation} -
   */


  _createClass(CAKeyframeAnimation, [{
    key: 'copy',
    value: function copy() {
      var anim = _get(CAKeyframeAnimation.prototype.__proto__ || Object.getPrototypeOf(CAKeyframeAnimation.prototype), 'copy', this).call(this);

      anim.values = this.values ? this.values.slice() : null;
      anim.path = this.path;
      anim.keyTimes = this.keyTimes ? this.keyTimes.slice() : null;
      anim.timingFunctions = this.timingFunctions ? this.timingFunctions.slice() : null;
      anim.calculationMode = this.calculationMode;
      anim.rotationMode = this.rotationMode;
      anim.tensionValues = this.tensionValues ? this.tensionValues.slice() : null;
      anim.continuityValues = this.continuityValues ? this.continuityValues.slice() : null;
      anim.biasValues = this.biasValues ? this.biasValues.slice() : null;

      return anim;
    }

    /**
     * apply animation to the given node.
     * @access private
     * @param {Object} obj - target object to apply this animation.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAnimation',
    value: function _applyAnimation(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var t = time;
      if (needTimeConversion) {
        var baseTime = this._basetimeFromTime(time);
        t = baseTime;
      }

      var index = this._indexCache;
      var key0 = 0;
      var key1 = 0;

      if (t > 1) {
        throw new Error('CAKeyframeAnimation._applyAnimation: t ' + t + ' > 1');
      }

      var len = this.keyTimes.length;
      if (index >= len) {
        console.log('CAKeyframeAnimation index >= len  ' + index + ' >= ' + len);
        index = len - 1;
      }

      // search keyTime linearly
      if (this.keyTimes[index] < t) {
        for (; index < len; index++) {
          if (this.keyTimes[index] >= t) break;
        }
        key0 = index - 1;
        key1 = index;
      } else {
        for (; index >= 0; index--) {
          if (this.keyTimes[index] < t) break;
        }
        key0 = index;
        key1 = index + 1;
      }
      if (key0 <= 0) {
        key0 = 0;
      }
      if (key1 >= len) {
        key1 = len - 1;
      }

      this._indexCache = key0;

      var time0 = this.keyTimes[key0];
      var time1 = this.keyTimes[key1];
      var val0 = this.values[key0];
      var val1 = this.values[key1];

      var value = val0;
      if (time0 !== time1) {
        var dt = (t - time0) / (time1 - time0);
        var r = dt;
        if (this.timingFunctions !== null) {
          r = this.timingFunctions[key0]._getValueAtTime(dt);
        }

        switch (this.calculationMode) {
          case Constants.kCAAnimationLinear:
            value = this._lerp(val0, val1, r);
            break;
          case Constants.kCAAnimationDiscrete:
            // TODO: implement
            throw new Error('kCAAnimationDiscrete not implemented');
          case Constants.kCAAnimationPaced:
            // TODO: implement
            throw new Error('kCAAnimationPaced not implemented');
          case Constants.kCAAnimationCubic:
            // TODO: implement
            throw new Error('kCAAnimationCubic not implemented');
          case Constants.kCAAnimationCubicPaced:
            // TODO: impelement
            throw new Error('kCAAnimationCubicPaced not implemented');
          default:
            throw new Error('unknown calculation mode: ' + this.calculationMode);
        }

        //console.log(`t: ${t}, time0: ${time0}, time1: ${time1}, dt: ${dt}, r: ${r}, value: ${value}`)
      } else {
          //console.log(`t: ${t}, time0: ${time0}, time1: ${time1}, value: ${value}`)
        }

      value = this._calculateWithBaseValue(obj, value);

      this._applyValue(obj, value);
      this._handleEvents(obj, t);
    }
  }]);

  return CAKeyframeAnimation;
}(_CAPropertyAnimation3.default);

exports.default = CAKeyframeAnimation;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Values that inform SceneKit’s rendering for movement-related effects, used by the movabilityHint property.
 * @typedef {Object} SCNMovabilityHint
 * @property {number} fixed - The node is not expected to move over time.
 * @property {number} movable - The node is expected to move over time.
 * @see https://developer.apple.com/documentation/scenekit/scnmovabilityhint
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNMovabilityHint = {
  fixed: 0,
  movable: 1
};

exports.default = SCNMovabilityHint;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Modes that describe how SceneKit blends source colors rendered using a material with destination colors already in a rendering target, used by the blendMode property.
 * @typedef {Object} SCNBlendMode
 * @property {number} alpha - Blend by multiplying source and destination color values by their corresponding alpha values.
 * @property {number} add - Blend by adding the source color to the destination color.
 * @property {number} subtract - Blend by subtracting the source color from the destination color.
 * @property {number} multiply - Blend by multiplying the source color with the background color.
 * @property {number} screen - Blend by multiplying the inverse of the source color with the inverse of the destination color.
 * @property {number} replace - Blend by replacing the destination color with the source color, ignoring alpha.
 * @see https://developer.apple.com/documentation/scenekit/scnblendmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNBlendMode = {
  alpha: 0,
  add: 1,
  subtract: 2,
  multiply: 3,
  screen: 4,
  replace: 5
};

exports.default = SCNBlendMode;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 
 * @access public
 * @typedef {Object} SCNColorMask
 * @property {number} red -
 * @property {number} blue -
 * @property {number} green -
 * @property {number} alpha -
 * @property {number} all -
 * @see https://developer.apple.com/documentation/scenekit/scncolormask
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNColorMask = {
  red: 1,
  green: 2,
  blue: 4,
  alpha: 8,
  all: 15
};

exports.default = SCNColorMask;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 
 * @typedef {Object} SCNFillMode
 * @property {Symbol} fill - 
 * @property {Symbol} lines - 
 * @see https://developer.apple.com/documentation/scenekit/scnfillmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNFillMode = {
  fill: 2,
  lines: 1
};

exports.default = SCNFillMode;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Texture filtering modes, used by the the minificationFilter, magnificationFilter, and mipFilter properties.
 * @typedef {Object} SCNFilterMode
 * @property {number} none - No texture filtering is applied.
 * @property {number} nearest - Texture filtering returns the color from only one texel, whose location is nearest to the coordinates being sampled.
 * @property {number} linear - Texture filtering sample texels from the neighborhood of the coordinates being sampled and linearly interpolates their colors.
 * @see https://developer.apple.com/documentation/scenekit/scnfiltermode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNFilterMode = {
  none: 0,
  nearest: 1,
  linear: 2
};

exports.default = SCNFilterMode;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Modes to apply to texture wrapping, used by the wrapT and wrapS properties.
 * @typedef {Object} SCNWrapMode
 * @property {number} clamp - Texture coordinates are clamped to the range from 0.0 to 1.0, inclusive.
 * @property {number} repeat - Texture sampling uses only the fractional part of texture coordinates, passing through the range from 0.0 to (but not including) 1.0.
 * @property {number} clampToBorder - Texture sampling uses texture colors for coordinates in the range from 0.0 to 1.0 (inclusive) and the material property’s borderColor value otherwise.
 * @property {number} mirror - Texture sampling of texture coordinates outside range from 0.0 to 1.0 should behave as if the range reverses before repeating.
 * @see https://developer.apple.com/documentation/scenekit/scnwrapmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNWrapMode = {
  clamp: 1,
  repeat: 2,
  clampToBorder: 3,
  mirror: 4
};

exports.default = SCNWrapMode;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The modes SceneKit uses to calculate the opacity of pixels rendered with a material, used by the transparencyMode property.
 * @typedef {Object} SCNTransparencyMode
 * @property {number} aOne - SceneKit derives transparency information from the alpha channel of colors. The value 1.0 is opaque.
 * @property {number} rgbZero - SceneKit derives transparency information from the luminance of colors. The value 0.0 is opaque.
 * @see https://developer.apple.com/documentation/scenekit/scntransparencymode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNTransparencyMode = {
  aOne: 0,
  rgbZero: 1
};

exports.default = SCNTransparencyMode;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNNode from './SCNNode'
//import SCNVector3 from './SCNVector3'

/**
 * Detailed information about a contact between two physics bodies in a scene’s physics simulation. 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact
 */
var SCNPhysicsContact = function (_NSObject) {
  _inherits(SCNPhysicsContact, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNPhysicsContact() {
    _classCallCheck(this, SCNPhysicsContact);

    // Inspecting the Contact Properties

    var _this = _possibleConstructorReturn(this, (SCNPhysicsContact.__proto__ || Object.getPrototypeOf(SCNPhysicsContact)).call(this));

    _this._nodeA = null;
    _this._nodeB = null;
    _this._contactPoint = null;
    _this._contactNormal = null;
    _this._collisionImpulse = 0;
    _this._penetrationDistance = 0;
    return _this;
  }

  // Inspecting the Contact Properties

  /**
   * The node containing the first body in the contact.
   * @type {SCNNode}
   * @desc Use the node’s physicsBody property to examine physics characteristics of the node.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact/1523445-nodea
   */


  _createClass(SCNPhysicsContact, [{
    key: 'nodeA',
    get: function get() {
      return this._nodeA;
    }

    /**
     * The node containing the second body in the contact.
     * @type {SCNNode}
     * @desc Use the node’s physicsBody property to examine physics characteristics of the node.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact/1524232-nodeb
     */

  }, {
    key: 'nodeB',
    get: function get() {
      return this._nodeB;
    }

    /**
     * The contact point between the two physics bodies, in scene coordinates.
     * @type {SCNVector3}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact/1523810-contactpoint
     */

  }, {
    key: 'contactPoint',
    get: function get() {
      return this._contactPoint;
    }

    /**
     * The normal vector at the contact point between the two physics bodies, in scene coordinates.
     * @type {SCNVector3}
     * @desc This vector tells you which direction the bodies were moving relative to one another at the time of the collision. For example, in a game you can examine this vector to have enemy characters take damage when struck from above by the player character but damage the player character instead when they collide side-to-side.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact/1522833-contactnormal
     */

  }, {
    key: 'contactNormal',
    get: function get() {
      return this._contactNormal;
    }

    /**
     * The force over time of the collision, in newton-seconds.
     * @type {number}
     * @desc This property’s value tells you how hard the bodies struck each other in a collision. For example, in a game you might allow a character to proceed unhindered after a minor collision, but take damage when struck with sufficient force.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact/1523944-collisionimpulse
     */

  }, {
    key: 'collisionImpulse',
    get: function get() {
      return this._collisionImpulse;
    }

    /**
     * The distance of overlap, in units of scene coordinate space, between the two physics bodies.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnphysicscontact/1522870-penetrationdistance
     */

  }, {
    key: 'penetrationDistance',
    get: function get() {
      return this._penetrationDistance;
    }
  }]);

  return SCNPhysicsContact;
}(_NSObject3.default);

exports.default = SCNPhysicsContact;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import CAAnimation from '../QuartzCore/CAAnimation'
//import SCNTimingFunction from './SCNTimingFunction'

/**
 * 
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimationProtocol}
 * @see https://developer.apple.com/documentation/scenekit/scnanimation
 */
var SCNAnimation = function (_NSObject) {
  _inherits(SCNAnimation, _NSObject);

  // Initializers

  /**
   * 
   * @access public
   * @param {CAAnimation} caAnimation - 
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866056-init
   */
  function SCNAnimation(caAnimation) {
    _classCallCheck(this, SCNAnimation);

    // Instance Properties

    /**
     * 
     * @type {?SCNAnimationDidStartBlock}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866063-animationdidstart
     */
    var _this = _possibleConstructorReturn(this, (SCNAnimation.__proto__ || Object.getPrototypeOf(SCNAnimation)).call(this));

    _this.animationDidStart = null;

    /**
     * 
     * @type {?SCNAnimationDidStopBlock}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866040-animationdidstop
     */
    _this.animationDidStop = null;

    /**
     * 
     * @type {?SCNAnimationEvent[]}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866038-animationevents
     */
    _this.animationEvents = null;

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878140-autoreverses
     */
    _this.autoreverses = false;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2881689-blendinduration
     */
    _this.blendInDuration = 0;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2881690-blendoutduration
     */
    _this.blendOutDuration = 0;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866057-duration
     */
    _this.duration = 0;

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878138-fillsbackward
     */
    _this.fillsBackward = false;

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878132-fillsforward
     */
    _this.fillsForward = false;

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866062-isadditive
     */
    _this.isAdditive = false;

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878139-isappliedoncompletion
     */
    _this.isAppliedOnCompletion = false;

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866047-iscumulative
     */
    _this.isCumulative = false;

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878126-isremovedoncompletion
     */
    _this.isRemovedOnCompletion = false;

    /**
     * 
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878148-keypath
     */
    _this.keyPath = null;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878146-repeatcount
     */
    _this.repeatCount = 0;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878135-startdelay
     */
    _this.startDelay = 0;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878147-timeoffset
     */
    _this.timeOffset = 0;

    /**
     * 
     * @type {SCNTimingFunction}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878143-timingfunction
     */
    _this.timingFunction = null;

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2878127-usesscenetimebase
     */
    _this.usesSceneTimeBase = false;

    /**
     * @access private
     * @type {CAAnimation}
     */
    _this._animation = caAnimation;
    return _this;
  }

  /**
   * 
   * @access public
   * @param {string} animationUrl - 
   * @returns {SCNAnimation} -
   * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866053-init
   */


  _createClass(SCNAnimation, null, [{
    key: 'animationWithContentsOf',
    value: function animationWithContentsOf(animationUrl) {}
    // TODO: implement


    /**
     * 
     * @access public
     * @param {string} animationName - 
     * @returns {SCNAnimation} -
     * @see https://developer.apple.com/documentation/scenekit/scnanimation/2866042-init
     */

  }, {
    key: 'animationNamed',
    value: function animationNamed(animationName) {
      // TODO: implement
    }
  }]);

  return SCNAnimation;
}(_NSObject3.default);

exports.default = SCNAnimation;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Modes for antialiased rendering of the view’s scene, used by the SCNView property.
 * @typedef {Object} SCNAntialiasingMode
 * @property {number} none - Disables antialiased rendering.
 * @property {number} multisampling2X - Enables multisample antialiasing, with two samples per screen pixel.
 * @property {number} multisampling4X - Enables multisample antialiasing, with four samples per screen pixel.
 * @property {number} multisampling8X - Enables multisample antialiasing, with eight samples per screen pixel.
 * @property {number} multisampling16X - Enables multisample antialiasing, with sixteen samples per screen pixel.
 * @see https://developer.apple.com/documentation/scenekit/scnantialiasingmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNAntialiasingMode = {
  none: 0,
  multisampling2X: 1,
  multisampling4X: 2,
  multisampling8X: 3,
  multisampling16X: 4
};

exports.default = SCNAntialiasingMode;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNCameraProjectionDirection = __webpack_require__(89);

var _SCNCameraProjectionDirection2 = _interopRequireDefault(_SCNCameraProjectionDirection);

var _SCNMaterialProperty = __webpack_require__(26);

var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNAnimatable from './SCNAnimatable'

//import SCNTechniqueSupport from './SCNTechniqueSupport'


/**
 * A set of camera attributes that can be attached to a node to provide a point of view for displaying the scene.
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @implements {SCNTechniqueSupport}
 * @see https://developer.apple.com/documentation/scenekit/scncamera
 */
var SCNCamera = function (_NSObject) {
  _inherits(SCNCamera, _NSObject);

  _createClass(SCNCamera, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        name: 'string',
        zNear: 'float',
        zFar: 'float',
        yFov: 'float',
        xFov: 'float',
        fov: ['float', null], // TODO: implement
        automaticallyAdjustsZRange: 'boolean',
        usesOrthographicProjection: 'boolean',
        orthographicScale: 'float',
        projectionDirection: 'integer',
        categoryBitMask: 'integer',
        focalDistance: 'float',
        focalSize: 'float',
        focalBlurRadius: 'float',
        aperture: 'float',
        motionBlurIntensity: 'float',
        wantsHDR: 'boolean',
        exposureOffset: 'float',
        averageGray: 'float',
        whitePoint: 'float',
        minimumExposure: 'float',
        maximumExposure: 'float',
        wantsExposureAdaptation: 'boolean',
        exposureAdaptationDarkeningSpeedFactor: 'float',
        exposureAdaptationBrighteningSpeedFactor: 'float',
        exposureAdaptationDuration: ['float', null],
        exposureAdaptationHistogramRangeHighProbability: ['float', null],
        exposureAdaptationHistogramRangeLowProbability: ['float', null],
        exposureAdaptationMode: ['integer', null],
        contrast: 'float',
        saturation: 'float',
        //_colorGrading: 'SCNMaterialProperty',
        bloomIntensity: 'float',
        bloomThreshold: 'float',
        bloomBlurRadius: 'float',
        colorFringeIntensity: 'float',
        colorFringeStrength: 'float',
        vignettingIntensity: 'float',
        vignettingPower: 'float',
        //projectionTransform: 'SCNMatrix4'
        bladeCount: ['integer', 'apertureBladeCount'],
        fStop: 'float',
        focalBlurSampleCount: 'integer',
        focusDistance: 'float',
        screenSpaceAmbientOcclusionBias: 'float',
        screenSpaceAmbientOcclusionDepthThreshold: 'float',
        screenSpaceAmbientOcclusionIntensity: 'float',
        screenSpaceAmbientOcclusionNormalThreshold: 'float',
        screenSpaceAmbientOcclusionRadius: 'float',
        sensorSize: ['float', 'sensorHeight'], // TODO: check if it is correct

        entityID: ['string', '_entityID'],
        screenSpaceAmbientOcclusionSampleCount: ['integer', null],
        screenSpaceAmbientOcclusionDownSample: ['integer', null],
        dofIntensity: ['float', null],
        fillMode: ['integer', null]
      };
    }

    /**
     * constructor
     * @access public
     * @returns {void}
     */

  }]);

  function SCNCamera() {
    _classCallCheck(this, SCNCamera);

    // Managing Camera Attributes

    /**
     * A name associated with the camera object.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436623-name
     */
    var _this = _possibleConstructorReturn(this, (SCNCamera.__proto__ || Object.getPrototypeOf(SCNCamera)).call(this));

    _this.name = null;

    // Adjusting Camera Perspective

    /**
     * The camera's near depth limit. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436592-znear
     */
    _this.zNear = 1.0;

    /**
     * The camera’s far depth limit. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436596-zfar
     */
    _this.zFar = 100.0;

    /**
     * The camera’s field of view, in degrees, on the vertical axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436598-yfov
     */
    _this.yFov = 0;

    /**
     * The camera's field of view, in degrees, on the horizontal axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436608-xfov
     */
    _this.xFov = 0;

    /**
     * A Boolean value that determines whether the camera automatically adjusts its zNear and zFar depth limits.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436610-automaticallyadjustszrange
     */
    _this.automaticallyAdjustsZRange = false;

    // Managing the Camera Projection

    /**
     * A Boolean value that determines whether the camera uses an orthographic projection.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436621-usesorthographicprojection
     */
    _this.usesOrthographicProjection = false;

    /**
     * Specifies the camera’s magnification factor when using an orthographic projection.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436612-orthographicscale
     */
    _this.orthographicScale = 1.0;

    /**
     *
     * @type {SCNCameraProjectionDirection}
     * @see
     */
    _this.projectionDirection = _SCNCameraProjectionDirection2.default.horizontal;

    // Choosing Nodes to Be Visible to the Camera

    /**
     * A mask that defines which categories this camera belongs to.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436625-categorybitmask
     */
    _this.categoryBitMask = -1;

    // Adding Depth of Field and Blur Effects

    /**
     * The distance from the camera at which objects appear in sharp focus. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436600-focaldistance
     */
    _this.focalDistance = 10.0;

    /**
     * The width of the distance range at which objects appear in sharp focus. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436604-focalsize
     */
    _this.focalSize = 0.0;

    /**
     * The maximum amount of blurring, in pixels, applied to areas outside the camera’s depth of field. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436606-focalblurradius
     */
    _this.focalBlurRadius = 0.0;

    /**
     * A factor that determines the transition between in-focus and out-of-focus areas. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1436594-aperture
     */
    _this.aperture = 0.125;

    /**
     * A factor that determines the intensity of motion blur effects. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644099-motionblurintensity
     */
    _this.motionBlurIntensity = 0.0;

    // Adding High Dynamic Range Effects

    /**
     * A Boolean value that determines whether SceneKit applies High Dynamic Range (HDR) postprocessing effects to a scene.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644101-wantshdr
     */
    _this.wantsHDR = false;

    /**
     * A logarithmic bias that adjusts the results of SceneKit’s tone mapping operation, brightening or darkening the visible scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644105-exposureoffset
     */
    _this.exposureOffset = 0;

    /**
     * The luminance level to use as the midpoint of a tone mapping curve.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644097-averagegray
     */
    _this.averageGray = 0.18;

    /**
     * The luminance level to use as the upper end of a tone mapping curve.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644110-whitepoint
     */
    _this.whitePoint = 1.0;

    /**
     * The minimum exposure value to use in tone mapping.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644103-minimumexposure
     */
    _this.minimumExposure = -15.0;

    /**
     * The minimum exposure value to use in tone mapping.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644120-maximumexposure
     */
    _this.maximumExposure = 15.0;

    // Adding Automatic HDR Exposure Adaptation

    /**
     * A Boolean value that determines whether SceneKit automatically adjusts the exposure level.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644117-wantsexposureadaptation
     */
    _this.wantsExposureAdaptation = false;

    /**
     * The relative duration of automatically animated exposure transitions from dark to bright areas.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644093-exposureadaptationbrighteningspe
     */
    _this.exposureAdaptationBrighteningSpeedFactor = 0.4;

    /**
     * The relative duration of automatically animated exposure transitions from bright to dark areas.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644094-exposureadaptationdarkeningspeed
     */
    _this.exposureAdaptationDarkeningSpeedFactor = 0.6;

    // Adjusting Rendered Colors

    /**
     * An adjustment factor to apply to the overall visual contrast of the rendered scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644112-contrast
     */
    _this.contrast = 0.0;

    /**
     * An adjustment factor to apply to the overall color saturation of the rendered scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644100-saturation
     */
    _this.saturation = 1.0;

    _this._colorGrading = new _SCNMaterialProperty2.default();

    // Adding Stylistic Visual Effects

    /**
     * The magnitude of bloom effect to apply to highlights in the rendered scene. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644104-bloomintensity
     */
    _this.bloomIntensity = 0.0;

    /**
     * The brightness threshold at which to apply a bloom effect to highlights in the rendered scene. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644098-bloomthreshold
     */
    _this.bloomThreshold = 0.5;

    /**
     * The radius, in pixels, for the blurring portion of the bloom effect applied to highlights in the rendered scene. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644096-bloomblurradius
     */
    _this.bloomBlurRadius = 4.0;

    /**
     * The blend factor for fading the color fringing effect applied to the rendered scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644108-colorfringeintensity
     */
    _this.colorFringeIntensity = 1.0;

    /**
     * The magnitude of color fringing effect to apply to the rendered scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644113-colorfringestrength
     */
    _this.colorFringeStrength = 0.0;

    /**
     * The magnitude of vignette (darkening around edges) effect to apply to the rendered scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644106-vignettingintensity
     */
    _this.vignettingIntensity = 1.0;

    /**
     * The amount of the rendered scene to darken with a vignette effect.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644118-vignettingpower
     */
    _this.vignettingPower = 0.0;

    // Instance Properties

    /**
     * 
     * @type {SCNMatrix4}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1690501-projectiontransform
     */
    _this.projectionTransform = null;

    /**
     * @access private
     * @type {?string}
     */
    _this._entityID = null;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/2867484-aperturebladecount
     */
    _this.apertureBladeCount = 0; // TODO: check the default value

    /**
     *
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/2867490-fstop
     */
    _this.fStop = 0.0; // TODO: check the default value

    /**
     *
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/2867510-fieldofview
     */
    _this.fieldOfView = 0.0; // TODO: check the default value

    /**
     *
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncamera/2872999-focalblursamplecount
     */
    _this.focalBlurSampleCount = 0; // TODO: check the default value

    /**
     *
     * @type {number}
     * @see
     */
    _this.focalLength = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */
    _this.focalDistance = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */
    _this.screenSpaceAmbientOcclusionBias = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */
    _this.screenSpaceAmbientOcclusionDepthThreshold = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */
    _this.screenSpaceAmbientOcclusionIntensity = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */
    _this.screenSpaceAmbientOcclusionNormalThreshold = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */
    _this.screenSpaceAmbientOcclusionRadius = 0.0; // TODO:

    /**
     *
     * @type {number}
     * @see
     */
    _this.sensorHeight = 0.0; // TODO:

    /**
     *
     * @type {boolean}
     * @see
     */
    _this.wantsDepthOfField = false; // TODO:
    return _this;
  }

  // Creating a Camera

  /**
   * Creates a camera from the specified Model I/O camera object.
   * @access public
   * @param {MDLCamera} mdlCamera - A Model I/O camera object.
   * @returns {void}
   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLCamera class is a generic description of a viewpoint on a scene, supporting a superset of the attributes described by the SCNCamera class.
   * @see https://developer.apple.com/documentation/scenekit/scncamera/1419839-init
   */


  _createClass(SCNCamera, [{
    key: 'init',
    value: function init(mdlCamera) {}

    // Adjusting Rendered Colors
    /**
     * A texture for applying color grading effects to the entire rendered scene.
     * @type {SCNMaterialProperty}
     * @desc The contents value for this material property must be a 3D color lookup table, or a 2D texture image that represents such a table arranged in a horizontal strip. A lookup table is a cube of color values: the red, green, and blue components of an input color map to the x, y, and z coordinates of a location in that cube, and at that location in the cube is a corresponding output color. You can provide data in this cubic format as a Metal texture with the type3D texture type.The 2D representation of a 3D color cube is an arrangement of slices: for example, a 16 x 16 x 16 color cube becomes a horizontal strip of 16 squares, each 16 x 16 pixels (that is, a 256 x 16 image). Each square contains a gradation of red and green components, and together the 16 squares form a gradation for the blue component. To provide a 2D representation of a color cube, set this material property’s contents value to an image.By using a color table, you can easily create custom color effects that apply to an entire rendered scene:Create a basic color table image such as Figure 1, where the color value for each R, G, and B coordinate in the cube is the corresponding RGB color.Figure 1 Basic color table imageUse an image editor to create the color effect you want using some other image—such as a screenshot of your game. Apply only effects that affect pixel colors without modifying pixel positions. (For example, you can use hue/saturation, color curves, or color matrix filters, but not blur or distort filters.)Figure 2 Creating a color grading effectApply the same color effect you created in step 2 to your basic color table image. You can even perform these steps together: paste the basic color table into your game screenshot, apply an effect to the combined picture, then crop the picture to just the modified color table. Figure 2 shows an example effect.Assign your customized color table image (such as the example in Figure 3) to this property. When rendering, SceneKit looks up the RGB values for each pixel in the rendered scene, and displays the corresponding color values from the color table.Figure 3 Custom color table image for color gradingBasic color table imageCreating a color grading effectCustom color table image for color grading
     * @see https://developer.apple.com/documentation/scenekit/scncamera/1644114-colorgrading
     */

  }, {
    key: '_updateProjectionTransform',


    /**
     * @access private
     * @param {CGRect} viewRect -
     * @returns {void}
     */
    value: function _updateProjectionTransform(viewRect) {
      var m = new _SCNMatrix2.default();
      var left = viewRect.minX;
      var right = viewRect.maxX;
      var top = viewRect.maxY;
      var bottom = viewRect.minY;
      var aspect = viewRect.size.width / viewRect.size.height;

      if (this.usesOrthographicProjection) {
        //this.orthographicScale
        m.m11 = 2 / (right - left);
        m.m12 = 0;
        m.m13 = 0;
        m.m14 = 0;
        m.m21 = 0;
        m.m22 = 2 / (top - bottom);
        m.m23 = 0;
        m.m24 = 0;
        m.m31 = 0;
        m.m32 = 0;
        m.m33 = -2 / (this.zFar - this.zNear);
        m.m34 = 0;
        m.m41 = -(right + left) / (right - left);
        m.m42 = -(top + bottom) / (top - bottom);
        m.m43 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
        m.m44 = 1;
      } else {
        // perspective
        //this.yFov
        //this.xFov
        //this.automaticallyAdjustsZRange
        var m11 = 1;
        var m22 = 1;
        if (this.yFov <= 0 && this.xFov <= 0) {
          var cot = 1.0 / Math.tan(Math.PI / 6.0);
          m11 = cot / aspect;
          m22 = cot;
        } else if (this.yFov <= 0) {
          var _cot = 1.0 / Math.tan(this.xFov * Math.PI / 360.0);
          m11 = _cot;
          m22 = _cot * aspect;
        } else if (this.xFov <= 0) {
          var _cot2 = 1.0 / Math.tan(this.yFov * Math.PI / 360.0);
          m11 = _cot2 / aspect;
          m22 = _cot2;
        } else {
          // FIXME: compare xFov to yFov
          var _cot3 = 1.0 / Math.tan(this.yFov * Math.PI / 360.0);
          m11 = _cot3 / aspect;
          m22 = _cot3;
        }

        m.m11 = m11;
        m.m12 = 0;
        m.m13 = 0;
        m.m14 = 0;
        m.m21 = 0;
        m.m22 = m22;
        m.m23 = 0;
        m.m24 = 0;
        m.m31 = 0;
        m.m32 = 0;
        m.m33 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
        m.m34 = -1;
        m.m41 = 0;
        m.m42 = 0;
        m.m43 = -2 * this.zFar * this.zNear / (this.zFar - this.zNear);
        m.m44 = 0;
      }
      this.projectionTransform = m;
    }
  }, {
    key: 'colorGrading',
    get: function get() {
      return this._colorGrading;
    }
  }]);

  return SCNCamera;
}(_NSObject3.default);

exports.default = SCNCamera;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 
 * @typedef {Object} SCNCameraProjectionDirection
 * @property {number} horizontal - 
 * @property {number} vertical - 
 * @see https://developer.apple.com/documentation/scenekit/scncameraprojectiondirection
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNCameraProjectionDirection = {
  horizontal: 0,
  vertical: 1
};

exports.default = SCNCameraProjectionDirection;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 
 * @typedef {Object} SCNTessellationSmoothingMode
 * @property {number} none - 
 * @property {number} phong - 
 * @property {number} pnTriangles - 
 * @see https://developer.apple.com/documentation/scenekit/scntessellationsmoothingmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNTessellationSmoothingMode = {
  none: 0,
  phong: 1,
  pnTriangles: 2
};

exports.default = SCNTessellationSmoothingMode;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 
 * @typedef {Object} SCNHitTestOption
 * @property {string} backFaceCulling - An option to ignore faces not oriented toward the camera.
 * @property {string} boundingBoxOnly - An option to search for objects by bounding box only.
 * @property {string} categoryBitMask - 
 * @property {string} clipToZRange - An option to search for objects only within the depth range of the current point of view.
 * @property {string} firstFoundOnly - An option to return only the first object found.
 * @property {string} ignoreChildNodes - An option to ignore child nodes when searching.
 * @property {string} ignoreHiddenNodes - An option to ignore hidden nodes when searching.
 * @property {string} rootNode - The root of the node hierarchy to be searched.
 * @property {string} sortResults - An option to sort the results of a hit-test.
 * @see https://developer.apple.com/documentation/scenekit/scnhittestoption
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNHitTestOption = {
  backFaceCulling: 'kHitTestBackFaceCulling',
  boundingBoxOnly: 'kHitTestBoundingBoxOnly',
  categoryBitMask: 'kHitTestCategoryBitMask',
  clipToZRange: 'kHitTestClipToZRange',
  firstFoundOnly: 'kHitTestFirstFoundOnly',
  ignoreChildNodes: 'kHitTestIgnoreChildNodes',
  ignoreHiddenNodes: 'kHitTestSkipHiddenNode',
  rootNode: 'kHitTestRootNode',
  sortResults: 'kHitTestSortResults'
};

exports.default = SCNHitTestOption;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNMaterialProperty = __webpack_require__(26);

var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNAnimatable from './SCNAnimatable'
//import SCNTechniqueSupport from './SCNTechniqueSupport'


//import SCNShadowMode from './SCNShadowMode'

var _LightType = {
  IES: 'ies',
  ambient: 'ambient',
  directional: 'directional',
  omni: 'omni',
  probe: 'probe',
  spot: 'spot'

  /**
   * A light source that can be attached to a node to illuminate the scene.
   * @access public
   * @extends {NSObject}
   * @implements {SCNAnimatable}
   * @implements {SCNTechniqueSupport}
   * @see https://developer.apple.com/documentation/scenekit/scnlight
   */
};
var SCNLight = function (_NSObject) {
  _inherits(SCNLight, _NSObject);

  _createClass(SCNLight, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        type: 'string',
        color: 'plist',
        temperature: 'float',
        intensity: 'float',
        name: 'string',
        attenuationStartDistance: 'float',
        attenuationEndDistance: 'float',
        attenuationFalloffExponent: 'float',
        spotInnerAngle: 'float',
        spotOuterAngle: 'float',
        gobo: ['SCNMaterialProperty', '_gobo'],
        castsShadow: 'boolean',
        shadowRadius: 'float',
        shadowColor: 'plist',
        shadowMapSize: 'CGSize',
        shadowSampleCount: 'integer',
        shadowMode: 'integer',
        shadowBias: 'float',
        orthographicScale: 'float',
        zFar: 'float',
        zNear: 'float',
        lightCategoryBitMask: ['integer', 'categoryBitMask'],
        automaticallyAdjustsShadowProjection: 'boolean',
        forcesBackFaceCasters: 'boolean',
        maximumShadowDistance: 'float',
        sampleDistributedShadowMaps: 'boolean',
        shadowCascadeCount: 'integer',
        shadowCascadeSplittingFactor: 'float',

        entityID: ['string', '_entityID'],
        version: ['float', null],
        spotFallOffExponent: ['float', null],
        usesDeferredShadows: ['boolean', null],
        usesModulatedMode: ['boolean', null],
        shouldBakeIndirectLighting: ['boolean', null],
        shouldBakeDirectLighting: ['boolean', null],
        baked: ['boolean', null],
        goboProjectShadows: ['boolean', null],
        shadowSampleCount2: ['integer', null],
        sphericalHarmonics: ['NSMutableData', null],
        autoShadowProjection: ['boolean', null]
      };
    }

    // Creating a Light

    /**
     * Creates a light from the specified Model I/O light object.
     * @access public
     * @constructor
     * @param {?MDLLight} [mdlLight = null] - A Model I/O light object.
     * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLLight class is a generic description of a light source in a scene, supporting a superset of the attributes described by the SCNLight class.
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1419849-init
     */

  }]);

  function SCNLight() {
    var mdlLight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, SCNLight);

    // Modifying a Light’s Appearance

    /**
     * A constant identifying the general behavior of the light.
     * @type {SCNLight.LightType}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522919-type
     */
    var _this = _possibleConstructorReturn(this, (SCNLight.__proto__ || Object.getPrototypeOf(SCNLight)).call(this));

    _this.type = _LightType.omni;

    /**
     * The color of the light. Animatable.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523627-color
     */
    _this.color = new _SKColor2.default(1, 1, 1, 1);

    /**
     * The color temperature, in degrees Kelvin, of the light source. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1640545-temperature
     */
    _this.temperature = 6500.0;

    /**
     * The luminous flux, in lumens, or total brightness of the light. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1640548-intensity
     */
    _this.intensity = 1000.0;

    // Managing Light Attributes

    /**
     * A name associated with the light.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522839-name
     */
    _this.name = null;

    // Managing Light Attenuation

    /**
     * The distance from the light at which its intensity begins to diminish. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1524223-attenuationstartdistance
     */
    _this.attenuationStartDistance = 0;

    /**
     * The distance from the light at which its intensity is completely diminished. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1524140-attenuationenddistance
     */
    _this.attenuationEndDistance = 0;

    /**
     * The transition curve for the light’s intensity between its attenuation start and end distances. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522879-attenuationfalloffexponent
     */
    _this.attenuationFalloffExponent = 0;

    // Managing Spotlight Extent

    /**
     * The angle, in degrees, of the area fully lit by a spotlight. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522797-spotinnerangle
     */
    _this.spotInnerAngle = 0;

    /**
     * The angle, in degrees, of the area partially lit by a spotlight. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523382-spotouterangle
     */
    _this.spotOuterAngle = 45.0;

    _this._gobo = new _SCNMaterialProperty2.default();

    // Managing Shadows Cast by the Light

    /**
     * A Boolean value that determines whether the light casts shadows.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523816-castsshadow
     */
    _this.castsShadow = false;

    /**
     * A number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523724-shadowradius
     */
    _this.shadowRadius = 3.0;

    /**
     * The color of shadows cast by the light. Animatable.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522864-shadowcolor
     */
    _this.shadowColor = new _SKColor2.default(0, 0, 0, 1);

    /**
     * The size of the shadow map image that SceneKit renders when creating shadows.
     * @type {CGSize}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1524127-shadowmapsize
     */
    _this.shadowMapSize = new _CGSize2.default(0, 0);

    /**
     * The number of samples from the shadow map that SceneKit uses to render each pixel.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523300-shadowsamplecount
     */
    _this.shadowSampleCount = 0;

    /**
     * The mode SceneKit uses to render shadows.
     * @type {SCNShadowMode}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522847-shadowmode
     */
    _this.shadowMode = null;

    /**
     * The amount of correction to apply to the shadow to prevent rendering artifacts.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522849-shadowbias
     */
    _this.shadowBias = 1.0;

    /**
     * The orthographic scale SceneKit uses when rendering the shadow map for a directional light.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523951-orthographicscale
     */
    _this.orthographicScale = 1.0;

    /**
     * The maximum distance between the light and a visible surface for casting shadows.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522845-zfar
     */
    _this.zFar = 100.0;

    /**
     * The minimum distance between the light and a visible surface for casting shadows. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1522630-znear
     */
    _this.zNear = 1.0;

    // Choosing Nodes to be Illuminated by the Light

    /**
     * A mask that defines which categories this light belongs to.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523669-categorybitmask
     */
    _this.categoryBitMask = -1;

    // Managing Photometric Lights

    /**
     * The URL for a file that contains photometry data describing the intended appearance of the light.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1640546-iesprofileurl
     */
    _this.iesProfileURL = null;

    /**
     * @access private
     * @type {?string}
     */
    _this._entityID = null;

    _this._context = null;
    _this._shadowFrameBuffer = null;
    _this._shadowDepthBuffer = null;
    _this._shadowDepthTexture = null;
    _this._projectionTransform = null;

    /**
     * 
     * @type {boolean}
     * @see
     */
    _this.automaticallyAdjustsShadowProjection = false;

    /**
     * 
     * @type {boolean}
     * @see
     */
    _this.forcesBackFaceCasters = false;

    /**
     *
     * @type {number}
     * @see
     */
    _this.maximumShadowDistance = 0.0;

    /**
     *
     * @type {boolean}
     * @see
     */
    _this.sampleDistributedShadowMaps = false;

    /**
     *
     * @type {number}
     * @see
     */
    _this.shadowCascadeCount = 1;

    /**
     *
     * @type {number}
     * @see
     */
    _this.shadowCascadeSplittingFactor = 1.0;
    return _this;
  }

  // Managing Light Attributes

  /**
   * Returns the value of a lighting attribute.
   * @deprecated
   * @access public
   * @param {string} key - A constant specifying a lighting attribute. See Lighting Attribute Keys for available keys and their possible values.
   * @returns {?Object} - 
   * @desc A light’s type property determines its set of available attributes.You can also get the values of lighting attributes using Key-value coding. The key path for each lighting attribute is listed in Lighting Attribute Keys.
   * @see https://developer.apple.com/documentation/scenekit/scnlight/1523345-attribute
   */


  _createClass(SCNLight, [{
    key: 'attributeForKey',
    value: function attributeForKey(key) {
      return null;
    }

    /**
     * Sets the value for a lighting attribute.
     * @deprecated
     * @access public
     * @param {?Object} attribute - The value for the lighting attribute.
     * @param {string} key - A constant specifying a lighting attribute. See Lighting Attribute Keys for available keys and their possible values.
     * @returns {void}
     * @desc A light’s type property determines its set of available attributes.You can also set or animate changes to the values of lighting attributes using Key-value coding. The key path for each lighting attribute is listed in Lighting Attribute Keys.
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523148-setattribute
     */

  }, {
    key: 'setAttributeForKey',
    value: function setAttributeForKey(attribute, key) {}

    // Managing Spotlight Extent

    /**
     * An image or other visual content affecting the shape and color of a light’s illuminated area.
     * @type {?SCNMaterialProperty}
     * @desc In photographic and stage lighting terminology, a gobo (also known as a flag or cookie) is a stencil, gel, or other object placed just in front of a light source, shaping or coloring the beam of light.You alter the appearance of a spotlight by changing the contents property of the object permanently assigned to this property. As with other material properties, you can use a color or image, or a Core Animation layer containing animated content, as a lighting gobo.This property applies only to lights whose type property is spot.
     * @see https://developer.apple.com/documentation/scenekit/scnlight/1523524-gobo
     */

  }, {
    key: '_getDepthBufferForContext',
    value: function _getDepthBufferForContext(context) {
      if (this._shadowFrameBuffer && this._context === context) {
        return this._shadowFrameBuffer;
      }
      this._context = context;

      var gl = context;
      var width = this._shadowMapWidth;
      var height = this._shadowMapHeight;
      this._shadowFrameBuffer = gl.createFramebuffer();
      this._shadowDepthBuffer = gl.createRenderbuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._shadowFrameBuffer);

      gl.bindRenderbuffer(gl.RENDERBUFFER, this._shadowDepthBuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._shadowDepthBuffer);

      this._shadowDepthTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this._shadowDepthTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.generateMipmap(gl.TEXTURE_2D);

      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._shadowDepthTexture, 0);
      gl.drawBuffers([gl.COLOR_ATTACHMENT0]);

      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);

      return this._shadowFrameBuffer;
    }

    /**
     * @access private
     * @param {CGRect} viewRect -
     * @returns {void}
     */

  }, {
    key: '_updateProjectionTransform',
    value: function _updateProjectionTransform() {
      var m = new _SCNMatrix2.default();
      var left = 0;
      var right = this._shadowMapWidth;
      var top = 0;
      var bottom = this._shadowMapHeight;
      var aspect = this._shadowMapWidth / this._shadowMapHeight;

      if (this.type === _LightType.directional) {
        // orthographic
        // FIXME: use orthographicScale, adjust x/y scale automatically
        //m.m11 = 2 / (right - left)
        m.m11 = 0.2;
        //m.m11 = 2 / (right - left)
        m.m12 = 0;
        m.m13 = 0;
        m.m14 = 0;
        m.m21 = 0;
        //m.m22 = 2 / (top - bottom)
        m.m22 = 0.2;
        m.m23 = 0;
        m.m24 = 0;
        m.m31 = 0;
        m.m32 = 0;
        m.m33 = -2 / (this.zFar - this.zNear);
        //m.m33 = -1 / (this.zFar - this.zNear)
        m.m34 = 0;
        m.m41 = 0;
        m.m42 = 0;
        m.m43 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
        //m.m43 = -this.zFar / (this.zFar - this.zNear)
        m.m44 = 1;
      } else {
        // perspective
        var m11 = 1;
        var m22 = 1;
        if (this.yFov <= 0 && this.xFov <= 0) {
          var cot = 1.0 / Math.tan(Math.PI / 6.0);
          m11 = cot / aspect;
          m22 = cot;
        } else if (this.yFov <= 0) {
          var _cot = 1.0 / Math.tan(this.xFov * Math.PI / 360.0);
          m11 = _cot;
          m22 = _cot * aspect;
        } else if (this.xFov <= 0) {
          var _cot2 = 1.0 / Math.tan(this.yFov * Math.PI / 360.0);
          m11 = _cot2 / aspect;
          m22 = _cot2;
        } else {
          // FIXME: compare xFov to yFov
          var _cot3 = 1.0 / Math.tan(this.yFov * Math.PI / 360.0);
          m11 = _cot3 / aspect;
          m22 = _cot3;
        }

        m.m11 = m11;
        m.m12 = 0;
        m.m13 = 0;
        m.m14 = 0;
        m.m21 = 0;
        m.m22 = m22;
        m.m23 = 0;
        m.m24 = 0;
        m.m31 = 0;
        m.m32 = 0;
        m.m33 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
        m.m34 = -1;
        m.m41 = 0;
        m.m42 = 0;
        m.m43 = -2 * this.zFar * this.zNear / (this.zFar - this.zNear);
        m.m44 = 0;
      }
      this._projectionTransform = m;
    }
  }, {
    key: 'gobo',
    get: function get() {
      return this._gobo;
    }

    // Structures

    /**
     * @type {Object} LightType
     * @property {string} IES A light source whose shape, direction, and intensity of illumination is determined by a photometric profile.
     * @property {string} ambient A light that illuminates all objects in the scene from all directions.
     * @property {string} directional A light source with a uniform direction and constant intensity.
     * @property {string} omni An omnidirectional light, also known as a point light. 
     * @property {string} probe A sample of the environment around a point in a scene to be used in environment-based lighting.
     * @property {string} spot A light source that illuminates a cone-shaped area.
     * @see https://developer.apple.com/documentation/scenekit/scnlight.lighttype
     */

  }, {
    key: '_shadowMapWidth',
    get: function get() {
      if (this.shadowMapSize.width > 0) {
        return this.shadowMapSize.width;
      }
      // FIXME: adjust shadowMapSize
      return 2048;
    }
  }, {
    key: '_shadowMapHeight',
    get: function get() {
      if (this.shadowMapSize.height > 0) {
        return this.shadowMapSize.height;
      }
      // FIXME: adjust shadowMapSize
      return 2048;
    }
  }], [{
    key: 'LightType',
    get: function get() {
      return _LightType;
    }
  }]);

  return SCNLight;
}(_NSObject3.default);

exports.default = SCNLight;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a matrix describing a scale transformation.
 * @access public
 * @param {number} sx - The scale factor in the x-axis direction.
 * @param {number} sy - The scale factor in the y-axis direction.
 * @param {number} sz - The scale factor in the z-axis direction.
 * @returns {SCNMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409681-scnmatrix4makescale
 */
var SCNMatrix4MakeScale = function SCNMatrix4MakeScale(sx, sy, sz) {
  return new _SCNMatrix2.default(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
};

exports.default = SCNMatrix4MakeScale;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The interpolation formulas for blending between target geometries.
 * @typedef {Object} SCNMorpherCalculationMode
 * @property {number} normalized - Target weights must be in the range between 0.0 and 1.0, and the contribution of the base geometry to the morphed surface is related to the sum of target weights. This is the default mode.
 * @property {number} additive - Target weights may take on any value, and weighted contributions for each target are added to the base geometry,
 * @see https://developer.apple.com/documentation/scenekit/scnmorphercalculationmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNMorpherCalculationMode = {
  normalized: 0,
  additive: 1
};

exports.default = SCNMorpherCalculationMode;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for the initial direction of each emitted particle, used by the birthDirection property.
 * @typedef {Object} SCNParticleBirthDirection
 * @property {number} constant - The emitting direction is the same for all particles.
 * @property {number} surfaceNormal - The emitting direction for each particle is along the surface normal vector at the point where the particle is emitted.
 * @property {number} random - SceneKit randomizes the emitting direction for each particle.
 * @see https://developer.apple.com/documentation/scenekit/scnparticlebirthdirection
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNParticleBirthDirection = {
  constant: 0,
  surfaceNormal: 1,
  random: 2
};

exports.default = SCNParticleBirthDirection;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for the initial location of each emitted particle, used by the birthLocation property.
 * @typedef {Object} SCNParticleBirthLocation
 * @property {number} surface - New particles can be created at any location on the surface of the emitter shape.
 * @property {number} volume - New particles can be created at any location within the volume of the emitter shape.
 * @property {number} vertex - New particles can be created at only at the locations of the vertices in the emitter shape.
 * @see https://developer.apple.com/documentation/scenekit/scnparticlebirthlocation
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNParticleBirthLocation = {
  surface: 0,
  volume: 1,
  vertex: 2
};

exports.default = SCNParticleBirthLocation;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.
 * @typedef {Object} SCNParticleBlendMode
 * @property {number} additive - The source and destination colors are added together.
 * @property {number} subtract - The source color is subtracted from the destination color.
 * @property {number} multiply - The source color is multiplied by the destination color.
 * @property {number} screen - The source color is added to the destination color times the inverted source color.
 * @property {number} alpha - The source and destination colors are blended by multiplying the source alpha value.
 * @property {number} replace - The source color replaces the destination color.
 * @see https://developer.apple.com/documentation/scenekit/scnparticleblendmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNParticleBlendMode = {
  additive: 0,
  subtract: 1,
  multiply: 2,
  screen: 3,
  alpha: 4,
  replace: 5
};

exports.default = SCNParticleBlendMode;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for animating each particle with a sequence of images, used by the imageSequenceAnimationMode property.
 * @typedef {Object} SCNParticleImageSequenceAnimationMode
 * @property {number} repeat - The animation loops after displaying all of its images.
 * @property {number} clamp - The animation stops after displaying all of its images.
 * @property {number} autoReverse - After the animation displays all of its images, it plays again in reverse order.
 * @see https://developer.apple.com/documentation/scenekit/scnparticleimagesequenceanimationmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNParticleImageSequenceAnimationMode = {
  repeat: 0,
  clamp: 1,
  autoReverse: 2
};

exports.default = SCNParticleImageSequenceAnimationMode;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for restricting the orientation of particles, used by the orientationMode property.
 * @typedef {Object} SCNParticleOrientationMode
 * @property {number} billboardScreenAligned - Each particle’s orientation is always fixed with respect to the point of view camera.
 * @property {number} billboardViewAligned - Each particle always faces the point of view camera (but may rotate about an axis parallel to the view direction).
 * @property {number} free - Particle orientations are not restricted; they may rotate freely in all axes.
 * @property {number} billboardYAligned - The y-axis direction of each particle is always fixed with respect to the point of view camera.
 * @see https://developer.apple.com/documentation/scenekit/scnparticleorientationmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNParticleOrientationMode = {
  billboardScreenAligned: 0,
  billboardViewAligned: 1,
  free: 2,
  billboardYAligned: 3
};

exports.default = SCNParticleOrientationMode;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for the rendering order of particles, used by the sortingMode property.
 * @typedef {Object} SCNParticleSortingMode
 * @property {number} none - Particles are not sorted; they may be rendered in any order.
 * @property {number} projectedDepth - Particles farther from the point of view (as measured using projected depth) are rendered before closer particles.
 * @property {number} distance - Particles farther from the point of view (as measured using distance from the camera in scene space) are rendered before closer particles.
 * @property {number} oldestFirst - Particles emitted earlier are rendered before particles emitted more recently.
 * @property {number} youngestFirst - Particles emitted more recently are rendered before particles emitted earlier.
 * @see https://developer.apple.com/documentation/scenekit/scnparticlesortingmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNParticleSortingMode = {
  none: 0,
  projectedDepth: 1,
  distance: 2,
  oldestFirst: 3,
  youngestFirst: 4
};

exports.default = SCNParticleSortingMode;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNFieldForceEvaluator from './SCNFieldForceEvaluator'
//import SCNVector3 from './SCNVector3'
//import SCNPhysicsFieldScope from './SCNPhysicsFieldScope'

/**
 * An object that applies forces, such as gravitation, electromagnetism, and turbulence, to physics bodies within a certain area of effect. 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield
 */
var SCNPhysicsField = function (_NSObject) {
  _inherits(SCNPhysicsField, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNPhysicsField() {
    _classCallCheck(this, SCNPhysicsField);

    // Specifying a Field’s Area of Effect

    /**
     * A location marking the end of the field’s area of effect.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388138-halfextent
     */
    var _this = _possibleConstructorReturn(this, (SCNPhysicsField.__proto__ || Object.getPrototypeOf(SCNPhysicsField)).call(this));

    _this.halfExtent = null;

    /**
     * The area affected by the field, either inside or outside its region.
     * @type {SCNPhysicsFieldScope}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388136-scope
     */
    _this.scope = null;

    /**
     * A Boolean value that determines whether the field’s area of effect is shaped like a box or ellipsoid.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388158-usesellipsoidalextent
     */
    _this.usesEllipsoidalExtent = false;

    /**
     * The offset of the field’s center within its area of effect.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388154-offset
     */
    _this.offset = null;

    /**
     * The field’s directional axis.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388128-direction
     */
    _this.direction = null;

    // Specifying a Field’s Behavior

    /**
     * A multiplier for the force that the field applies to objects in its area of effect.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388132-strength
     */
    _this.strength = 0;

    /**
     * An exponent that determines how the field’s strength diminishes with distance.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388146-falloffexponent
     */
    _this.falloffExponent = 0;

    /**
     * The minimum value for distance-based effects.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388148-minimumdistance
     */
    _this.minimumDistance = 0;

    /**
     * A Boolean value that determines whether the field’s effect is enabled.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388117-isactive
     */
    _this.isActive = false;

    /**
     * A Boolean value that determines whether the field overrides other fields whose areas of effect it overlaps.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388126-isexclusive
     */
    _this.isExclusive = false;

    // Choosing Physics Bodies to Be Affected by the Field

    /**
     * A mask that defines which categories this physics field belongs to.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388119-categorybitmask
     */
    _this.categoryBitMask = 0;

    return _this;
  }

  // Creating Physics Fields

  /**
   * Creates a field that slows any object in its area of effect with a force proportional to the object’s velocity.
   * @access public
   * @returns {SCNPhysicsField} - 
   * @desc Like the damping and angularDamping properties of a physics body, drag fields can simulate effects such as fluid friction or air resistance. Unlike those properties, drag fields can simulate different intensities of fluid friction in different areas of your scene. For example, you can use a drag field to represent underwater areas.The default falloffExponent value for a drag field is 0.0, indicating that the field’s effect is constant throughout its area of effect.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388164-drag
   */


  _createClass(SCNPhysicsField, null, [{
    key: 'drag',
    value: function drag() {
      return null;
    }

    /**
     * Creates a field whose forces circulate around an axis.
     * @access public
     * @returns {SCNPhysicsField} - 
     * @desc The force on an object in a vortex field is tangential to the line from the object’s position to the field’s axis and proportional to the object’s mass. (The field’s axis is a line that is parallel to its direction vector and that passes through its center. For details, see the offset property.) For example, when a vortex field’s area of effect contains many objects, the resulting scene resembles a tornado: The objects simultaneously revolve around and fly away from the field’s center.By default, a vortex circulates counterclockwise relative to its direction vector. To make it circulate clockwise, set the field’s strength property to a negative value.The default falloffExponent value for a vortex field is 0.0, indicating that the field’s effect is constant throughout its area of effect.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388160-vortex
     */

  }, {
    key: 'vortex',
    value: function vortex() {
      return null;
    }

    /**
     * Creates a field that accelerates objects toward its center.
     * @access public
     * @returns {SCNPhysicsField} - 
     * @desc Because the force of gravity on an object is proportional to the object’s mass, this force accelerates all objects at the same distance from the field’s center by the same amount. The field’s strength property measures this acceleration in meters per second per second.By default, a radial gravity field attracts objects toward its center. To make it repel objects instead, set the field’s strength property to a negative value.The default falloffExponent value for a radial gravity field is 2.0, indicating that the field’s effect diminishes with the square of distance from its center.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388115-radialgravity
     */

  }, {
    key: 'radialGravity',
    value: function radialGravity() {
      return null;
    }

    /**
     * Creates a field that accelerates objects in a specific direction.
     * @access public
     * @returns {SCNPhysicsField} - 
     * @desc Because the force of gravity on an object is proportional to the object’s mass, this force accelerates all objects in the field’s area of affect by the same amount. The field’s strength property measures this acceleration in meters per second per second.By default, a linear gravity field accelerates objects in along its direction vector. To make it accelerate objects in the opposite direction, set the field’s strength property to a negative value.The default falloffExponent value for a linear gravity field is 0.0, indicating that the field’s effect is constant throughout its area of effect.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388130-lineargravity
     */

  }, {
    key: 'linearGravity',
    value: function linearGravity() {
      return null;
    }

    /**
     * Creates a field that applies random forces to objects in its area of effect.
     * @access public
     * @param {number} smoothness - The amount of randomness in the field. A value of 0.0 specifies maximum noise, and a value of 1.0 specifies no noise at all.
     * @param {number} speed - The field’s variation over time. Specify 0.0 for a static field.
     * @returns {SCNPhysicsField} - 
     * @desc Use this field type to simulate effects involving random motion, such as fireflies or gently falling snow.In calculating the direction and strength of the field’s effect on an object, SceneKit uses a Perlin simplex noise function. This function produces a velocity field that varies over time.The default falloffExponent value for a noise field is 0.0, indicating that the field’s effect is constant throughout its area of effect. This field type ignores the field’s direction property.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388150-noisefield
     */

  }, {
    key: 'noiseFieldAnimationSpeed',
    value: function noiseFieldAnimationSpeed(smoothness, speed) {
      return null;
    }

    /**
     * Creates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects’ velocities.
     * @access public
     * @param {number} smoothness - The amount of randomness in the field. A value of 0.0 specifies maximum noise, and a value of 1.0 specifies no noise at all.
     * @param {number} speed - The field’s variation over time. Specify 0.0 for a static field.
     * @returns {SCNPhysicsField} - 
     * @desc Like a noise field, a turbulence field applies forces in random directions to the objects that it affects. Unlike a noise field, a turbulence field applies a force whose magnitude is proportional to the speed of each affected object. For example, an object passing through a noise field shakes as it travels through the field, but an object passing through a turbulence field shakes more violently the faster it travels. The field’s strength property scales the magnitude of the turbulence effect.The default falloffExponent value for a turbulence field is 0.0, indicating that the field’s effect is constant throughout its area of effect.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388162-turbulencefield
     */

  }, {
    key: 'turbulenceFieldAnimationSpeed',
    value: function turbulenceFieldAnimationSpeed(smoothness, speed) {
      return null;
    }

    /**
     * Creates a field that pulls objects toward its center with a spring-like force.
     * @access public
     * @returns {SCNPhysicsField} - 
     * @desc The force a spring field applies to objects in its area of effect is linearly proportional to the distance from the object to the center of the field. (That is, the field behaves according to Hooke’s Law of real-world spring forces.) An object placed at the center of the field and moved away will oscillate around the center, with a period of oscillation that is proportional to the object’s mass. The field’s strength property scales the magnitude of the spring effect—a larger strength simulates a stiffer spring.The default falloffExponent value for a spring field is 1.0, indicating that the field’s effect diminishes linearly with distance from its center.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388134-spring
     */

  }, {
    key: 'spring',
    value: function spring() {
      return null;
    }

    /**
     * Creates a field that attracts or repels objects based on their electrical charge and on their distance from the field’s center.
     * @access public
     * @returns {SCNPhysicsField} - 
     * @desc Use this field type to make objects behave differently from one another when they enter a region, or to make an object's behavior different from its mass-based behavior. An electric field behaves according to the first part of the Lorentz force equation modeling real-world electromagnetic forces—the field applies a force whose magnitude is proportional to electric charge and distance.By default, physics bodies and particle systems have no electric charge, so they are unaffected by electric and magnetic fields. Use the charge property of a physics body or the particleCharge property of a particle system to add charge-based behavior.When the field’s strength value is positive (the default), it attracts bodies whose charge is negative and repels bodies whose charge is positive. To reverse this behavior, set the field’s strength property to a negative value.The default falloffExponent value for an electric field is 2.0, indicating that the field’s effect diminishes with the square of its distance from its center.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388152-electric
     */

  }, {
    key: 'electric',
    value: function electric() {
      return null;
    }

    /**
     * Creates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the field’s axis.
     * @access public
     * @returns {SCNPhysicsField} - 
     * @desc Use this field type to make objects behave differently from one another when they enter a region, or to make an object's behavior different from its mass based behavior. A magnetic field behaves according to the second part of the Lorentz force equation modeling real-world electromagnetic forces—the field applies a force determined by the cross product of an object’s velocity vector and the magnetic field vector at the object’s location, with magnitude proportional to the object’s electric charge. By default, physics bodies and particle systems have no electric charge, so they are unaffected by electric and magnetic fields. Use the charge property of a physics body or the particleCharge property of a particle system to add charge-based behavior.When the field’s strength value is positive (the default), the magnetic field vectors circulate counterclockwise relative to the field’s direction vector. (That is, the magnetic field models a real-world magnetic field created by current in a wire oriented in the field’s direction.) To make field vectors circulate clockwise, set the field’s strength property to a negative value.NoteThis SCNPhysicsField option models the real-world physics effect of magnetic fields on moving, electrically charged bodies, not the behavior of permanent magnets or electromagnets. To make objects in your scene simply attract or repel one another, use a different field type. For example, a field created by the radialGravity() method attracts or repels all dynamic bodies near it according to its strength property, and a field created by the electric() method selectively attracts or repels bodies according to their electric charge.The default falloffExponent value for a magnetic field is 2.0, indicating that the field’s effect diminishes with the square of distance from its center.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388168-magnetic
     */

  }, {
    key: 'magnetic',
    value: function magnetic() {
      return null;
    }

    // Creating Custom Physics Fields

    /**
     * Creates a field that runs the specified block to determine the force a field applies to each object in its area of effect.
     * @access public
     * @param {SCNFieldForceEvaluator} block - A block that SceneKit runs for each object in the field’s area of effect. See SCNFieldForceEvaluator. 
     * @returns {SCNPhysicsField} - 
     * @desc For custom physics fields, SceneKit ignores the direction, strength, falloffExponent, and minimumDistance properties. Instead, SceneKit calls your block to determine the direction and magnitude of force to apply to each physics body or particle in the field’s area of effect.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsfield/1388140-customfield
     */

  }, {
    key: 'customFieldEvaluationBlock',
    value: function customFieldEvaluationBlock(block) {
      return null;
    }
  }]);

  return SCNPhysicsField;
}(_NSObject3.default);

exports.default = SCNPhysicsField;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNPhysicsField2 = __webpack_require__(101);

var _SCNPhysicsField3 = _interopRequireDefault(_SCNPhysicsField2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 * @access public
 * @extends {SCNPhysicsField}
 *
 */
var SCNPhysicsNoiseField = function (_SCNPhysicsField) {
  _inherits(SCNPhysicsNoiseField, _SCNPhysicsField);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNPhysicsNoiseField() {
    _classCallCheck(this, SCNPhysicsNoiseField);

    var _this = _possibleConstructorReturn(this, (SCNPhysicsNoiseField.__proto__ || Object.getPrototypeOf(SCNPhysicsNoiseField)).call(this));

    _this._smoothness = 0.0;
    _this._animationSpeed = 1.0;
    return _this;
  }

  return SCNPhysicsNoiseField;
}(_SCNPhysicsField3.default);

exports.default = SCNPhysicsNoiseField;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNProgramDelegate from './SCNProgramDelegate'
//import SCNBufferFrequency from './SCNBufferFrequency'
//import SCNBufferBindingBlock from './SCNBufferBindingBlock'


/**
 * A complete Metal or OpenGL shader program that replaces SceneKit's rendering of a geometry or material.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnprogram
 */
var SCNProgram = function (_NSObject) {
  _inherits(SCNProgram, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNProgram() {
    _classCallCheck(this, SCNProgram);

    // Working with OpenGL Shader Source Code

    /**
     * GLSL source code for the program’s vertex shader.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1522891-vertexshader
     */
    var _this = _possibleConstructorReturn(this, (SCNProgram.__proto__ || Object.getPrototypeOf(SCNProgram)).call(this));

    _this.vertexShader = null;

    /**
     * GLSL source code for the program’s fragment shader.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1523135-fragmentshader
     */
    _this.fragmentShader = null;

    /**
     * GLSL source code for the program’s optional geometry shader.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1524049-geometryshader
     */
    _this.geometryShader = null;

    /**
     * GLSL source code for the program’s optional tessellation control shader.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1523852-tessellationcontrolshader
     */
    _this.tessellationControlShader = null;

    /**
     * GLSL source code for the program’s optional tessellation evaluation shader.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1523760-tessellationevaluationshader
     */
    _this.tessellationEvaluationShader = null;

    // Providing a Delegate Object

    /**
     * The delegate of the program object.
     * @type {?SCNProgramDelegate}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1522611-delegate
     */
    _this.delegate = null;

    // Managing Opacity

    /**
     * A Boolean value that indicates whether fragments rendered by the program are fully opaque.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1522844-isopaque
     */
    _this.isOpaque = false;

    // Working With Metal Shaders

    /**
     * The name of the vertex shader function to load from a Metal shader library.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1522799-vertexfunctionname
     */
    _this.vertexFunctionName = null;

    /**
     * The name of the fragment shader function to load from a Metal shader library.
     * @type {?string}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1524012-fragmentfunctionname
     */
    _this.fragmentFunctionName = null;

    /**
     * The Metal shader library containing shader functions to be used by this program.
     * @type {?MTLLibrary}
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1522934-library
     */
    _this.library = null;

    /**
     * @access private
     * @type {Map<string, NSObject}}
     */
    _this._semantics = new Map();

    /**
     * @access private
     * @type {Map<string, SCNBufferBindingBlock>[]}
     */
    _this._bufferBindings = [new Map(), new Map(), new Map()];

    /**
     * @access private
     * @type {boolean}
     */
    _this._programCompiled = false;

    _this._context = null;

    /**
     * @access private
     * @type {WebGLProgram}
     */
    _this._glProgram = null;

    /**
     * @access private
     * @type {WebGLShader}
     */
    _this._glVertexShader = null;

    /**
     * @access private
     * @type {WebGLShader}
     */
    _this._glFragmentShader = null;

    /**
     * @access private
     * @type {WebGLTexture}
     */
    _this._dummyTexture = null;

    /**
     * @access private
     * @type {WebGLTexture}
     */
    _this._dummyCubeMapTexture = null;

    /**
     * @access private
     * @type {SCNShadable}
     */
    _this._parentObject = null;
    return _this;
  }

  // Mapping GLSL Symbols to SceneKit Semantics

  /**
   * Associates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.
   * @access public
   * @param {?string} semantic - A SceneKit semantic identifier. See Geometry Semantic Identifiers and Rendering Transform Keys for possible values.
   * @param {string} symbol - The name declared in the program’s GLSL source code for the vertex attribute or uniform variable to be associated with the semantic.
   * @param {?Map<string, Object>} [options = null] - A dictionary of options affecting the semantic. See Program Semantic Options for applicable keys and values.
   * @returns {void}
   * @desc Use this method to provide inputs managed by SceneKit to your GLSL program.To use vertex attributes provided by SCNGeometry objects, use the constants listed in Geometry Semantic Identifiers.To use the coordinate transformations defined by the scene’s node hierarchy and point-of-view camera, use the constants listed in Rendering Transform Keys.
   * @see https://developer.apple.com/documentation/scenekit/scnprogram/1522730-setsemantic
   */


  _createClass(SCNProgram, [{
    key: 'setSemanticForSymbol',
    value: function setSemanticForSymbol(semantic, symbol) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      this._semantics.set(symbol, semantic);
    }

    /**
     * Returns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.
     * @access public
     * @param {string} symbol - The name declared in the program’s GLSL source code for a vertex attribute or uniform variable semantic.
     * @returns {?string} - 
     * @see https://developer.apple.com/documentation/scenekit/scnprogram/1523350-semantic
     */

  }, {
    key: 'semanticForSymbol',
    value: function semanticForSymbol(symbol) {
      return this._semantics.set(symbol);
    }

    // Providing Input for Metal Shaders

    /**
     * Registers a block for SceneKit to call at render time for binding a Metal buffer to the shader program.
     * @access public
     * @param {string} name - The name identifying the buffer in Metal shader source code.
     * @param {SCNBufferFrequency} frequency - An option specifying whether SceneKit calls the block only once per rendered frame or more frequently (for example, once for each object to be rendered).
     * @param {SCNBufferBindingBlock} block - A block to be run when SceneKit prepares for rendering with the Metal shader.
     * @returns {void}
     * @desc Use this method to associate a block with a Metal shader program to handle setup of a buffer used in that shader. SceneKit calls your block before rendering any objects whose program property is set to this SCNProgram object. In the block, use the writeBytes(_:count:) method to provide data for the buffer.  
      * @see https://developer.apple.com/documentation/scenekit/scnprogram/1524047-handlebinding
     */

  }, {
    key: 'handleBindingOfBufferNamedHandler',
    value: function handleBindingOfBufferNamedHandler(name, frequency, block) {
      this._bufferBindings[frequency].set(name, block);
    }
  }, {
    key: '_getGLProgramForContext',
    value: function _getGLProgramForContext(context) {
      if (this._context === context) {
        if (this._glProgram) {
          return this._glProgram;
        }
      }

      this._context = context;
      this._glProgram = context.createProgram();
      return this._glProgram;
    }
  }, {
    key: '_setDummyTextureForContext',
    value: function _setDummyTextureForContext(context) {
      var gl = context;
      this._createDummyTextureForContext(gl);

      var texNames = [gl.TEXTURE0, gl.TEXTURE1, gl.TEXTURE2, gl.TEXTURE3, gl.TEXTURE4, gl.TEXTURE5, gl.TEXTURE6, gl.TEXTURE7];
      var texSymbols = ['u_emissionTexture', 'u_ambientTexture', 'u_diffuseTexture', 'u_specularTexture', 'u_reflectiveTexture', 'u_transparentTexture', 'u_multiplyTexture', 'u_normalTexture'];
      var isCubeMap = [false, false, false, false, true, false, false, false];
      for (var i = 0; i < texNames.length; i++) {
        var texName = texNames[i];
        var symbol = texSymbols[i];
        var loc = gl.getUniformLocation(this._glProgram, symbol);
        if (loc !== null) {
          gl.uniform1i(loc, i);
          gl.activeTexture(texName);
          if (isCubeMap[i]) {
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._dummyCubeMapTexture);
          } else {
            gl.bindTexture(gl.TEXTURE_2D, this._dummyTexture);
          }
        }
      }
    }
  }, {
    key: '_createDummyTextureForContext',
    value: function _createDummyTextureForContext(context) {
      if (this._dummyTexture !== null) {
        return;
      }
      var gl = context;
      var canvas = document.createElement('canvas');
      canvas.width = 1;
      canvas.height = 1;
      var c = canvas.getContext('2d');
      c.fillStyle = 'rgba(255, 255, 255, 1.0)';
      c.fillRect(0, 0, 1, 1);

      this._dummyTexture = gl.createTexture();

      gl.bindTexture(gl.TEXTURE_2D, this._dummyTexture
      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
      // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
      );gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
      gl.bindTexture(gl.TEXTURE_2D, null);

      this._dummyCubeMapTexture = gl.createTexture();

      var targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Y];

      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._dummyCubeMapTexture);
      for (var i = 0; i < 6; i++) {
        gl.texImage2D(targets[i], 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
      }
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
    }
  }]);

  return SCNProgram;
}(_NSObject3.default);

exports.default = SCNProgram;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNVector = __webpack_require__(11);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A representation of a quaternion.
 * @type {SCNVector4}
 * @desc A quaternion is a mathematical construct useful for describing rotations in three-dimensional space. Although its implementation differs from that of a 4-component vector, you specify a quaternion value using the same fields as an SCNVector4 structure.SceneKit uses unit quaternions (those whose components satisfy the equation x*x + y*y + z*z + w*w == 1) for the orientation property of nodes.
 * @see https://developer.apple.com/documentation/scenekit/scnquaternion
 */
var SCNQuaternion = _SCNVector2.default;

exports.default = SCNQuaternion;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for when to load the reference node’s content, used by the loadingPolicy property.
 * @typedef {Object} SCNReferenceLoadingPolicy
 * @property {number} immediate - Load the node’s external content immediately when the reference node is unarchived.
 * @property {number} onDemand - Load the node’s external comment only when the load() method is called.
 * @see https://developer.apple.com/documentation/scenekit/scnreferenceloadingpolicy
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNReferenceLoadingPolicy = {
  immediate: 0,
  onDemand: 1
};

exports.default = SCNReferenceLoadingPolicy;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _SCNNode = __webpack_require__(14);

var _SCNNode2 = _interopRequireDefault(_SCNNode);

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNBox = __webpack_require__(34);

var _SCNBox2 = _interopRequireDefault(_SCNBox);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNSceneSource = __webpack_require__(107);

var _SCNSceneSource2 = _interopRequireDefault(_SCNSceneSource);

var _SCNPhysicsWorld = __webpack_require__(33);

var _SCNPhysicsWorld2 = _interopRequireDefault(_SCNPhysicsWorld);

var _BinaryRequest2 = __webpack_require__(36);

var _BinaryRequest3 = _interopRequireDefault(_BinaryRequest2);

var _File2 = __webpack_require__(42);

var _File3 = _interopRequireDefault(_File2);

var _FileReader2 = __webpack_require__(43);

var _FileReader3 = _interopRequireDefault(_FileReader2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNMaterialProperty from './SCNMaterialProperty'

//import SCNSceneExportDelegate from './SCNSceneExportDelegate'
//import SCNSceneExportProgressHandler from './SCNSceneExportProgressHandler'

//import SCNParticleSystem from './SCNParticleSystem'
//import SCNMatrix4 from './SCNMatrix4'


var _Attribute = {
  endTime: 'kSceneEndTimeAttributeKey',
  frameRate: 'kSceneFrameRateAttributeKey',
  startTime: 'kSceneStartTimeAttributeKey',
  upAxis: 'kSceneUpAxisAttributeKey'

  /**
   * A scene graph—a hierarchy of nodes with attached geometries, lights, cameras and other attributes that together form a displayable 3D scene.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/scenekit/scnscene
   */
};
var SCNScene = function (_NSObject) {
  _inherits(SCNScene, _NSObject);

  _createClass(SCNScene, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        paused: ['boolean', 'isPaused'],
        rootNode: ['SCNNode', '_rootNode'],
        upAxis: ['SCNVector3', null],
        physicsWorld: ['SCNPhysicsWorld', function (obj, value) {
          obj._physicsWorld = value;
          obj._physicsWorld._scene = obj;
        }],
        background: ['SCNMaterialProperty', function (obj, value) {
          obj._skyBox.geometry.firstMaterial._emission = value;
          obj._skyBox.geometry.firstMaterial._emission._createPresentation();
        }],
        startTime: ['double', null],
        endTime: ['double', null],
        frameRate: ['double', null],
        fogDensityExponent: 'double',
        fogStartDistance: 'double',
        fogEndDistance: 'double',
        fogColor: 'plist',
        environment: ['SCNMaterialProperty', '_lightingEnvironment'],

        version: ['float', null],
        userAttributes: ['NSMutableDictionary', null],
        sourceURL: ['NSURL', null]
      };
    }

    /**
     * Loads a scene from the specified URL.
     * @access public
     * @constructor
     * @param {string} url - The URL to the scene file to load.
     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
     * @param {function} onload -
     * @param {function} onerror -
     * @throws {Error}
     * @desc This method provides a convenient way to load a complete scene from a file at an arbitrary URL. For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.Handling Errors in Swift:
    In Swift, this method returns a nonoptional result and is marked with the throws keyword to indicate that it throws an error in cases of failure.
    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
      * @see https://developer.apple.com/documentation/scenekit/scnscene/1522660-init
     */

  }]);

  function SCNScene(url) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var onload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var onerror = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, SCNScene);

    // Managing Animated Effects in a Scene

    /**
     * A Boolean value that determines whether to run actions, animations, particle systems, and physics simulations in the scene graph.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1523604-ispaused
     */
    var _this = _possibleConstructorReturn(this, (SCNScene.__proto__ || Object.getPrototypeOf(SCNScene)).call(this));

    _this.isPaused = false;

    // Accessing Scene Contents

    _this._rootNode = new _SCNNode2.default();
    _this._lightingEnvironment = null;

    // Adding Fog to a Scene

    /**
     * The distance from a point of view at which the scene’s contents begin to be obscured by fog. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1522790-fogstartdistance
     */
    _this.fogStartDistance = 0;

    /**
     * The distance from a point of view at which the scene’s contents are completely obscured by fog. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1523836-fogenddistance
     */
    _this.fogEndDistance = 0;

    /**
     * The transition curve for the fog’s intensity between its start and end distances. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1523776-fogdensityexponent
     */
    _this.fogDensityExponent = 0;

    /**
     * The color of the fog effect to be rendered with the scene. Animatable.
     * @type {Object}
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1522774-fogcolor
     */
    _this.fogColor = null;

    // Working With Physics in the Scene

    _this._physicsWorld = new _SCNPhysicsWorld2.default();
    _this._physicsWorld._scene = _this;

    // Working with Particle Systems in the Scene

    _this._particleSystems = null;
    _this._particleSystemsTransform = null;

    /**
     * @access private
     * @type {Promise}
     */
    _this._dataLoadedPromise = null;

    if (url) {
      var promise = _this._loadSceneWithURL(url, options).then(function (scene) {
        _this._copyValue(scene);
        if (onload) {
          onload(_this);
        }
      }).catch(function (error) {
        if (onerror) {
          onerror(error);
        }
      });
      _this._dataLoadedPromise = promise;
    }

    _this._createSkyBox

    /**
     * @access private
     * @type {Promise}
     */
    ();_this._loadedPromise = null;
    return _this;
  }

  _createClass(SCNScene, [{
    key: '_copyValue',
    value: function _copyValue(src) {
      this.isPaused = src.isPaused;
      this._rootNode = src._rootNode;
      //this._background = src._background
      this._skyBox.geometry = src._skyBox.geometry.copy();
      this._lightingEnvironment = src._lightingEnvironment;
      this.fogStartDistance = src.fogStartDistance;
      this.fogEndDistance = src.fogEndDistance;
      this.fogDensityExponent = src.fogDensityExponent;
      this.fogColor = src.fogColor;
      this._physicsWorld = src._physicsWorld; // TODO: copy SCNPhysicsWorld
      this._particleSystems = src._particleSystems ? src._particleSystems.slice(0) : null;
      this._particleSystemsTransform = src._particleSystemsTransform ? src._particleSystemsTransform.slice(0) : null;
    }

    /**
     * @access private
     * @param {string} url -
     * @param {Object} options -
     * @returns {Promise} -
     */

  }, {
    key: '_loadSceneWithURL',
    value: function _loadSceneWithURL(url, options) {
      var _this2 = this;

      var _options = options;
      if (_options === null) {
        _options = new Map();
      }
      if (typeof _options.get(_SCNSceneSource2.default.LoadingOption.assetDirectoryURLs) === 'undefined') {
        var paths = url.split('/');
        var name = paths.pop();
        var directory = paths.join('/');

        _options.set(_SCNSceneSource2.default.LoadingOption.assetDirectoryURLs, directory);
      }

      if (url instanceof _File3.default) {
        return Promise(function (resolve, reject) {
          var reader = new _FileReader3.default();
          reader.onload = function () {
            var scene = _this2._loadSceneWithData(reader.result, _options);
            resolve(scene);
          };
          reader.onerror = function () {
            reject(reader.error);
          };
          reader.readAsBinaryString(url);
        });
      }

      return _BinaryRequest3.default.get(url).then(function (data) {
        return _this2._loadSceneWithData(data, _options);
      });
    }

    /**
     * @access private
     * @param {Blob} data -
     * @param {Object} options -
     * @returns {SCNScene} -
     */

  }, {
    key: '_loadSceneWithData',
    value: function _loadSceneWithData(data, options) {
      var source = new _SCNSceneSource2.default(data, options);
      return source.scene();
    }
  }, {
    key: '_createSkyBox',
    value: function _createSkyBox() {
      var skyBoxGeometry = new _SCNBox2.default();
      var material = new _SCNMaterial2.default();
      material._diffuse._contents = _SKColor2.default.black;
      material._ambient._contents = _SKColor2.default.black;
      material._emission._contents = null;
      material.isDoubleSided = true;

      skyBoxGeometry.firstMaterial = material;
      var texSrc = skyBoxGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];
      var margin = 0.001;
      var w0 = 0.0;
      var w1 = 1.0 / 6.0;
      var w2 = 2.0 / 6.0;
      var w3 = 3.0 / 6.0;
      var w4 = 4.0 / 6.0;
      var w5 = 5.0 / 6.0;
      var w6 = 1.0;
      var data = [w5 - margin, 1, w5 - margin, 0, w4 + margin, 1, w4 + margin, 0, w2 - margin, 1, w2 - margin, 0, w1 + margin, 1, w1 + margin, 0, w6 - margin, 1, w6 - margin, 0, w5 + margin, 1, w5 + margin, 0, w1 - margin, 1, w1 - margin, 0, w0 + margin, 1, w0 + margin, 0, w3 - margin, 1, w3 - margin, 0, w2 + margin, 1, w2 + margin, 0, w4 - margin, 1, w4 - margin, 0, w3 + margin, 1, w3 + margin, 0];
      var dataIndex = 0;
      var srcIndex = 6;
      for (var i = 0; i < 24; i++) {
        texSrc._data[srcIndex + 0] = data[dataIndex + 0];
        texSrc._data[srcIndex + 1] = data[dataIndex + 1];
        srcIndex += 8;
        dataIndex += 2;
      }
      this._skyBox = new _SCNNode2.default(skyBoxGeometry);
      this._skyBox._presentation = this._skyBox;
    }

    // Creating or Loading a Scene

    /**
     * Loads a scene from a file with the specified name in the app’s main bundle.
     * @access public
     * @param {string} name - The name of a scene file in the app bundle’s resources directory.
     * @returns {void}
     * @desc This method provides a convenient way to load a complete scene from a file in the app’s main bundle. Calling this method is equivalent to using the Bundle class to locate the scene file and passing the resulting URL to the init(url:options:) method, specifying no options and no error handling.For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1523355-init
     */

  }, {
    key: 'attributeForKey',


    // Managing Scene Attributes

    /**
     * Returns the scene attribute for the specified key.
     * @access public
     * @param {string} key - One of the constants described in Scene Attributes that identifies the attribute to be read.
     * @returns {?Object} - 
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1522858-attribute
     */
    value: function attributeForKey(key) {
      return null;
    }

    /**
     * Sets a scene attribute for the specified key.
     * @access public
     * @param {?Object} attribute - An object that specifies the value of the attribute to be written.
     * @param {string} key - One of the constants described in Scene Attributes that identifies the attribute to be written.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1524229-setattribute
     */

  }, {
    key: 'setAttributeForKey',
    value: function setAttributeForKey(attribute, key) {}

    // Exporting a Scene File

    /**
     * Exports the scene and its contents to a file at the specified URL.
     * @access public
     * @param {string} url - The URL to write the scene file to. This URL must use the file scheme.
     * @param {?Map<string, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
     * @param {?SCNSceneExportDelegate} delegate - A delegate object to customize export of external resources used by the scene. Pass nil for default export of external resources.
     * @param {?SCNSceneExportProgressHandler} [progressHandler = null] - A block that SceneKit calls repeatedly to report progress of the export operation.
     * @returns {boolean} - 
     * @desc SceneKit creates and writes a file containing the scene graph in the Digital Asset Exchange (DAE) format. The format of the file created depends on OS version and on the filename extension you specify:In iOS 10.0, tvOS 10.0, watchOS 3.0, OS X v10.11, and later versions, specify the .scn extension to save a file in SceneKit’s native format. This format supports all features of SceneKit (including physics, constraints, and particle systems), and reading files in this format is faster than importing from other scene file formats.In macOS only, specify the .dae extension to export in Digital Asset Exchange (DAE) format for use by other apps. Exported DAE files do not contain scene elements specific to SceneKit, such as physics bodies and fields, constraints, and particle systems.If the scene references external resources, such as image files used in material properties, SceneKit exports these files to a nearby location and references their URLs in the exported scene file. To override SceneKit’s exporting of external resources, provide an object implementing the SCNSceneExportDelegate protocol in the delegate parameter.
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1523577-write
     */

  }, {
    key: 'writeTo',
    value: function writeTo(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var delegate = arguments[2];
      var progressHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      return false;
    }

    // Working With Physics in the Scene
    /**
     * The physics simulation associated with the scene.
     * @type {SCNPhysicsWorld}
     * @desc Every scene automatically creates a physics world object to simulate physics on nodes in the scene. You use this property to access the scene’s global physics properties, such as gravity, and to manage physics interactions between nodes. To make a node in the scene participate in the physics simulation, use either or both of its physicsBody and physicsField properties.
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1522643-physicsworld
     */

  }, {
    key: 'addParticleSystem',


    // Working with Particle Systems in the Scene

    /**
     * Attaches a particle system to the scene, using the specified transform.
     * @access public
     * @param {SCNParticleSystem} system - A particle system.
     * @param {SCNMatrix4} transform - A transformation matrix that positions and orients the particle system relative to the world coordinate space of the scene.
     * @returns {void}
     * @desc A particle system directly attached to a scene is not related to the coordinate space of any node in the scene. To attach a particle system whose emitter location follows the movement of a node within the scene, use the corresponding SCNNode method.For details on particle systems, see SCNParticleSystem.
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1523359-addparticlesystem
     */
    value: function addParticleSystem(system, transform) {
      if (this._particleSystems === null) {
        this._particleSystems = [];
        this._particleSystemsTransform = [];
      }
      //system._startTime = Date.now() * 0.001
      system.reset();
      this._particleSystems.push(system);
      this._particleSystemsTransform.push(transform);

      if (this._particleSystems.length !== this._particleSystemsTransform.length) {
        throw new Error('particleSystems array length inconsistency');
      }
    }

    /**
     * Removes a particle system attached to the scene.
     * @access public
     * @param {SCNParticleSystem} system - A particle system.
     * @returns {void}
     * @desc This method has no effect if the system parameter does not reference a particle system directly attached to the scene.
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1523498-removeparticlesystem
     */

  }, {
    key: 'removeParticleSystem',
    value: function removeParticleSystem(system) {
      if (this._particleSystems === null) {
        return;
      }
      var index = this._particleSystems.indexOf(system);
      if (index < 0) {
        return;
      }
      this._particleSystems.splice(index, 1);
      this._particleSystemsTransform.splice(index, 1);
    }

    /**
     * Removes any particle systems directly attached to the scene.
     * @access public
     * @returns {void}
     * @desc Calling this method does not remove particle systems attached to nodes within the scene.
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1522786-removeallparticlesystems
     */

  }, {
    key: 'removeAllParticleSystems',
    value: function removeAllParticleSystems() {
      this._particleSystems = [];
      this._particleSystemsTransform = [];
    }

    /**
     * The particle systems attached to the scene.
     * @type {?SCNParticleSystem[]}
     * @desc An array of SCNParticleSystem objects directly attached to the scene. This array does not include particle systems attached to nodes within the scene.For details on particle systems, see SCNParticleSystem.
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1522787-particlesystems
     */

  }, {
    key: '_getLoadedPromise',


    /**
     * @access private
     * @returns {Promise} -
     */
    value: function _getLoadedPromise() {
      var _this3 = this;

      if (this._loadedPromise) {
        return this._loadedPromise;
      }
      if (!this._dataLoadedPromise) {
        return Promise.resolve();
      }

      this._loadedPromise = this._dataLoadedPromise.then(function () {
        var promises = [];
        promises.push(_this3._rootNode.didLoad);
        promises.push(_this3._skyBox.didLoad);
        if (_this3._lightingEnvironment) {
          promises.push(_this3._lightingEnvironment.didLoad);
        }
        return Promise.all(promises);
      });
      return this._loadedPromise;
    }

    /**
     * @access public
     * @type {Promise} -
     */

  }, {
    key: 'rootNode',


    // Accessing Scene Contents
    /**
     * The root node of the scene graph.
     * @type {SCNNode}
     * @desc All scene content—nodes, geometries and their materials, lights, cameras, and related objects—is organized in a node hierarchy with a single common root node.Some scene files created using external tools may describe node hierarchies containing multiple root nodes. When SceneKit imports such files, their separate root nodes will be made children of a new, unique root node.Each child node’s coordinate system is defined relative to the transformation of its parent node. You should not modify the transform property of the root node.
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1524029-rootnode
     */
    get: function get() {
      return this._rootNode;
    }

    /**
     * A background to be rendered before the rest of the scene.
     * @type {SCNMaterialProperty}
     * @desc If the material property’s contents object is nil, SceneKit does not draw any background before drawing the rest of the scene. (If the scene is presented in an SCNView instance, the view’s background color is visible behind the contents of the scene.)If you specify a cube map texture for the material property (see the discussion of the contents property), SceneKit renders the background as a skybox.
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1523665-background
     */

  }, {
    key: 'background',
    get: function get() {
      return this._skyBox.geometry.firstMaterial._emission;
    }

    /**
     * A cube map texture that depicts the environment surrounding the scene’s contents, used for advanced lighting effects.
     * @type {SCNMaterialProperty}
     * @desc When rendering materials with the physicallyBased lighting model, SceneKit illuminates surfaces differently according to the environment that surrounds them. For example, with physically based shading, even a diffuse surface takes on some color from the sky above it and the ground below it.TipFor realistic results, reuse the same contents for both the lighting environment and the background property.For information about defining cube maps, see the discussion of the contents property.
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1639532-lightingenvironment
     */

  }, {
    key: 'lightingEnvironment',
    get: function get() {
      return this._lightingEnvironment;
    }
  }, {
    key: 'physicsWorld',
    get: function get() {
      return this._physicsWorld;
    }
  }, {
    key: 'particleSystems',
    get: function get() {
      return this._particleSystems.slice(0);
    }
  }, {
    key: 'didLoad',
    get: function get() {
      return this._getLoadedPromise();
    }

    // Structures

    /**
     * @type {Object} Attribute
     * @property {string} endTime A floating-point value (in an NSNumber object) for the end time of the scene.
     * @property {string} frameRate A floating-point value (in an NSNumber object) for the frame rate of the scene.
     * @property {string} startTime A floating-point value (in an NSNumber object) for the start time of the scene.
     * @property {string} upAxis An SCNVector3 structure (in an NSValue object) specifying the orientation of the scene.
     * @see https://developer.apple.com/documentation/scenekit/scnscene.attribute
     */

  }], [{
    key: 'sceneNamed',
    value: function sceneNamed(name) {
      return this.sceneNamedInDirectory(name);
    }

    /**
     * Loads a scene from a file with the specified name in a specific subdirectory of the app’s main bundle.
     * @access public
     * @param {string} name - The name of a scene file in the app bundle.
     * @param {?string} directory - The path to the subdirectory of the bundle’s resources directory containing the scene file.
     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
     * @returns {void}
     * @desc This method provides a convenient way to load a complete scene from a file in the app’s main bundle. Calling this method is equivalent to using the Bundle class to locate the scene file and passing the resulting URL to the init(url:options:) method.For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.
     * @see https://developer.apple.com/documentation/scenekit/scnscene/1522851-init
     */

  }, {
    key: 'sceneNamedInDirectory',
    value: function sceneNamedInDirectory(name, directory) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var path = name;
      if (directory) {
        path = directory + '/' + name;
      }
      return new SCNScene(path, options);
    }

    /**
     * Loads a scene from the specified URL.
     * @access public
     * @param {string} url - The URL to the scene file to load.
     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
     * @returns {SCNScene} -
     * @throws {Error}
     * @desc This method provides a convenient way to load a complete scene from a file at an arbitrary URL. For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.Handling Errors in Swift:
    In Swift, this method returns a nonoptional result and is marked with the throws keyword to indicate that it throws an error in cases of failure.
    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
      * @see https://developer.apple.com/documentation/scenekit/scnscene/1522660-init
     */

  }, {
    key: 'scene',
    value: function scene(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      return new SCNScene(url, options);
    }
  }, {
    key: 'Attribute',
    get: function get() {
      return _Attribute;
    }
  }]);

  return SCNScene;
}(_NSObject3.default);

exports.default = SCNScene;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSKeyedUnarchiver = __webpack_require__(41);

var _NSKeyedUnarchiver2 = _interopRequireDefault(_NSKeyedUnarchiver);

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _BinaryRequest2 = __webpack_require__(36);

var _BinaryRequest3 = _interopRequireDefault(_BinaryRequest2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNScene from './SCNScene'
//import SCNSceneSourceStatusHandler from './SCNSceneSourceStatusHandler'


//import _File from '../util/_File'

var _AnimationImportPolicy = {
  doNotPlay: 'keepSeparate',
  play: 'playOnce',
  playRepeatedly: 'playRepeatedly',
  playUsingSceneTimeBase: 'playUsingSceneTime'
};

var _LoadingOption = {
  animationImportPolicy: 'kSceneSourceAnimationLoadingMode',
  assetDirectoryURLs: 'kSceneSourceAssetDirectoryURLs',
  checkConsistency: 'kSceneSourceCheckConsistency',
  convertToYUp: 'kSceneSourceConvertToYUpIfNeeded',
  convertUnitsToMeters: 'kSceneSourceConvertToUnit',
  createNormalsIfAbsent: 'kSceneSourceCreateNormalsIfAbsent',
  flattenScene: 'kSceneSourceFlattenScene',
  overrideAssetURLs: 'kSceneSourceOverrideAssetURLs',
  preserveOriginalTopology: 'kSceneSourcePreserveOriginalTopology',
  strictConformance: 'kSceneSourceStrictConformanceKey',
  useSafeMode: 'kSceneSourceUseSafeMode'

  /**
   * Manages the data-reading tasks associated with loading scene contents from a file or data.
   * @access public
   * @extends {NSObject}
   * @see https://developer.apple.com/documentation/scenekit/scnscenesource
   */
};
var SCNSceneSource = function (_NSObject) {
  _inherits(SCNSceneSource, _NSObject);

  // Creating a Scene Source

  /**
   * Initializes a scene source for reading the scene graph contained in an NSData object.
   * @access public
   * @constructor
   * @param {Blob} data - A data object containing a scene file in a format recognized by SceneKit.
   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.
   * @desc The data parameter of this method should contain the same data as directly read from a scene file (such as by using the NSData method dataWithContentsOfURL:). Use this method when you have the contents of a scene file but not the file itself—for example, if your app downloads scene files from the network.
   * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1523500-init
   */
  function SCNSceneSource(data) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, SCNSceneSource);

    // Getting Information about the Scene

    var _this = _possibleConstructorReturn(this, (SCNSceneSource.__proto__ || Object.getPrototypeOf(SCNSceneSource)).call(this));

    _this._url = null;
    _this._options = options;
    _this._data = data;

    /**
     * @access private
     * @type {Promise}
     */
    _this._loadedPromise = new Promise(function (resolve, reject) {
      _this._resolveFunction = resolve;
      _this._rejectFunction = reject;
    });

    if (data) {
      _this._resolveFunction();
    }
    return _this;
  }

  /**
   * @access public
   * @param {Blob} data -
   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] -
   * @returns {SCNSceneSource} -
   */


  _createClass(SCNSceneSource, [{
    key: 'scene',


    // Loading a Complete Scene

    /**
     * Loads the entire scene graph from the scene source and calls the specified block to provide progress information.
     * @access public
     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.
     * @param {?SCNSceneSourceStatusHandler} [statusHandler = null] - An SCNSceneSourceStatusHandler block. SceneKit calls this block periodically to report progress while loading the scene.
     * @returns {?SCNScene} - 
     * @desc Use this method if you need to monitor progress while loading a scene from the scene source. For simpler scene loading, use the scene(options:) method or the SCNScene method init(url:options:).A scene source can contain objects that are not part of its scene graph. To obtain these objects, you must load them individually with the the entryWithIdentifier:withClass: or entries(passingTest:) method. For example, a scene file containing a game character could include several animations for the character geometry (such as running, jumping, and standing idle). Because you typically do not apply multiple animations at once, the scene file contains these animations without their being attached to the character geometry.
     * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1522887-scene
     */
    value: function scene() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var statusHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var _options = options;
      if (!_options) {
        if (this._options) {
          _options = this._options;
        }
      }

      var url = this._url;
      var assetDirectoryURLs = _options.get(_LoadingOption.assetDirectoryURLs);
      if (assetDirectoryURLs) {
        var dir = assetDirectoryURLs;
        if (Array.isArray(dir)) {
          dir = dir[0];
        }
        url = dir + '/';
        if (this._url) {
          url += this._url.split('/').pop();
        }
      }

      return _NSKeyedUnarchiver2.default.unarchiveObjectWithData(this._data, url);
    }

    // Loading and Inspecting Scene Elements

    /**
     * Returns the identifiers for all objects in the scene source of the specified class.
     * @access public
     * @param {Object} entryClass - The class of objects to find identifiers for.
     * @returns {string[]} - 
     * @desc SceneKit recognizes objects of the following classes in scene files:CAAnimationNSImageSCNCameraSCNGeometrySCNLightSCNMaterialSCNMorpherSCNNodeSCNSceneSCNSkinnerEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene file—for example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.Use this method to enumerate all objects in a scene file of a specified class without loading the objects and their content. For example, the following code finds the identifiers for all animations stored in a scene source:NSArray *animations = [sceneSource identifiersOfEntriesWithClass:[CAAnimation class]];
    NSArray *animations = [sceneSource identifiersOfEntriesWithClass:[CAAnimation class]];
      * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1523656-identifiersofentries
     */

  }, {
    key: 'identifiersOfEntriesWithClass',
    value: function identifiersOfEntriesWithClass(entryClass) {
      return null;
    }

    /**
     * Loads and returns all objects in the scene source that pass the test in a given block.
     * @access public
     * @param {function(arg1: Object, arg2: string, arg3: UnsafeMutablePointer<ObjCBool>): boolean} predicate - The block to be applied to each object in the scene source.The block takes three parameters:entryThe object to be tested.identifierThe unique identifier of the object in the scene source.stopA reference to a Boolean value. Set *stop to true within the block to abort further processing of the scene source’s contents.The block returns a Boolean value indicating whether the entry object passed the test and should be included in the method’s returned array.
     * @returns {Object[]} - 
     * @desc SceneKit recognizes objects of the following classes in scene files:CAAnimationNSImageSCNCameraSCNGeometrySCNLightSCNMaterialSCNMorpherSCNNodeSCNSceneSCNSkinnerEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene file—for example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.Use this method to selectively load objects from a scene source matching criteria you specify. For example, the following code loads from a scene file only the nodes that have attached geometry:NSArray *geometryNodes = [sceneSource entriesPassingTest:^BOOL(id entry, NSString *identifier, BOOL *stop) {
      if ([entry isKindOfClass:[SCNNode class]]) {
          SCNNode *node = (SCNNode *)entry;
          return (node.geometry != nil);
      } else {
          return NO;
      }
    }];
    NSArray *geometryNodes = [sceneSource entriesPassingTest:^BOOL(id entry, NSString *identifier, BOOL *stop) {
      if ([entry isKindOfClass:[SCNNode class]]) {
          SCNNode *node = (SCNNode *)entry;
          return (node.geometry != nil);
      } else {
          return NO;
      }
    }];
      * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1523055-entries
     */

  }, {
    key: 'entriesPassingTest',
    value: function entriesPassingTest(predicate) {
      return null;
    }

    // Getting Information about the Scene

    /**
     * Returns metadata about the scene.
     * @access public
     * @param {string} key - A constant identifying a metadata property of the scene source. See Scene Source Properties for available keys and the formats of their values.
     * @returns {?Object} - 
     * @desc This method returns information about the scene that is defined in the file but is not directly referenced by the scene.
     * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1523277-property
     */

  }, {
    key: 'propertyForKey',
    value: function propertyForKey(key) {
      return null;
    }
    /**
     * The URL identifying the file from which the scene source was created.
     * @type {?string}
     * @desc The value of this property is nil if the scene source was not created using the sceneSourceWithURL:options: or init(url:options:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1524038-url
     */

  }, {
    key: 'entryWithIdentifierWithClass',


    // Instance Methods

    /**
     * 
     * @access public
     * @param {string} uid - 
     * @param {T.Type} entryClass - 
     * @returns {Object} - 
     * @see https://developer.apple.com/documentation/scenekit/scnscenesource/2805685-entrywithidentifier
     */
    value: function entryWithIdentifierWithClass(uid, entryClass) {
      return null;
    }

    // Structures
    /**
     * @type {Object} AnimationImportPolicy
     * @property {string} doNotPlay Animations are not loaded from the scene file.
     * @property {string} play Animations loaded from the scene file are immediately added to the scene and played once.
     * @property {string} playRepeatedly Animations loaded from the scene file are immediately added to the scene and played repeatedly.
     * @property {string} playUsingSceneTimeBase Animations loaded from the scene file are immediately added to the scene and played according to the scene’s sceneTime property.
     * @see https://developer.apple.com/documentation/scenekit/scnscenesource.animationimportpolicy
     */

  }, {
    key: '_getLoadedPromise',


    /**
     * @access private
     * @returns {Promise* -
     */
    value: function _getLoadedPromise() {
      return this._loadedPromise;
    }

    /**
     * @access public
     * @type {Promise}
     */

  }, {
    key: 'url',
    get: function get() {
      return this._url;
    }
    /**
     * The data object from which the scene source loads scene content.
     * @type {?Data}
     * @desc If the scene source was created using the sceneSourceWithData:options: or init(data:options:) method, this property’s value is the data from which the scene source was created. If the scene source was created from a scene file using the the sceneSourceWithURL:options: or init(url:options:) method, this property’s value is the data loaded from that URL at the time the scene source was created.
     * @see https://developer.apple.com/documentation/scenekit/scnscenesource/1523061-data
     */

  }, {
    key: 'data',
    get: function get() {
      return this._data;
    }
  }, {
    key: 'didLoad',
    get: function get() {
      return this._getLoadedPromise();
    }
  }], [{
    key: 'sceneSourceWithDataOptions',
    value: function sceneSourceWithDataOptions(data, options) {
      return new SCNSceneSource(data, options);
    }

    /**
     * @access public
     * @param {string|File} url -
     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] -
     * @returns {SCNSceneSource} -
     */

  }, {
    key: 'sceneSourceWithURLOptions',
    value: function sceneSourceWithURLOptions(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var _options = options;
      if (_options === null) {
        _options = new Map();
      }
      if (typeof _options.get(_LoadingOption.assetDirectoryURLs) === 'undefined') {
        var paths = url.split('/');
        var name = paths.pop();
        var directory = paths.join('/');

        _options.set(_LoadingOption.assetDirectoryURLs, directory);
      }

      var source = new SCNSceneSource();
      source._url = url;
      _BinaryRequest3.default.get(url).then(function (data) {
        source._data = data;
        source._options = _options;
        source._resolveFunction();
      });
      return source;
    }
  }, {
    key: 'AnimationImportPolicy',
    get: function get() {
      return _AnimationImportPolicy;
    }

    /**
     * @type {Object} LoadingOption
     * @property {string} animationImportPolicy An option for controlling the playback of animations in a scene file.
     * @property {string} assetDirectoryURLs Locations to use for resolving relative URLs to external resources.
     * @property {string} checkConsistency An option to validate scene files while loading.
     * @property {string} convertToYUp An option for whether to transform assets loaded from the scene file for use in a coordinate system where the y-axis points up.
     * @property {string} convertUnitsToMeters An option for whether to automatically scale the scene’s contents.
     * @property {string} createNormalsIfAbsent An option for automatically generating surface normals if they are absent when loading geometry.
     * @property {string} flattenScene An option for automatically merging portions of a scene graph during loading.
     * @property {string} overrideAssetURLs An option to attempt loading external resources using their URLs as specified in a scene file.
     * @property {string} preserveOriginalTopology 
     * @property {string} strictConformance An option to interpret scene files exactly as specified by the scene file format.
     * @property {string} useSafeMode An option to limit filesystem and network access for external resources referenced by a scene file.
     * @see https://developer.apple.com/documentation/scenekit/scnscenesource.loadingoption
     */

  }, {
    key: 'LoadingOption',
    get: function get() {
      return _LoadingOption;
    }
  }]);

  return SCNSceneSource;
}(_NSObject3.default);

exports.default = SCNSceneSource;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _CGRect = __webpack_require__(16);

var _CGRect2 = _interopRequireDefault(_CGRect);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNMaterialProperty = __webpack_require__(26);

var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

var _SCNMatrix4MakeTranslation = __webpack_require__(18);

var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

var _SCNNode = __webpack_require__(14);

var _SCNNode2 = _interopRequireDefault(_SCNNode);

var _SCNProgram = __webpack_require__(103);

var _SCNProgram2 = _interopRequireDefault(_SCNProgram);

var _SCNPhysicsWorld = __webpack_require__(33);

var _SCNPhysicsWorld2 = _interopRequireDefault(_SCNPhysicsWorld);

var _SCNCamera = __webpack_require__(88);

var _SCNCamera2 = _interopRequireDefault(_SCNCamera);

var _SCNLight = __webpack_require__(92);

var _SCNLight2 = _interopRequireDefault(_SCNLight);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _SCNVector3 = __webpack_require__(11);

var _SCNVector4 = _interopRequireDefault(_SCNVector3);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNHitTestOption = __webpack_require__(91);

var _SCNHitTestOption2 = _interopRequireDefault(_SCNHitTestOption);

var _SCNHitTestResult = __webpack_require__(50);

var _SCNHitTestResult2 = _interopRequireDefault(_SCNHitTestResult);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _SKSpriteNode = __webpack_require__(109);

var _SKSpriteNode2 = _interopRequireDefault(_SKSpriteNode);

var _SKTexture = __webpack_require__(55);

var _SKTexture2 = _interopRequireDefault(_SKTexture);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNSceneRenderer from './SCNSceneRenderer'
//import SCNTechniqueSupport from './SCNTechniqueSupport'
//import SCNScene from './SCNScene'
//import SCNAntialiasingMode from './SCNAntialiasingMode'


/**
 * @access private
 * @type {string}
 */
var _defaultVertexShader = '#version 300 es\n  precision mediump float;\n\n  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__\n  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__\n  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__\n  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__\n  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__\n  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__\n  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__\n\n  #define NUM_SHADOW_LIGHTS (NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS)\n  #define NUM_LIGHTS (NUM_AMBIENT_LIGHTS + NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS + NUM_IES_LIGHTS + NUM_PROBE_LIGHTS)\n\n  #define USE_SHADER_MODIFIER_GEOMETRY __USE_SHADER_MODIFIER_GEOMETRY__\n\n  layout (std140) uniform cameraUniform {\n    vec4 position;\n    mat4 viewTransform;\n    mat4 viewProjectionTransform;\n  } camera;\n\n  layout (std140) uniform materialUniform {\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 normal;\n    vec4 reflective;\n    vec4 emission;\n    vec4 transparent;\n    vec4 multiply;\n    vec4 ambientOcclusion;\n    float shininess;\n    float fresnelExponent;\n  } material;\n\n  struct AmbientLight {\n    vec4 color;\n  };\n\n  struct DirectionalLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct DirectionalShadowLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n    vec4 shadowColor;\n    mat4 viewProjectionTransform;\n    mat4 shadowProjectionTransform;\n  };\n\n  struct OmniLight {\n    vec4 color;\n    vec4 position; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct SpotLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct IESLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct ProbeLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  layout (std140) uniform lightUniform {\n    #if NUM_AMBIENT_LIGHTS > 0\n      AmbientLight ambient[NUM_AMBIENT_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n      DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    #endif\n    #if NUM_OMNI_LIGHTS > 0\n      OmniLight omni[NUM_OMNI_LIGHTS];\n    #endif\n    #if NUM_SPOT_LIGHTS > 0\n      SpotLight spot[NUM_SPOT_LIGHTS];\n    #endif\n    #if NUM_IES_LIGHTS > 0\n      IESLight ies[NUM_IES_LIGHTS];\n    #endif\n    #if NUM_PROBE_LIGHTS > 0\n      ProbeLight probe[NUM_PROBE_LIGHTS];\n    #endif\n    #if NUM_LIGHTS == 0\n      vec4 dummy;\n    #endif\n  } light;\n\n  #if NUM_SHADOW_LIGHTS > 0\n    out vec3 v_light[NUM_SHADOW_LIGHTS];\n  #endif\n  #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n    out vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    out vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n  #endif\n\n  layout (std140) uniform fogUniform {\n    vec4 color;\n    float startDistance;\n    float endDistance;\n    float densityExponent;\n  } fog;\n\n  #define kSCNTexcoordCount 2\n  struct SCNShaderGeometry {\n    vec3 position;\n    vec3 normal;\n    vec4 tangent;\n    vec4 color;\n    vec2 texcoords[kSCNTexcoordCount];\n  };\n\n  uniform float u_time;\n  //uniform mat3x4[255] skinningJoints;\n  uniform vec4[765] skinningJoints;\n  uniform int numSkinningJoints;\n  uniform mat4 modelTransform;\n\n  in vec3 position;\n  in vec3 normal;\n  in vec3 tangent;\n  in vec4 color;\n  in vec2 texcoord0;\n  in vec2 texcoord1;\n  in vec4 boneIndices;\n  in vec4 boneWeights;\n\n  out vec3 v_position;\n  out vec3 v_normal;\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n  out vec2 v_texcoord0;\n  out vec2 v_texcoord1;\n  //out vec4 v_color;\n  out vec3 v_eye;\n  out float v_fogFactor;\n\n  __USER_CUSTOM_UNIFORM__\n\n  #if USE_SHADER_MODIFIER_GEOMETRY\n  void shaderModifierGeometry(inout SCNShaderGeometry _geometry) {\n    __SHADER_MODIFIER_GEOMETRY__\n  }\n  #endif\n\n  void main() {\n    SCNShaderGeometry _geometry;\n    _geometry.position = position;\n    _geometry.normal = normal;\n    _geometry.tangent = vec4(tangent, 1.0);\n    _geometry.color = color;\n    _geometry.texcoords[0] = texcoord0;\n    _geometry.texcoords[1] = texcoord1;\n    \n    #if USE_SHADER_MODIFIER_GEOMETRY\n      shaderModifierGeometry(_geometry);\n    #endif\n\n    vec3 pos = vec3(0, 0, 0);\n    vec3 nom = vec3(0, 0, 0);\n    vec3 tng = vec3(0, 0, 0);\n    vec4 col = _geometry.color;\n\n    if(numSkinningJoints > 0){\n      for(int i=0; i<numSkinningJoints; i++){\n        float weight = boneWeights[i];\n        if(int(boneIndices[i]) < 0){\n          continue;\n        }\n        int idx = int(boneIndices[i]) * 3;\n        mat4 jointMatrix = transpose(mat4(skinningJoints[idx],\n                                          skinningJoints[idx+1],\n                                          skinningJoints[idx+2],\n                                          vec4(0, 0, 0, 1)));\n        pos += (jointMatrix * vec4(_geometry.position, 1.0)).xyz * weight;\n        nom += (mat3(jointMatrix) * _geometry.normal) * weight;\n        tng += (mat3(jointMatrix) * _geometry.tangent.xyz) * weight;\n      }\n    }else{\n      mat4 jointMatrix = transpose(mat4(skinningJoints[0],\n                                        skinningJoints[1],\n                                        skinningJoints[2],\n                                        vec4(0, 0, 0, 1)));\n      pos = (jointMatrix * vec4(_geometry.position, 1.0)).xyz;\n      nom = mat3(jointMatrix) * _geometry.normal;\n      tng = mat3(jointMatrix) * _geometry.tangent.xyz;\n    }\n    //v_position = pos;\n    //v_normal = normalize(nom);\n    //v_tangent = normalize(tng);\n    v_position = (camera.viewTransform * vec4(pos, 1.0)).xyz;\n    v_normal = normalize((camera.viewTransform * vec4(nom, 0.0)).xyz);\n    v_tangent = normalize((camera.viewTransform * vec4(tng, 0.0)).xyz);\n    v_bitangent = cross(v_tangent, v_normal);\n\n    //vec3 viewVec = camera.position.xyz - pos;\n    vec3 viewVec = (camera.viewTransform * vec4(camera.position.xyz - pos, 0.0)).xyz;\n    v_eye = viewVec;\n\n    //v_color = material.emission;\n\n    // Lighting\n    int numLights = 0;\n\n    //#if NUM_AMBIENT_LIGHTS > 0\n    //  for(int i=0; i<NUM_AMBIENT_LIGHTS; i++){\n    //    v_color += light.ambient[i].color * material.ambient;\n    //    v_ambient += light.ambient[i].color;\n    //  }\n    //#endif\n\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){\n        //v_light[numLights + i] = -light.directional[i].direction.xyz;\n        v_light[numLights + i] = (camera.viewTransform * (-light.directional[i].direction)).xyz;\n      }\n      numLights += NUM_DIRECTIONAL_LIGHTS;\n    #endif\n\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n      for(int i=0; i<NUM_DIRECTIONAL_SHADOW_LIGHTS; i++){\n        //v_light[numLights + i] = -light.directionalShadow[i].direction.xyz;\n        v_light[numLights + i] = (camera.viewTransform * (-light.directionalShadow[i].direction)).xyz;\n        v_directionalShadowDepth[i] = light.directionalShadow[i].viewProjectionTransform * vec4(pos, 1.0);\n        v_directionalShadowTexcoord[i] = light.directionalShadow[i].shadowProjectionTransform * vec4(pos, 1.0);\n      }\n      numLights += NUM_DIRECTIONAL_SHADOW_LIGHTS;\n    #endif\n\n    #if NUM_OMNI_LIGHTS > 0\n      for(int i=0; i<NUM_OMNI_LIGHTS; i++){\n        //v_light[numLights + i] = light.omni[i].position.xyz - pos;\n        v_light[numLights + i] = (camera.viewTransform * vec4(light.omni[i].position.xyz - pos, 0.0)).xyz;\n      }\n      numLights += NUM_OMNI_LIGHTS;\n    #endif\n\n    #if NUM_SPOT_LIGHTS > 0\n      for(int i=0; i<NUM_SPOT_LIGHTS; i++){\n        //v_light[numLights + i] = light.spot[i].position.xyz - pos;\n        v_light[numLights + i] = (camera.viewTransform * vec4(light.spot[i].position.xyz - pos, 0.0)).xyz;\n      }\n      numLights += NUM_SPOT_LIGHTS;\n    #endif\n\n    #if NUM_IES_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_PROBE_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n\n    float distance = length(viewVec);\n    v_fogFactor = clamp((distance - fog.startDistance) / (fog.endDistance - fog.startDistance), 0.0, 1.0);\n\n    v_texcoord0 = _geometry.texcoords[0];\n    v_texcoord1 = _geometry.texcoords[1];\n    gl_Position = camera.viewProjectionTransform * vec4(pos, 1.0);\n  }\n';

var _cameraLoc = 0;
var _materialLoc = 1;
var _lightLoc = 2;
var _scnLightsLoc = 3;
var _fogLoc = 4;

/**
 * @access private
 * @type {string}
 */
var _defaultFragmentShader = '#version 300 es\n  precision mediump float;\n  precision highp sampler2DShadow;\n\n  uniform bool[8] textureFlags;\n  #define TEXTURE_EMISSION_INDEX 0\n  #define TEXTURE_AMBIENT_INDEX 1\n  #define TEXTURE_DIFFUSE_INDEX 2\n  #define TEXTURE_SPECULAR_INDEX 3\n  #define TEXTURE_REFLECTIVE_INDEX 4\n  #define TEXTURE_TRANSPARENT_INDEX 5\n  #define TEXTURE_MULTIPLY_INDEX 6\n  #define TEXTURE_NORMAL_INDEX 7\n\n  uniform bool selfIllumination;\n\n  uniform sampler2D u_emissionTexture;\n  uniform sampler2D u_ambientTexture;\n  uniform sampler2D u_diffuseTexture;\n  uniform sampler2D u_specularTexture;\n  uniform samplerCube u_reflectiveTexture;\n  uniform sampler2D u_transparentTexture;\n  uniform sampler2D u_multiplyTexture;\n  uniform sampler2D u_normalTexture;\n\n  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__\n  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__\n  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__\n  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__\n  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__\n  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__\n  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__\n\n  #define NUM_SHADOW_LIGHTS (NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS)\n  #define NUM_LIGHTS (NUM_AMBIENT_LIGHTS + NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS + NUM_IES_LIGHTS + NUM_PROBE_LIGHTS)\n\n  #define USE_SHADER_MODIFIER_SURFACE __USE_SHADER_MODIFIER_SURFACE__\n  #define USE_SHADER_MODIFIER_FRAGMENT __USE_SHADER_MODIFIER_FRAGMENT__\n\n  layout (std140) uniform cameraUniform {\n    vec4 position;\n    mat4 viewTransform;\n    mat4 viewProjectionTransform;\n  } camera;\n\n  layout (std140) uniform materialUniform {\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 normal;\n    vec4 reflective;\n    vec4 emission;\n    vec4 transparent;\n    vec4 multiply;\n    vec4 ambientOcclusion;\n    float shininess;\n    float fresnelExponent;\n  } material;\n\n  struct AmbientLight {\n    vec4 color;\n  };\n\n  struct SCNShaderLightingContribution {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n  } _lightingContribution;\n\n  struct DirectionalLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct DirectionalShadowLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n    vec4 shadowColor;\n    mat4 viewProjectionTransform;\n    mat4 shadowProjectionTransform;\n  };\n\n  struct OmniLight {\n    vec4 color;\n    vec4 position; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct ProbeLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct SpotLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  layout (std140) uniform lightUniform {\n    #if NUM_AMBIENT_LIGHTS > 0\n      AmbientLight ambient[NUM_AMBIENT_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n      DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    #endif\n    #if NUM_OMNI_LIGHTS > 0\n      OmniLight omni[NUM_OMNI_LIGHTS];\n    #endif\n    #if NUM_SPOT_LIGHTS > 0\n      SpotLight spot[NUM_SPOT_LIGHTS];\n    #endif\n    #if NUM_IES_LIGHTS > 0\n      IESLight ies[NUM_IES_LIGHTS];\n    #endif\n    #if NUM_PROBE_LIGHTS > 0\n      ProbeLight probe[NUM_PROBE_LIGHTS];\n    #endif\n    #if NUM_LIGHTS == 0\n      vec4 dummy;\n    #endif\n  } light;\n  #if NUM_SHADOW_LIGHTS > 0\n    in vec3 v_light[NUM_SHADOW_LIGHTS];\n  #endif\n  #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n    in vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    in vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    uniform sampler2D u_shadowTexture0;\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 1\n      uniform sampler2D u_shadowTexture1;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 2\n      uniform sampler2D u_shadowTexture2;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 3\n      uniform sampler2D u_shadowTexture3;\n    #endif\n  #endif\n\n  layout (std140) uniform SCNLightsUniform {\n    vec4 direction0;\n    mat4 shadowMatrix0;\n  } scn_lights;\n\n  layout (std140) uniform fogUniform {\n    vec4 color;\n    float startDistance;\n    float endDistance;\n    float densityExponent;\n  } fog;\n\n  struct SCNShaderSurface {\n    vec3 view;\n    vec3 position;\n    vec3 normal;\n    vec2 normalTexcoord;\n    vec3 geometryNormal;\n    vec3 tangent;\n    vec3 bitangent;\n    vec4 ambient;\n    vec2 ambientTexcoord;\n    vec4 diffuse;\n    vec2 diffuseTexcoord;\n    vec4 specular;\n    vec2 specularTexcoord;\n    vec4 emission;\n    vec2 emissionTexcoord;\n    vec4 multiply;\n    vec2 multiplyTexcoord;\n    vec4 transparent;\n    vec2 transparentTexcoord;\n    vec4 reflective;\n    float ambientOcclusion;\n    float shininess;\n    float fresnel;\n    __USER_CUSTOM_SURFACE__\n  } _surface;\n\n  struct SCNShaderOutput {\n    vec4 color;\n  } _output;\n\n  vec2 poissonDisk[4] = vec2[](\n    vec2( -0.94201624, -0.39906216 ),\n    vec2( 0.94558609, -0.76890725 ),\n    vec2( -0.094184101, -0.92938870 ),\n    vec2( 0.34495938, 0.29387760 )\n  );\n\n  uniform float u_time;\n\n  in vec3 v_position;\n  in vec3 v_normal;\n  in vec2 v_texcoord0;\n  in vec2 v_texcoord1;\n  //in vec4 v_color;\n  in vec3 v_eye;\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  in float v_fogFactor;\n\n  out vec4 outColor;\n\n  __USER_CUSTOM_UNIFORM__\n\n  float saturate(float value) {\n    return clamp(value, 0.0, 1.0);\n  }\n\n  float convDepth(vec4 color) {\n    const float rMask = 1.0;\n    const float gMask = 1.0 / 255.0;\n    const float bMask = 1.0 / (255.0 * 255.0);\n    const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n    float depth = dot(color, vec4(rMask, gMask, bMask, aMask));\n    return depth * 2.0 - 1.0;\n  }\n\n  #if USE_SHADER_MODIFIER_SURFACE\n  void shaderModifierSurface() {\n    __SHADER_MODIFIER_SURFACE__\n  }\n  #endif\n\n  #if USE_SHADER_MODIFIER_FRAGMENT\n  void shaderModifierFragment() {\n    __SHADER_MODIFIER_FRAGMENT__\n  }\n  #endif\n\n    \n  void main() {\n    //_output.color = v_color;\n    //_output.color = vec4(0, 0, 0, 1);\n\n    //vec3 viewVec = normalize(v_eye);\n    //vec3 nom = normalize(v_normal);\n    _surface.view = normalize(v_eye);\n    _surface.position = v_position;\n    _surface.normal = normalize(v_normal);\n    _surface.tangent = normalize(v_tangent);\n    _surface.bitangent = normalize(v_bitangent);\n\n    // normal texture\n    if(textureFlags[TEXTURE_NORMAL_INDEX]){\n      mat3 tsInv = mat3(_surface.tangent, _surface.bitangent, _surface.normal);\n      vec3 color = normalize(texture(u_normalTexture, v_texcoord0).rgb * 2.0 - 1.0); // FIXME: check mappingChannel to decide which texture you use.\n      _surface.normal = normalize(tsInv * color);\n    }\n\n    //_surface.ambient = material.ambient;\n    _surface.ambient = vec4(0, 0, 0, 1); // FIXME: check: lock ambient with diffuse\n    _surface.diffuse = material.diffuse;\n    _surface.specular = material.specular;\n    _surface.emission = material.emission;\n    _surface.multiply = material.multiply;\n    _surface.transparent = material.transparent;\n    _surface.reflective = material.reflective;\n    _surface.ambientOcclusion = 1.0; // TODO: calculate AO\n    _surface.shininess = material.shininess;\n    _surface.fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent); // TODO: calculate coefficient\n\n    // TODO: check mapping channel for each material\n    _surface.ambientTexcoord = v_texcoord0;\n    _surface.diffuseTexcoord = v_texcoord0;\n    _surface.specularTexcoord = v_texcoord0;\n    if(selfIllumination){\n      _surface.emissionTexcoord = v_texcoord1;\n    }else{\n      _surface.emissionTexcoord = v_texcoord0;\n    }\n    _surface.multiplyTexcoord = v_texcoord0;\n    _surface.transparentTexcoord = v_texcoord0;\n\n    if(textureFlags[TEXTURE_AMBIENT_INDEX]){\n      _surface.ambient = texture(u_ambientTexture, _surface.ambientTexcoord);\n    }\n    if(textureFlags[TEXTURE_DIFFUSE_INDEX]){\n      _surface.diffuse = texture(u_diffuseTexture, _surface.diffuseTexcoord);\n    }\n    if(textureFlags[TEXTURE_SPECULAR_INDEX]){\n      _surface.specular = texture(u_specularTexture, _surface.specularTexcoord);\n    }\n    if(textureFlags[TEXTURE_EMISSION_INDEX]){\n      _surface.emission = texture(u_emissionTexture, _surface.emissionTexcoord);\n    }\n    if(textureFlags[TEXTURE_MULTIPLY_INDEX]){\n      _surface.multiply = texture(u_multiplyTexture, _surface.multiplyTexcoord);\n    }\n    if(textureFlags[TEXTURE_TRANSPARENT_INDEX]){\n      _surface.transparent = texture(u_transparentTexture, _surface.transparentTexcoord);\n    }\n\n    __USER_CUSTOM_TEXCOORD__\n\n    #if USE_SHADER_MODIFIER_SURFACE\n      shaderModifierSurface();\n    #endif\n\n    // Lighting\n    int numLights = 0;\n    _lightingContribution.ambient = vec3(0);\n    _lightingContribution.diffuse = vec3(0);\n    _lightingContribution.specular = vec3(0);\n\n    #if NUM_AMBIENT_LIGHTS > 0\n      for(int i=0; i<NUM_AMBIENT_LIGHTS; i++){\n        _lightingContribution.ambient += light.ambient[i].color.rgb;\n      }\n    #endif\n\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){\n        // diffuse\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n        //_output.color.rgb += light.directional[i].color.rgb * material.diffuse.rgb * diffuse;\n        _lightingContribution.diffuse += light.directional[i].color.rgb * diffuse;\n\n        // specular\n        if(diffuse > 0.0f){\n          vec3 halfVec = normalize(lightVec + _surface.view);\n          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n          // TODO: use intensity\n          _lightingContribution.specular += vec3(specular);\n        }\n      }\n      numLights += NUM_DIRECTIONAL_LIGHTS;\n    #endif\n\n    #if NUM_OMNI_LIGHTS > 0\n      for(int i=0; i<NUM_OMNI_LIGHTS; i++){\n        // diffuse\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n        //_output.color.rgb += light.omni[i].color.rgb * material.diffuse.rgb * diffuse;\n        _lightingContribution.diffuse += light.omni[i].color.rgb * diffuse;\n\n        // specular\n        if(diffuse > 0.0f){\n          vec3 halfVec = normalize(lightVec + _surface.view);\n          float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n          // TODO: use intensity\n          _lightingContribution.specular += vec3(1, 1, 1) * specular;\n        }\n      }\n      numLights += NUM_OMNI_LIGHTS;\n    #endif\n\n    #if NUM_SPOT_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_IES_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_PROBE_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    __FS_LIGHTING__\n\n\n    // calculate color\n    _output.color = vec4(0, 0, 0, _surface.diffuse.a);\n\n    vec3 D = _lightingContribution.diffuse;\n\n    // lock ambient with diffuse\n    D += _lightingContribution.ambient * _surface.ambientOcclusion;\n\n    // emission\n    if(selfIllumination){\n      D += _surface.emission.rgb;\n    }\n\n    // diffuse\n    _output.color.rgb = _surface.diffuse.rgb * D;\n\n    vec3 S = _lightingContribution.specular;\n    //S += _surface.reflective.rgb * _surface.ambientOcclusion;\n    S *= _surface.specular.rgb;\n    _output.color.rgb += S;\n\n    // ambient\n    _output.color.rgb += _surface.ambient.rgb * _lightingContribution.ambient;\n\n    if(!selfIllumination){\n      _output.color.rgb += _surface.emission.rgb;\n    }\n\n    // multiply\n    _output.color.rgb *= _surface.multiply.rgb;\n\n    // fresnel reflection\n    if(textureFlags[TEXTURE_REFLECTIVE_INDEX]){\n      vec3 r = reflect(_surface.view, _surface.normal);\n      //float fresnel = f0 + (1.0 - f0) * pow(1.0 - clamp(dot(viewVec, nom), 0.0, 1.0), material.fresnelExponent);\n      //float fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent);\n      _output.color.rgb += texture(u_reflectiveTexture, r).rgb * _surface.fresnel;\n    }\n\n    float fogFactor = pow(v_fogFactor, fog.densityExponent);\n    _output.color = mix(_output.color, fog.color, fogFactor);\n\n    _output.color.rgb *= _surface.diffuse.a;\n\n    #if USE_SHADER_MODIFIER_FRAGMENT\n      shaderModifierFragment();\n    #endif\n\n    if(_output.color.a <= 0.0){\n      // avoid overwriting the depth buffer\n      discard;\n    }\n\n    outColor = _output.color;\n\n    // linear To sRGB\n    //outColor.rgb = pow(_output.color.rgb, vec3(1.0/2.2));\n    //outColor.a = _output.color.a;\n  }\n';

var _fsDirectionalShadow = '\n  //float shadow = convDepth(texture(u_shadowTexture__I__, v_directionalShadowTexcoord[__I__].xy / v_directionalShadowTexcoord[__I__].w));\n  //if(v_directionalShadowDepth[__I__].z / v_directionalShadowDepth[__I__].w - 0.0001 > shadow){\n  //  _output.color.rgb += material.diffuse.rgb * light.directionalShadow[__I__].shadowColor.rgb;\n  //}else{\n  //  // diffuse\n  //  vec3 lightVec = normalize(v_light[numLights]);\n  //  float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n  //  _output.color.rgb += light.directionalShadow[__I__].color.rgb * material.diffuse.rgb * diffuse;\n\n  //  // specular\n  //  if(diffuse > 0.0f){\n  //    vec3 halfVec = normalize(lightVec + _surface.view);\n  //    float specular = pow(dot(halfVec, _surface.normal), material.shininess);\n  //    _output.color.rgb += specularColor.rgb * specular;\n  //  }\n  //}\n\n  {\n    float shadow = 0.0;\n    for(int i=0; i<4; i++){\n      float d = convDepth(texture(u_shadowTexture__I__, (v_directionalShadowTexcoord[__I__].xy + poissonDisk[i]/700.0) / v_directionalShadowTexcoord[__I__].w));\n      if(v_directionalShadowDepth[__I__].z / v_directionalShadowDepth[__I__].w - 0.0001 > d){\n        shadow += 0.25;\n      }\n    }\n    //vec3 shadowColor = material.diffuse.rgb * light.directionalShadow[__I__].shadowColor.rgb;\n    vec3 shadowColor = light.directionalShadow[__I__].shadowColor.rgb;\n    // diffuse\n    vec3 lightVec = normalize(v_light[numLights]);\n    float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n    vec3 lightDiffuse = light.directionalShadow[__I__].color.rgb * diffuse;\n    _lightingContribution.diffuse += shadowColor * shadow + lightDiffuse * (1.0 - shadow);\n\n    // specular\n    if(diffuse > 0.0f){\n      vec3 halfVec = normalize(lightVec + _surface.view);\n      float specular = pow(dot(halfVec, _surface.normal), _surface.shininess);\n      // TODO: use intensity\n      _lightingContribution.specular += vec3(specular);\n    }\n    //_output.color.rgb += shadowColor * shadow + lightColor * (1.0 - shadow);\n  }\n\n  numLights += 1;\n';

var _defaultCameraDistance = 15;

/**
 * @access private
 * @type {string}
 */
var _defaultParticleVertexShader = '#version 300 es\n  precision mediump float;\n\n  uniform mat4 modelTransform;\n  uniform mat4 viewTransform;\n  uniform mat4 projectionTransform;\n  uniform int orientationMode;\n  uniform float stretchFactor;\n\n  in vec3 position;\n  in vec3 velocity;\n  in vec4 rotation;\n  in vec4 color;\n  in float size;\n  //in float life;\n  in vec2 corner;\n  in vec2 texcoord;\n\n  out vec2 v_texcoord;\n  out vec4 v_color;\n\n  void main() {\n    vec4 pos = viewTransform * vec4(position, 1.0);\n    vec3 d;\n\n    if(stretchFactor > 0.0){\n      vec4 v = viewTransform * vec4(velocity, 0.0) * stretchFactor;\n      if(corner.y > 0.0){\n        pos.xyz += v.xyz;\n      }\n      vec2 cy = normalize(v.xy);\n      vec2 cx = vec2(-cy.y, cy.x);\n      d = vec3(cx * corner.x + cy * corner.y, 0) * size;\n    }else{\n      float sinAngle = sin(rotation.w);\n      float cosAngle = cos(rotation.w);\n      float tcos = 1.0 - cosAngle;\n\n      d = vec3(\n          corner.x * (rotation.x * rotation.x * tcos + cosAngle)\n        + corner.y * (rotation.x * rotation.y * tcos - rotation.z * sinAngle),\n          corner.x * (rotation.y * rotation.x * tcos + rotation.z * sinAngle)\n        + corner.y * (rotation.y * rotation.y * tcos + cosAngle),\n          corner.x * (rotation.z * rotation.x * tcos - rotation.y * sinAngle)\n        + corner.y * (rotation.z * rotation.y * tcos + rotation.x * sinAngle)) * size;\n      if(orientationMode == 2){\n        // orientation: free\n        d = mat3(viewTransform) * mat3(modelTransform) * d;\n      }\n    }\n    pos.xyz += d;\n\n    v_color = color;\n    v_texcoord = texcoord;\n    gl_Position = projectionTransform * pos;\n  }\n';

/**
 * @access private
 * @type {string}
 */
var _defaultParticleFragmentShader = '#version 300 es\n  precision mediump float;\n\n  uniform sampler2D particleTexture;\n\n  in vec2 v_texcoord;\n  in vec4 v_color;\n\n  out vec4 outColor;\n\n  void main() {\n    vec4 texColor = texture(particleTexture, v_texcoord);\n    if(texColor.a <= 0.0){\n      // avoid overwriting the depth buffer\n      discard;\n    }\n\n    texColor.rgb *= texColor.a;\n    outColor = v_color * texColor;\n  }\n';

/**
 * @access private
 * @type {string}
 */
var _defaultHitTestVertexShader = '#version 300 es\n  precision mediump float;\n\n  uniform mat4 viewProjectionTransform;\n  uniform vec4[765] skinningJoints;\n  uniform int numSkinningJoints;\n\n  in vec3 position;\n  in vec3 normal;\n  in vec4 boneIndices;\n  in vec4 boneWeights;\n  \n  out vec3 v_normal;\n  out vec3 v_position;\n\n  void main() {\n    vec3 pos = vec3(0, 0, 0);\n    vec3 nom = vec3(0, 0, 0);\n    if(numSkinningJoints > 0){\n      for(int i=0; i<numSkinningJoints; i++){\n        float weight = boneWeights[i];\n        if(int(boneIndices[i]) < 0){\n          continue;\n        }\n        int idx = int(boneIndices[i]) * 3;\n        mat4 jointMatrix = transpose(mat4(skinningJoints[idx],\n                                          skinningJoints[idx+1],\n                                          skinningJoints[idx+2],\n                                          vec4(0, 0, 0, 1)));\n        pos += (jointMatrix * vec4(position, 1.0)).xyz * weight;\n        nom += (mat3(jointMatrix) * normal) * weight;\n      }\n    }else{\n      mat4 jointMatrix = transpose(mat4(skinningJoints[0],\n                                        skinningJoints[1],\n                                        skinningJoints[2],\n                                        vec4(0, 0, 0, 1)));\n      pos = (jointMatrix * vec4(position, 1.0)).xyz;\n      nom = mat3(jointMatrix) * normal;\n    }\n    //v_position = pos;\n    v_normal = nom;\n\n    gl_Position = viewProjectionTransform * vec4(pos, 1.0);\n    v_position = gl_Position.xyz / gl_Position.w;\n  }\n';

/**
 * @access private
 * @type {string}
 */
var _defaultHitTestFragmentShader = '#version 300 es\n  precision mediump float;\n\n  uniform int objectID;\n  uniform int geometryID;\n\n  in vec3 v_normal;\n  in vec3 v_position;\n\n  layout(location = 0) out vec4 out_objectID;\n  layout(location = 1) out vec4 out_faceID;\n  layout(location = 2) out vec4 out_position;\n  layout(location = 3) out vec4 out_normal;\n\n  void main() {\n    out_objectID = vec4(\n      float(objectID >> 8) / 255.0,\n      float(objectID & 0xFF) / 255.0,\n      float(geometryID >> 8) / 255.0,\n      float(geometryID & 0xFF) / 255.0\n    );\n    //out_faceID = vec4(\n    //  (gl_PrimitiveID >> 24) / 255.0,\n    //  ((gl_PrimitiveID >> 16) & 0xFF) / 255.0,\n    //  ((gl_PrimitiveID >> 8) & 0xFF) / 255.0,\n    //  (gl_PrimitiveID & 0xFF) / 255.0\n    //);\n    out_faceID = vec4(0, 0, 0, 0); // TODO: implement\n    vec3 n = normalize(v_normal);\n    out_normal = vec4((n.x + 1.0) * 0.5, (n.y + 1.0) * 0.5, (n.z + 1.0) * 0.5, 0);\n    //out_position = vec4((v_position.x + 1.0) * 0.5, (v_position.y + 1.0) * 0.5, (v_position.z + 1.0) * 0.5, 0);\n    float r = (v_position.z + 1.0) * 0.5;\n    float g = fract(r * 255.0);\n    float b = fract(g * 255.0);\n    float a = fract(b * 255.0);\n    float coef = 1.0 / 255.0;\n\n    r -= g * coef;\n    g -= b * coef;\n    b -= a * coef;\n    out_position = vec4(r, g, b, a);\n  }\n';

/**
 * @access private
 * @type {string}
 */
var _defaultShadowVertexShader = '#version 300 es\n  precision mediump float;\n\n  uniform mat4 viewProjectionTransform;\n  uniform vec4[765] skinningJoints;\n  uniform int numSkinningJoints;\n\n  in vec3 position;\n  //in vec3 normal;\n  in vec4 boneIndices;\n  in vec4 boneWeights;\n\n  out vec3 v_position;\n\n  void main() {\n    vec3 pos = vec3(0, 0, 0);\n    if(numSkinningJoints > 0){\n      for(int i=0; i<numSkinningJoints; i++){\n        float weight = boneWeights[i];\n        if(int(boneIndices[i]) < 0){\n          continue;\n        }\n        int idx = int(boneIndices[i]) * 3;\n        mat4 jointMatrix = transpose(mat4(skinningJoints[idx],\n                                          skinningJoints[idx+1],\n                                          skinningJoints[idx+2],\n                                          vec4(0, 0, 0, 1)));\n        pos += (jointMatrix * vec4(position, 1.0)).xyz * weight;\n      }\n    }else{\n      mat4 jointMatrix = transpose(mat4(skinningJoints[0],\n                                        skinningJoints[1],\n                                        skinningJoints[2],\n                                        vec4(0, 0, 0, 1)));\n      pos = (jointMatrix * vec4(position, 1.0)).xyz;\n    }\n    //v_position = pos;\n\n    gl_Position = viewProjectionTransform * vec4(pos, 1.0);\n    v_position = gl_Position.xyz / gl_Position.w;\n  }\n';

/**
 * @access private
 * @type {string}
 */
var _defaultShadowFragmentShader = '#version 300 es\n  precision mediump float;\n\n  in vec3 v_position;\n\n  layout(location = 0) out vec4 out_depth;\n  //layout(location = 0) out float out_depth;\n\n  void main() {\n    float r = (v_position.z + 1.0) * 0.5;\n    float g = fract(r * 255.0);\n    float b = fract(g * 255.0);\n    float a = fract(b * 255.0);\n    float coef = 1.0 / 255.0;\n\n    r -= g * coef;\n    g -= b * coef;\n    b -= a * coef;\n    out_depth = vec4(r, g, b, a);\n    //out_depth = v_position.z;\n  }\n';

/**
 * A renderer for displaying SceneKit scene in an an existing Metal workflow or OpenGL context. 
 * @access public
 * @extends {NSObject}
 * @implements {SCNSceneRenderer}
 * @implements {SCNTechniqueSupport}
 * @see https://developer.apple.com/documentation/scenekit/scnrenderer
 */

var SCNRenderer = function (_NSObject) {
  _inherits(SCNRenderer, _NSObject);

  // Creating a Renderer

  /**
   * Creates a renderer with the specified Metal device.
   * @access public
   * @constructor
   * @param {?MTLDevice} device - A Metal device.
   * @param {?Map<AnyHashable, Object>} [options = null] - An optional dictionary for future extensions.
   * @desc Use this initializer to create a SceneKit renderer that draws into the rendering targets your app already uses to draw other content. For the device parameter, pass the MTLDevice object your app uses for drawing. Then, to tell SceneKit to render your content, call the SCNRenderer method, providing a command buffer and render pass descriptor for SceneKit to use in its rendering.
   * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1518404-init
   */
  function SCNRenderer(device) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, SCNRenderer);

    // Specifying a Scene

    /**
     * The scene to be rendered.
     * @type {?SCNScene}
     * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1518400-scene
     */
    var _this = _possibleConstructorReturn(this, (SCNRenderer.__proto__ || Object.getPrototypeOf(SCNRenderer)).call(this));

    _this.scene = null;

    // Managing Animation Timing

    _this._nextFrameTime = 0;

    /**
     * context to draw frame
     * @type {WebGLRenderingContext}
     */
    _this._context = null;

    /**
     *
     * @access private
     * @type {SKColor}
     */
    _this._backgroundColor = null;

    //////////////////////
    // SCNSceneRenderer //
    //////////////////////

    // Managing Scene Display

    /**
     * Required. The node from which the scene’s contents are viewed for rendering.
     * @access private
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523982-pointofview
     */
    _this._pointOfView = null;

    /**
     * Required. A Boolean value that determines whether SceneKit automatically adds lights to a scene.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting
     */
    _this.autoenablesDefaultLighting = false;

    /**
     * Required. A Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524026-isjitteringenabled
     */
    _this.isJitteringEnabled = false;

    /**
     * Required. A Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522763-showsstatistics
     */
    _this.showsStatistics = false;

    /**
     * Required. Options for drawing overlay content in a scene that can aid debugging.
     * @type {SCNDebugOptions}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523281-debugoptions
     */
    _this.debugOptions = null;

    _this._renderingAPI = null;

    // Managing Scene Animation Timing

    /**
     * Required. The current scene time.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522680-scenetime
     */
    _this.sceneTime = 0;

    /**
     * current time in seconds
     * @access private
     * @type {number}
     */
    _this._time = 0;

    /**
     * Required. A Boolean value that determines whether the scene is playing.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523401-isplaying
     */
    _this.isPlaying = false;

    /**
     * Required. A Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522878-loops
     */
    _this.loops = false;

    // Participating in the Scene Rendering Process

    /**
     * Required. A delegate object that receives messages about SceneKit’s rendering process.
     * @type {?SCNSceneRendererDelegate}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522671-delegate
     */
    _this.delegate = null;

    // Customizing Scene Rendering with Metal

    _this._currentRenderCommandEncoder = null;
    _this._device = null;
    _this._commandQueue = null;
    _this._colorPixelFormat = null;
    _this._depthPixelFormat = null;
    _this._stencilPixelFormat = null;

    // Rendering Sprite Kit Content over a Scene

    /**
     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
     * @type {?SKScene}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524051-overlayskscene
     */
    _this.overlaySKScene = null;

    // Working With Positional Audio

    /**
     * Required. The node representing the listener’s position in the scene for use with positional audio effects.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523747-audiolistener
     */
    //this.audioListener = null
    //this._audioEnvironmentNode = null
    //this._audioEngine = null

    // Instance Properties

    /**
     * Required. 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522854-currenttime
     */
    _this.currentTime = 0;

    /**
     * @access private
     * @type {SCNProgram}
     */
    _this.__defaultProgram = null;

    /**
     * @access private
     * @type {SCNProgram}
     */
    _this.__defaultParticleProgram = null;

    /**
     * @access private
     * @type {SCNProgram}
     */
    _this.__defaultHitTestProgram = null;

    /**
     * @access private
     * @type {SCNProgram}
     */
    _this.__defaultShadowProgram = null;

    _this._location = new Map();

    _this._defaultCameraPosNode = new _SCNNode2.default();
    _this._defaultCameraRotNode = new _SCNNode2.default();
    _this._defaultCameraNode = new _SCNNode2.default();
    _this._defaultCameraNode.name = 'kSCNFreeViewCameraName';

    var camera = new _SCNCamera2.default();
    camera.name = 'kSCNFreeViewCameraNameCamera';
    _this._defaultCameraNode.camera = camera;
    _this._defaultCameraNode.position = new _SCNVector2.default(0, 0, _defaultCameraDistance);
    _this._defaultCameraNode._presentation = _this._defaultCameraNode.copy();

    _this._defaultCameraPosNode.addChildNode(_this._defaultCameraRotNode);
    _this._defaultCameraPosNode._presentation = _this._defaultCameraPosNode.copy();
    _this._defaultCameraRotNode.addChildNode(_this._defaultCameraNode);
    _this._defaultCameraRotNode._presentation = _this._defaultCameraRotNode.copy();

    _this._defaultLightNode = new _SCNNode2.default();
    var light = new _SCNLight2.default();
    light.color = _SKColor2.default.white;
    light.type = _SCNLight2.default.LightType.omni;
    light.position = new _SCNVector2.default(0, 10, 10);
    _this._defaultLightNode.light = light;
    _this._defaultLightNode._presentation = _this._defaultLightNode.copy

    /**
     * @access private
     * @type {CGRect}
     */
    ();_this._viewRect = new _CGRect2.default(new _CGPoint2.default(0, 0), new _CGSize2.default(0, 0));

    /**
     * The background color of the view.
     * @type {SKColor}
     */
    _this._backgroundColor = _SKColor2.default.white;

    /**
     * @access private
     * @type {WebGLTexture}
     */
    _this.__dummyTexture = null;

    /**
     * @access private
     * @type {Object}
     */
    _this._lightNodes = {};

    /**
     * @access private
     * @type {Object}
     */
    _this._numLights = {};

    /**
     * @access private
     * @type {WebGLBuffer}
     */
    _this._cameraBuffer = null;

    /**
     * @access private
     * @type {WebGLBuffer}
     */
    _this._lightBuffer = null;

    /**
     * @access private
     * @type {WebGLBuffer}
     */
    _this._scnLightsBuffer = null;

    /**
     * @access private
     * @type {WebGLBuffer}
     */
    _this._fogBuffer = null;

    ////////////////////////////
    // Hit Test
    ////////////////////////////

    /**
     * @access private
     * @type {WebGLFramebuffer}
     */
    _this._hitFrameBuffer = null;

    /**
     * @access private
     * @type {WebGLRenderbuffer}
     */
    _this._hitDepthBuffer = null;

    /**
     * @access private
     * @type {WebGLTexture}
     */
    _this._hitObjectIDTexture = null;

    /**
     * @access private
     * @type {WebGLTexture}
     */
    _this._hitFaceIDTexture = null;

    /**
     * @access private
     * @type {WebGLTexture}
     */
    _this._hitPositionTexture = null;

    /**
     * @access private
     * @type {WebGLTexture}
     */
    _this._hitNormalTexture = null;

    /**
     * @access private
     * @type {SCNProgram}
     */
    _this._currentProgram = null;
    return _this;
  }

  // Managing Animation Timing

  /**
   * The timestamp for the next frame to be rendered.
   * @type {number}
   * @desc If the renderer’s scene has any attached actions or animations, use this property to determine how long your app should wait before telling the renderer to draw another frame. If this property’s value matches that of the renderer’s currentTime property, the scene contains a continuous animation—schedule your next render at whatever time best maintains your app’s performance. If the value is infinite, the scene has no running actions or animations.
   * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1518410-nextframetime
   */


  _createClass(SCNRenderer, [{
    key: 'renderAtTimePassDescriptor',


    // Rendering a Scene Using Metal

    /**
     * Renders the scene’s contents at the specified system time in the specified Metal command buffer.
     * @access public
     * @param {number} time - The timestamp, in seconds, at which to render the scene.
     * @param {CGRect} viewport - The pixel dimensions in which to render.
     * @param {MTLCommandBuffer} commandBuffer - The Metal command buffer in which SceneKit should schedule rendering commands.
     * @param {MTLRenderPassDescriptor} renderPassDescriptor - The Metal render pass descriptor describing the rendering target.
     * @returns {void}
     * @desc This method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderer’s scene into the render target described by the renderPassDescriptor parameter, by encoding render commands into the commandBuffer parameter.When you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene using the specified Metal objects. NoteBy default, the playback timing of actions and animations in a scene is based on the system time, not the scene time. Before using this method to control the playback of animations, set the usesSceneTimeBase property of each animation to true, or specify the playUsingSceneTimeBase option when loading a scene file that contains animations.
     * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1518401-render
     */
    value: function renderAtTimePassDescriptor(time, viewport, commandBuffer, renderPassDescriptor) {}

    // Rendering a Scene Using OpenGL

    /**
     * Renders the scene’s contents in the renderer’s OpenGL context.
     * @deprecated
     * @access public
     * @returns {void}
     * @desc This method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderer’s scene into the OpenGL context you created the renderer with.When you call this method, SceneKit updates its hierarchy of presentation nodes based on the current system time, and then draws the scene.
     * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1518403-render
     */

  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      if (this.context === null) {
        console.error('SCNRenderer.render(): context is null');
        return;
      }
      var gl = this.context;

      if (this.scene === null) {
        if (this.overlaySKScene) {
          var sk = this.overlaySKScene;
          gl.clearColor(sk.backgroundColor.red, sk.backgroundColor.green, sk.backgroundColor.blue, sk.backgroundColor.alpha);
          gl.clear(gl.COLOR_BUFFER_BIT);
          this._renderOverlaySKScene();
        }
        return;
      }

      this._lightNodes = this._createLightNodeArray // createLightNodeArray must be called before getting program

      ();var p = this._defaultProgram;
      var glProgram = p._getGLProgramForContext(gl);

      gl.clearColor(this._backgroundColor.red, this._backgroundColor.green, this._backgroundColor.blue, this._backgroundColor.alpha);
      gl.clearDepth(1.0);
      gl.clearStencil(0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT

      //gl.useProgram(glProgram)
      );this._useProgram(p);

      gl.depthFunc(gl.LEQUAL);
      gl.depthMask(true);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA

      //////////////////////////
      // Camera
      //////////////////////////
      );if (this._cameraBuffer === null) {
        this._initializeCameraBuffer(glProgram);
      }
      var cameraData = [];
      var cameraNode = this._getCameraNode();
      cameraNode._updateWorldTransform();
      var cameraPNode = cameraNode.presentation || cameraNode;
      var camera = cameraPNode.camera;
      camera._updateProjectionTransform(this._viewRect);

      cameraData.push.apply(cameraData, _toConsumableArray(cameraPNode.worldTransform.getTranslation().floatArray()).concat([0]));
      cameraData.push.apply(cameraData, _toConsumableArray(cameraPNode.viewTransform.floatArray()));
      cameraData.push.apply(cameraData, _toConsumableArray(cameraPNode.viewProjectionTransform.floatArray()));
      gl.bindBuffer(gl.UNIFORM_BUFFER, this._cameraBuffer);
      gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(cameraData), gl.DYNAMIC_DRAW);
      gl.bindBuffer(gl.UNIFORM_BUFFER, null

      //console.log('cameraNode.worldPosition: ' + cameraPNode.worldTransform.getTranslation().float32Array())
      //console.log('viewTransform: ' + cameraPNode.viewTransform.float32Array())
      //console.log('projectionTransform: ' + cameraNode.camera.projectionTransform.float32Array())
      //console.log('viewProjectionTransform: ' + cameraNode.viewProjectionTransform.float32Array())

      //////////////////////////
      // Fog
      //////////////////////////
      );if (this._fogBuffer === null) {
        this._initializeFogBuffer(glProgram);
      }
      var fogData = [];
      if (this.scene.fogColor !== null && this.scene.fogEndDistance !== 0) {
        fogData.push.apply(fogData, _toConsumableArray(this.scene.fogColor.floatArray()).concat([this.scene.fogStartDistance, this.scene.fogEndDistance, this.scene.fogDensityExponent, 0]));
      } else {
        fogData.push(0, 0, 0, 0, camera.zFar * 2, camera.zFar * 2 + 1, 1, 0);
      }
      gl.bindBuffer(gl.UNIFORM_BUFFER, this._fogBuffer);
      gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(fogData), gl.DYNAMIC_DRAW);
      gl.bindBuffer(gl.UNIFORM_BUFFER, null

      //////////////////////////
      // Lights
      //////////////////////////
      );if (this._lightBuffer === null) {
        this._initializeLightBuffer(glProgram);
      }
      var lights = this._lightNodes;
      var lightData = [];
      lights.ambient.forEach(function (node) {
        lightData.push.apply(lightData, _toConsumableArray(node.presentation.light.color.float32Array()));
      });
      lights.directional.forEach(function (node) {
        var direction = new _SCNVector2.default(0, 0, -1).rotateWithQuaternion(node.presentation._worldOrientation);
        lightData.push.apply(lightData, _toConsumableArray(node.presentation.light.color.float32Array()).concat(_toConsumableArray(direction.float32Array()), [0]));
      });
      lights.directionalShadow.forEach(function (node) {
        var direction = new _SCNVector2.default(0, 0, -1).rotateWithQuaternion(node.presentation._worldOrientation);
        node.presentation.light._updateProjectionTransform();
        lightData.push.apply(lightData, _toConsumableArray(node.presentation.light.color.float32Array()).concat(_toConsumableArray(direction.float32Array()), [0], _toConsumableArray(node.presentation.light.shadowColor.float32Array()), _toConsumableArray(node.presentation.lightViewProjectionTransform.float32Array()), _toConsumableArray(node.presentation.shadowProjectionTransform.float32Array())));
      });
      lights.omni.forEach(function (node) {
        lightData.push.apply(lightData, _toConsumableArray(node.presentation.light.color.float32Array()).concat(_toConsumableArray(node.presentation._worldTranslation.float32Array()), [0]));
      });
      lights.probe.forEach(function (node) {
        lightData.push.apply(lightData, _toConsumableArray(node.presentation.light.color.float32Array()));
      });
      lights.spot.forEach(function (node) {
        lightData.push.apply(lightData, _toConsumableArray(node.presentation.light.color.float32Array()));
      });

      gl.bindBuffer(gl.UNIFORM_BUFFER, this._lightBuffer);
      gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(lightData), gl.DYNAMIC_DRAW);
      gl.bindBuffer(gl.UNIFORM_BUFFER, null

      // FIXME: set params for each light
      );var scnLightsData = [];
      if (lights.directionalShadow.length > 0) {
        var l = lights.directionalShadow[0].presentation;
        var direction = new _SCNVector2.default(0, 0, -1).rotateWithQuaternion(l._worldOrientation);
        scnLightsData.push.apply(scnLightsData, _toConsumableArray(direction.float32Array()).concat([0]));
        scnLightsData.push.apply(scnLightsData, _toConsumableArray(l.shadowProjectionTransform.float32Array()));
      } else {
        // direction
        scnLightsData.push(0, 0, 0, 0
        // identity matrix
        );scnLightsData.push(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      gl.bindBuffer(gl.UNIFORM_BUFFER, this._scnLightsBuffer);
      gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(scnLightsData), gl.DYNAMIC_DRAW);
      gl.bindBuffer(gl.UNIFORM_BUFFER, null

      //////////////////////////
      // Background (SkyBox)
      //////////////////////////
      );if (this.scene.background._contents !== null) {
        var skyBox = this.scene._skyBox;
        skyBox.position = cameraPNode._worldTranslation;
        var scale = camera.zFar * 1.154;
        skyBox.scale = new _SCNVector2.default(scale, scale, scale);
        skyBox._updateWorldTransform

        // disable fog
        ();var disabledFogData = fogData.slice(0);
        disabledFogData[4] = camera.zFar * 2.0; // startDistance
        disabledFogData[5] = camera.zFar * 2.1; // endDistance
        disabledFogData[6] = 1.0; // densityExponent
        gl.bindBuffer(gl.UNIFORM_BUFFER, this._fogBuffer);
        gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(disabledFogData), gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);

        this._renderNode(skyBox

        // enable fog
        );gl.bindBuffer(gl.UNIFORM_BUFFER, this._fogBuffer);
        gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(fogData), gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
      }

      //////////////////////////
      // Shadow
      //////////////////////////
      //gl.useProgram(this._defaultShadowProgram._glProgram)
      this._useProgram(this._defaultShadowProgram);
      gl.enable(gl.DEPTH_TEST);
      gl.depthMask(true);
      gl.depthFunc(gl.LEQUAL);
      gl.clearDepth(1.0);
      gl.clearColor(1.0, 1.0, 1.0, 1.0);
      gl.disable(gl.BLEND);
      var shadowRenderingArray = this._createShadowNodeArray();

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(lights)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = lights[key][Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var lightNode = _step3.value;

              this._renderNodesShadowOfLight(shadowRenderingArray, lightNode);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._setViewPort // reset viewport size
      ();this._useProgram(p);
      for (var i = 0; i < lights.directionalShadow.length; i++) {
        var node = lights.directionalShadow[i];
        var symbol = 'TEXTURE' + (i + 8);
        gl.activeTexture(gl[symbol]);
        gl.bindTexture(gl.TEXTURE_2D, node.presentation.light._shadowDepthTexture);
      }
      gl.enable(gl.BLEND

      //////////////////////////
      // Nodes
      //////////////////////////
      );var renderingArray = this._createRenderingNodeArray();
      renderingArray.forEach(function (node) {
        _this2._renderNode(node);
      });

      var particleProgram = this._defaultParticleProgram._glProgram;
      //gl.useProgram(particleProgram)
      this._useProgram(this._defaultParticleProgram);
      gl.depthMask(false);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
      gl.uniformMatrix4fv(gl.getUniformLocation(particleProgram, 'viewTransform'), false, cameraPNode.viewTransform.float32Array());
      gl.uniformMatrix4fv(gl.getUniformLocation(particleProgram, 'projectionTransform'), false, cameraPNode.projectionTransform.float32Array()

      //////////////////////////
      // Particles
      //////////////////////////
      );if (this.scene._particleSystems !== null) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.scene._particleSystems[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var system = _step2.value;

            this._renderParticleSystem(system);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
      var particleArray = this._createParticleNodeArray();
      particleArray.forEach(function (node) {
        _this2._renderParticle(node);
      }

      //////////////////////////
      // 2D Overlay
      //////////////////////////
      );this._renderOverlaySKScene

      // DEBUG: show shadow map
      //this._showShadowMapOfLight(lights.directionalShadow[0])

      ();gl.flush();
    }
  }, {
    key: '_renderOverlaySKScene',
    value: function _renderOverlaySKScene() {
      if (this.overlaySKScene === null) {
        return;
      }
      var gl = this.context;
      gl.disable(gl.CULL_FACE);

      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.GEQUAL);

      gl.enable(gl.BLEND);
      gl.depthMask(true);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      gl.clearStencil(0);
      gl.clearDepth(-1);
      gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

      var skNodes = this._createSKNodeArray();
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = skNodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var node = _step4.value;

          this._renderSKNode(node);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }

    /**
     * @access private
     * @returns {SCNNode} -
     */

  }, {
    key: '_getCameraNode',
    value: function _getCameraNode() {
      var cameraNode = this._pointOfView;
      if (cameraNode === null) {
        cameraNode = this._searchCameraNode();
        this._pointOfView = cameraNode;
        if (cameraNode === null) {
          cameraNode = this._defaultCameraNode;
        }
      }
      if (cameraNode === this._defaultCameraNode) {
        this._defaultCameraPosNode._updateWorldTransform();
      }
      return cameraNode;
    }

    /**
     *
     * @access private
     * @returns {SCNNode[]} -
     */

  }, {
    key: '_createShadowNodeArray',
    value: function _createShadowNodeArray() {
      var arr = [this.scene._rootNode];
      var targetNodes = [];
      while (arr.length > 0) {
        var node = arr.shift();
        if (node.presentation !== null && node.presentation.geometry !== null && node.presentation.castsShadow && node.presentation._worldOpacity > 0 && !node.presentation.isHidden) {
          targetNodes.push(node);
        }
        arr.push.apply(arr, _toConsumableArray(node.childNodes));
      }

      return targetNodes;
    }

    /**
     *
     * @access private
     * @returns {SCNNode[]} -
     */

  }, {
    key: '_createRenderingNodeArray',
    value: function _createRenderingNodeArray() {
      var arr = [this.scene._rootNode];
      var targetNodes = [];
      while (arr.length > 0) {
        var node = arr.shift();
        if (node.presentation !== null && node.presentation.geometry !== null) {
          targetNodes.push(node);
        }
        arr.push.apply(arr, _toConsumableArray(node.childNodes));
      }
      targetNodes.sort(function (a, b) {
        return a.presentation.renderingOrder - b.presentation.renderingOrder + (b.presentation._worldOpacity - a.presentation._worldOpacity) * 0.5;
      });

      return targetNodes;
    }

    /**
     *
     * @access private
     * @returns {SCNNode[]} -
     */

  }, {
    key: '_createParticleNodeArray',
    value: function _createParticleNodeArray() {
      var arr = [this.scene._rootNode];
      var targetNodes = [];
      while (arr.length > 0) {
        var node = arr.shift();
        if (node.presentation !== null && node.presentation.particleSystems !== null) {
          targetNodes.push(node);
        }
        arr.push.apply(arr, _toConsumableArray(node.childNodes));
      }
      targetNodes.sort(function (a, b) {
        return a.renderingOrder - b.renderingOrder + (b.opacity - a.opacity) * 0.5;
      });

      return targetNodes;
    }

    /**
     *
     * @access private
     * @returns {SCNNode[]} -
     */

  }, {
    key: '_createLightNodeArray',
    value: function _createLightNodeArray() {
      var targetNodes = {
        ies: [],
        ambient: [],
        directional: [],
        omni: [],
        probe: [],
        spot: [],

        directionalShadow: []
      };

      var arr = [this.scene.rootNode];
      var numLights = 0;
      while (arr.length > 0) {
        var node = arr.shift();
        if (node.presentation !== null && node.presentation.light !== null) {
          if (node.presentation.light.type === 'directional' && node.presentation.light.castsShadow) {
            targetNodes.directionalShadow.push(node);
          } else {
            targetNodes[node.presentation.light.type].push(node);
          }
          if (node.presentation.light.type !== _SCNLight2.default.LightType.ambient) {
            numLights += 1;
          }
        }
        arr.push.apply(arr, _toConsumableArray(node.childNodes));
      }
      if (this.autoenablesDefaultLighting && numLights === 0) {
        targetNodes[this._defaultLightNode.light.type].push(this._defaultLightNode);
      }

      return targetNodes;
    }

    /**
     *
     * @access private
     * @returns {SCNNode[]} -
     */

  }, {
    key: '_createRenderingPhysicsNodeArray',
    value: function _createRenderingPhysicsNodeArray() {
      var arr = [this.scene._rootNode];
      var targetNodes = [];
      while (arr.length > 0) {
        var node = arr.shift();
        if (node.presentation !== null && node.presentation.physicsBody !== null && node.presentation.physicsBody.physicsShape !== null) {
          targetNodes.push(node);
        }
        arr.push.apply(arr, _toConsumableArray(node.childNodes));
      }
      targetNodes.sort(function (a, b) {
        return a.renderingOrder - b.renderingOrder;
      });

      return targetNodes;
    }

    /**
     *
     * @access private
     * @param {SCNNode[]} nodes -
     * @param {SCNNode} lightNode -
     * @returns {void}
     */

  }, {
    key: '_renderNodesShadowOfLight',
    value: function _renderNodesShadowOfLight(nodes, lightNode) {
      var lp = lightNode.presentation;
      var light = lp.light;
      if (!lp.castsShadow) {
        return;
      }
      this._setViewPort(light._shadowMapWidth, light._shadowMapHeight);
      var gl = this.context;
      var glProgram = this._defaultShadowProgram._getGLProgramForContext(gl);
      gl.bindFramebuffer(gl.FRAMEBUFFER, light._getDepthBufferForContext(gl));
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      gl.uniformMatrix4fv(gl.getUniformLocation(glProgram, 'viewProjectionTransform'), false, lp.lightViewProjectionTransform.float32Array());

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = nodes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var node = _step5.value;

          var geometry = node.presentation.geometry;
          var geometryCount = geometry.geometryElements.length;
          if (geometryCount === 0) {
            // nothing to draw...
            continue;
          }

          if (geometry._shadowVAO === null) {
            this._initializeShadowVAO(node, glProgram);
          }

          if (node.morpher !== null) {
            //this._updateVAO(node)
          }

          if (node.presentation.skinner !== null) {
            if (node.presentation.skinner._useGPU) {
              gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
              gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation.skinner.float32Array());
            } else {
              gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
              gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0).float32Array3x4f());
            }
          } else {
            gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
            gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
          }

          for (var i = 0; i < geometryCount; i++) {
            var vao = geometry._shadowVAO[i];
            var element = geometry.geometryElements[i];

            gl.bindVertexArray(vao
            // FIXME: use bufferData instead of bindBufferBase

            );var shape = null;
            switch (element.primitiveType) {
              case _SCNGeometryPrimitiveType2.default.triangles:
                shape = gl.TRIANGLES;
                break;
              case _SCNGeometryPrimitiveType2.default.triangleStrip:
                shape = gl.TRIANGLE_STRIP;
                break;
              case _SCNGeometryPrimitiveType2.default.line:
                shape = gl.LINES;
                break;
              case _SCNGeometryPrimitiveType2.default.point:
                shape = gl.POINTS;
                break;
              case _SCNGeometryPrimitiveType2.default.polygon:
                shape = gl.TRIANGLE_FAN;
                break;
              default:
                throw new Error('unsupported primitiveType: ' + element.primitiveType);
            }

            var size = null;
            switch (element.bytesPerIndex) {
              case 1:
                size = gl.UNSIGNED_BYTE;
                break;
              case 2:
                size = gl.UNSIGNED_SHORT;
                break;
              case 4:
                size = gl.UNSIGNED_INT;
                break;
              default:
                throw new Error('unsupported index size: ' + element.bytesPerIndex);
            }

            gl.drawElements(shape, element._glData.length, size, 0);
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    /**
     *
     * @access private
     * @param {SCNNode} node -
     * @returns {void}
     */

  }, {
    key: '_renderNode',
    value: function _renderNode(node) {
      if (node.presentation.isHidden || node.presentation._worldOpacity <= 0) {
        return;
      }
      var gl = this.context;
      var geometry = node.presentation.geometry;
      var geometryCount = geometry.geometryElements.length;
      if (geometryCount === 0) {
        // nothing to draw...
        return;
      }
      var scnProgram = this._getProgramForGeometry(geometry);
      var glProgram = scnProgram._getGLProgramForContext(gl);

      this._switchProgram(scnProgram);

      if (geometry._vertexArrayObjects === null) {
        this._initializeVAO(node, glProgram);
        this._initializeUBO(node, glProgram // FIXME: program should have UBO, not node.
        );
      }

      if (node.morpher !== null || node.skinner && !node.skinner._useGPU) {
        this._updateVAO(node);
      }

      gl.uniformMatrix4fv(gl.getUniformLocation(glProgram, 'modelTransform'), false, node._worldTransform.float32Array());

      if (node.presentation.skinner !== null) {
        if (node.presentation.skinner._useGPU) {
          gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
          gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation.skinner.float32Array());
        } else {
          gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
          gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0).float32Array3x4f());
        }
      } else {
        gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
        gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
      }

      for (var i = 0; i < geometryCount; i++) {
        var materialCount = geometry.materials.length;
        var material = geometry.materials[i % materialCount];
        var p = glProgram;
        if (material && material.program) {
          this._switchProgram(material.program
          // TODO: refactoring
          );p = material.program._getGLProgramForContext(gl);
          if (node.presentation.skinner !== null) {
            if (node.presentation.skinner._useGPU) {
              gl.uniform1i(gl.getUniformLocation(p, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
              gl.uniform4fv(gl.getUniformLocation(p, 'skinningJoints'), node.presentation.skinner.float32Array());
            } else {
              gl.uniform1i(gl.getUniformLocation(p, 'numSkinningJoints'), 0);
              gl.uniform4fv(gl.getUniformLocation(p, 'skinningJoints'), (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0).float32Array3x4f());
            }
          } else {
            gl.uniform1i(gl.getUniformLocation(p, 'numSkinningJoints'), 0);
            gl.uniform4fv(gl.getUniformLocation(p, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
          }
          var materialIndex = gl.getUniformBlockIndex(p, 'materialUniform');
          gl.uniformBlockBinding(p, materialIndex, _materialLoc);
          gl.bindBufferBase(gl.UNIFORM_BUFFER, _materialLoc, geometry._materialBuffer);

          material._callBindingHandlerForNodeProgramContextRenderer(node, p, gl, this);
        } else {
          this._switchProgram(scnProgram);

          geometry._callBindingHandlerForNodeProgramContextRenderer(node, glProgram, gl, this);
        }
        var vao = geometry._vertexArrayObjects[i];
        var element = geometry.geometryElements[i];

        gl.bindVertexArray(vao
        // FIXME: use bufferData instead of bindBufferBase
        );gl.bindBufferBase(gl.UNIFORM_BUFFER, _materialLoc, geometry._materialBuffer);

        geometry._bufferMaterialData(gl, p, i, node.presentation._worldOpacity);

        var shape = null;
        switch (element.primitiveType) {
          case _SCNGeometryPrimitiveType2.default.triangles:
            shape = gl.TRIANGLES;
            break;
          case _SCNGeometryPrimitiveType2.default.triangleStrip:
            shape = gl.TRIANGLE_STRIP;
            break;
          case _SCNGeometryPrimitiveType2.default.line:
            shape = gl.LINES;
            break;
          case _SCNGeometryPrimitiveType2.default.point:
            shape = gl.POINTS;
            break;
          case _SCNGeometryPrimitiveType2.default.polygon:
            shape = gl.TRIANGLE_FAN;
            break;
          default:
            throw new Error('unsupported primitiveType: ' + element.primitiveType);
        }

        var size = null;
        switch (element.bytesPerIndex) {
          case 1:
            size = gl.UNSIGNED_BYTE;
            break;
          case 2:
            size = gl.UNSIGNED_SHORT;
            break;
          case 4:
            size = gl.UNSIGNED_INT;
            break;
          default:
            throw new Error('unsupported index size: ' + element.bytesPerIndex);
        }

        gl.drawElements(shape, element._glData.length, size, 0);
      }
    }

    /**
     *
     * @access private
     * @param {SCNNode} node -
     * @returns {void}
     */

  }, {
    key: '_renderParticle',
    value: function _renderParticle(node) {
      var _this3 = this;

      if (node.presentation.isHidden) {
        return;
      }

      //const systems = node.presentation.particleSystems
      var systems = node.particleSystems;
      systems.forEach(function (system) {
        _this3._renderParticleSystem(system, node);
      });
    }

    /**
     *
     * @access private
     * @param {SCNParticleSystem} system - 
     * @param {?SCNNode} [node = null] -
     * @returns {void}
     */

  }, {
    key: '_renderParticleSystem',
    value: function _renderParticleSystem(system) {
      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      //this.currentTime
      var gl = this.context;
      //let program = this._defaultParticleProgram._glProgram
      //if(system._program !== null){
      //  program = system._program._glProgram
      //}
      var p = this._defaultParticleProgram;
      if (system._program !== null) {
        p = system._program;
      }
      var glProgram = p._getGLProgramForContext(gl);
      this._useProgram(p
      //this._switchProgram(p)
      );gl.disable(gl.CULL_FACE);

      if (system._vertexBuffer === null) {
        system._initializeVAO(gl, glProgram);
      }
      gl.bindVertexArray(system._vertexArray);

      system._bufferMaterialData(gl, glProgram);
      if (node) {
        gl.uniformMatrix4fv(gl.getUniformLocation(glProgram, 'modelTransform'), false, node._worldTransform.float32Array());
      } else {
        var m = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);
        gl.uniformMatrix4fv(gl.getUniformLocation(glProgram, 'modelTransform'), false, m.float32Array());
      }

      gl.drawElements(gl.TRIANGLES, system._particles.length * 6, system._glIndexSize, 0);
    }

    /**
     *
     * @access private
     * @param {SCNNode} node -
     * @param {number} objectID -
     * @param {Map} options -
     * @returns {void}
     */

  }, {
    key: '_renderNodeForHitTest',
    value: function _renderNodeForHitTest(node, objectID, options) {
      var gl = this.context;
      var geometry = node.presentation.geometry;
      var glProgram = this._defaultHitTestProgram._getGLProgramForContext(gl);

      var geometryCount = geometry.geometryElements.length;
      if (geometryCount === 0) {
        // nothing to draw...
        return;
      }
      if (geometry._vertexArrayObjects === null) {
        // geometry is not ready
        return;
      }
      if (geometry._hitTestVAO === null) {
        this._initializeHitTestVAO(node, glProgram);
      }

      gl.uniform1i(gl.getUniformLocation(glProgram, 'objectID'), objectID);

      if (node.presentation.skinner !== null && node.presentation.skinner._useGPU) {
        if (node.presentation.skinner._useGPU) {
          gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
          gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation.skinner.float32Array());
        } else {
          gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
          gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0).float32Array3x4f());
        }
      } else {
        gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
        gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
      }

      for (var i = 0; i < geometryCount; i++) {
        var vao = geometry._hitTestVAO[i];
        var element = geometry.geometryElements[i];

        gl.bindVertexArray(vao);
        gl.uniform1i(gl.getUniformLocation(glProgram, 'geometryID'), i);

        var shape = null;
        switch (element.primitiveType) {
          case _SCNGeometryPrimitiveType2.default.triangles:
            shape = gl.TRIANGLES;
            break;
          case _SCNGeometryPrimitiveType2.default.triangleStrip:
            shape = gl.TRIANGLE_STRIP;
            break;
          case _SCNGeometryPrimitiveType2.default.line:
            shape = gl.LINES;
            break;
          case _SCNGeometryPrimitiveType2.default.point:
            shape = gl.POINTS;
            break;
          case _SCNGeometryPrimitiveType2.default.polygon:
            shape = gl.TRIANGLE_FAN;
            break;
          default:
            throw new Error('unsupported primitiveType: ' + element.primitiveType);
        }

        var size = null;
        switch (element.bytesPerIndex) {
          case 1:
            size = gl.UNSIGNED_BYTE;
            break;
          case 2:
            size = gl.UNSIGNED_SHORT;
            break;
          case 4:
            size = gl.UNSIGNED_INT;
            break;
          default:
            throw new Error('unsupported index size: ' + element.bytesPerIndex);
        }

        //console.log(`hitTest drawElements: length: ${element._glData.length}`)
        gl.drawElements(shape, element._glData.length, size, 0);
      }
    }

    /**
     *
     * @access private
     * @param {SCNNode} node -
     * @param {number} objectID -
     * @param {Map} options -
     * @returns {void}
     */

  }, {
    key: '_renderPhysicsNodeForHitTest',
    value: function _renderPhysicsNodeForHitTest(node, objectID, options) {
      var gl = this.context;
      var p = node.presentation;
      var body = p.physicsBody;
      var geometry = body.physicsShape._sourceGeometry;
      var geometryCount = geometry.geometryElements.length;
      if (geometryCount === 0) {
        // nothing to draw...
        return;
      }
      var glProgram = this._defaultHitTestProgram._getGLProgramForContext(gl);

      if (geometry._vertexBuffer === null) {
        // should I copy the geometry?
        geometry._createVertexBuffer(gl, node, false, geometry);
      }
      if (geometry._hitTestVAO === null) {
        this._initializeHitTestVAO(node, glProgram, true);
      }

      gl.uniform1i(gl.getUniformLocation(glProgram, 'objectID'), objectID);

      if (node.presentation.skinner !== null && node.presentation.skinner._useGPU) {
        if (node.presentation.skinner._useGPU) {
          gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
          gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation.skinner.float32Array());
        } else {
          gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
          gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0).float32Array3x4f());
        }
      } else {
        gl.uniform1i(gl.getUniformLocation(glProgram, 'numSkinningJoints'), 0);
        gl.uniform4fv(gl.getUniformLocation(glProgram, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
      }

      for (var i = 0; i < geometryCount; i++) {
        var vao = geometry._hitTestVAO[i];
        var element = geometry.geometryElements[i];

        gl.bindVertexArray(vao);
        gl.uniform1i(gl.getUniformLocation(glProgram, 'geometryID'), i);

        var shape = null;
        switch (element.primitiveType) {
          case _SCNGeometryPrimitiveType2.default.triangles:
            shape = gl.TRIANGLES;
            break;
          case _SCNGeometryPrimitiveType2.default.triangleStrip:
            shape = gl.TRIANGLE_STRIP;
            break;
          case _SCNGeometryPrimitiveType2.default.line:
            shape = gl.LINES;
            break;
          case _SCNGeometryPrimitiveType2.default.point:
            shape = gl.POINTS;
            break;
          case _SCNGeometryPrimitiveType2.default.polygon:
            shape = gl.TRIANGLE_FAN;
            break;
          default:
            throw new Error('unsupported primitiveType: ' + element.primitiveType);
        }

        var size = null;
        switch (element.bytesPerIndex) {
          case 1:
            size = gl.UNSIGNED_BYTE;
            break;
          case 2:
            size = gl.UNSIGNED_SHORT;
            break;
          case 4:
            size = gl.UNSIGNED_INT;
            break;
          default:
            throw new Error('unsupported index size: ' + element.bytesPerIndex);
        }

        gl.drawElements(shape, element._glData.length, size, 0);
      }
    }

    /**
     *
     * @access private
     * @returns {SKNode[]} -
     */

  }, {
    key: '_createSKNodeArray',
    value: function _createSKNodeArray() {
      if (this.overlaySKScene === null) {
        return [];
      }

      var arr = [this.overlaySKScene];
      var targetNodes = [];
      while (arr.length > 0) {
        var node = arr.shift();
        targetNodes.push(node);
        arr.push.apply(arr, _toConsumableArray(node.children));
      }
      //targetNodes.sort((a, b) => { return a.renderingOrder - b.renderingOrder })

      return targetNodes;
    }

    /**
     *
     * @access private
     * @param {SKNode} node -
     * @returns {void}
     */

  }, {
    key: '_renderSKNode',
    value: function _renderSKNode(node) {
      node._render(this.context, this._viewRect);
    }

    /**
     * Renders the scene’s contents at the specified system time in the renderer’s OpenGL context.
     * @access public
     * @param {number} time - The timestamp, in seconds, at which to render the scene.
     * @returns {void}
     * @desc This method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderer’s scene into the OpenGL context you created the renderer with.When you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene.NoteBy default, the playback timing of actions and animations in a scene is based on the system time, not the scene time. Before using this method to control the playback of animations, set the usesSceneTimeBase property of each animation to true, or specify the playUsingSceneTimeBase option when loading a scene file that contains animations.
     * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1518402-render
     */

  }, {
    key: 'renderAtTime',
    value: function renderAtTime(time) {}

    // Capturing a Snapshot

    /**
     * Creates an image by drawing the renderer’s content at the specified system time.
     * @access public
     * @param {number} time - The timestamp, in seconds, at which to render the scene.
     * @param {CGSize} size - The size, in pixels, of the image to create.
     * @param {SCNAntialiasingMode} antialiasingMode - The antialiasing mode to use for the image output.
     * @returns {Image} - 
     * @desc When you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene into a new image object of the specified size.
     * @see https://developer.apple.com/documentation/scenekit/scnrenderer/1641767-snapshot
     */

  }, {
    key: 'snapshotAtTimeWith',
    value: function snapshotAtTimeWith(time, size, antialiasingMode) {
      return null;
    }

    // Instance Methods

    /**
     * 
     * @access public
     * @param {SCNNode[]} lightProbes - 
     * @param {number} time - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnrenderer/2097153-updateprobes
     */

  }, {
    key: 'updateProbesAtTime',
    value: function updateProbesAtTime(lightProbes, time) {}

    //////////////////////
    // SCNSceneRenderer //
    //////////////////////

    // Presenting a Scene

    /**
     * Required. Displays the specified scene with an animated transition.
     * @access public
     * @param {SCNScene} scene - The new scene to be displayed.
     * @param {SKTransition} transition - An object that specifies the duration and style of the animated transition.
     * @param {?SCNNode} pointOfView - The node to use as the pointOfView property when displaying the new scene.
     * @param {?function(): void} [completionHandler = null] - A block that SceneKit calls after the transition animation has completed.This block takes no parameters and has no return value.
     * @returns {void}
     * @desc Use this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523028-present
     */

  }, {
    key: 'presentWithIncomingPointOfView',
    value: function presentWithIncomingPointOfView(scene, transition, pointOfView) {
      var completionHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    }

    // Managing Scene Display

    /**
     * Required. The node from which the scene’s contents are viewed for rendering.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523982-pointofview
     */

  }, {
    key: 'prepareShouldAbortBlock',


    // Preloading Renderer Resources

    /**
     * Required. Prepares a SceneKit object for rendering.
     * @access public
     * @param {Object} object - An SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.
     * @param {?function(): boolean} [block = null] - A block that SceneKit calls periodically while preparing the object. The block takes no parameters.Your block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.Pass nil for this parameter if you do not need an opportunity to cancel preparing the object.
     * @returns {boolean} - 
     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously. SceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.You can observe the progress of this operation with the Progress class. For details, see Progress.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522798-prepare
     */
    value: function prepareShouldAbortBlock(object) {
      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      return false;
    }

    /**
     * Required. Prepares the specified SceneKit objects for rendering, using a background thread.
     * @access public
     * @param {Object[]} objects - An array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.
     * @param {?function(arg1: boolean): void} [completionHandler = null] - A block that SceneKit calls when object preparation fails or completes.The block takes the following parameter:successtrue if all content was successfully prepared for rendering; otherwise, false.
     * @returns {void}
     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.SceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can observe the progress of this operation with the Progress class. For details, see Progress.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523375-prepare
     */

  }, {
    key: 'prepare',
    value: function prepare(objects) {
      var completionHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    }

    // Working With Projected Scene Contents

    /**
     * Required. Searches the renderer’s scene for objects corresponding to a point in the rendered image.
     * @access public
     * @param {CGPoint} point - 
     * @param {?Map<SCNHitTestOption, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
     * @returns {SCNHitTestResult[]} - 
     * @desc A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522929-hittest
     */

  }, {
    key: 'hitTest',
    value: function hitTest(point) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.scene === null) {
        return [];
      }
      var _options = new Map();
      if (options instanceof Map) {
        _options = options;
      } else if (Array.isArray(options)) {
        _options = new Map(options);
      }

      var cameraNode = this._getCameraNode();
      cameraNode.camera._updateProjectionTransform(this._viewRect);
      var from = new _SCNVector2.default(point.x, point.y, 0);
      var to = new _SCNVector2.default(point.x, point.y, 1.0);

      var useGPU = false;
      if (!useGPU) {
        return this._hitTestByCPU(cameraNode.viewProjectionTransform, from, to, _options);
      }
      return this._hitTestByGPU(cameraNode.viewProjectionTransform, from, to, _options);
    }
  }, {
    key: '_initializeHitFrameBuffer',
    value: function _initializeHitFrameBuffer() {
      var gl = this.context;
      var width = this._viewRect.size.width;
      var height = this._viewRect.size.height;
      this._hitFrameBuffer = gl.createFramebuffer();
      this._hitDepthBuffer = gl.createRenderbuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._hitFrameBuffer);
      gl.bindRenderbuffer(gl.RENDERBUFFER, this._hitDepthBuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);

      this._hitObjectIDTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this._hitObjectIDTexture
      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
      );gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

      this._hitFaceIDTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this._hitFaceIDTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

      this._hitPositionTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this._hitPositionTexture
      //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_BYTE, null)
      );gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

      this._hitNormalTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this._hitNormalTexture
      //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_BYTE, null)
      );gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null

      //gl.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer)
      );gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._hitDepthBuffer
      //gl.framebufferTexture2D(target, attachment, textarget, texture, level)
      );gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._hitObjectIDTexture, 0);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, this._hitFaceIDTexture, 0);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT2, gl.TEXTURE_2D, this._hitPositionTexture, 0);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT3, gl.TEXTURE_2D, this._hitNormalTexture, 0);
      gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1, gl.COLOR_ATTACHMENT2, gl.COLOR_ATTACHMENT3]);

      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    /**
     * @access private
     * @param {SCNMatrix4} viewProjectionMatrix -
     * @param {SCNVector3} from -
     * @param {SCNVector3} to -
     * @param {Object} options -
     * @returns {SCNHitTestResult[]} -
     */

  }, {
    key: '_hitTestByCPU',
    value: function _hitTestByCPU(viewProjectionMatrix, from, to, options) {
      var result = [];

      var invVp = viewProjectionMatrix.invert();
      var rayFrom = from.transform(invVp);
      var rayTo = to.transform(invVp
      //console.log(`rayFrom: ${rayFrom.float32Array()}`)
      //console.log(`rayTo  : ${rayTo.float32Array()}`)

      //const rayVec = rayTo.sub(rayFrom)
      );var renderingArray = this._createRenderingNodeArray
      //console.log(`renderingArray.length: ${renderingArray.length}`)

      ();var categoryBitMask = options.get(_SCNHitTestOption2.default.categoryBitMask);
      if (typeof categoryBitMask === 'undefined') {
        categoryBitMask = -1;
      }

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = renderingArray[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var node = _step6.value;

          if (node.categoryBitMask & categoryBitMask) {
            //result.push(...this._nodeHitTestByCPU(node, rayFrom, rayVec))
            var hits = _SCNPhysicsWorld2.default._hitTestWithSegmentNode(rayFrom, rayTo, node);
            if (hits.length > 0) {
              // convert from the child's coordinate to this node's coordinate
              var _iteratorNormalCompletion7 = true;
              var _didIteratorError7 = false;
              var _iteratorError7 = undefined;

              try {
                for (var _iterator7 = hits[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                  var h = _step7.value;

                  h._node = node;
                  h._worldCoordinates = node.convertPositionTo(h._localCoordinates, null);
                  h._worldNormal = node.convertPositionTo(h._localNormal, null);
                }
              } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion7 && _iterator7.return) {
                    _iterator7.return();
                  }
                } finally {
                  if (_didIteratorError7) {
                    throw _iteratorError7;
                  }
                }
              }

              result.push.apply(result, _toConsumableArray(hits));
            }
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return result;
    }

    /**
     * @access private
     * @param {SCNMatrix4} viewProjectionTransform -
     * @param {SCNVector3} from -
     * @param {SCNVector3} to -
     * @param {Map} options -
     * @returns {SCNHitTestResult[]} -
     */

  }, {
    key: '_hitTestByGPU',
    value: function _hitTestByGPU(viewProjectionTransform, from, to, options) {
      var result = [];
      var gl = this._context;

      if (this._hitFrameBuffer === null) {
        this._initializeHitFrameBuffer();
      }
      var prg = this._defaultHitTestProgram;
      var hitTestProgram = prg._glProgram;
      this._useProgram(prg
      //gl.useProgram(hitTestProgram)

      );gl.bindFramebuffer(gl.FRAMEBUFFER, this._hitFrameBuffer);

      gl.depthMask(true);
      gl.depthFunc(gl.LEQUAL);
      gl.enable(gl.SCISSOR_TEST);
      gl.disable(gl.BLEND);
      gl.clearColor(0, 0, 0, 0);
      gl.clearDepth(1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      var x = (from.x + 1.0) * 0.5 * this._viewRect.size.width;
      var y = (from.y + 1.0) * 0.5 * this._viewRect.size.height;
      var sx = x - 1;
      var sy = y - 1;
      if (sx < 0) {
        sx = 0;
      } else if (sx + 3 > this._viewRect.size.width) {
        sx = this._viewRect.size.width - 3;
      }
      if (sy < 0) {
        sy = 0;
      } else if (sy + 3 > this._viewRect.size.height) {
        sy = this._viewRect.size.width - 3;
      }

      gl.scissor(sx, sy, 3, 3);
      gl.uniformMatrix4fv(gl.getUniformLocation(hitTestProgram, 'viewProjectionTransform'), false, viewProjectionTransform.float32Array());
      var backFaceCulling = options.get(_SCNHitTestOption2.default.backFaceCulling);
      if (typeof backFaceCulling === 'undefined') {
        backFaceCulling = true;
      }
      if (backFaceCulling) {
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
      } else {
        gl.disable(gl.CULL_FACE);
      }

      var categoryBitMask = options.get(_SCNHitTestOption2.default.categoryBitMask);
      if (typeof categoryBitMask === 'undefined') {
        categoryBitMask = -1;
      }
      var ignoreHiddenNodes = options.get(_SCNHitTestOption2.default.ignoreHiddenNodes);
      if (typeof ignoreHiddenNodes === 'undefined') {
        ignoreHiddenNodes = true;
      }

      var renderingArray = this._createRenderingNodeArray();
      var len = renderingArray.length;
      for (var i = 0; i < len; i++) {
        var node = renderingArray[i];
        if ((node.categoryBitMask & categoryBitMask) === 0) {
          continue;
        }
        if (ignoreHiddenNodes && node.isHidden) {
          continue;
        }
        this._renderNodeForHitTest(node, i + 100, options);
      }

      var objectIDBuf = new Uint8Array(4);
      gl.readBuffer(gl.COLOR_ATTACHMENT0);
      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, objectIDBuf, 0);
      var objectID = objectIDBuf[0] * 256 + objectIDBuf[1];
      var geometryIndex = objectIDBuf[2] * 256 + objectIDBuf[3];

      var faceIDBuf = new Uint8Array(4);
      gl.readBuffer(gl.COLOR_ATTACHMENT1);
      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, faceIDBuf, 0);
      var faceIndex = faceIDBuf[0] * 16777216 + faceIDBuf[1] * 65536 + faceIDBuf[2] * 256 + faceIDBuf[3];

      var positionBuf = new Uint8Array(4);
      gl.readBuffer(gl.COLOR_ATTACHMENT2);
      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, positionBuf, 0
      //const screenPos = new SCNVector3(positionBuf[0] / 127.5 - 1.0, positionBuf[1] / 127.5 - 1.0, positionBuf[2] / 127.5 - 1.0)
      //const position = screenPos.transform(viewProjectionTransform.invert())
      );var p = ((positionBuf[3] / 255.0 + positionBuf[2]) / 255.0 + positionBuf[1] / 255.0 + positionBuf[0]) / 255.0;
      var position = from.lerp(to, p);

      var normalBuf = new Uint8Array(4);
      gl.readBuffer(gl.COLOR_ATTACHMENT3);
      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, normalBuf, 0);
      var normal = new _SCNVector2.default(normalBuf[0] / 127.5 - 1.0, normalBuf[1] / 127.5 - 1.0, normalBuf[2] / 127.5 - 1.0);

      //console.log('***** Hit Result *****')
      //console.log(`objectID: ${objectID}`)
      //console.log(`geometryIndex: ${geometryIndex}`)
      //console.log(`faceIndex: ${faceIndex}`)
      //console.log(`position: ${position.floatArray()}`)
      //console.log(`normal: ${normal.floatArray()}`)
      //console.log('**********************')

      if (objectID >= 100) {
        var r = new _SCNHitTestResult2.default();
        var _node = renderingArray[objectID - 100];
        var worldInv = _node.presentation._worldTransform.invert();
        r._node = _node;
        r._geometryIndex = geometryIndex;
        r._faceIndex = faceIndex;
        r._worldCoordinates = position;
        r._worldNormal = normal;
        r._modelTransform = _node.presentation._worldTransform;
        r._localCoordinates = position.transform(worldInv);
        r._localNormal = normal.transform(worldInv);

        result.push(r);
      }

      gl.disable(gl.SCISSOR_TEST);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);

      return result;
    }

    /**
     * @access private
     * @param {SCNVector3} from -
     * @param {SCNVector3} to -
     * @param {Map} options -
     * @param {Object} _options -
     * @returns {SCNHitTestResult[]} -
     */

  }, {
    key: '_physicsHitTestByGPU',
    value: function _physicsHitTestByGPU(from, to, options, _options) {
      var result = [];
      var gl = this._context;

      var viewProjectionTransform = this._createViewProjectionTransformForRay(from, to);
      var _from = from.transform(viewProjectionTransform);
      var _to = to.transform(viewProjectionTransform);

      if (this._hitFrameBuffer === null) {
        this._initializeHitFrameBuffer();
      }
      var prg = this._defaultHitTestProgram;
      var hitTestProgram = prg._glProgram;
      //gl.useProgram(hitTestProgram)
      this._useProgram(prg);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._hitFrameBuffer);

      gl.depthMask(true);
      gl.depthFunc(gl.LEQUAL);
      gl.enable(gl.SCISSOR_TEST);
      gl.disable(gl.BLEND);
      gl.clearColor(0, 0, 0, 0);
      gl.clearDepth(1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT

      // screen position
      );var x = (_from.x + 1.0) * 0.5 * this._viewRect.size.width;
      var y = (_from.y + 1.0) * 0.5 * this._viewRect.size.height;
      // left top of the scissor area
      var areaSize = 3;
      var sx = x - 1;
      var sy = y - 1;
      if (sx < 0) {
        sx = 0;
      } else if (sx + areaSize > this._viewRect.size.width) {
        sx = this._viewRect.size.width - areaSize;
      }
      if (sy < 0) {
        sy = 0;
      } else if (sy + areaSize > this._viewRect.size.height) {
        sy = this._viewRect.size.width - areaSize;
      }

      gl.scissor(sx, sy, areaSize, areaSize);
      gl.uniformMatrix4fv(gl.getUniformLocation(hitTestProgram, 'viewProjectionTransform'), false, viewProjectionTransform.float32Array());
      var backFaceCulling = options.get(_SCNPhysicsWorld2.default.TestOption.backfaceCulling);
      if (typeof backFaceCulling === 'undefined') {
        backFaceCulling = true;
      }
      if (backFaceCulling) {
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
      } else {
        gl.disable(gl.CULL_FACE);
      }

      var collisionBitMask = options.get(_SCNPhysicsWorld2.default.TestOption.collisionBitMask);
      if (typeof collisionBitMask === 'undefined') {
        collisionBitMask = -1;
      }

      var searchMode = options.get(_SCNPhysicsWorld2.default.TestOption.searchMode);
      if (typeof searchMode === 'undefined') {
        searchMode = _SCNPhysicsWorld2.default.TestSearchMode.closest;
      }

      var renderingArray = null;
      if (_options && _options.targets) {
        renderingArray = _options.targets;
        collisionBitMask = -1;
      } else {
        renderingArray = this._createRenderingPhysicsNodeArray();
      }

      var len = renderingArray.length;
      for (var i = 0; i < len; i++) {
        var node = renderingArray[i];
        var body = node.physicsBody;
        if ((body.categoryBitMask & collisionBitMask) === 0) {
          continue;
        }
        this._renderPhysicsNodeForHitTest(node, i + 100, options);
      }

      var objectIDBuf = new Uint8Array(4);
      gl.readBuffer(gl.COLOR_ATTACHMENT0);
      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, objectIDBuf, 0);
      var objectID = objectIDBuf[0] * 256 + objectIDBuf[1];
      var geometryIndex = objectIDBuf[2] * 256 + objectIDBuf[3];

      var faceIDBuf = new Uint8Array(4);
      gl.readBuffer(gl.COLOR_ATTACHMENT1);
      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, faceIDBuf, 0);
      var faceIndex = faceIDBuf[0] * 16777216 + faceIDBuf[1] * 65536 + faceIDBuf[2] * 256 + faceIDBuf[3];

      var positionBuf = new Uint8Array(4);
      gl.readBuffer(gl.COLOR_ATTACHMENT2);
      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, positionBuf, 0
      //const screenPos = new SCNVector3(positionBuf[0] / 127.5 - 1.0, positionBuf[1] / 127.5 - 1.0, positionBuf[2] / 127.5 - 1.0)
      //const position = screenPos.transform(viewProjectionTransform.invert())
      );var p = ((positionBuf[3] / 255.0 + positionBuf[2]) / 255.0 + positionBuf[1] / 255.0 + positionBuf[0]) / 255.0;
      var screenPos = _from.lerp(_to, p);
      var position = screenPos.transform(viewProjectionTransform.invert());

      var normalBuf = new Uint8Array(4);
      gl.readBuffer(gl.COLOR_ATTACHMENT3);
      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, normalBuf, 0);
      var normal = new _SCNVector2.default(normalBuf[0] / 127.5 - 1.0, normalBuf[1] / 127.5 - 1.0, normalBuf[2] / 127.5 - 1.0);

      //console.log('***** Hit Result *****')
      //console.log(`objectID: ${objectID}`)
      //console.log(`geometryIndex: ${geometryIndex}`)
      //console.log(`faceIndex: ${faceIndex}`)
      //console.log(`from: ${from.floatArray()}`)
      //console.log(`to: ${to.floatArray()}`)
      //console.log(`positionBuf: ${positionBuf[0]}, ${positionBuf[1]}, ${positionBuf[2]}`)
      //console.log(`sPos: ${screenPos.floatArray()}`)
      //console.log(`position: ${position.floatArray()}`)
      //console.log(`normal: ${normal.floatArray()}`)
      //console.log('**********************')

      if (objectID >= 100) {
        var r = new _SCNHitTestResult2.default();
        var _node2 = renderingArray[objectID - 100];
        var worldInv = _node2.presentation._worldTransform.invert();
        r._node = _node2;
        r._geometryIndex = geometryIndex;
        r._faceIndex = faceIndex;
        r._worldCoordinates = position;
        r._worldNormal = normal;
        r._modelTransform = _node2.presentation._worldTransform;
        r._localCoordinates = position.transform(worldInv);
        r._localNormal = normal.transform(worldInv);

        result.push(r);
      }

      gl.disable(gl.SCISSOR_TEST);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);

      return result;
    }

    /**
     *
     * @access private
     * @param {SCNVector3} from -
     * @param {SCNVector3} to -
     * @returns {SCNMatrix4} -
     */

  }, {
    key: '_createViewProjectionTransformForRay',
    value: function _createViewProjectionTransformForRay(from, to) {
      var vec = to.sub(from);
      var len = vec.length();
      var zNear = 1;
      var zFar = zNear + len;
      var proj = new _SCNMatrix2.default();
      proj.m11 = 1;
      proj.m22 = 1;
      proj.m33 = -(zFar + zNear) / len;
      proj.m34 = -1;
      proj.m43 = -2 * zFar * zNear / len;
      // TODO: use an orthographic projection
      //proj.m33 = -2 / len
      //proj.m43 = -(zFar + zNear) / len
      //proj.m44 = 1

      var view = new _SCNMatrix2.default();
      var up = new _SCNVector2.default(0, 1, 0);
      if (vec.x === 0 && vec.z === 0) {
        up.y = 0;
        up.z = 1;
      }
      var f = vec.normalize();
      var s = f.cross(up).normalize();
      var u = s.cross(f).normalize();
      view.m11 = s.x;
      view.m21 = s.y;
      view.m31 = s.z;
      view.m12 = u.x;
      view.m22 = u.y;
      view.m32 = u.z;
      view.m13 = -f.x;
      view.m23 = -f.y;
      view.m33 = -f.z;
      view.m44 = 1;
      var eye = from.sub(f.mul(zNear));
      var t = eye.transform(view);
      view.m41 = -t.x;
      view.m42 = -t.y;
      view.m43 = -t.z;

      return view.mult(proj);
    }

    /**
     * Required. Returns a Boolean value indicating whether a node might be visible from a specified point of view.
     * @access public
     * @param {SCNNode} node - The node whose visibility is to be tested.
     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
     * @returns {boolean} - 
     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.Note that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522647-isnode
     */

  }, {
    key: 'isNodeInsideFrustumOf',
    value: function isNodeInsideFrustumOf(node, pointOfView) {
      return false;
    }

    /**
     * Required. Returns all nodes that might be visible from a specified point of view.
     * @access public
     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
     * @returns {SCNNode[]} - 
     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node).Note that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522942-nodesinsidefrustum
     */

  }, {
    key: 'nodesInsideFrustumOf',
    value: function nodesInsideFrustumOf(pointOfView) {
      return null;
    }

    /**
     * Required. Projects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.
     * @access public
     * @param {SCNVector3} point - A point in the world coordinate system of the renderer’s scene.
     * @returns {SCNVector3} - 
     * @desc The z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524089-projectpoint
     */

  }, {
    key: 'projectPoint',
    value: function projectPoint(point) {
      return null;
    }

    /**
     * Required. Unprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.
     * @access public
     * @param {SCNVector3} point - A point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.
     * @returns {SCNVector3} - 
     * @desc The z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this line—for example, to find the geometry corresponding to the location of a click event in a view—use the hitTest(_:options:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522631-unprojectpoint
     */

  }, {
    key: 'unprojectPoint',
    value: function unprojectPoint(point) {
      return null;
    }

    // Customizing Scene Rendering with Metal
    /**
     * Required. The Metal render command encoder in use for the current SceneKit rendering pass.
     * @type {?MTLRenderCommandEncoder}
     * @desc Use this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.This property is valid only during the SceneKit rendering loop—that is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522609-currentrendercommandencoder
     */

  }, {
    key: '_setContext',
    value: function _setContext(context) {
      this._context = context;
      this._createDummyTexture();
    }

    // Working With Positional Audio

    /**
     * Required. The 3D audio mixing node SceneKit uses for positional audio effects.
     * @type {AVAudioEnvironmentNode}
     * @desc SceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523582-audioenvironmentnode
     */

  }, {
    key: '_getProgramForGeometry',


    /**
     * @access private
     * @param {SCNGeometry} geometry -
     * @returns {SCNProgram} -
     */
    value: function _getProgramForGeometry(geometry) {
      if (geometry.program !== null && geometry.program._programCompiled) {
        return geometry.program;
      }

      if (geometry.program || geometry.shaderModifiers !== null || geometry._shadableHelper !== null) {
        this._compileProgramForObject(geometry);
      }
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = geometry.materials[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var material = _step8.value;

          if (material.program || material.shaderModifiers !== null || material._shadableHelper !== null) {
            this._compileProgramForObject(material);
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      if (geometry.program) {
        return geometry.program;
      }
      return this._defaultProgram;
    }

    /**
     * @access private
     * @param {SCNShadable} obj -
     * @returns {void}
     */

  }, {
    key: '_compileProgramForObject',
    value: function _compileProgramForObject(obj) {
      var gl = this.context;
      var p = obj.program;
      if (!p) {
        p = new _SCNProgram2.default();
        obj.program = p;
      } else if (p._programCompiled) {
        return p;
      }
      p._parentObject = obj;

      var glProgram = p._getGLProgramForContext(gl);

      var vsText = this._vertexShaderForObject(obj);
      var fsText = this._fragmentShaderForObject(obj

      // initialize vertex shader
      );var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vsText);
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(vertexShader);
        throw new Error('vertex shader compile error: ' + info);
      }
      p._glVertexShader = vertexShader;

      // initialize fragment shader
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fsText);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        var _info = gl.getShaderInfoLog(fragmentShader);
        throw new Error('fragment shader compile error: ' + _info);
      }
      p._glFragmentShader = fragmentShader;

      gl.attachShader(glProgram, vertexShader);
      gl.attachShader(glProgram, fragmentShader

      // link program object
      );gl.linkProgram(glProgram);
      if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
        var _info2 = gl.getProgramInfoLog(glProgram);
        throw new Error('program link error: ' + _info2);
      }

      p._programCompiled = true;

      return p;
    }

    /**
     * @access private
     * @param {SCNProgram} program -
     * @returns {void}
     */

  }, {
    key: '_useProgram',
    value: function _useProgram(program) {
      if (this._currentProgram === program) {
        return;
      }
      var gl = this.context;
      var glProgram = program._getGLProgramForContext(gl);
      gl.useProgram(glProgram);
      program._setDummyTextureForContext(gl);
      this._currentProgram = program;
    }

    /**
     * @access private
     * @param {SCNProgram} program -
     * @returns {void}
     */

  }, {
    key: '_switchProgram',
    value: function _switchProgram(program) {
      if (this._currentProgram === program) {
        return;
      }

      var gl = this.context;
      var glProgram = program._getGLProgramForContext(gl);
      gl.useProgram(glProgram

      // set dummy textures
      );program._setDummyTextureForContext(gl

      // set shadow textures
      );var lights = this._lightNodes;
      for (var i = 0; i < lights.directionalShadow.length; i++) {
        var node = lights.directionalShadow[i];
        var symbol = 'TEXTURE' + (i + 8);
        gl.activeTexture(gl[symbol]);
        gl.bindTexture(gl.TEXTURE_2D, node.presentation.light._shadowDepthTexture);
      }

      // bind buffers
      var cameraIndex = gl.getUniformBlockIndex(glProgram, 'cameraUniform');
      gl.uniformBlockBinding(glProgram, cameraIndex, _cameraLoc);
      gl.bindBufferBase(gl.UNIFORM_BUFFER, _cameraLoc, this._cameraBuffer);
      var fogIndex = gl.getUniformBlockIndex(glProgram, 'fogUniform');
      gl.uniformBlockBinding(glProgram, fogIndex, _fogLoc);
      gl.bindBufferBase(gl.UNIFORM_BUFFER, _fogLoc, this._fogBuffer);
      var lightIndex = gl.getUniformBlockIndex(glProgram, 'lightUniform');
      gl.uniformBlockBinding(glProgram, lightIndex, _lightLoc);
      gl.bindBufferBase(gl.UNIFORM_BUFFER, _lightLoc, this._lightBuffer);
      var scnLightsIndex = gl.getUniformBlockIndex(glProgram, 'SCNLightsUniform');
      gl.uniformBlockBinding(glProgram, scnLightsIndex, _scnLightsLoc);
      gl.bindBufferBase(gl.UNIFORM_BUFFER, _scnLightsLoc, this._scnLightsBuffer

      // set uniform variables
      );var uniformTime = gl.getUniformLocation(glProgram, 'u_time');
      if (uniformTime) {
        // this._time might be too large.
        var time = this._time % 100000.0;
        gl.uniform1f(uniformTime, time);
      }

      var obj = program._parentObject;
      if (obj) {
        // bind custom uniforms
        var textureNo = 12; // TEXTURE0-11 is reserved for the default renderer (0-7: material, 8-11: shadow)
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = Object.keys(obj._valuesForUndefinedKeys)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var key = _step9.value;

            var loc = gl.getUniformLocation(glProgram, key);
            if (loc !== null) {
              var val = obj._valuesForUndefinedKeys[key];
              if (typeof val === 'number') {
                gl.uniform1f(loc, val);
              } else if ((0, _InstanceOf3.default)(val, _SCNMaterialProperty2.default)) {
                // TODO: refactoring: SCNGeometry has the same function
                if (val._contents instanceof Image) {
                  //val._contents = this._createTexture(gl, val._contents)
                  var image = val._contents;
                  var texture = gl.createTexture();
                  var canvas = document.createElement('canvas');
                  canvas.width = image.naturalWidth;
                  canvas.height = image.naturalHeight;
                  canvas.getContext('2d').drawImage(image, 0, 0);
                  gl.bindTexture(gl.TEXTURE_2D, texture
                  // texImage2D(target, level, internalformat, width, height, border, format, type, source)
                  // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
                  );gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
                  gl.generateMipmap(gl.TEXTURE_2D);
                  val._contents = texture;
                }
                if (val._contents instanceof WebGLTexture) {
                  gl.uniform1i(loc, textureNo);
                  gl.activeTexture(gl['TEXTURE' + textureNo]
                  // TODO: check texture type
                  );gl.bindTexture(gl.TEXTURE_2D, val._contents);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, val._magnificationFilterFor(gl));
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, val._minificationFilterFor(gl));
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, val._wrapSFor(gl));
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, val._wrapTFor(gl));
                }
                textureNo += 1;
              }
              // TODO: implement for other types
            }
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9.return) {
              _iterator9.return();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }
      }

      this._currentProgram = program;
    }

    /**
     * @access private
     * @type {SCNProgram}
     */

  }, {
    key: '_programForGeometry',


    /**
     * @access private
     * @param {SCNGeometry} geometry -
     * @returns {SCNProgram} -
     */
    value: function _programForGeometry(geometry) {}

    /**
     * @access private
     * @returns {string} -
     */

  }, {
    key: '_vertexShaderForObject',


    /**
     * @access private
     * @param {SCNShadable} obj -
     * @returns {string} -
     */
    value: function _vertexShaderForObject(obj) {
      var txt = obj.program.vertexShader;
      if (!txt) {
        txt = _defaultVertexShader;
      }

      return this._replaceTexts(txt, obj);
    }

    /**
     * @access private
     * @returns {string} -
     */

  }, {
    key: '_fragmentShaderForObject',


    /**
     * @access private
     * @param {SCNShadable} obj -
     * @returns {string} -
     */
    value: function _fragmentShaderForObject(obj) {
      var txt = obj.program.fragmentShader;
      if (!txt) {
        txt = _defaultFragmentShader;
      }

      return this._replaceTexts(txt, obj);
    }

    /**
     * @access private
     * @param {string} text -
     * @param {?SCNShadable} [shadable = null] -
     * @returns {string} -
     */

  }, {
    key: '_replaceTexts',
    value: function _replaceTexts(text) {
      var shadable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var vars = new Map();
      var numAmbient = this._numLights[_SCNLight2.default.LightType.ambient];
      var numDirectional = this._numLights[_SCNLight2.default.LightType.directional];
      var numDirectionalShadow = this._numLights.directionalShadow;
      var numOmni = this._numLights[_SCNLight2.default.LightType.omni];
      var numSpot = this._numLights[_SCNLight2.default.LightType.spot];
      var numIES = this._numLights[_SCNLight2.default.LightType.IES];
      var numProbe = this._numLights[_SCNLight2.default.LightType.probe];
      var shadableHelper = shadable ? shadable._shadableHelper : null;
      var customProperties = shadable ? shadable._valuesForUndefinedKeys : {};
      var shaderModifiers = shadable ? shadable.shaderModifiers : null;

      vars.set('__NUM_AMBIENT_LIGHTS__', numAmbient);
      vars.set('__NUM_DIRECTIONAL_LIGHTS__', numDirectional);
      vars.set('__NUM_DIRECTIONAL_SHADOW_LIGHTS__', numDirectionalShadow);
      vars.set('__NUM_OMNI_LIGHTS__', numOmni);
      vars.set('__NUM_SPOT_LIGHTS__', numSpot);
      vars.set('__NUM_IES_LIGHTS__', numIES);
      vars.set('__NUM_PROBE_LIGHTS__', numProbe);

      vars.set('__USE_SHADER_MODIFIER_GEOMETRY__', 0);
      vars.set('__SHADER_MODIFIER_GEOMETRY__', '');
      vars.set('__USE_SHADER_MODIFIER_SURFACE__', 0);
      vars.set('__SHADER_MODIFIER_SURFACE__', '');
      vars.set('__USE_SHADER_MODIFIER_FRAGMENT__', 0);
      vars.set('__SHADER_MODIFIER_FRAGMENT__', '');

      var customUniform = '';
      var customSurface = '';
      var customTexcoord = '';

      if (shaderModifiers) {
        var _iteratorNormalCompletion10 = true;
        var _didIteratorError10 = false;
        var _iteratorError10 = undefined;

        try {
          for (var _iterator10 = Object.keys(shaderModifiers)[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
            var key = _step10.value;

            var mod = shaderModifiers[key];
            var _texts = mod.split(/^\s*#pragma\s+body\s*$/m);
            if (_texts.length === 1) {
              // nothing to do
            } else if (_texts.length === 2) {
              customUniform += _texts[0].replace(/^\s*#pragma\s+.*$/mg, '');
            } else {
              throw new Error('found multiple "#pragma body" in the shaderModifier');
            }
          }
        } catch (err) {
          _didIteratorError10 = true;
          _iteratorError10 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion10 && _iterator10.return) {
              _iterator10.return();
            }
          } finally {
            if (_didIteratorError10) {
              throw _iteratorError10;
            }
          }
        }
      } else {
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = Object.keys(customProperties)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var _key = _step11.value;

            var val = customProperties[_key];
            if (typeof val === 'number') {
              customUniform += 'uniform float ' + _key + ';';
            } else if ((0, _InstanceOf3.default)(val, _SCNMaterialProperty2.default)) {
              customUniform += 'uniform sampler2D ' + _key + ';';
              customTexcoord += '_surface.' + _key + 'Texcoord = v_texcoord' + val.mappingChannel + ';';
              customSurface += 'vec2 ' + _key + 'Texcoord;';
            } else {
              // TODO: implement for other types
              throw new Error('custom property for ' + _key + ' is not implemented');
            }
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11.return) {
              _iterator11.return();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }
      }

      vars.set('__USER_CUSTOM_UNIFORM__', customUniform);
      vars.set('__USER_CUSTOM_SURFACE__', customSurface);
      vars.set('__USER_CUSTOM_TEXCOORD__', customTexcoord);

      var modifiers = null;
      if (shaderModifiers) {
        modifiers = shaderModifiers;
      } else if (shadableHelper) {
        modifiers = shadableHelper._shaderModifiers;
      }

      if (modifiers) {
        if (modifiers.SCNShaderModifierEntryPointGeometry) {
          var _text = this._processShaderText(modifiers.SCNShaderModifierEntryPointGeometry);
          vars.set('__USE_SHADER_MODIFIER_GEOMETRY__', 1);
          vars.set('__SHADER_MODIFIER_GEOMETRY__', _text);
        }
        if (modifiers.SCNShaderModifierEntryPointSurface) {
          var _text2 = this._processShaderText(modifiers.SCNShaderModifierEntryPointSurface);
          vars.set('__USE_SHADER_MODIFIER_SURFACE__', 1);
          vars.set('__SHADER_MODIFIER_SURFACE__', _text2);
        }
        if (modifiers.SCNShaderModifierEntryPointFragment) {
          var _text3 = this._processShaderText(modifiers.SCNShaderModifierEntryPointFragment);
          vars.set('__USE_SHADER_MODIFIER_FRAGMENT__', 1);
          vars.set('__SHADER_MODIFIER_FRAGMENT__', _text3);
        }
      }

      var vsLighting = '';
      var fsLighting = '';
      if (numDirectionalShadow > 0) {
        for (var i = 0; i < numDirectionalShadow; i++) {
          var fsDSText = _fsDirectionalShadow.replace(new RegExp('__I__', 'g'), i);
          fsLighting += fsDSText;
        }
      }
      vars.set('__FS_LIGHTING__', fsLighting);

      var result = text;
      vars.forEach(function (value, key) {
        var rex = new RegExp(key, 'g');
        result = result.replace(rex, value);
      });

      return result;
    }
  }, {
    key: '_processShaderText',
    value: function _processShaderText(text) {
      var _text = text;

      var _texts = text.split(/^\s*#pragma\s+body\s*$/m);
      if (_texts.length == 2) {
        _text = _texts[1].replace(/^\s*#pragma\s+.*$/mg, '');
      }

      _text = _text.replace(/texture2D/g, 'texture');
      _text = _text.replace(/float2/g, 'vec2');
      _text = _text.replace(/float3/g, 'vec3');
      _text = _text.replace(/float4/g, 'vec4');
      _text = _text.replace(/scn_frame\.time/g, 'u_time'
      //_text = _text.replace(/#pragma alpha/g, '')
      );_text = _text.replace(/half /g, 'float ' // FIXME: check semicolon before half

      );_text = _text.replace(/u_modelTransform/g, 'modelTransform' // TODO: use u_modelTransform
      );_text = _text.replace(/u_viewTransform/g, 'camera.viewTransform' // TODO: use u_viewTransform
      );_text = _text.replace(/u_viewProjectionTransform/g, 'caemra.viewProjectionTransform' // TODO: use u_viewTransform
      );_text = _text.replace(/\s*uniform[^;]*;/g, ''

      // workaround for Badger...
      );_text = _text.replace('uvs.x *= 2', 'uvs.x *= 2.0');
      _text = _text.replace('tn * 2 - 1', 'tn * 2.0 - vec3(1)');
      _text = _text.replace('tn2 * 2 - 1', 'tn2 * 2.0 - vec3(1)'

      // workaround for Fox2...
      );_text = _text.replace('pow(_surface.ambientOcclusion,3)', 'pow(_surface.ambientOcclusion,3.0)');
      _text = _text.replace('pow(AO,5)', 'pow(AO,5.0)');
      _text = _text.replace('pow(1.-fresnelBasis , 6)', 'pow(1.-fresnelBasis , 6.0)');
      _text = _text.replace('pow(1.-fresnelBasis , 4)', 'pow(1.-fresnelBasis , 4.0)');
      _text = _text.replace('vec3(1,0.4,0.0) * 1;', 'vec3(1,0.4,0.0);');
      _text = _text.replace('vec3(0.6,0.3,0.2) * 1;', 'vec3(0.6,0.3,0.2);');
      _text = _text.replace('vec4 WorldPos', 'vec3 WorldPos');
      _text = _text.replace('mult * 5;', 'mult * 5.0;');
      _text = _text.replace('mask * (1 - feather) + feather / 2', 'mask * (1.0 - feather) + feather / 2.0');
      _text = _text.replace('vec4 pos = modelTransform * _geometry.position;', 'vec4 pos = modelTransform * vec4(_geometry.position, 1);');
      _text = _text.replace('cos((u_time * 0.5 + pos.x) * 2)', 'cos((u_time * 0.5 + pos.x) * 2.0)');
      _text = _text.replace('(WorldPos.x * 10)', '(WorldPos.x * 10.0)');
      _text = _text.replace('(WorldPos.z + WorldPos.x) * 3)', '(WorldPos.z + WorldPos.x) * 3.0)');
      _text = _text.replace('pow(flowmap, 1.0/2.2)', 'pow(flowmap, vec2(1.0/2.2))');
      _text = _text.replace(/\(flowmap\/2\)/g, '(flowmap/2.0)');

      return _text;
    }
  }, {
    key: '_initializeVAO',
    value: function _initializeVAO(node, glProgram) {
      var gl = this.context;
      var geometry = node.presentation.geometry;
      var baseGeometry = node.geometry;

      // prepare vertex array data
      var vertexBuffer = geometry._createVertexBuffer(gl, node
      // TODO: retain attribute locations
      );var positionLoc = gl.getAttribLocation(glProgram, 'position');
      var normalLoc = gl.getAttribLocation(glProgram, 'normal');
      var tangentLoc = gl.getAttribLocation(glProgram, 'tangent');
      var colorLoc = gl.getAttribLocation(glProgram, 'color');
      var texcoord0Loc = gl.getAttribLocation(glProgram, 'texcoord0');
      var texcoord1Loc = gl.getAttribLocation(glProgram, 'texcoord1');
      var boneIndicesLoc = gl.getAttribLocation(glProgram, 'boneIndices');
      var boneWeightsLoc = gl.getAttribLocation(glProgram, 'boneWeights');

      geometry._vertexArrayObjects = [];
      var elementCount = node.presentation.geometry.geometryElements.length;
      for (var i = 0; i < elementCount; i++) {
        var element = node.presentation.geometry.geometryElements[i];
        var material = node.presentation.geometry.materials[i];
        var vao = gl.createVertexArray();
        gl.bindVertexArray(vao

        // initialize vertex buffer
        );gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

        gl.bindAttribLocation(glProgram, positionLoc, 'position');
        gl.bindAttribLocation(glProgram, normalLoc, 'normal');
        gl.bindAttribLocation(glProgram, tangentLoc, 'tangent');
        gl.bindAttribLocation(glProgram, colorLoc, 'color');
        gl.bindAttribLocation(glProgram, texcoord0Loc, 'texcoord0');
        gl.bindAttribLocation(glProgram, texcoord1Loc, 'texcoord1');
        gl.bindAttribLocation(glProgram, boneIndicesLoc, 'boneIndices');
        gl.bindAttribLocation(glProgram, boneWeightsLoc, 'boneWeights'

        // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)

        // position
        );var posSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
        if (posSrc) {
          gl.enableVertexAttribArray(positionLoc);
          gl.vertexAttribPointer(positionLoc, posSrc.componentsPerVector, gl.FLOAT, false, posSrc.dataStride, posSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(positionLoc);
        }

        // normal
        var nrmSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
        if (nrmSrc) {
          gl.enableVertexAttribArray(normalLoc);
          gl.vertexAttribPointer(normalLoc, nrmSrc.componentsPerVector, gl.FLOAT, false, nrmSrc.dataStride, nrmSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(normalLoc);
        }

        // tangent
        var tanSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.tangent)[0];
        if (tanSrc) {
          gl.enableVertexAttribArray(tangentLoc);
          gl.vertexAttribPointer(tangentLoc, tanSrc.componentsPerVector, gl.FLOAT, false, tanSrc.dataStride, tanSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(tangentLoc);
        }

        // color
        var colorSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.color)[0];
        if (colorSrc) {
          gl.enableVertexAttribArray(colorLoc);
          gl.vertexAttribPointer(colorLoc, colorSrc.componentsPerVector, gl.FLOAT, false, colorSrc.dataStride, colorSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(colorLoc);
        }

        // texcoord0
        var tex0Src = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];
        if (tex0Src) {
          //console.log(`texSrc: ${texcoordLoc}, ${texSrc.componentsPerVector}, ${texSrc.dataStride}, ${texSrc.dataOffset}`)
          gl.enableVertexAttribArray(texcoord0Loc);
          gl.vertexAttribPointer(texcoord0Loc, tex0Src.componentsPerVector, gl.FLOAT, false, tex0Src.dataStride, tex0Src.dataOffset);
        } else {
          gl.disableVertexAttribArray(texcoord0Loc);
        }

        // texcoord1
        var tex1Src = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[1];
        if (tex1Src) {
          gl.enableVertexAttribArray(texcoord1Loc);
          gl.vertexAttribPointer(texcoord1Loc, tex1Src.componentsPerVector, gl.FLOAT, false, tex1Src.dataStride, tex1Src.dataOffset);
        } else {
          gl.disableVertexAttribArray(texcoord1Loc);
        }

        // boneIndices
        var indSrc = node.skinner && node.skinner._useGPU ? node.skinner._boneIndices : null;
        if (indSrc) {
          //console.log(`indSrc: ${boneIndicesLoc}, ${indSrc.componentsPerVector}, ${indSrc.dataStride}, ${indSrc.dataOffset}`)
          gl.enableVertexAttribArray(boneIndicesLoc);
          gl.vertexAttribPointer(boneIndicesLoc, indSrc.componentsPerVector, gl.FLOAT, false, indSrc.dataStride, indSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(boneIndicesLoc);
        }

        // boneWeights
        var wgtSrc = node.skinner && node.skinner._useGPU ? node.skinner._boneWeights : null;
        if (wgtSrc) {
          //console.log(`wgtSrc: ${boneWeightsLoc}, ${wgtSrc.componentsPerVector}, ${wgtSrc.dataStride}, ${wgtSrc.dataOffset}`)
          gl.enableVertexAttribArray(boneWeightsLoc);
          gl.vertexAttribPointer(boneWeightsLoc, wgtSrc.componentsPerVector, gl.FLOAT, false, wgtSrc.dataStride, wgtSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(boneWeightsLoc);
        }

        // FIXME: use setting
        gl.disable(gl.CULL_FACE

        // initialize index buffer
        // FIXME: check geometrySource semantic
        );var indexBuffer = element._createBuffer(gl);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

        geometry._vertexArrayObjects.push(vao);
      }
    }
  }, {
    key: '_initializeShadowVAO',
    value: function _initializeShadowVAO(node, glProgram) {
      var gl = this.context;
      var geometry = node.presentation.geometry;
      var baseGeometry = node.geometry;

      // prepare vertex array data
      var vertexBuffer = geometry._createVertexBuffer(gl, node
      // TODO: retain attribute locations
      );var positionLoc = gl.getAttribLocation(glProgram, 'position');
      var boneIndicesLoc = gl.getAttribLocation(glProgram, 'boneIndices');
      var boneWeightsLoc = gl.getAttribLocation(glProgram, 'boneWeights');

      geometry._shadowVAO = [];
      var elementCount = node.presentation.geometry.geometryElements.length;
      for (var i = 0; i < elementCount; i++) {
        var element = node.presentation.geometry.geometryElements[i];
        var material = node.presentation.geometry.materials[i];
        var shadowVAO = gl.createVertexArray();
        gl.bindVertexArray(shadowVAO

        // initialize vertex buffer
        );gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

        gl.bindAttribLocation(glProgram, positionLoc, 'position');
        gl.bindAttribLocation(glProgram, boneIndicesLoc, 'boneIndices');
        gl.bindAttribLocation(glProgram, boneWeightsLoc, 'boneWeights'

        // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)

        // position
        );var posSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
        if (posSrc) {
          gl.enableVertexAttribArray(positionLoc);
          gl.vertexAttribPointer(positionLoc, posSrc.componentsPerVector, gl.FLOAT, false, posSrc.dataStride, posSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(positionLoc);
        }

        // boneIndices
        var indSrc = node.skinner && node.skinner._useGPU ? node.skinner._boneIndices : null;
        if (indSrc) {
          gl.enableVertexAttribArray(boneIndicesLoc);
          gl.vertexAttribPointer(boneIndicesLoc, indSrc.componentsPerVector, gl.FLOAT, false, indSrc.dataStride, indSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(boneIndicesLoc);
        }

        // boneWeights
        var wgtSrc = node.skinner && node.skinner._useGPU ? node.skinner._boneWeights : null;
        if (wgtSrc) {
          gl.enableVertexAttribArray(boneWeightsLoc);
          gl.vertexAttribPointer(boneWeightsLoc, wgtSrc.componentsPerVector, gl.FLOAT, false, wgtSrc.dataStride, wgtSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(boneWeightsLoc);
        }

        // FIXME: use setting
        gl.disable(gl.CULL_FACE

        // initialize index buffer
        // FIXME: check geometrySource semantic
        );var indexBuffer = element._createBuffer(gl);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

        geometry._shadowVAO.push(shadowVAO);
      }
    }
  }, {
    key: '_initializeHitTestVAO',
    value: function _initializeHitTestVAO(node, glProgram) {
      var physics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var gl = this.context;
      var geometry = physics ? node.physicsBody.physicsShape._sourceGeometry : node.presentation.geometry;
      var baseGeometry = physics ? geometry : node.geometry;

      // TODO: retain attribute locations
      var positionLoc = gl.getAttribLocation(glProgram, 'position');
      var normalLoc = gl.getAttribLocation(glProgram, 'normal');
      var boneIndicesLoc = gl.getAttribLocation(glProgram, 'boneIndices');
      var boneWeightsLoc = gl.getAttribLocation(glProgram, 'boneWeights');

      geometry._hitTestVAO = [];
      var elementCount = geometry.geometryElements.length;
      for (var i = 0; i < elementCount; i++) {
        var element = geometry.geometryElements[i];
        var vao = gl.createVertexArray();
        gl.bindVertexArray(vao);

        gl.bindBuffer(gl.ARRAY_BUFFER, geometry._vertexBuffer);

        gl.bindAttribLocation(glProgram, positionLoc, 'position');
        gl.bindAttribLocation(glProgram, normalLoc, 'normal');
        gl.bindAttribLocation(glProgram, boneIndicesLoc, 'boneIndices');
        gl.bindAttribLocation(glProgram, boneWeightsLoc, 'boneWeights'

        // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)

        // position
        );var posSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
        if (posSrc) {
          gl.enableVertexAttribArray(positionLoc);
          gl.vertexAttribPointer(positionLoc, posSrc.componentsPerVector, gl.FLOAT, false, posSrc.dataStride, posSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(positionLoc);
        }

        // normal
        var nrmSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
        if (nrmSrc) {
          gl.enableVertexAttribArray(normalLoc);
          gl.vertexAttribPointer(normalLoc, nrmSrc.componentsPerVector, gl.FLOAT, false, nrmSrc.dataStride, nrmSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(normalLoc);
        }

        // boneIndices
        var indSrc = node.skinner ? node.skinner._boneIndices : null;
        if (indSrc) {
          gl.enableVertexAttribArray(boneIndicesLoc);
          gl.vertexAttribPointer(boneIndicesLoc, indSrc.componentsPerVector, gl.FLOAT, false, indSrc.dataStride, indSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(boneIndicesLoc);
        }

        // boneWeights
        var wgtSrc = node.skinner ? node.skinner._boneWeights : null;
        if (wgtSrc) {
          gl.enableVertexAttribArray(boneWeightsLoc);
          gl.vertexAttribPointer(boneWeightsLoc, wgtSrc.componentsPerVector, gl.FLOAT, false, wgtSrc.dataStride, wgtSrc.dataOffset);
        } else {
          gl.disableVertexAttribArray(boneWeightsLoc);
        }

        // initialize index buffer
        // FIXME: check geometrySource semantic
        var indexBuffer = element._createBuffer(gl);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, element._buffer);

        geometry._hitTestVAO.push(vao);
      }
    }
  }, {
    key: '_initializeCameraBuffer',
    value: function _initializeCameraBuffer(glProgram) {
      var gl = this.context;

      var cameraIndex = gl.getUniformBlockIndex(glProgram, 'cameraUniform');

      this._cameraBuffer = gl.createBuffer();
      gl.uniformBlockBinding(glProgram, cameraIndex, _cameraLoc);
      gl.bindBufferBase(gl.UNIFORM_BUFFER, _cameraLoc, this._cameraBuffer);
    }
  }, {
    key: '_initializeFogBuffer',
    value: function _initializeFogBuffer(glProgram) {
      var gl = this.context;

      var fogIndex = gl.getUniformBlockIndex(glProgram, 'fogUniform');

      this._fogBuffer = gl.createBuffer();
      gl.uniformBlockBinding(glProgram, fogIndex, _fogLoc);
      gl.bindBufferBase(gl.UNIFORM_BUFFER, _fogLoc, this._fogBuffer);
    }
  }, {
    key: '_initializeLightBuffer',
    value: function _initializeLightBuffer(glProgram) {
      var gl = this.context;

      // TODO: replace lightUniform to SCNLightsUniform
      var lightIndex = gl.getUniformBlockIndex(glProgram, 'lightUniform');
      this._lightBuffer = gl.createBuffer();
      gl.uniformBlockBinding(glProgram, lightIndex, _lightLoc);
      gl.bindBufferBase(gl.UNIFORM_BUFFER, _lightLoc, this._lightBuffer);

      var scnLightsIndex = gl.getUniformBlockIndex(glProgram, 'SCNLightsUniform');
      this._scnLightsBuffer = gl.createBuffer();
      gl.uniformBlockBinding(glProgram, scnLightsIndex, _scnLightsLoc);
      gl.bindBufferBase(gl.UNIFORM_BUFFER, _scnLightsLoc, this._scnLightsBuffer);

      for (var i = 0; i < this._lightNodes.directionalShadow.length; i++) {
        var node = this._lightNodes.directionalShadow[i];
        var symbol = 'TEXTURE' + (i + 8);
        var name = 'u_shadowTexture' + i;

        gl.uniform1i(gl.getUniformLocation(glProgram, name), i + 8);
        gl.activeTexture(gl[symbol]);
        gl.bindTexture(gl.TEXTURE_2D, node.presentation.light._shadowDepthTexture);
      }
    }
  }, {
    key: '_initializeUBO',
    value: function _initializeUBO(node, glProgram) {
      var gl = this.context;
      var geometry = node.presentation.geometry;

      var materialIndex = gl.getUniformBlockIndex(glProgram, 'materialUniform');
      geometry._materialBuffer = gl.createBuffer();
      gl.uniformBlockBinding(glProgram, materialIndex, _materialLoc);
      gl.bindBufferBase(gl.UNIFORM_BUFFER, _materialLoc, geometry._materialBuffer);
    }
  }, {
    key: '_updateVAO',
    value: function _updateVAO(node) {
      var gl = this.context;
      var geometry = node.presentation.geometry;
      var baseGeometry = node.geometry;

      geometry._updateVertexBuffer(gl, baseGeometry);
    }
  }, {
    key: '_createDummyTexture',
    value: function _createDummyTexture() {
      var gl = this.context;

      var canvas = document.createElement('canvas');
      canvas.width = 1;
      canvas.height = 1;
      var context = canvas.getContext('2d');
      context.fillStyle = 'rgba(255, 255, 255, 1.0)';
      context.fillRect(0, 0, 1, 1);

      this.__dummyTexture = gl.createTexture();

      gl.bindTexture(gl.TEXTURE_2D, this.__dummyTexture
      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
      // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
      );gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }

    /**
     * @access private
     * @param {SCNProgram} program -
     * @returns {void}
     */
    //_setDummyTextureAsDefault(program) {
    //  const gl = this.context
    //  const p = program

    //  const texNames = [
    //    gl.TEXTURE0,
    //    gl.TEXTURE1,
    //    gl.TEXTURE2,
    //    gl.TEXTURE3,
    //    gl.TEXTURE4,
    //    gl.TEXTURE5,
    //    gl.TEXTURE6,
    //    gl.TEXTURE7
    //  ]
    //  const texSymbols = [
    //    'u_emissionTexture',
    //    'u_ambientTexture',
    //    'u_diffuseTexture',
    //    'u_specularTexture',
    //    'u_reflectiveTexture',
    //    'u_transparentTexture',
    //    'u_multiplyTexture',
    //    'u_normalTexture'
    //  ]
    //  for(let i=0; i<texNames.length; i++){
    //    const texName = texNames[i]
    //    const symbol = texSymbols[i]
    //    gl.uniform1i(gl.getUniformLocation(p._glProgram, symbol), i)
    //    gl.activeTexture(texName)
    //    gl.bindTexture(gl.TEXTURE_2D, this.__dummyTexture)
    //  }
    //}

  }, {
    key: '_switchToDefaultCamera',
    value: function _switchToDefaultCamera() {
      if (this._pointOfView === null) {
        this._defaultCameraPosNode.position = new _SCNVector2.default(0, 0, 0);
        this._defaultCameraRotNode.rotation = new _SCNVector4.default(0, 0, 0, 0);
        this._defaultCameraNode.position = new _SCNVector2.default(0, 0, _defaultCameraDistance);
      } else if (this._pointOfView !== this._defaultCameraNode) {
        var rot = this.pointOfView.presentation._worldRotation;
        var rotMat = _SCNMatrix2.default.matrixWithRotation(rot);
        var pos = this.pointOfView.presentation._worldTranslation;

        this._defaultCameraPosNode.position = new _SCNVector2.default(0, 0, -_defaultCameraDistance).rotate(rotMat).add(pos);
        this._defaultCameraRotNode.rotation = rot;
        this._defaultCameraNode.position = new _SCNVector2.default(0, 0, _defaultCameraDistance);
        //console.log(`pov defined: pov.pos: ${this._pointOfView._worldTranslation.float32Array()}`)
        //console.log(`pov defined: node.pos: ${this._defaultCameraNode._worldTranslation.float32Array()}`)
      }
      this._pointOfView = this._defaultCameraNode;
    }
  }, {
    key: '_setDefaultCameraOrientation',
    value: function _setDefaultCameraOrientation(orientation) {
      this._defaultCameraRotNode.orientation = orientation;
    }
  }, {
    key: '_searchCameraNode',
    value: function _searchCameraNode() {
      var nodes = [this.scene._rootNode];
      var node = nodes.shift();
      while (node) {
        if (node.camera !== null) {
          return node;
        }
        nodes.push.apply(nodes, _toConsumableArray(node._childNodes));
        node = nodes.shift();
      }
      return null;
    }

    /**
     * @access private
     * @returns {SCNVector3} -
     */

  }, {
    key: '_getCameraPosition',
    value: function _getCameraPosition() {
      if (this._pointOfView === this._defaultCameraNode) {
        return this._defaultCameraPosNode.position;
      } else if (this._pointOfView === null) {
        return new _SCNVector2.default(0, 0, 0);
      }
      var rot = this._getCameraOrientation();
      var rotMat = _SCNMatrix2.default.matrixWithRotation(rot);
      var pos = this._pointOfView.presentation._worldTranslation;
      return pos.add(new _SCNVector2.default(0, 0, -_defaultCameraDistance).rotate(rotMat));
    }

    /**
     * @access private
     * @returns {SCNVector4} -
     */

  }, {
    key: '_getCameraOrientation',
    value: function _getCameraOrientation() {
      if (this._pointOfView === this._defaultCameraNode) {
        return this._defaultCameraRotNode.presentation.orientation;
      } else if (this._pointOfView === null) {
        return new _SCNVector4.default(0, 0, 0, 0);
      }
      return this._pointOfView.presentation._worldOrientation;
    }

    /**
     * @access private
     * @returns {number} -
     */

  }, {
    key: '_getCameraDistance',
    value: function _getCameraDistance() {
      if (this._pointOfView === this._defaultCameraNode) {
        return this._defaultCameraNode.presentation.position.z;
      }
      return _defaultCameraDistance;
    }

    /**
     * @access private
     * @returns {boolean} - true if the number of lights is changed.
     */

  }, {
    key: '_numLightsChanged',
    value: function _numLightsChanged() {
      var changed = false;
      var types = [].concat(_toConsumableArray(Object.values(_SCNLight2.default.LightType)), ['directionalShadow']);
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = types[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var type = _step12.value;

          var num = this._lightNodes[type].length;
          if (num !== this._numLights[type]) {
            changed = true;
            this._numLights[type] = num;
          }
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }

      return changed;
    }

    /**
     * @access private
     * @param {SCNNode} node -
     * @param {SCNVector3} rayPoint - 
     * @param {SCNVector3} rayVec -
     * @returns {SCNHitTestResult[]} -
     */

  }, {
    key: '_nodeHitTestByCPU',
    value: function _nodeHitTestByCPU(node, rayPoint, rayVec) {
      var result = [];
      var geometry = node.presentation.geometry;
      var geometryCount = geometry.geometryElements.length;
      if (geometryCount === 0) {
        // nothing to draw...
        return result;
      }
      var invRay = rayVec.mul(-1

      //console.log(`rayPoint: ${rayPoint.float32Array()}`)
      //console.log(`rayVec: ${rayVec.float32Array()}`)

      //if(node.morpher !== null){
      //  this._updateVAO(node)
      //}

      // TODO: test the bounding box/sphere first for performance

      );var source = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
      var sourceLen = source.vectorCount;
      var sourceData = [];
      var modelTransform = node.presentation._worldTransform;
      var skinningJoints = [];
      if (node.presentation.skinner) {
        var skinner = node.presentation.skinner;
        var numBones = skinner._bones.length;
        for (var i = 0; i < numBones; i++) {
          var bone = skinner._bones[i];
          var mat = skinner._boneInverseBindTransforms[i].mult(bone._presentation._worldTransform);
          skinningJoints.push(mat);
        }
        for (var _i = 0; _i < sourceLen; _i++) {
          var weights = skinner._boneWeights._vectorAt(_i);
          var indices = skinner._boneIndices._vectorAt(_i);
          var _mat = new _SCNMatrix2.default();
          for (var j = 0; j < skinner.numSkinningJoints; j++) {
            _mat.add(skinningJoints[indices[j]].mul(weights[j]));
          }
          sourceData.push(source._scnVectorAt(_i).transform(_mat));
        }
      } else {
        for (var _i2 = 0; _i2 < sourceLen; _i2++) {
          sourceData.push(source._scnVectorAt(_i2).transform(modelTransform));
        }
      }

      for (var _i3 = 0; _i3 < geometryCount; _i3++) {
        //console.log(`geometry element ${i}`)
        var element = geometry.geometryElements[_i3];
        switch (element.primitiveType) {
          case _SCNGeometryPrimitiveType2.default.line:
            console.warn('hitTest for line is not implemented');
            continue;
          case _SCNGeometryPrimitiveType2.default.point:
            console.warn('hitTest for point is not implemented');
            continue;
        }

        var elementData = element._glData;
        var len = element.primitiveCount;
        //console.log(`primitiveCount: ${len}`)
        // TODO: check cull settings
        for (var pi = 0; pi < len; pi++) {
          var _indices = element._indexAt(pi);

          var v0 = sourceData[_indices[0]];
          var v1 = sourceData[_indices[1]];
          var v2 = sourceData[_indices[2]];

          var e1 = v1.sub(v0);
          var e2 = v2.sub(v0);

          var denom = this._det(e1, e2, invRay);
          if (denom <= 0) {
            continue;
          }
          denom = 1.0 / denom;

          var d = rayPoint.sub(v0);
          var u = this._det(d, e2, invRay) * denom;
          if (u < 0 || u > 1) {
            continue;
          }

          var v = this._det(e1, d, invRay) * denom;
          if (v < 0 || v > 1) {
            continue;
          }

          var t = this._det(e1, e2, d) * denom;
          if (t < 0) {
            continue;
          }

          // Hit!
          //console.log(`Hit! ${i}: ${pi}`)
          var hitPoint = rayPoint.add(rayVec.mul(t));
          var invModel = modelTransform.invert();

          var res = new _SCNHitTestResult2.default();
          res._node = node;
          res._geometryIndex = _i3;
          res._faceIndex = pi;
          res._worldCoordinates = hitPoint;
          res._localCoordinates = hitPoint.transform(invModel);
          var nom = e1.cross(e2);
          res._worldNormal = nom.normalize();
          res._localNormal = nom.transform(invModel);
          res._modelTransform = modelTransform;
          res._boneNode = null; // it should be array... what should I put here?
          result.push(res);
        }
      }

      return result;
    }

    /**
     * @access private
     * @type {SCNProgram}
     */

  }, {
    key: '_setDummyParticleTextureAsDefault',
    value: function _setDummyParticleTextureAsDefault() {
      var gl = this.context;
      var p = this._defaultParticleProgram;
      var glProgram = p._getGLProgramForContext(gl);

      var texNames = [gl.TEXTURE0
      //gl.TEXTURE1
      ];
      var texSymbols = ['particleTexture'
      //'colorTexture'
      ];
      for (var i = 0; i < texNames.length; i++) {
        var texName = texNames[i];
        var symbol = texSymbols[i];
        gl.uniform1i(gl.getUniformLocation(glProgram, symbol), i);
        gl.activeTexture(texName);
        gl.bindTexture(gl.TEXTURE_2D, this.__dummyTexture);
      }
    }

    /**
     * @access private
     * @type {SCNProgram}
     */

  }, {
    key: '_showShadowMapOfLight',


    // for debug
    value: function _showShadowMapOfLight(lightNode) {
      var gl = this.context;
      var p = lightNode.presentation;
      var light = p.light;
      if (!this.__debugShadowMapSprite) {
        var node = new _SKSpriteNode2.default();
        node.size = new _CGSize2.default(100, 100);
        node.anchorPoint = new _CGPoint2.default(0.0, 0.0);
        var texture = new _SKTexture2.default();
        texture._glTexture = light._shadowDepthTexture;
        texture._image = {
          naturalWidth: 100,
          naturalHeight: 100
        };
        node._texture = texture;
        node.__presentation = node.copy();
        node.__presentation._isPresentationInstance = true;
        node.position = new _CGPoint2.default(100, 100);
        node._updateWorldTransform();

        this.__debugShadowMapSprite = node;
      }
      gl.clearDepth(-1);
      gl.clearStencil(0);
      gl.depthMask(true);
      gl.enable(gl.DEPTH_TEST);
      gl.disable(gl.CULL_FACE);
      gl.depthFunc(gl.GEQUAL);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

      this._renderSKNode(this.__debugShadowMapSprite);
    }
  }, {
    key: '_setViewPort',
    value: function _setViewPort() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var w = width;
      var h = height;
      if (w === null || h === null) {
        w = this._viewRect.size.width;
        h = this._viewRect.size.height;
      }
      this.context.viewport(0, 0, w, h);
    }

    /**
     * calculate a determinant of 3x3 matrix from 3 vectors.
     * @access private
     * @param {SCNVector3} v1 -
     * @param {SCNVector3} v2 -
     * @param {SCNVector3} v3 -
     * @returns {number} -
     */

  }, {
    key: '_det',
    value: function _det(v1, v2, v3) {
      return v1.x * v2.y * v3.z + v1.y * v2.z * v3.x + v1.z * v2.x * v3.y - v1.x * v2.z * v3.y - v1.y * v2.x * v3.z - v1.z * v2.y * v3.x;
    }
  }, {
    key: 'nextFrameTime',
    get: function get() {
      return this._nextFrameTime;
    }
  }, {
    key: 'pointOfView',
    get: function get() {
      return this._getCameraNode();
    }

    /**
     * Required. The node from which the scene’s contents are viewed for rendering.
     * @type {?SCNNode}
     * @param {?SCNNode} newValue -
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523982-pointofview
     */
    ,
    set: function set(newValue) {
      this._pointOfView = newValue;
    }

    /**
     * Required. The graphics technology SceneKit uses to render the scene.
     * @type {SCNRenderingAPI}
     * @desc You choose a graphics technology when initializing a scene renderer:When initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.To create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.The rendering technology used by a SCNLayer object is determined by Core Animation.After initializing a renderer, this property reflects the rendering technology in use.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522616-renderingapi
     */

  }, {
    key: 'renderingAPI',
    get: function get() {
      return this._renderingAPI;
    }
  }, {
    key: 'currentRenderCommandEncoder',
    get: function get() {
      return this._currentRenderCommandEncoder;
    }

    /**
     * Required. The Metal device this renderer uses for rendering.
     * @type {?MTLDevice}
     * @desc Use this property to create or look up other Metal resources that use the same device as your SceneKit renderer.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523935-device
     */

  }, {
    key: 'device',
    get: function get() {
      return this._device;
    }

    /**
     * Required. The Metal command queue this renderer uses for rendering.
     * @type {?MTLCommandQueue}
     * @desc Use this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523974-commandqueue
     */

  }, {
    key: 'commandQueue',
    get: function get() {
      return this._commandQueue;
    }

    /**
     * Required. The Metal pixel format for the renderer’s color output.
     * @type {MTLPixelFormat}
     * @desc Use this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523701-colorpixelformat
     */

  }, {
    key: 'colorPixelFormat',
    get: function get() {
      return this._colorPixelFormat;
    }

    /**
     * Required. The Metal pixel format for the renderer’s depth buffer.
     * @type {MTLPixelFormat}
     * @desc Use this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523780-depthpixelformat
     */

  }, {
    key: 'depthPixelFormat',
    get: function get() {
      return this._depthPixelFormat;
    }

    /**
     * Required. The Metal pixel format for the renderer’s stencil buffer.
     * @type {MTLPixelFormat}
     * @desc Use this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523315-stencilpixelformat
     */

  }, {
    key: 'stencilPixelFormat',
    get: function get() {
      return this._stencilPixelFormat;
    }

    // Customizing Scene Rendering with OpenGL

    /**
     * Required. The OpenGL rendering context that SceneKit uses for rendering the scene.
     * @type {?Object}
     * @desc In macOS, the value of this property is a Core OpenGL cglContextObj object.In iOS, the value of this property is an EAGLContext object.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522840-context
     */

  }, {
    key: 'context',
    get: function get() {
      return this._context;
    }
  }, {
    key: 'audioEnvironmentNode',
    get: function get() {
      return this._audioEnvironmentNode;
    }

    /**
     * Required. The audio engine SceneKit uses for playing scene sounds.
     * @type {AVAudioEngine}
     * @desc SceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522686-audioengine
     */

  }, {
    key: 'audioEngine',
    get: function get() {
      return this._audioEngine;
    }
  }, {
    key: '_defaultProgram',
    get: function get() {
      var numLightsChanged = this._numLightsChanged();
      if (this.__defaultProgram !== null && !numLightsChanged) {
        return this.__defaultProgram;
      }

      var gl = this.context;
      if (this.__defaultProgram === null) {
        this.__defaultProgram = new _SCNProgram2.default();
      }
      var p = this.__defaultProgram;
      var glProgram = p._getGLProgramForContext(gl);
      var vsText = this._defaultVertexShader;
      var fsText = this._defaultFragmentShader;

      // initialize vertex shader
      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vsText);
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(vertexShader);
        throw new Error('vertex shader compile error: ' + info);
      }
      this.__defaultProgram._glVertexShader = vertexShader;

      // initialize fragment shader
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fsText);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        var _info3 = gl.getShaderInfoLog(fragmentShader);
        throw new Error('fragment shader compile error: ' + _info3);
      }
      this.__defaultProgram._glFragmentShader = fragmentShader;

      gl.attachShader(glProgram, vertexShader);
      gl.attachShader(glProgram, fragmentShader

      // link program object
      );gl.linkProgram(glProgram);
      if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
        var _info4 = gl.getProgramInfoLog(glProgram);
        throw new Error('program link error: ' + _info4);
      }

      this._switchProgram(p);

      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK

      // set default textures to prevent warnings
      //this._setDummyTextureAsDefault(p)

      );return this.__defaultProgram;
    }
  }, {
    key: '_defaultVertexShader',
    get: function get() {
      return this._replaceTexts(_defaultVertexShader);
    }
  }, {
    key: '_defaultFragmentShader',
    get: function get() {
      return this._replaceTexts(_defaultFragmentShader);
    }
  }, {
    key: '_dummyTexture',
    get: function get() {
      return this.__dummyTexture;
    }
  }, {
    key: '_defaultParticleProgram',
    get: function get() {
      if (this.__defaultParticleProgram !== null) {
        return this.__defaultParticleProgram;
      }
      var gl = this.context;
      if (this.__defaultParticleProgram === null) {
        this.__defaultParticleProgram = new _SCNProgram2.default();
      }
      var p = this.__defaultParticleProgram;
      var glProgram = p._getGLProgramForContext(gl);
      var vsText = _defaultParticleVertexShader;
      var fsText = _defaultParticleFragmentShader;

      // initialize vertex shader
      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vsText);
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(vertexShader);
        throw new Error('particle vertex shader compile error: ' + info);
      }

      // initialize fragment shader
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fsText);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        var _info5 = gl.getShaderInfoLog(fragmentShader);
        throw new Error('particle fragment shader compile error: ' + _info5);
      }

      gl.attachShader(glProgram, vertexShader);
      gl.attachShader(glProgram, fragmentShader

      // link program object
      );gl.linkProgram(glProgram);
      if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
        var _info6 = gl.getProgramInfoLog(glProgram);
        throw new Error('program link error: ' + _info6);
      }

      //gl.useProgram(glProgram)
      this._useProgram(p
      //gl.clearColor(1, 1, 1, 1)
      //gl.clearDepth(1.0)
      //gl.clearStencil(0)

      );gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK

      // set default textures to prevent warnings
      );this._setDummyParticleTextureAsDefault();

      return this.__defaultParticleProgram;
    }

    /**
     * @access private
     * @type {SCNProgram}
     */

  }, {
    key: '_defaultShadowProgram',
    get: function get() {
      if (this.__defaultShadowProgram !== null) {
        return this.__defaultShadowProgram;
      }
      var gl = this.context;
      if (this.__defaultShadowProgram === null) {
        this.__defaultShadowProgram = new _SCNProgram2.default();
      }
      var p = this.__defaultShadowProgram;
      var glProgram = p._getGLProgramForContext(gl);
      var vsText = _defaultShadowVertexShader;
      var fsText = _defaultShadowFragmentShader;

      // initialize vertex shader
      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vsText);
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(vertexShader);
        throw new Error('particle vertex shader compile error: ' + info);
      }

      // initialize fragment shader
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fsText);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        var _info7 = gl.getShaderInfoLog(fragmentShader);
        throw new Error('particle fragment shader compile error: ' + _info7);
      }

      gl.attachShader(glProgram, vertexShader);
      gl.attachShader(glProgram, fragmentShader

      // link program object
      );gl.linkProgram(glProgram);
      if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
        var _info8 = gl.getProgramInfoLog(glProgram);
        throw new Error('program link error: ' + _info8);
      }

      //gl.useProgram(glProgram)
      this._useProgram(p
      //gl.clearColor(1, 1, 1, 1)
      //gl.clearDepth(1.0)
      //gl.clearStencil(0)

      );gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL
      //gl.enable(gl.BLEND)
      );gl.disable(gl.BLEND
      //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
      );gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK);

      return this.__defaultShadowProgram;
    }
  }, {
    key: '_defaultHitTestProgram',
    get: function get() {
      if (this.__defaultHitTestProgram !== null) {
        return this.__defaultHitTestProgram;
      }
      var gl = this.context;
      if (this.__defaultHitTestProgram === null) {
        this.__defaultHitTestProgram = new _SCNProgram2.default();
      }
      var p = this.__defaultHitTestProgram;
      var glProgram = p._getGLProgramForContext(gl);
      var vsText = _defaultHitTestVertexShader;
      var fsText = _defaultHitTestFragmentShader;

      // initialize vertex shader
      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vsText);
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(vertexShader);
        throw new Error('hitTest vertex shader compile error: ' + info);
      }

      // initialize fragment shader
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fsText);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        var _info9 = gl.getShaderInfoLog(fragmentShader);
        throw new Error('hitTest fragment shader compile error: ' + _info9);
      }

      gl.attachShader(glProgram, vertexShader);
      gl.attachShader(glProgram, fragmentShader

      // link program object
      );gl.linkProgram(glProgram);
      if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
        var _info10 = gl.getProgramInfoLog(glProgram);
        throw new Error('program link error: ' + _info10);
      }

      //gl.useProgram(glProgram)
      this._useProgram(p
      //gl.clearColor(1, 1, 1, 1)
      //gl.clearDepth(1.0)
      //gl.clearStencil(0)

      );gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK

      //this._setDummyHitTestTextureAsDefault()

      );return this.__defaultHitTestProgram;
    }
  }]);

  return SCNRenderer;
}(_NSObject3.default);

exports.default = SCNRenderer;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _CGRect = __webpack_require__(16);

var _CGRect2 = _interopRequireDefault(_CGRect);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

var _SKBlendMode = __webpack_require__(28);

var _SKBlendMode2 = _interopRequireDefault(_SKBlendMode);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _SKNode2 = __webpack_require__(19);

var _SKNode3 = _interopRequireDefault(_SKNode2);

var _SKTexture = __webpack_require__(55);

var _SKTexture2 = _interopRequireDefault(_SKTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SKWarpable from './SKWarpable'
//import SKShader from './SKShader'
//import SKAttributeValue from './SKAttributeValue'
//import NSCoder from '../undefined/NSCoder'

/**
 * @access private
 * @type {string}
 */
var _defaultVertexShader = '#version 300 es\n  precision mediump float;\n\n  in vec3 position;\n  in vec2 texcoord;\n\n  uniform float screenWidth;\n  uniform float screenHeight;\n\n  //out vec3 v_position;\n  out vec2 v_texcoord;\n\n  void main() {\n    vec3 pos = position;\n    pos.x = (pos.x * 2.0 / screenWidth) - 1.0;\n    pos.y = (pos.y * 2.0 / screenHeight) - 1.0;\n    v_texcoord = texcoord;\n    gl_Position = vec4(pos, 1.0);\n  }\n';

/**
 * @access private
 * @type {string}
 */
var _defaultFragmentShader = '#version 300 es\n  precision mediump float;\n\n  uniform sampler2D spriteTexture;\n  uniform float alpha;\n  in vec2 v_texcoord;\n\n  out vec4 outColor;\n\n  void main() {\n    outColor = texture(spriteTexture, v_texcoord);\n    outColor.a *= alpha;\n  }\n';

/**
 * A node that draws a rectangular texture, image or color. 
 * @access public
 * @extends {SKNode}
 * @implements {SKWarpable}
 * @see https://developer.apple.com/documentation/spritekit/skspritenode
 */

var SKSpriteNode = function (_SKNode) {
  _inherits(SKSpriteNode, _SKNode);

  // Initializing a New Sprite

  /**
   * Initializes a textured sprite using an image file, optionally adding a normal map to simulate 3D lighting.
   * @access public
   * @constructor
   * @param {string} name - The name of an image file stored in the app bundle.
   * @param {boolean} generateNormalMap - If true, a normal map is generated from the image texture without applying any filter to it (SKTextureNormalMapFilteringTypeNone). If false, no normal map is generated (matching the behavior of the spriteNodeWithImageNamed: class method).
   * @desc The normal map is used only when lighting is enabled in the scene. For more information, see Adding Lighting to a Sprite and SKLightNode.
   * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519721-init
   */
  function SKSpriteNode() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var generateNormalMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, SKSpriteNode);

    // Inspecting Physical Properties

    /**
     * The dimensions of the sprite, in points.
     * @type {CGSize}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519668-size
     */
    var _this = _possibleConstructorReturn(this, (SKSpriteNode.__proto__ || Object.getPrototypeOf(SKSpriteNode)).call(this));

    _this.size = new _CGSize2.default(0, 0);

    /**
     * Defines the point in the sprite that corresponds to the node’s position.
     * @type {CGPoint}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519877-anchorpoint
     */
    _this.anchorPoint = new _CGPoint2.default(0.5, 0.5);

    // Inspecting the Sprite’s Texture

    /**
     * The texture used to draw the sprite.
     * @type {?SKTexture}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1520011-texture
     */
    _this._texture = null;

    /**
     * A property that defines how the texture is applied to the sprite.
     * @type {CGRect}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1520119-centerrect
     */
    _this.centerRect = new _CGRect2.default(new _CGPoint2.default(0, 0), new _CGSize2.default(1, 1));

    /**
     * A floating-point value that describes how the color is blended with the sprite’s texture.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519780-colorblendfactor
     */
    _this.colorBlendFactor = 0;

    // Inspecting Color Properties

    /**
     * The sprite’s color.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519639-color
     */
    _this.color = new _SKColor2.default(1.0, 1.0, 1.0, 0.0);

    // Blending the Sprite with the Framebuffer

    /**
     * The blend mode used to draw the sprite into the parent’s framebuffer.
     * @type {SKBlendMode}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519931-blendmode
     */
    _this.blendMode = _SKBlendMode2.default.alpha;

    // Adding Lighting to a Sprite

    /**
     * A mask that defines how this sprite is lit by light nodes in the scenes.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519637-lightingbitmask
     */
    _this.lightingBitMask = 0;

    /**
     * A mask that defines which lights add additional shadows to the sprite.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519974-shadowedbitmask
     */
    _this.shadowedBitMask = 0;

    /**
     * A mask that defines which lights are occluded by this sprite.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1520325-shadowcastbitmask
     */
    _this.shadowCastBitMask = 0;

    /**
     * A texture that specifies the normal map for the sprite.
     * @type {?SKTexture}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519657-normaltexture
     */
    _this.normalTexture = null;

    // Working with Custom Shaders

    /**
     * A property that determines whether the sprite is rendered using a custom shader.
     * @type {?SKShader}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519714-shader
     */
    _this.shader = null;

    /**
     * The values of each attribute associated with the node's attached shader.
     * @type {Map<string, SKAttributeValue>}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/2715845-attributevalues
     */
    _this.attributeValues = new Map();

    // Instance Properties

    //this._customPlaygroundQuickLook = new PlaygroundQuickLook()
    _this._customPlaygroundQuickLook = null;

    /**
     * @access private
     * @type {WebGLProgram}
     */
    _this._program = null;

    _this._vertexArrayObject = null;
    _this._vertexBuffer = null;
    _this._indexBuffer = null;

    _this._loadingImagePromise = null;

    if (name !== null) {
      _this.texture = _SKTexture2.default.textureWithImageNamed(name
      //if(generateNormalMap){
      //  this.normalTexture = this.texture.generatingNormalMap()
      //}
      );
    }
    return _this;
  }

  /**
   * Initializes a colored sprite node.
   * @access public
   * @param {CGColor} color - The color for the resulting sprite node.
   * @param {CGSize} size - The size of the sprite node in points.
   * @returns {SKSpriteNode} -
   * @desc Although textured nodes are the most common way to use the SKSpriteNode class, you can also create sprite nodes without a texture. The behavior of the class changes when the node lacks a texture:The sprite node that is returned from this method has its texture property set to nil.There is no texture to stretch, so the centerRect parameter is ignored.There is no colorization step; the color property is used as the sprite’s color.The sprite node's alpha component is used to determine how it is blended into the buffer.Listing 1 shows how to create a red sprite node 100 x 100 points in size.Listing 1 Creating a non-textured sprite nodelet node = SKSpriteNode(color: .red,
                        size: CGSize(width: 100, height: 100))
  Creating a non-textured sprite nodelet node = SKSpriteNode(color: .red,
                        size: CGSize(width: 100, height: 100))
    * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519762-init
   */


  _createClass(SKSpriteNode, [{
    key: 'scaleTo',


    // Inspecting Physical Properties

    /**
     * Scales to sprite node to a specified size. 
     * @access public
     * @param {CGSize} size - 
     * @returns {void}
     * @desc This method works by setting the sprite node's xScale and yScale to achieve the specified size in its parent's coordinate space. 
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1645445-scale
     */
    value: function scaleTo(size) {}

    // Working with Custom Shaders

    /**
     * Sets an attribute value for an attached shader.
     * @access public
     * @param {SKAttributeValue} value - An attribute value object containing the scalar or vector value to set in the attached shader.
     * @param {string} key - The attribute name.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/2715849-setvalue
     */

  }, {
    key: 'setValueForAttribute',
    value: function setValueForAttribute(value, key) {}

    /**
     * The value of a shader attribute.
     * @access public
     * @param {string} key - The attribute name.
     * @returns {?SKAttributeValue} - 
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/2715846-value
     */

  }, {
    key: 'valueForAttributeNamed',
    value: function valueForAttributeNamed(key) {
      return null;
    }

    // Initializers

    /**
     * 
     * @access public
     * @param {NSCoder} aDecoder - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1520399-init
     */

  }, {
    key: 'initCoder',
    value: function initCoder(aDecoder) {}

    // Instance Properties
    /**
     * A custom playground quick look for this instance.
     * @type {PlaygroundQuickLook}
     * @desc 
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1645797-customplaygroundquicklook
     */

  }, {
    key: '_render',


    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @param {CGRect} viewRect -
     * @returns {void}
     */
    value: function _render(gl, viewRect) {
      var p = this.__presentation;
      if (this.texture === null) {
        //if(this.color === null){
        //  return
        //}
        //this.texture = this._createTextureFromColor()
        return;
      }
      if (this.texture._glTexture === null) {
        this.texture._createTexture(gl);
        if (this.texture._glTexture === null) {
          // the texture is not ready
          return;
        }
        this.size = new _CGSize2.default(this.texture._image.naturalWidth, this.texture._image.naturalHeight);
        p.size = this.size.copy();
      }
      if (this._program === null) {
        this._program = this._createProgram(gl);
      }
      var program = this._program;
      gl.useProgram(program);

      if (this._vertexArrayObject === null) {
        this._createVertexArrayObject(gl, program);
      }
      gl.bindVertexArray(this._vertexArrayObject);

      gl.uniform1f(gl.getUniformLocation(program, 'screenWidth'), viewRect.size.width);
      gl.uniform1f(gl.getUniformLocation(program, 'screenHeight'), viewRect.size.height);
      gl.uniform1f(gl.getUniformLocation(program, 'alpha'), p.alpha);

      var data = this._createVertexData();
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform1i(gl.getUniformLocation(program, 'spriteTexture'), 0);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.texture._glTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);
    }
  }, {
    key: '_createProgram',
    value: function _createProgram(gl) {
      var program = gl.createProgram();
      var vsText = _defaultVertexShader;
      var fsText = _defaultFragmentShader;

      // initialize vertex shader
      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vsText);
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(vertexShader);
        throw new Error('SKSpriteNode vertex shader compile error: ' + info);
      }

      // initialize fragment shader
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fsText);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        var _info = gl.getShaderInfoLog(fragmentShader);
        throw new Error('particle fragment shader compile error: ' + _info);
      }

      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader

      // link program object
      );gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var _info2 = gl.getProgramInfoLog(program);
        throw new Error('program link error: ' + _info2);
      }

      //gl.useProgram(program)

      return program;
    }

    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @param {WebGLProgram} program -
     * @returns {void}
     */

  }, {
    key: '_createVertexArrayObject',
    value: function _createVertexArrayObject(gl, program) {
      this._vertexArrayObject = gl.createVertexArray();
      gl.bindVertexArray(this._vertexArrayObject);

      this._vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);

      var positionLoc = gl.getAttribLocation(program, 'position');
      gl.bindAttribLocation(program, positionLoc, 'position');
      gl.enableVertexAttribArray(positionLoc
      // idx, size, type, norm, stride, offset
      );gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 20, 0);

      var texcoordLoc = gl.getAttribLocation(program, 'texcoord');
      gl.bindAttribLocation(program, texcoordLoc, 'texcoord');
      gl.enableVertexAttribArray(texcoordLoc
      // idx, size, type, norm, stride, offset
      );gl.vertexAttribPointer(texcoordLoc, 2, gl.FLOAT, false, 20, 12);

      this._indexBuffer = gl.createBuffer();
      var indexData = new Uint8Array([0, 3, 2, 0, 1, 3]);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
    }
  }, {
    key: '_createVertexData',
    value: function _createVertexData() {
      var p = this.__presentation;
      var w = p.size.width * p._worldXScale;
      var h = p.size.height * p._worldYScale;
      var pos = p._worldPosition;
      var zPos = p._worldZPosition;
      var left = pos.x - p.anchorPoint.x * w;
      var right = pos.x + (1.0 - p.anchorPoint.x) * w;
      var top = pos.y + (1.0 - p.anchorPoint.y) * h;
      var bottom = pos.y - p.anchorPoint.y * h;
      var arr = [left, top, zPos, p.centerRect.minX, p.centerRect.minY, right, top, zPos, p.centerRect.maxX, p.centerRect.minY, left, bottom, zPos, p.centerRect.minX, p.centerRect.maxY, right, bottom, zPos, p.centerRect.maxX, p.centerRect.maxY];
      return new Float32Array(arr);
    }
  }, {
    key: '_copyValue',
    value: function _copyValue(src) {
      _get(SKSpriteNode.prototype.__proto__ || Object.getPrototypeOf(SKSpriteNode.prototype), '_copyValue', this).call(this, src);
      this.size = src.size.copy();
      this.anchorPoint = src.anchorPoint.copy();
      this._texture = src._texture ? src._texture : null;
      this.centerRect = src.centerRect.copy();
      this.colorBlendFactor = src.colorBlendFactor;
      this.color = src.color.copy();
      this.blendMode = src.blendMode;
      this.lightingBitMask = src.lightingBitMask;
      this.shadowedBitMask = src.shadowedBitMask;
      this.shadowCastBitMask = src.shadowCastBitMask;
      this.normalTexture = src.normalTexture ? src.normalTexture : null;
      this.shader = src.shader;
      this.attributeValues = src.attributeValues;
      this._customerPlaygroundQuickLook = src._customerPlaygroundQuickLook;
      // this._program
      // this._vertexArrayObject
      // this._vertexBuffer
      // this._indexBuffer
    }
  }, {
    key: '_getLoadedPromise',
    value: function _getLoadedPromise() {
      if (this._loadingImagePromise) {
        return this._loadingImagePromise;
      }
      return Promise.resolve();
    }
  }, {
    key: 'customPlaygroundQuickLook',
    get: function get() {
      return this._customPlaygroundQuickLook;
    }
  }, {
    key: 'texture',
    get: function get() {
      return this._texture;
    },
    set: function set(newValue) {
      var _this2 = this;

      this._texture = newValue;

      this.size = new _CGSize2.default(0, 0);
      this._frame = new _CGRect2.default(new _CGPoint2.default(0, 0), this.size);
      if (this._texture) {
        this._loadingImagePromise = this._texture._loadingImagePromise.then(function (texture) {
          if (_this2._texture === texture) {
            _this2.size = _this2._texture.size();
            var x = -_this2.size.width * _this2.anchorPoint.x;
            var y = -_this2.size.height * (1.0 - _this2.anchorPoint.y);
            _this2._frame = new _CGRect2.default(new _CGPoint2.default(x, y), _this2.size);
          }
        });
      } else {
        this._loadingImagePromise = null;
      }
    }
  }, {
    key: 'didLoad',
    get: function get() {
      return this._getLoadedPromise();
    }
  }], [{
    key: 'nodeWithColorSize',
    value: function nodeWithColorSize(color, size) {
      var node = new SKSpriteNode();
      node.size = size;
      node.color = color;
      return node;
    }

    /**
     * Initializes a textured sprite using an image file.
     * @access public
     * @param {string} name - The name of an image file stored in the app bundle.
     * @returns {SKSpriteNode} -
     * @desc This method creates a new texture object from the image file and assigns that texture to the texture property, the normalTexture properties is set to nil. The size property of the sprite is set to the dimensions of the image. The color property is set to white with an alpha of zero (1.0,1.0,1.0,0.0).
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1520391-init
     */

  }, {
    key: 'nodeWithImageNamed',
    value: function nodeWithImageNamed(name) {
      return new SKSpriteNode(name);
    }

    /**
     * Initializes a textured sprite using an image file, optionally adding a normal map to simulate 3D lighting.
     * @access public
     * @param {string} name - The name of an image file stored in the app bundle.
     * @param {boolean} generateNormalMap - If true, a normal map is generated from the image texture without applying any filter to it (SKTextureNormalMapFilteringTypeNone). If false, no normal map is generated (matching the behavior of the spriteNodeWithImageNamed: class method).
     * @returns {SKSpriteNode} -
     * @desc The normal map is used only when lighting is enabled in the scene. For more information, see Adding Lighting to a Sprite and SKLightNode.
     * @see https://developer.apple.com/documentation/spritekit/skspritenode/1519721-init
     */

  }, {
    key: 'nodeWithImageNamedNormalMapped',
    value: function nodeWithImageNamedNormalMapped(name, generateNormalMap) {
      return new SKSpriteNode(name, generateNormalMap);
    }
  }]);

  return SKSpriteNode;
}(_SKNode3.default);

exports.default = SKSpriteNode;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Texture filtering modes to use when the texture is drawn in a size other than its native size.
 * @typedef {Object} SKTextureFilteringMode
 * @property {number} nearest - Each pixel is drawn using the nearest point in the texture. This mode is faster, but the results are often pixelated.
 * @property {number} linear - Each pixel is drawn by using a linear filter of multiple texels in the texture. This mode produces higher quality results but may be slower.
 * @see https://developer.apple.com/documentation/spritekit/sktexturefilteringmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SKTextureFilteringMode = {
  nearest: 0,
  linear: 1
};

exports.default = SKTextureFilteringMode;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the preferredRenderingAPI option when initializing an SCNView object.
 * @typedef {Object} SCNRenderingAPI
 * @property {number} metal - Use the Metal framework for SceneKit rendering.
 * @property {number} openGLES2 - Use the OpenGL ES 2.0 API for SceneKit rendering in iOS.
 * @property {number} openGLLegacy - Use the Legacy OpenGL API for SceneKit rendering in macOS.
 * @property {number} openGLCore32 - Use the OpenGL 3.2 Core Profile API for SceneKit rendering in macOS.
 * @property {number} openGLCore41 - Use the OpenGL 4.1 Core Profile API for SceneKit rendering in macOS.
 * @property {number} webGL - Use the OpenGL 4.1 Core Profile API for SceneKit rendering in macOS.
 * @see https://developer.apple.com/documentation/scenekit/scnrenderingapi
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNRenderingAPI = {
  metal: 0,
  openGLLegacy: 1,
  openGLCore32: 2,
  openGLCore41: 3,
  openGLES2: 999,
  webGL: 998
};

exports.default = SCNRenderingAPI;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SKNode2 = __webpack_require__(19);

var _SKNode3 = _interopRequireDefault(_SKNode2);

var _SKBlendMode = __webpack_require__(28);

var _SKBlendMode2 = _interopRequireDefault(_SKBlendMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SKWarpable from './SKWarpable'


//import SKShader from './SKShader'
//import SKAttributeValue from './SKAttributeValue'


/**
 * A node that can apply Core Image filters or SKWarpGeometry distortions to its children.
 * @access public
 * @extends {SKNode}
 * @implements {SKWarpable}
 * @see https://developer.apple.com/documentation/spritekit/skeffectnode
 */
var SKEffectNode = function (_SKNode) {
  _inherits(SKEffectNode, _SKNode);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SKEffectNode() {
    _classCallCheck(this, SKEffectNode);

    // Enabling Filter Effects

    /**
     * A Boolean value that determines whether the effect node applies the filter to its children as they are drawn.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/1459385-shouldenableeffects
     */
    var _this = _possibleConstructorReturn(this, (SKEffectNode.__proto__ || Object.getPrototypeOf(SKEffectNode)).call(this));

    _this.shouldEnableEffects = true;

    // Configuring the Filter

    /**
     * The Core Image filter to apply.
     * @type {?CIFilter}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/1459392-filter
     */
    _this.filter = null;

    /**
     * A Boolean value that determines whether the effect node automatically sets the filter’s image center.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/1459390-shouldcenterfilter
     */
    _this.shouldCenterFilter = true;

    // Blending the Results to the Framebuffer

    /**
     * The blend mode used to draw the filtered image into the parent’s framebuffer.
     * @type {SKBlendMode}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/1459386-blendmode
     */
    _this.blendMode = _SKBlendMode2.default.alpha;

    // Working with Custom Shaders

    /**
     * A custom shader that is called when the effect node is blended into the parent’s framebuffer.
     * @type {?SKShader}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/1459388-shader
     */
    _this.shader = null;

    /**
     * The values of each attribute associated with the node's attached shader.
     * @type {Map<string, SKAttributeValue>}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/2715848-attributevalues
     */
    _this.attributeValues = new Map();

    // Caching the Filter Results

    /**
     * A Boolean value that indicates whether the results of rendering the child nodes should be cached.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/skeffectnode/1459381-shouldrasterize
     */
    _this.shouldRasterize = false;

    return _this;
  }

  // Working with Custom Shaders

  /**
   * Sets an attribute value for an attached shader.
   * @access public
   * @param {SKAttributeValue} value - An attribute value object containing the scalar or vector value to set in the attached shader.
   * @param {string} key - The attribute name.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skeffectnode/2715853-setvalue
   */
  //setValueForAttribute(value, key) {
  //}

  /**
   * The value of a shader attribute.
   * @access public
   * @param {string} key - The attribute name.
   * @returns {?SKAttributeValue} - 
   * @see https://developer.apple.com/documentation/spritekit/skeffectnode/2715844-value
   */
  //valueForAttributeNamed(key) {
  //  return null
  //}


  return SKEffectNode;
}(_SKNode3.default);

exports.default = SKEffectNode;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for aligning text horizontally.
 * @typedef {Object} SKLabelHorizontalAlignmentMode
 * @property {number} center - Centers the text horizontally on the node’s origin.
 * @property {number} left - Positions the text so that the left side of the text is on the node’s origin.
 * @property {number} right - Positions the text so that the right side of the text is on the node’s origin.
 * @see https://developer.apple.com/documentation/spritekit/sklabelhorizontalalignmentmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SKLabelHorizontalAlignmentMode = {
  center: 0,
  left: 1,
  right: 2
};

exports.default = SKLabelHorizontalAlignmentMode;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for aligning text vertically. 
 * @typedef {Object} SKLabelVerticalAlignmentMode
 * @property {number} baseline - Positions the text so that the font’s baseline lies on the node’s origin.
 * @property {number} center - Centers the text vertically on the node’s origin.
 * @property {number} top - Positions the text so that the top of the text is on the node’s origin.
 * @property {number} bottom - Positions the text so that the bottom of the text is on the node’s origin.
 * @see https://developer.apple.com/documentation/spritekit/sklabelverticalalignmentmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SKLabelVerticalAlignmentMode = {
  baseline: 0,
  center: 1,
  top: 2,
  bottom: 3
};

exports.default = SKLabelVerticalAlignmentMode;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The modes that determine how the scene’s area is mapped to the view that presents it.
 * @typedef {Object} SKSceneScaleMode
 * @property {number} fill - Each axis of the scene is scaled independently so that each axis in the scene exactly maps to the length of that axis in the view.
 * @property {number} aspectFill - The scaling factor of each dimension is calculated and the larger of the two is chosen. Each axis of the scene is scaled by the same scaling factor. This guarantees that the entire area of the view is filled but may cause parts of the scene to be cropped.
 * @property {number} aspectFit - The scaling factor of each dimension is calculated and the smaller of the two is chosen. Each axis of the scene is scaled by the same scaling factor. This guarantees that the entire scene is visible but may require letterboxing in the view.
 * @property {number} resizeFill - The scene is not scaled to match the view. Instead, the scene is automatically resized so that its dimensions always match those of the view.
 * @see https://developer.apple.com/documentation/spritekit/skscenescalemode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SKSceneScaleMode = {
  fill: 0,
  aspectFill: 1,
  aspectFit: 2,
  resizeFill: 3
};

exports.default = SKSceneScaleMode;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _NSColor = __webpack_require__(117);

var _NSColor2 = _interopRequireDefault(_NSColor);

var _NSColorSpaceModel = __webpack_require__(122);

var _NSColorSpaceModel2 = _interopRequireDefault(_NSColorSpaceModel);

var _AVAudioMixerNode = __webpack_require__(56);

var _AVAudioMixerNode2 = _interopRequireDefault(_AVAudioMixerNode);

var _AVAudioNode = __webpack_require__(57);

var _AVAudioNode2 = _interopRequireDefault(_AVAudioNode);

var _CFAbsoluteTimeGetCurrent = __webpack_require__(123);

var _CFAbsoluteTimeGetCurrent2 = _interopRequireDefault(_CFAbsoluteTimeGetCurrent);

var _CGBlendMode = __webpack_require__(124);

var _CGBlendMode2 = _interopRequireDefault(_CGBlendMode);

var _CGLineCap = __webpack_require__(58);

var _CGLineCap2 = _interopRequireDefault(_CGLineCap);

var _CGLineJoin = __webpack_require__(59);

var _CGLineJoin2 = _interopRequireDefault(_CGLineJoin);

var _CGMutablePath = __webpack_require__(125);

var _CGMutablePath2 = _interopRequireDefault(_CGMutablePath);

var _CGPath = __webpack_require__(126);

var _CGPath2 = _interopRequireDefault(_CGPath);

var _CGPathApplierFunction = __webpack_require__(127);

var _CGPathApplierFunction2 = _interopRequireDefault(_CGPathApplierFunction);

var _CGPathFillRule = __webpack_require__(128);

var _CGPathFillRule2 = _interopRequireDefault(_CGPathFillRule);

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _CGRect = __webpack_require__(16);

var _CGRect2 = _interopRequireDefault(_CGRect);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

var _CGVector = __webpack_require__(60);

var _CGVector2 = _interopRequireDefault(_CGVector);

var _DispatchObject = __webpack_require__(61);

var _DispatchObject2 = _interopRequireDefault(_DispatchObject);

var _DispatchQueue = __webpack_require__(129);

var _DispatchQueue2 = _interopRequireDefault(_DispatchQueue);

var _DispatchTime = __webpack_require__(130);

var _DispatchTime2 = _interopRequireDefault(_DispatchTime);

var _DispatchTimeInterval = __webpack_require__(131);

var _DispatchTimeInterval2 = _interopRequireDefault(_DispatchTimeInterval);

var _NotificationCenter = __webpack_require__(132);

var _NotificationCenter2 = _interopRequireDefault(_NotificationCenter);

var _NSArray = __webpack_require__(67);

var _NSArray2 = _interopRequireDefault(_NSArray);

var _NSCoder = __webpack_require__(39);

var _NSCoder2 = _interopRequireDefault(_NSCoder);

var _NSColorSpace = __webpack_require__(133);

var _NSColorSpace2 = _interopRequireDefault(_NSColorSpace);

var _NSData = __webpack_require__(40);

var _NSData2 = _interopRequireDefault(_NSData);

var _NSDictionary = __webpack_require__(68);

var _NSDictionary2 = _interopRequireDefault(_NSDictionary);

var _NSKeyedArchiver = __webpack_require__(134);

var _NSKeyedArchiver2 = _interopRequireDefault(_NSKeyedArchiver);

var _NSKeyedUnarchiver = __webpack_require__(41);

var _NSKeyedUnarchiver2 = _interopRequireDefault(_NSKeyedUnarchiver);

var _NSMutableArray = __webpack_require__(135);

var _NSMutableArray2 = _interopRequireDefault(_NSMutableArray);

var _NSMutableData = __webpack_require__(136);

var _NSMutableData2 = _interopRequireDefault(_NSMutableData);

var _NSMutableDictionary = __webpack_require__(137);

var _NSMutableDictionary2 = _interopRequireDefault(_NSMutableDictionary);

var _NSNotification = __webpack_require__(62);

var _NSNotification2 = _interopRequireDefault(_NSNotification);

var _NSURL = __webpack_require__(138);

var _NSURL2 = _interopRequireDefault(_NSURL);

var _NSValue = __webpack_require__(139);

var _NSValue2 = _interopRequireDefault(_NSValue);

var _GCController = __webpack_require__(29);

var _GCController2 = _interopRequireDefault(_GCController);

var _GCControllerAxisInput = __webpack_require__(64);

var _GCControllerAxisInput2 = _interopRequireDefault(_GCControllerAxisInput);

var _GCControllerButtonInput = __webpack_require__(30);

var _GCControllerButtonInput2 = _interopRequireDefault(_GCControllerButtonInput);

var _GCControllerDirectionPad = __webpack_require__(38);

var _GCControllerDirectionPad2 = _interopRequireDefault(_GCControllerDirectionPad);

var _GCControllerElement = __webpack_require__(31);

var _GCControllerElement2 = _interopRequireDefault(_GCControllerElement);

var _GCExtendedGamepad = __webpack_require__(65);

var _GCExtendedGamepad2 = _interopRequireDefault(_GCExtendedGamepad);

var _GCGamepad = __webpack_require__(63);

var _GCGamepad2 = _interopRequireDefault(_GCGamepad);

var _GCMicroGamepad = __webpack_require__(66);

var _GCMicroGamepad2 = _interopRequireDefault(_GCMicroGamepad);

var _GKAgent = __webpack_require__(44);

var _GKAgent2 = _interopRequireDefault(_GKAgent);

var _GKAgent2D = __webpack_require__(140);

var _GKAgent2D2 = _interopRequireDefault(_GKAgent2D);

var _GKAgentDelegate = __webpack_require__(74);

var _GKAgentDelegate2 = _interopRequireDefault(_GKAgentDelegate);

var _GKBehavior = __webpack_require__(72);

var _GKBehavior2 = _interopRequireDefault(_GKBehavior);

var _GKComponent = __webpack_require__(32);

var _GKComponent2 = _interopRequireDefault(_GKComponent);

var _GKEntity = __webpack_require__(71);

var _GKEntity2 = _interopRequireDefault(_GKEntity);

var _GKGoal = __webpack_require__(73);

var _GKGoal2 = _interopRequireDefault(_GKGoal);

var _GKPath = __webpack_require__(141);

var _GKPath2 = _interopRequireDefault(_GKPath);

var _GKScene = __webpack_require__(142);

var _GKScene2 = _interopRequireDefault(_GKScene);

var _GKSCNNodeComponent = __webpack_require__(143);

var _GKSCNNodeComponent2 = _interopRequireDefault(_GKSCNNodeComponent);

var _MTLTessellationPartitionMode = __webpack_require__(75);

var _MTLTessellationPartitionMode2 = _interopRequireDefault(_MTLTessellationPartitionMode);

var _NSObject = __webpack_require__(0);

var _NSObject2 = _interopRequireDefault(_NSObject);

var _CAAction = __webpack_require__(144);

var _CAAction2 = _interopRequireDefault(_CAAction);

var _CAAnimation = __webpack_require__(24);

var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

var _CAAnimationDelegate = __webpack_require__(145);

var _CAAnimationDelegate2 = _interopRequireDefault(_CAAnimationDelegate);

var _CAAnimationGroup = __webpack_require__(76);

var _CAAnimationGroup2 = _interopRequireDefault(_CAAnimationGroup);

var _CABasicAnimation = __webpack_require__(45);

var _CABasicAnimation2 = _interopRequireDefault(_CABasicAnimation);

var _CACurrentMediaTime = __webpack_require__(146);

var _CACurrentMediaTime2 = _interopRequireDefault(_CACurrentMediaTime);

var _CAKeyframeAnimation = __webpack_require__(77);

var _CAKeyframeAnimation2 = _interopRequireDefault(_CAKeyframeAnimation);

var _CAMediaTiming = __webpack_require__(147);

var _CAMediaTiming2 = _interopRequireDefault(_CAMediaTiming);

var _CAMediaTimingFunction = __webpack_require__(47);

var _CAMediaTimingFunction2 = _interopRequireDefault(_CAMediaTimingFunction);

var _CAPropertyAnimation = __webpack_require__(46);

var _CAPropertyAnimation2 = _interopRequireDefault(_CAPropertyAnimation);

var _CATransform3D = __webpack_require__(148);

var _CATransform3D2 = _interopRequireDefault(_CATransform3D);

var _SCNAccelerationConstraint = __webpack_require__(149);

var _SCNAccelerationConstraint2 = _interopRequireDefault(_SCNAccelerationConstraint);

var _SCNAction = __webpack_require__(4);

var _SCNAction2 = _interopRequireDefault(_SCNAction);

var _SCNActionable = __webpack_require__(150);

var _SCNActionable2 = _interopRequireDefault(_SCNActionable);

var _SCNActionCustom = __webpack_require__(151);

var _SCNActionCustom2 = _interopRequireDefault(_SCNActionCustom);

var _SCNActionFade = __webpack_require__(152);

var _SCNActionFade2 = _interopRequireDefault(_SCNActionFade);

var _SCNActionGroup = __webpack_require__(153);

var _SCNActionGroup2 = _interopRequireDefault(_SCNActionGroup);

var _SCNActionHide = __webpack_require__(154);

var _SCNActionHide2 = _interopRequireDefault(_SCNActionHide);

var _SCNActionJavaScript = __webpack_require__(155);

var _SCNActionJavaScript2 = _interopRequireDefault(_SCNActionJavaScript);

var _SCNActionMove = __webpack_require__(156);

var _SCNActionMove2 = _interopRequireDefault(_SCNActionMove);

var _SCNActionPerformSelector = __webpack_require__(157);

var _SCNActionPerformSelector2 = _interopRequireDefault(_SCNActionPerformSelector);

var _SCNActionPlaySound = __webpack_require__(158);

var _SCNActionPlaySound2 = _interopRequireDefault(_SCNActionPlaySound);

var _SCNActionReference = __webpack_require__(159);

var _SCNActionReference2 = _interopRequireDefault(_SCNActionReference);

var _SCNActionRemove = __webpack_require__(160);

var _SCNActionRemove2 = _interopRequireDefault(_SCNActionRemove);

var _SCNActionRepeat = __webpack_require__(161);

var _SCNActionRepeat2 = _interopRequireDefault(_SCNActionRepeat);

var _SCNActionRotate = __webpack_require__(162);

var _SCNActionRotate2 = _interopRequireDefault(_SCNActionRotate);

var _SCNActionRunAction = __webpack_require__(163);

var _SCNActionRunAction2 = _interopRequireDefault(_SCNActionRunAction);

var _SCNActionRunBlock = __webpack_require__(164);

var _SCNActionRunBlock2 = _interopRequireDefault(_SCNActionRunBlock);

var _SCNActionScale = __webpack_require__(165);

var _SCNActionScale2 = _interopRequireDefault(_SCNActionScale);

var _SCNActionSequence = __webpack_require__(166);

var _SCNActionSequence2 = _interopRequireDefault(_SCNActionSequence);

var _SCNActionTimingFunction = __webpack_require__(167);

var _SCNActionTimingFunction2 = _interopRequireDefault(_SCNActionTimingFunction);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

var _SCNActionWait = __webpack_require__(168);

var _SCNActionWait2 = _interopRequireDefault(_SCNActionWait);

var _SCNAnimatable = __webpack_require__(169);

var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

var _SCNAnimation = __webpack_require__(86);

var _SCNAnimation2 = _interopRequireDefault(_SCNAnimation);

var _SCNAnimationEvent = __webpack_require__(170);

var _SCNAnimationEvent2 = _interopRequireDefault(_SCNAnimationEvent);

var _SCNAnimationEventBlock = __webpack_require__(171);

var _SCNAnimationEventBlock2 = _interopRequireDefault(_SCNAnimationEventBlock);

var _SCNAnimationPlayer = __webpack_require__(172);

var _SCNAnimationPlayer2 = _interopRequireDefault(_SCNAnimationPlayer);

var _SCNAntialiasingMode = __webpack_require__(87);

var _SCNAntialiasingMode2 = _interopRequireDefault(_SCNAntialiasingMode);

var _SCNAudioPlayer = __webpack_require__(173);

var _SCNAudioPlayer2 = _interopRequireDefault(_SCNAudioPlayer);

var _SCNAudioSource = __webpack_require__(174);

var _SCNAudioSource2 = _interopRequireDefault(_SCNAudioSource);

var _SCNBillboardAxis = __webpack_require__(175);

var _SCNBillboardAxis2 = _interopRequireDefault(_SCNBillboardAxis);

var _SCNBillboardConstraint = __webpack_require__(176);

var _SCNBillboardConstraint2 = _interopRequireDefault(_SCNBillboardConstraint);

var _SCNBindingBlock = __webpack_require__(177);

var _SCNBindingBlock2 = _interopRequireDefault(_SCNBindingBlock);

var _SCNBlendMode = __webpack_require__(79);

var _SCNBlendMode2 = _interopRequireDefault(_SCNBlendMode);

var _SCNBoundingVolume = __webpack_require__(178);

var _SCNBoundingVolume2 = _interopRequireDefault(_SCNBoundingVolume);

var _SCNBox = __webpack_require__(34);

var _SCNBox2 = _interopRequireDefault(_SCNBox);

var _SCNBufferBindingBlock = __webpack_require__(179);

var _SCNBufferBindingBlock2 = _interopRequireDefault(_SCNBufferBindingBlock);

var _SCNBufferFrequency = __webpack_require__(180);

var _SCNBufferFrequency2 = _interopRequireDefault(_SCNBufferFrequency);

var _SCNBufferStream = __webpack_require__(181);

var _SCNBufferStream2 = _interopRequireDefault(_SCNBufferStream);

var _SCNCamera = __webpack_require__(88);

var _SCNCamera2 = _interopRequireDefault(_SCNCamera);

var _SCNCameraProjectionDirection = __webpack_require__(89);

var _SCNCameraProjectionDirection2 = _interopRequireDefault(_SCNCameraProjectionDirection);

var _SCNCapsule = __webpack_require__(49);

var _SCNCapsule2 = _interopRequireDefault(_SCNCapsule);

var _SCNChamferMode = __webpack_require__(182);

var _SCNChamferMode2 = _interopRequireDefault(_SCNChamferMode);

var _SCNColorMask = __webpack_require__(80);

var _SCNColorMask2 = _interopRequireDefault(_SCNColorMask);

var _SCNCone = __webpack_require__(183);

var _SCNCone2 = _interopRequireDefault(_SCNCone);

var _SCNConstraint = __webpack_require__(17);

var _SCNConstraint2 = _interopRequireDefault(_SCNConstraint);

var _SCNCullMode = __webpack_require__(48);

var _SCNCullMode2 = _interopRequireDefault(_SCNCullMode);

var _SCNCylinder = __webpack_require__(184);

var _SCNCylinder2 = _interopRequireDefault(_SCNCylinder);

var _SCNDebugOptions = __webpack_require__(185);

var _SCNDebugOptions2 = _interopRequireDefault(_SCNDebugOptions);

var _SCNDistanceConstraint = __webpack_require__(186);

var _SCNDistanceConstraint2 = _interopRequireDefault(_SCNDistanceConstraint);

var _SCNFieldForceEvaluator = __webpack_require__(187);

var _SCNFieldForceEvaluator2 = _interopRequireDefault(_SCNFieldForceEvaluator);

var _SCNFillMode = __webpack_require__(81);

var _SCNFillMode2 = _interopRequireDefault(_SCNFillMode);

var _SCNFilterMode = __webpack_require__(82);

var _SCNFilterMode2 = _interopRequireDefault(_SCNFilterMode);

var _SCNFloor = __webpack_require__(188);

var _SCNFloor2 = _interopRequireDefault(_SCNFloor);

var _SCNGeometry = __webpack_require__(9);

var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

var _SCNGeometryElement = __webpack_require__(15);

var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNGeometryTessellator = __webpack_require__(189);

var _SCNGeometryTessellator2 = _interopRequireDefault(_SCNGeometryTessellator);

var _SCNHitTestOption = __webpack_require__(91);

var _SCNHitTestOption2 = _interopRequireDefault(_SCNHitTestOption);

var _SCNHitTestResult = __webpack_require__(50);

var _SCNHitTestResult2 = _interopRequireDefault(_SCNHitTestResult);

var _SCNIKConstraint = __webpack_require__(190);

var _SCNIKConstraint2 = _interopRequireDefault(_SCNIKConstraint);

var _SCNLayer = __webpack_require__(191);

var _SCNLayer2 = _interopRequireDefault(_SCNLayer);

var _SCNLevelOfDetail = __webpack_require__(192);

var _SCNLevelOfDetail2 = _interopRequireDefault(_SCNLevelOfDetail);

var _SCNLight = __webpack_require__(92);

var _SCNLight2 = _interopRequireDefault(_SCNLight);

var _SCNLookAtConstraint = __webpack_require__(193);

var _SCNLookAtConstraint2 = _interopRequireDefault(_SCNLookAtConstraint);

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNMaterialProperty = __webpack_require__(26);

var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

var _SCNMatrix4EqualToMatrix = __webpack_require__(194);

var _SCNMatrix4EqualToMatrix2 = _interopRequireDefault(_SCNMatrix4EqualToMatrix);

var _SCNMatrix4FromGLKMatrix = __webpack_require__(195);

var _SCNMatrix4FromGLKMatrix2 = _interopRequireDefault(_SCNMatrix4FromGLKMatrix);

var _SCNMatrix4FromMat = __webpack_require__(196);

var _SCNMatrix4FromMat2 = _interopRequireDefault(_SCNMatrix4FromMat);

var _SCNMatrix4Invert = __webpack_require__(197);

var _SCNMatrix4Invert2 = _interopRequireDefault(_SCNMatrix4Invert);

var _SCNMatrix4IsIdentity = __webpack_require__(198);

var _SCNMatrix4IsIdentity2 = _interopRequireDefault(_SCNMatrix4IsIdentity);

var _SCNMatrix4MakeRotation = __webpack_require__(199);

var _SCNMatrix4MakeRotation2 = _interopRequireDefault(_SCNMatrix4MakeRotation);

var _SCNMatrix4MakeScale = __webpack_require__(93);

var _SCNMatrix4MakeScale2 = _interopRequireDefault(_SCNMatrix4MakeScale);

var _SCNMatrix4MakeTranslation = __webpack_require__(18);

var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

var _SCNMatrix4Mult = __webpack_require__(200);

var _SCNMatrix4Mult2 = _interopRequireDefault(_SCNMatrix4Mult);

var _SCNMatrix4Rotate = __webpack_require__(201);

var _SCNMatrix4Rotate2 = _interopRequireDefault(_SCNMatrix4Rotate);

var _SCNMatrix4Scale = __webpack_require__(202);

var _SCNMatrix4Scale2 = _interopRequireDefault(_SCNMatrix4Scale);

var _SCNMatrix4ToGLKMatrix = __webpack_require__(203);

var _SCNMatrix4ToGLKMatrix2 = _interopRequireDefault(_SCNMatrix4ToGLKMatrix);

var _SCNMatrix4ToMat = __webpack_require__(204);

var _SCNMatrix4ToMat2 = _interopRequireDefault(_SCNMatrix4ToMat);

var _SCNMatrix4Translate = __webpack_require__(205);

var _SCNMatrix4Translate2 = _interopRequireDefault(_SCNMatrix4Translate);

var _SCNMorpher = __webpack_require__(206);

var _SCNMorpher2 = _interopRequireDefault(_SCNMorpher);

var _SCNMorpherCalculationMode = __webpack_require__(94);

var _SCNMorpherCalculationMode2 = _interopRequireDefault(_SCNMorpherCalculationMode);

var _SCNMovabilityHint = __webpack_require__(78);

var _SCNMovabilityHint2 = _interopRequireDefault(_SCNMovabilityHint);

var _SCNNode = __webpack_require__(14);

var _SCNNode2 = _interopRequireDefault(_SCNNode);

var _SCNNodeRendererDelegate = __webpack_require__(207);

var _SCNNodeRendererDelegate2 = _interopRequireDefault(_SCNNodeRendererDelegate);

var _SCNOrderedDictionary = __webpack_require__(22);

var _SCNOrderedDictionary2 = _interopRequireDefault(_SCNOrderedDictionary);

var _SCNParticleBirthDirection = __webpack_require__(95);

var _SCNParticleBirthDirection2 = _interopRequireDefault(_SCNParticleBirthDirection);

var _SCNParticleBirthLocation = __webpack_require__(96);

var _SCNParticleBirthLocation2 = _interopRequireDefault(_SCNParticleBirthLocation);

var _SCNParticleBlendMode = __webpack_require__(97);

var _SCNParticleBlendMode2 = _interopRequireDefault(_SCNParticleBlendMode);

var _SCNParticleEvent = __webpack_require__(208);

var _SCNParticleEvent2 = _interopRequireDefault(_SCNParticleEvent);

var _SCNParticleEventBlock = __webpack_require__(209);

var _SCNParticleEventBlock2 = _interopRequireDefault(_SCNParticleEventBlock);

var _SCNParticleImageSequenceAnimationMode = __webpack_require__(98);

var _SCNParticleImageSequenceAnimationMode2 = _interopRequireDefault(_SCNParticleImageSequenceAnimationMode);

var _SCNParticleInputMode = __webpack_require__(210);

var _SCNParticleInputMode2 = _interopRequireDefault(_SCNParticleInputMode);

var _SCNParticleModifierBlock = __webpack_require__(211);

var _SCNParticleModifierBlock2 = _interopRequireDefault(_SCNParticleModifierBlock);

var _SCNParticleModifierStage = __webpack_require__(212);

var _SCNParticleModifierStage2 = _interopRequireDefault(_SCNParticleModifierStage);

var _SCNParticleOrientationMode = __webpack_require__(99);

var _SCNParticleOrientationMode2 = _interopRequireDefault(_SCNParticleOrientationMode);

var _SCNParticlePropertyController = __webpack_require__(213);

var _SCNParticlePropertyController2 = _interopRequireDefault(_SCNParticlePropertyController);

var _SCNParticleSortingMode = __webpack_require__(100);

var _SCNParticleSortingMode2 = _interopRequireDefault(_SCNParticleSortingMode);

var _SCNParticleSystem = __webpack_require__(214);

var _SCNParticleSystem2 = _interopRequireDefault(_SCNParticleSystem);

var _SCNPhysicsBallSocketJoint = __webpack_require__(215);

var _SCNPhysicsBallSocketJoint2 = _interopRequireDefault(_SCNPhysicsBallSocketJoint);

var _SCNPhysicsBehavior = __webpack_require__(27);

var _SCNPhysicsBehavior2 = _interopRequireDefault(_SCNPhysicsBehavior);

var _SCNPhysicsBody = __webpack_require__(216);

var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

var _SCNPhysicsBodyType = __webpack_require__(51);

var _SCNPhysicsBodyType2 = _interopRequireDefault(_SCNPhysicsBodyType);

var _SCNPhysicsCollisionCategory = __webpack_require__(217);

var _SCNPhysicsCollisionCategory2 = _interopRequireDefault(_SCNPhysicsCollisionCategory);

var _SCNPhysicsContact = __webpack_require__(85);

var _SCNPhysicsContact2 = _interopRequireDefault(_SCNPhysicsContact);

var _SCNPhysicsContactDelegate = __webpack_require__(218);

var _SCNPhysicsContactDelegate2 = _interopRequireDefault(_SCNPhysicsContactDelegate);

var _SCNPhysicsField = __webpack_require__(101);

var _SCNPhysicsField2 = _interopRequireDefault(_SCNPhysicsField);

var _SCNPhysicsFieldScope = __webpack_require__(219);

var _SCNPhysicsFieldScope2 = _interopRequireDefault(_SCNPhysicsFieldScope);

var _SCNPhysicsHingeJoint = __webpack_require__(220);

var _SCNPhysicsHingeJoint2 = _interopRequireDefault(_SCNPhysicsHingeJoint);

var _SCNPhysicsNoiseField = __webpack_require__(102);

var _SCNPhysicsNoiseField2 = _interopRequireDefault(_SCNPhysicsNoiseField);

var _SCNPhysicsShape = __webpack_require__(52);

var _SCNPhysicsShape2 = _interopRequireDefault(_SCNPhysicsShape);

var _SCNPhysicsSliderJoint = __webpack_require__(221);

var _SCNPhysicsSliderJoint2 = _interopRequireDefault(_SCNPhysicsSliderJoint);

var _SCNPhysicsTurbulenceField = __webpack_require__(222);

var _SCNPhysicsTurbulenceField2 = _interopRequireDefault(_SCNPhysicsTurbulenceField);

var _SCNPhysicsVehicle = __webpack_require__(223);

var _SCNPhysicsVehicle2 = _interopRequireDefault(_SCNPhysicsVehicle);

var _SCNPhysicsVehicleWheel = __webpack_require__(224);

var _SCNPhysicsVehicleWheel2 = _interopRequireDefault(_SCNPhysicsVehicleWheel);

var _SCNPhysicsWorld = __webpack_require__(33);

var _SCNPhysicsWorld2 = _interopRequireDefault(_SCNPhysicsWorld);

var _SCNPlane = __webpack_require__(225);

var _SCNPlane2 = _interopRequireDefault(_SCNPlane);

var _SCNProgram = __webpack_require__(103);

var _SCNProgram2 = _interopRequireDefault(_SCNProgram);

var _SCNProgramDelegate = __webpack_require__(226);

var _SCNProgramDelegate2 = _interopRequireDefault(_SCNProgramDelegate);

var _SCNPyramid = __webpack_require__(227);

var _SCNPyramid2 = _interopRequireDefault(_SCNPyramid);

var _SCNQuaternion = __webpack_require__(104);

var _SCNQuaternion2 = _interopRequireDefault(_SCNQuaternion);

var _SCNReferenceLoadingPolicy = __webpack_require__(105);

var _SCNReferenceLoadingPolicy2 = _interopRequireDefault(_SCNReferenceLoadingPolicy);

var _SCNReferenceNode = __webpack_require__(228);

var _SCNReferenceNode2 = _interopRequireDefault(_SCNReferenceNode);

var _SCNRenderer = __webpack_require__(108);

var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

var _SCNRenderingAPI = __webpack_require__(111);

var _SCNRenderingAPI2 = _interopRequireDefault(_SCNRenderingAPI);

var _SCNScene = __webpack_require__(106);

var _SCNScene2 = _interopRequireDefault(_SCNScene);

var _SCNSceneExportDelegate = __webpack_require__(229);

var _SCNSceneExportDelegate2 = _interopRequireDefault(_SCNSceneExportDelegate);

var _SCNSceneExportProgressHandler = __webpack_require__(230);

var _SCNSceneExportProgressHandler2 = _interopRequireDefault(_SCNSceneExportProgressHandler);

var _SCNSceneRenderer = __webpack_require__(231);

var _SCNSceneRenderer2 = _interopRequireDefault(_SCNSceneRenderer);

var _SCNSceneRendererDelegate = __webpack_require__(232);

var _SCNSceneRendererDelegate2 = _interopRequireDefault(_SCNSceneRendererDelegate);

var _SCNSceneSource = __webpack_require__(107);

var _SCNSceneSource2 = _interopRequireDefault(_SCNSceneSource);

var _SCNSceneSourceStatus = __webpack_require__(233);

var _SCNSceneSourceStatus2 = _interopRequireDefault(_SCNSceneSourceStatus);

var _SCNSceneSourceStatusHandler = __webpack_require__(234);

var _SCNSceneSourceStatusHandler2 = _interopRequireDefault(_SCNSceneSourceStatusHandler);

var _SCNShadable = __webpack_require__(235);

var _SCNShadable2 = _interopRequireDefault(_SCNShadable);

var _SCNShadableHelper = __webpack_require__(236);

var _SCNShadableHelper2 = _interopRequireDefault(_SCNShadableHelper);

var _SCNShaderModifierEntryPoint = __webpack_require__(237);

var _SCNShaderModifierEntryPoint2 = _interopRequireDefault(_SCNShaderModifierEntryPoint);

var _SCNShadowMode = __webpack_require__(238);

var _SCNShadowMode2 = _interopRequireDefault(_SCNShadowMode);

var _SCNShape = __webpack_require__(239);

var _SCNShape2 = _interopRequireDefault(_SCNShape);

var _SCNSkinner = __webpack_require__(240);

var _SCNSkinner2 = _interopRequireDefault(_SCNSkinner);

var _SCNSphere = __webpack_require__(53);

var _SCNSphere2 = _interopRequireDefault(_SCNSphere);

var _SCNTechnique = __webpack_require__(241);

var _SCNTechnique2 = _interopRequireDefault(_SCNTechnique);

var _SCNTechniqueSupport = __webpack_require__(242);

var _SCNTechniqueSupport2 = _interopRequireDefault(_SCNTechniqueSupport);

var _SCNTessellationSmoothingMode = __webpack_require__(90);

var _SCNTessellationSmoothingMode2 = _interopRequireDefault(_SCNTessellationSmoothingMode);

var _SCNText = __webpack_require__(243);

var _SCNText2 = _interopRequireDefault(_SCNText);

var _SCNTimingFunction = __webpack_require__(244);

var _SCNTimingFunction2 = _interopRequireDefault(_SCNTimingFunction);

var _SCNTorus = __webpack_require__(245);

var _SCNTorus2 = _interopRequireDefault(_SCNTorus);

var _SCNTransaction = __webpack_require__(35);

var _SCNTransaction2 = _interopRequireDefault(_SCNTransaction);

var _SCNTransformConstraint = __webpack_require__(246);

var _SCNTransformConstraint2 = _interopRequireDefault(_SCNTransformConstraint);

var _SCNTransparencyMode = __webpack_require__(84);

var _SCNTransparencyMode2 = _interopRequireDefault(_SCNTransparencyMode);

var _SCNTube = __webpack_require__(247);

var _SCNTube2 = _interopRequireDefault(_SCNTube);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _SCNVector3EqualToVector = __webpack_require__(248);

var _SCNVector3EqualToVector2 = _interopRequireDefault(_SCNVector3EqualToVector);

var _SCNVector3FromFloat = __webpack_require__(249);

var _SCNVector3FromFloat2 = _interopRequireDefault(_SCNVector3FromFloat);

var _SCNVector3FromGLKVector = __webpack_require__(250);

var _SCNVector3FromGLKVector2 = _interopRequireDefault(_SCNVector3FromGLKVector);

var _SCNVector3Make = __webpack_require__(251);

var _SCNVector3Make2 = _interopRequireDefault(_SCNVector3Make);

var _SCNVector3ToFloat = __webpack_require__(252);

var _SCNVector3ToFloat2 = _interopRequireDefault(_SCNVector3ToFloat);

var _SCNVector3ToGLKVector = __webpack_require__(253);

var _SCNVector3ToGLKVector2 = _interopRequireDefault(_SCNVector3ToGLKVector);

var _SCNVector3Zero = __webpack_require__(254);

var _SCNVector3Zero2 = _interopRequireDefault(_SCNVector3Zero);

var _SCNVector3 = __webpack_require__(11);

var _SCNVector4 = _interopRequireDefault(_SCNVector3);

var _SCNVector4EqualToVector = __webpack_require__(255);

var _SCNVector4EqualToVector2 = _interopRequireDefault(_SCNVector4EqualToVector);

var _SCNVector4FromFloat = __webpack_require__(256);

var _SCNVector4FromFloat2 = _interopRequireDefault(_SCNVector4FromFloat);

var _SCNVector4FromGLKVector = __webpack_require__(257);

var _SCNVector4FromGLKVector2 = _interopRequireDefault(_SCNVector4FromGLKVector);

var _SCNVector4Make = __webpack_require__(258);

var _SCNVector4Make2 = _interopRequireDefault(_SCNVector4Make);

var _SCNVector4ToFloat = __webpack_require__(259);

var _SCNVector4ToFloat2 = _interopRequireDefault(_SCNVector4ToFloat);

var _SCNVector4ToGLKVector = __webpack_require__(260);

var _SCNVector4ToGLKVector2 = _interopRequireDefault(_SCNVector4ToGLKVector);

var _SCNView = __webpack_require__(261);

var _SCNView2 = _interopRequireDefault(_SCNView);

var _SCNWrapMode = __webpack_require__(83);

var _SCNWrapMode2 = _interopRequireDefault(_SCNWrapMode);

var _SKAction = __webpack_require__(20);

var _SKAction2 = _interopRequireDefault(_SKAction);

var _SKActionTimingMode = __webpack_require__(23);

var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

var _SKBlendMode = __webpack_require__(28);

var _SKBlendMode2 = _interopRequireDefault(_SKBlendMode);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _SKEffectNode = __webpack_require__(112);

var _SKEffectNode2 = _interopRequireDefault(_SKEffectNode);

var _SKFade = __webpack_require__(262);

var _SKFade2 = _interopRequireDefault(_SKFade);

var _SKGroup = __webpack_require__(263);

var _SKGroup2 = _interopRequireDefault(_SKGroup);

var _SKLabelHorizontalAlignmentMode = __webpack_require__(113);

var _SKLabelHorizontalAlignmentMode2 = _interopRequireDefault(_SKLabelHorizontalAlignmentMode);

var _SKLabelNode = __webpack_require__(264);

var _SKLabelNode2 = _interopRequireDefault(_SKLabelNode);

var _SKLabelVerticalAlignmentMode = __webpack_require__(114);

var _SKLabelVerticalAlignmentMode2 = _interopRequireDefault(_SKLabelVerticalAlignmentMode);

var _SKNode = __webpack_require__(19);

var _SKNode2 = _interopRequireDefault(_SKNode);

var _SKRepeat = __webpack_require__(265);

var _SKRepeat2 = _interopRequireDefault(_SKRepeat);

var _SKScale = __webpack_require__(266);

var _SKScale2 = _interopRequireDefault(_SKScale);

var _SKScene = __webpack_require__(267);

var _SKScene2 = _interopRequireDefault(_SKScene);

var _SKSceneScaleMode = __webpack_require__(115);

var _SKSceneScaleMode2 = _interopRequireDefault(_SKSceneScaleMode);

var _SKSequence = __webpack_require__(268);

var _SKSequence2 = _interopRequireDefault(_SKSequence);

var _SKShapeNode = __webpack_require__(269);

var _SKShapeNode2 = _interopRequireDefault(_SKShapeNode);

var _SKSpriteNode = __webpack_require__(109);

var _SKSpriteNode2 = _interopRequireDefault(_SKSpriteNode);

var _SKTexture = __webpack_require__(55);

var _SKTexture2 = _interopRequireDefault(_SKTexture);

var _SKTextureFilteringMode = __webpack_require__(110);

var _SKTextureFilteringMode2 = _interopRequireDefault(_SKTextureFilteringMode);

var _SKWait = __webpack_require__(270);

var _SKWait2 = _interopRequireDefault(_SKWait);

var _AjaxRequest2 = __webpack_require__(54);

var _AjaxRequest3 = _interopRequireDefault(_AjaxRequest2);

var _BinaryReader2 = __webpack_require__(69);

var _BinaryReader3 = _interopRequireDefault(_BinaryReader2);

var _BinaryRequest2 = __webpack_require__(36);

var _BinaryRequest3 = _interopRequireDefault(_BinaryRequest2);

var _Buffer2 = __webpack_require__(271);

var _Buffer3 = _interopRequireDefault(_Buffer2);

var _ClassList2 = __webpack_require__(37);

var _ClassList3 = _interopRequireDefault(_ClassList2);

var _File2 = __webpack_require__(42);

var _File3 = _interopRequireDefault(_File2);

var _FileReader2 = __webpack_require__(43);

var _FileReader3 = _interopRequireDefault(_FileReader2);

var _HTMLCanvasElement2 = __webpack_require__(273);

var _HTMLCanvasElement3 = _interopRequireDefault(_HTMLCanvasElement2);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_ClassList3.default.registerClass(_NSColor2.default, 'NSColor');
_ClassList3.default.registerClass(_NSColorSpaceModel2.default, 'NSColorSpaceModel');
_ClassList3.default.registerClass(_AVAudioMixerNode2.default, 'AVAudioMixerNode');
_ClassList3.default.registerClass(_AVAudioNode2.default, 'AVAudioNode');
_ClassList3.default.registerClass(_CFAbsoluteTimeGetCurrent2.default, 'CFAbsoluteTimeGetCurrent');
_ClassList3.default.registerClass(_CGBlendMode2.default, 'CGBlendMode');
_ClassList3.default.registerClass(_CGLineCap2.default, 'CGLineCap');
_ClassList3.default.registerClass(_CGLineJoin2.default, 'CGLineJoin');
_ClassList3.default.registerClass(_CGMutablePath2.default, 'CGMutablePath');
_ClassList3.default.registerClass(_CGPath2.default, 'CGPath');
_ClassList3.default.registerClass(_CGPathApplierFunction2.default, 'CGPathApplierFunction');
_ClassList3.default.registerClass(_CGPathFillRule2.default, 'CGPathFillRule');
_ClassList3.default.registerClass(_CGPoint2.default, 'CGPoint');
_ClassList3.default.registerClass(_CGRect2.default, 'CGRect');
_ClassList3.default.registerClass(_CGSize2.default, 'CGSize');
_ClassList3.default.registerClass(_CGVector2.default, 'CGVector');
_ClassList3.default.registerClass(_DispatchObject2.default, 'DispatchObject');
_ClassList3.default.registerClass(_DispatchQueue2.default, 'DispatchQueue');
_ClassList3.default.registerClass(_DispatchTime2.default, 'DispatchTime');
_ClassList3.default.registerClass(_DispatchTimeInterval2.default, 'DispatchTimeInterval');
_ClassList3.default.registerClass(_NotificationCenter2.default, 'NotificationCenter');
_ClassList3.default.registerClass(_NSArray2.default, 'NSArray');
_ClassList3.default.registerClass(_NSCoder2.default, 'NSCoder');
_ClassList3.default.registerClass(_NSColorSpace2.default, 'NSColorSpace');
_ClassList3.default.registerClass(_NSData2.default, 'NSData');
_ClassList3.default.registerClass(_NSDictionary2.default, 'NSDictionary');
_ClassList3.default.registerClass(_NSKeyedArchiver2.default, 'NSKeyedArchiver');
_ClassList3.default.registerClass(_NSKeyedUnarchiver2.default, 'NSKeyedUnarchiver');
_ClassList3.default.registerClass(_NSMutableArray2.default, 'NSMutableArray');
_ClassList3.default.registerClass(_NSMutableData2.default, 'NSMutableData');
_ClassList3.default.registerClass(_NSMutableDictionary2.default, 'NSMutableDictionary');
_ClassList3.default.registerClass(_NSNotification2.default, 'NSNotification');
_ClassList3.default.registerClass(_NSURL2.default, 'NSURL');
_ClassList3.default.registerClass(_NSValue2.default, 'NSValue');
_ClassList3.default.registerClass(_GCController2.default, 'GCController');
_ClassList3.default.registerClass(_GCControllerAxisInput2.default, 'GCControllerAxisInput');
_ClassList3.default.registerClass(_GCControllerButtonInput2.default, 'GCControllerButtonInput');
_ClassList3.default.registerClass(_GCControllerDirectionPad2.default, 'GCControllerDirectionPad');
_ClassList3.default.registerClass(_GCControllerElement2.default, 'GCControllerElement');
_ClassList3.default.registerClass(_GCExtendedGamepad2.default, 'GCExtendedGamepad');
_ClassList3.default.registerClass(_GCGamepad2.default, 'GCGamepad');
_ClassList3.default.registerClass(_GCMicroGamepad2.default, 'GCMicroGamepad');
_ClassList3.default.registerClass(_GKAgent2.default, 'GKAgent');
_ClassList3.default.registerClass(_GKAgent2D2.default, 'GKAgent2D');
_ClassList3.default.registerClass(_GKAgentDelegate2.default, 'GKAgentDelegate');
_ClassList3.default.registerClass(_GKBehavior2.default, 'GKBehavior');
_ClassList3.default.registerClass(_GKComponent2.default, 'GKComponent');
_ClassList3.default.registerClass(_GKEntity2.default, 'GKEntity');
_ClassList3.default.registerClass(_GKGoal2.default, 'GKGoal');
_ClassList3.default.registerClass(_GKPath2.default, 'GKPath');
_ClassList3.default.registerClass(_GKScene2.default, 'GKScene');
_ClassList3.default.registerClass(_GKSCNNodeComponent2.default, 'GKSCNNodeComponent');
_ClassList3.default.registerClass(_MTLTessellationPartitionMode2.default, 'MTLTessellationPartitionMode');
_ClassList3.default.registerClass(_NSObject2.default, 'NSObject');
_ClassList3.default.registerClass(_CAAction2.default, 'CAAction');
_ClassList3.default.registerClass(_CAAnimation2.default, 'CAAnimation');
_ClassList3.default.registerClass(_CAAnimationDelegate2.default, 'CAAnimationDelegate');
_ClassList3.default.registerClass(_CAAnimationGroup2.default, 'CAAnimationGroup');
_ClassList3.default.registerClass(_CABasicAnimation2.default, 'CABasicAnimation');
_ClassList3.default.registerClass(_CACurrentMediaTime2.default, 'CACurrentMediaTime');
_ClassList3.default.registerClass(_CAKeyframeAnimation2.default, 'CAKeyframeAnimation');
_ClassList3.default.registerClass(_CAMediaTiming2.default, 'CAMediaTiming');
_ClassList3.default.registerClass(_CAMediaTimingFunction2.default, 'CAMediaTimingFunction');
_ClassList3.default.registerClass(_CAPropertyAnimation2.default, 'CAPropertyAnimation');
_ClassList3.default.registerClass(_CATransform3D2.default, 'CATransform3D');
_ClassList3.default.registerClass(_SCNAccelerationConstraint2.default, 'SCNAccelerationConstraint');
_ClassList3.default.registerClass(_SCNAction2.default, 'SCNAction');
_ClassList3.default.registerClass(_SCNActionable2.default, 'SCNActionable');
_ClassList3.default.registerClass(_SCNActionCustom2.default, 'SCNActionCustom');
_ClassList3.default.registerClass(_SCNActionFade2.default, 'SCNActionFade');
_ClassList3.default.registerClass(_SCNActionGroup2.default, 'SCNActionGroup');
_ClassList3.default.registerClass(_SCNActionHide2.default, 'SCNActionHide');
_ClassList3.default.registerClass(_SCNActionJavaScript2.default, 'SCNActionJavaScript');
_ClassList3.default.registerClass(_SCNActionMove2.default, 'SCNActionMove');
_ClassList3.default.registerClass(_SCNActionPerformSelector2.default, 'SCNActionPerformSelector');
_ClassList3.default.registerClass(_SCNActionPlaySound2.default, 'SCNActionPlaySound');
_ClassList3.default.registerClass(_SCNActionReference2.default, 'SCNActionReference');
_ClassList3.default.registerClass(_SCNActionRemove2.default, 'SCNActionRemove');
_ClassList3.default.registerClass(_SCNActionRepeat2.default, 'SCNActionRepeat');
_ClassList3.default.registerClass(_SCNActionRotate2.default, 'SCNActionRotate');
_ClassList3.default.registerClass(_SCNActionRunAction2.default, 'SCNActionRunAction');
_ClassList3.default.registerClass(_SCNActionRunBlock2.default, 'SCNActionRunBlock');
_ClassList3.default.registerClass(_SCNActionScale2.default, 'SCNActionScale');
_ClassList3.default.registerClass(_SCNActionSequence2.default, 'SCNActionSequence');
_ClassList3.default.registerClass(_SCNActionTimingFunction2.default, 'SCNActionTimingFunction');
_ClassList3.default.registerClass(_SCNActionTimingMode2.default, 'SCNActionTimingMode');
_ClassList3.default.registerClass(_SCNActionWait2.default, 'SCNActionWait');
_ClassList3.default.registerClass(_SCNAnimatable2.default, 'SCNAnimatable');
_ClassList3.default.registerClass(_SCNAnimation2.default, 'SCNAnimation');
_ClassList3.default.registerClass(_SCNAnimationEvent2.default, 'SCNAnimationEvent');
_ClassList3.default.registerClass(_SCNAnimationEventBlock2.default, 'SCNAnimationEventBlock');
_ClassList3.default.registerClass(_SCNAnimationPlayer2.default, 'SCNAnimationPlayer');
_ClassList3.default.registerClass(_SCNAntialiasingMode2.default, 'SCNAntialiasingMode');
_ClassList3.default.registerClass(_SCNAudioPlayer2.default, 'SCNAudioPlayer');
_ClassList3.default.registerClass(_SCNAudioSource2.default, 'SCNAudioSource');
_ClassList3.default.registerClass(_SCNBillboardAxis2.default, 'SCNBillboardAxis');
_ClassList3.default.registerClass(_SCNBillboardConstraint2.default, 'SCNBillboardConstraint');
_ClassList3.default.registerClass(_SCNBindingBlock2.default, 'SCNBindingBlock');
_ClassList3.default.registerClass(_SCNBlendMode2.default, 'SCNBlendMode');
_ClassList3.default.registerClass(_SCNBoundingVolume2.default, 'SCNBoundingVolume');
_ClassList3.default.registerClass(_SCNBox2.default, 'SCNBox');
_ClassList3.default.registerClass(_SCNBufferBindingBlock2.default, 'SCNBufferBindingBlock');
_ClassList3.default.registerClass(_SCNBufferFrequency2.default, 'SCNBufferFrequency');
_ClassList3.default.registerClass(_SCNBufferStream2.default, 'SCNBufferStream');
_ClassList3.default.registerClass(_SCNCamera2.default, 'SCNCamera');
_ClassList3.default.registerClass(_SCNCameraProjectionDirection2.default, 'SCNCameraProjectionDirection');
_ClassList3.default.registerClass(_SCNCapsule2.default, 'SCNCapsule');
_ClassList3.default.registerClass(_SCNChamferMode2.default, 'SCNChamferMode');
_ClassList3.default.registerClass(_SCNColorMask2.default, 'SCNColorMask');
_ClassList3.default.registerClass(_SCNCone2.default, 'SCNCone');
_ClassList3.default.registerClass(_SCNConstraint2.default, 'SCNConstraint');
_ClassList3.default.registerClass(_SCNCullMode2.default, 'SCNCullMode');
_ClassList3.default.registerClass(_SCNCylinder2.default, 'SCNCylinder');
_ClassList3.default.registerClass(_SCNDebugOptions2.default, 'SCNDebugOptions');
_ClassList3.default.registerClass(_SCNDistanceConstraint2.default, 'SCNDistanceConstraint');
_ClassList3.default.registerClass(_SCNFieldForceEvaluator2.default, 'SCNFieldForceEvaluator');
_ClassList3.default.registerClass(_SCNFillMode2.default, 'SCNFillMode');
_ClassList3.default.registerClass(_SCNFilterMode2.default, 'SCNFilterMode');
_ClassList3.default.registerClass(_SCNFloor2.default, 'SCNFloor');
_ClassList3.default.registerClass(_SCNGeometry2.default, 'SCNGeometry');
_ClassList3.default.registerClass(_SCNGeometryElement2.default, 'SCNGeometryElement');
_ClassList3.default.registerClass(_SCNGeometryPrimitiveType2.default, 'SCNGeometryPrimitiveType');
_ClassList3.default.registerClass(_SCNGeometrySource2.default, 'SCNGeometrySource');
_ClassList3.default.registerClass(_SCNGeometryTessellator2.default, 'SCNGeometryTessellator');
_ClassList3.default.registerClass(_SCNHitTestOption2.default, 'SCNHitTestOption');
_ClassList3.default.registerClass(_SCNHitTestResult2.default, 'SCNHitTestResult');
_ClassList3.default.registerClass(_SCNIKConstraint2.default, 'SCNIKConstraint');
_ClassList3.default.registerClass(_SCNLayer2.default, 'SCNLayer');
_ClassList3.default.registerClass(_SCNLevelOfDetail2.default, 'SCNLevelOfDetail');
_ClassList3.default.registerClass(_SCNLight2.default, 'SCNLight');
_ClassList3.default.registerClass(_SCNLookAtConstraint2.default, 'SCNLookAtConstraint');
_ClassList3.default.registerClass(_SCNMaterial2.default, 'SCNMaterial');
_ClassList3.default.registerClass(_SCNMaterialProperty2.default, 'SCNMaterialProperty');
_ClassList3.default.registerClass(_SCNMatrix2.default, 'SCNMatrix4');
_ClassList3.default.registerClass(_SCNMatrix4EqualToMatrix2.default, 'SCNMatrix4EqualToMatrix4');
_ClassList3.default.registerClass(_SCNMatrix4FromGLKMatrix2.default, 'SCNMatrix4FromGLKMatrix4');
_ClassList3.default.registerClass(_SCNMatrix4FromMat2.default, 'SCNMatrix4FromMat4');
_ClassList3.default.registerClass(_SCNMatrix4Invert2.default, 'SCNMatrix4Invert');
_ClassList3.default.registerClass(_SCNMatrix4IsIdentity2.default, 'SCNMatrix4IsIdentity');
_ClassList3.default.registerClass(_SCNMatrix4MakeRotation2.default, 'SCNMatrix4MakeRotation');
_ClassList3.default.registerClass(_SCNMatrix4MakeScale2.default, 'SCNMatrix4MakeScale');
_ClassList3.default.registerClass(_SCNMatrix4MakeTranslation2.default, 'SCNMatrix4MakeTranslation');
_ClassList3.default.registerClass(_SCNMatrix4Mult2.default, 'SCNMatrix4Mult');
_ClassList3.default.registerClass(_SCNMatrix4Rotate2.default, 'SCNMatrix4Rotate');
_ClassList3.default.registerClass(_SCNMatrix4Scale2.default, 'SCNMatrix4Scale');
_ClassList3.default.registerClass(_SCNMatrix4ToGLKMatrix2.default, 'SCNMatrix4ToGLKMatrix4');
_ClassList3.default.registerClass(_SCNMatrix4ToMat2.default, 'SCNMatrix4ToMat4');
_ClassList3.default.registerClass(_SCNMatrix4Translate2.default, 'SCNMatrix4Translate');
_ClassList3.default.registerClass(_SCNMorpher2.default, 'SCNMorpher');
_ClassList3.default.registerClass(_SCNMorpherCalculationMode2.default, 'SCNMorpherCalculationMode');
_ClassList3.default.registerClass(_SCNMovabilityHint2.default, 'SCNMovabilityHint');
_ClassList3.default.registerClass(_SCNNode2.default, 'SCNNode');
_ClassList3.default.registerClass(_SCNNodeRendererDelegate2.default, 'SCNNodeRendererDelegate');
_ClassList3.default.registerClass(_SCNOrderedDictionary2.default, 'SCNOrderedDictionary');
_ClassList3.default.registerClass(_SCNParticleBirthDirection2.default, 'SCNParticleBirthDirection');
_ClassList3.default.registerClass(_SCNParticleBirthLocation2.default, 'SCNParticleBirthLocation');
_ClassList3.default.registerClass(_SCNParticleBlendMode2.default, 'SCNParticleBlendMode');
_ClassList3.default.registerClass(_SCNParticleEvent2.default, 'SCNParticleEvent');
_ClassList3.default.registerClass(_SCNParticleEventBlock2.default, 'SCNParticleEventBlock');
_ClassList3.default.registerClass(_SCNParticleImageSequenceAnimationMode2.default, 'SCNParticleImageSequenceAnimationMode');
_ClassList3.default.registerClass(_SCNParticleInputMode2.default, 'SCNParticleInputMode');
_ClassList3.default.registerClass(_SCNParticleModifierBlock2.default, 'SCNParticleModifierBlock');
_ClassList3.default.registerClass(_SCNParticleModifierStage2.default, 'SCNParticleModifierStage');
_ClassList3.default.registerClass(_SCNParticleOrientationMode2.default, 'SCNParticleOrientationMode');
_ClassList3.default.registerClass(_SCNParticlePropertyController2.default, 'SCNParticlePropertyController');
_ClassList3.default.registerClass(_SCNParticleSortingMode2.default, 'SCNParticleSortingMode');
_ClassList3.default.registerClass(_SCNParticleSystem2.default, 'SCNParticleSystem');
_ClassList3.default.registerClass(_SCNPhysicsBallSocketJoint2.default, 'SCNPhysicsBallSocketJoint');
_ClassList3.default.registerClass(_SCNPhysicsBehavior2.default, 'SCNPhysicsBehavior');
_ClassList3.default.registerClass(_SCNPhysicsBody2.default, 'SCNPhysicsBody');
_ClassList3.default.registerClass(_SCNPhysicsBodyType2.default, 'SCNPhysicsBodyType');
_ClassList3.default.registerClass(_SCNPhysicsCollisionCategory2.default, 'SCNPhysicsCollisionCategory');
_ClassList3.default.registerClass(_SCNPhysicsContact2.default, 'SCNPhysicsContact');
_ClassList3.default.registerClass(_SCNPhysicsContactDelegate2.default, 'SCNPhysicsContactDelegate');
_ClassList3.default.registerClass(_SCNPhysicsField2.default, 'SCNPhysicsField');
_ClassList3.default.registerClass(_SCNPhysicsFieldScope2.default, 'SCNPhysicsFieldScope');
_ClassList3.default.registerClass(_SCNPhysicsHingeJoint2.default, 'SCNPhysicsHingeJoint');
_ClassList3.default.registerClass(_SCNPhysicsNoiseField2.default, 'SCNPhysicsNoiseField');
_ClassList3.default.registerClass(_SCNPhysicsShape2.default, 'SCNPhysicsShape');
_ClassList3.default.registerClass(_SCNPhysicsSliderJoint2.default, 'SCNPhysicsSliderJoint');
_ClassList3.default.registerClass(_SCNPhysicsTurbulenceField2.default, 'SCNPhysicsTurbulenceField');
_ClassList3.default.registerClass(_SCNPhysicsVehicle2.default, 'SCNPhysicsVehicle');
_ClassList3.default.registerClass(_SCNPhysicsVehicleWheel2.default, 'SCNPhysicsVehicleWheel');
_ClassList3.default.registerClass(_SCNPhysicsWorld2.default, 'SCNPhysicsWorld');
_ClassList3.default.registerClass(_SCNPlane2.default, 'SCNPlane');
_ClassList3.default.registerClass(_SCNProgram2.default, 'SCNProgram');
_ClassList3.default.registerClass(_SCNProgramDelegate2.default, 'SCNProgramDelegate');
_ClassList3.default.registerClass(_SCNPyramid2.default, 'SCNPyramid');
_ClassList3.default.registerClass(_SCNQuaternion2.default, 'SCNQuaternion');
_ClassList3.default.registerClass(_SCNReferenceLoadingPolicy2.default, 'SCNReferenceLoadingPolicy');
_ClassList3.default.registerClass(_SCNReferenceNode2.default, 'SCNReferenceNode');
_ClassList3.default.registerClass(_SCNRenderer2.default, 'SCNRenderer');
_ClassList3.default.registerClass(_SCNRenderingAPI2.default, 'SCNRenderingAPI');
_ClassList3.default.registerClass(_SCNScene2.default, 'SCNScene');
_ClassList3.default.registerClass(_SCNSceneExportDelegate2.default, 'SCNSceneExportDelegate');
_ClassList3.default.registerClass(_SCNSceneExportProgressHandler2.default, 'SCNSceneExportProgressHandler');
_ClassList3.default.registerClass(_SCNSceneRenderer2.default, 'SCNSceneRenderer');
_ClassList3.default.registerClass(_SCNSceneRendererDelegate2.default, 'SCNSceneRendererDelegate');
_ClassList3.default.registerClass(_SCNSceneSource2.default, 'SCNSceneSource');
_ClassList3.default.registerClass(_SCNSceneSourceStatus2.default, 'SCNSceneSourceStatus');
_ClassList3.default.registerClass(_SCNSceneSourceStatusHandler2.default, 'SCNSceneSourceStatusHandler');
_ClassList3.default.registerClass(_SCNShadable2.default, 'SCNShadable');
_ClassList3.default.registerClass(_SCNShadableHelper2.default, 'SCNShadableHelper');
_ClassList3.default.registerClass(_SCNShaderModifierEntryPoint2.default, 'SCNShaderModifierEntryPoint');
_ClassList3.default.registerClass(_SCNShadowMode2.default, 'SCNShadowMode');
_ClassList3.default.registerClass(_SCNShape2.default, 'SCNShape');
_ClassList3.default.registerClass(_SCNSkinner2.default, 'SCNSkinner');
_ClassList3.default.registerClass(_SCNSphere2.default, 'SCNSphere');
_ClassList3.default.registerClass(_SCNTechnique2.default, 'SCNTechnique');
_ClassList3.default.registerClass(_SCNTechniqueSupport2.default, 'SCNTechniqueSupport');
_ClassList3.default.registerClass(_SCNTessellationSmoothingMode2.default, 'SCNTessellationSmoothingMode');
_ClassList3.default.registerClass(_SCNText2.default, 'SCNText');
_ClassList3.default.registerClass(_SCNTimingFunction2.default, 'SCNTimingFunction');
_ClassList3.default.registerClass(_SCNTorus2.default, 'SCNTorus');
_ClassList3.default.registerClass(_SCNTransaction2.default, 'SCNTransaction');
_ClassList3.default.registerClass(_SCNTransformConstraint2.default, 'SCNTransformConstraint');
_ClassList3.default.registerClass(_SCNTransparencyMode2.default, 'SCNTransparencyMode');
_ClassList3.default.registerClass(_SCNTube2.default, 'SCNTube');
_ClassList3.default.registerClass(_SCNVector2.default, 'SCNVector3');
_ClassList3.default.registerClass(_SCNVector3EqualToVector2.default, 'SCNVector3EqualToVector3');
_ClassList3.default.registerClass(_SCNVector3FromFloat2.default, 'SCNVector3FromFloat3');
_ClassList3.default.registerClass(_SCNVector3FromGLKVector2.default, 'SCNVector3FromGLKVector3');
_ClassList3.default.registerClass(_SCNVector3Make2.default, 'SCNVector3Make');
_ClassList3.default.registerClass(_SCNVector3ToFloat2.default, 'SCNVector3ToFloat3');
_ClassList3.default.registerClass(_SCNVector3ToGLKVector2.default, 'SCNVector3ToGLKVector3');
_ClassList3.default.registerClass(_SCNVector3Zero2.default, 'SCNVector3Zero');
_ClassList3.default.registerClass(_SCNVector4.default, 'SCNVector4');
_ClassList3.default.registerClass(_SCNVector4EqualToVector2.default, 'SCNVector4EqualToVector4');
_ClassList3.default.registerClass(_SCNVector4FromFloat2.default, 'SCNVector4FromFloat4');
_ClassList3.default.registerClass(_SCNVector4FromGLKVector2.default, 'SCNVector4FromGLKVector4');
_ClassList3.default.registerClass(_SCNVector4Make2.default, 'SCNVector4Make');
_ClassList3.default.registerClass(_SCNVector4ToFloat2.default, 'SCNVector4ToFloat4');
_ClassList3.default.registerClass(_SCNVector4ToGLKVector2.default, 'SCNVector4ToGLKVector4');
_ClassList3.default.registerClass(_SCNView2.default, 'SCNView');
_ClassList3.default.registerClass(_SCNWrapMode2.default, 'SCNWrapMode');
_ClassList3.default.registerClass(_SKAction2.default, 'SKAction');
_ClassList3.default.registerClass(_SKActionTimingMode2.default, 'SKActionTimingMode');
_ClassList3.default.registerClass(_SKBlendMode2.default, 'SKBlendMode');
_ClassList3.default.registerClass(_SKColor2.default, 'SKColor');
_ClassList3.default.registerClass(_SKEffectNode2.default, 'SKEffectNode');
_ClassList3.default.registerClass(_SKFade2.default, 'SKFade');
_ClassList3.default.registerClass(_SKGroup2.default, 'SKGroup');
_ClassList3.default.registerClass(_SKLabelHorizontalAlignmentMode2.default, 'SKLabelHorizontalAlignmentMode');
_ClassList3.default.registerClass(_SKLabelNode2.default, 'SKLabelNode');
_ClassList3.default.registerClass(_SKLabelVerticalAlignmentMode2.default, 'SKLabelVerticalAlignmentMode');
_ClassList3.default.registerClass(_SKNode2.default, 'SKNode');
_ClassList3.default.registerClass(_SKRepeat2.default, 'SKRepeat');
_ClassList3.default.registerClass(_SKScale2.default, 'SKScale');
_ClassList3.default.registerClass(_SKScene2.default, 'SKScene');
_ClassList3.default.registerClass(_SKSceneScaleMode2.default, 'SKSceneScaleMode');
_ClassList3.default.registerClass(_SKSequence2.default, 'SKSequence');
_ClassList3.default.registerClass(_SKShapeNode2.default, 'SKShapeNode');
_ClassList3.default.registerClass(_SKSpriteNode2.default, 'SKSpriteNode');
_ClassList3.default.registerClass(_SKTexture2.default, 'SKTexture');
_ClassList3.default.registerClass(_SKTextureFilteringMode2.default, 'SKTextureFilteringMode');
_ClassList3.default.registerClass(_SKWait2.default, 'SKWait'

/*global exports*/
);exports.NSColor = _NSColor2.default;
exports.NSColorSpaceModel = _NSColorSpaceModel2.default;
exports.AVAudioMixerNode = _AVAudioMixerNode2.default;
exports.AVAudioNode = _AVAudioNode2.default;
exports.CFAbsoluteTimeGetCurrent = _CFAbsoluteTimeGetCurrent2.default;
exports.CGBlendMode = _CGBlendMode2.default;
exports.CGLineCap = _CGLineCap2.default;
exports.CGLineJoin = _CGLineJoin2.default;
exports.CGMutablePath = _CGMutablePath2.default;
exports.CGPath = _CGPath2.default;
exports.CGPathApplierFunction = _CGPathApplierFunction2.default;
exports.CGPathFillRule = _CGPathFillRule2.default;
exports.CGPoint = _CGPoint2.default;
exports.CGRect = _CGRect2.default;
exports.CGSize = _CGSize2.default;
exports.CGVector = _CGVector2.default;
exports.DispatchObject = _DispatchObject2.default;
exports.DispatchQueue = _DispatchQueue2.default;
exports.DispatchTime = _DispatchTime2.default;
exports.DispatchTimeInterval = _DispatchTimeInterval2.default;
exports.NotificationCenter = _NotificationCenter2.default;
exports.NSArray = _NSArray2.default;
exports.NSCoder = _NSCoder2.default;
exports.NSColorSpace = _NSColorSpace2.default;
exports.NSData = _NSData2.default;
exports.NSDictionary = _NSDictionary2.default;
exports.NSKeyedArchiver = _NSKeyedArchiver2.default;
exports.NSKeyedUnarchiver = _NSKeyedUnarchiver2.default;
exports.NSMutableArray = _NSMutableArray2.default;
exports.NSMutableData = _NSMutableData2.default;
exports.NSMutableDictionary = _NSMutableDictionary2.default;
exports.NSNotification = _NSNotification2.default;
exports.NSURL = _NSURL2.default;
exports.NSValue = _NSValue2.default;
exports.GCController = _GCController2.default;
exports.GCControllerAxisInput = _GCControllerAxisInput2.default;
exports.GCControllerButtonInput = _GCControllerButtonInput2.default;
exports.GCControllerDirectionPad = _GCControllerDirectionPad2.default;
exports.GCControllerElement = _GCControllerElement2.default;
exports.GCExtendedGamepad = _GCExtendedGamepad2.default;
exports.GCGamepad = _GCGamepad2.default;
exports.GCMicroGamepad = _GCMicroGamepad2.default;
exports.GKAgent = _GKAgent2.default;
exports.GKAgent2D = _GKAgent2D2.default;
exports.GKAgentDelegate = _GKAgentDelegate2.default;
exports.GKBehavior = _GKBehavior2.default;
exports.GKComponent = _GKComponent2.default;
exports.GKEntity = _GKEntity2.default;
exports.GKGoal = _GKGoal2.default;
exports.GKPath = _GKPath2.default;
exports.GKScene = _GKScene2.default;
exports.GKSCNNodeComponent = _GKSCNNodeComponent2.default;
exports.MTLTessellationPartitionMode = _MTLTessellationPartitionMode2.default;
exports.NSObject = _NSObject2.default;
exports.CAAction = _CAAction2.default;
exports.CAAnimation = _CAAnimation2.default;
exports.CAAnimationDelegate = _CAAnimationDelegate2.default;
exports.CAAnimationGroup = _CAAnimationGroup2.default;
exports.CABasicAnimation = _CABasicAnimation2.default;
exports.CACurrentMediaTime = _CACurrentMediaTime2.default;
exports.CAKeyframeAnimation = _CAKeyframeAnimation2.default;
exports.CAMediaTiming = _CAMediaTiming2.default;
exports.CAMediaTimingFunction = _CAMediaTimingFunction2.default;
exports.CAPropertyAnimation = _CAPropertyAnimation2.default;
exports.CATransform3D = _CATransform3D2.default;
exports.SCNAccelerationConstraint = _SCNAccelerationConstraint2.default;
exports.SCNAction = _SCNAction2.default;
exports.SCNActionable = _SCNActionable2.default;
exports.SCNActionCustom = _SCNActionCustom2.default;
exports.SCNActionFade = _SCNActionFade2.default;
exports.SCNActionGroup = _SCNActionGroup2.default;
exports.SCNActionHide = _SCNActionHide2.default;
exports.SCNActionJavaScript = _SCNActionJavaScript2.default;
exports.SCNActionMove = _SCNActionMove2.default;
exports.SCNActionPerformSelector = _SCNActionPerformSelector2.default;
exports.SCNActionPlaySound = _SCNActionPlaySound2.default;
exports.SCNActionReference = _SCNActionReference2.default;
exports.SCNActionRemove = _SCNActionRemove2.default;
exports.SCNActionRepeat = _SCNActionRepeat2.default;
exports.SCNActionRotate = _SCNActionRotate2.default;
exports.SCNActionRunAction = _SCNActionRunAction2.default;
exports.SCNActionRunBlock = _SCNActionRunBlock2.default;
exports.SCNActionScale = _SCNActionScale2.default;
exports.SCNActionSequence = _SCNActionSequence2.default;
exports.SCNActionTimingFunction = _SCNActionTimingFunction2.default;
exports.SCNActionTimingMode = _SCNActionTimingMode2.default;
exports.SCNActionWait = _SCNActionWait2.default;
exports.SCNAnimatable = _SCNAnimatable2.default;
exports.SCNAnimation = _SCNAnimation2.default;
exports.SCNAnimationEvent = _SCNAnimationEvent2.default;
exports.SCNAnimationEventBlock = _SCNAnimationEventBlock2.default;
exports.SCNAnimationPlayer = _SCNAnimationPlayer2.default;
exports.SCNAntialiasingMode = _SCNAntialiasingMode2.default;
exports.SCNAudioPlayer = _SCNAudioPlayer2.default;
exports.SCNAudioSource = _SCNAudioSource2.default;
exports.SCNBillboardAxis = _SCNBillboardAxis2.default;
exports.SCNBillboardConstraint = _SCNBillboardConstraint2.default;
exports.SCNBindingBlock = _SCNBindingBlock2.default;
exports.SCNBlendMode = _SCNBlendMode2.default;
exports.SCNBoundingVolume = _SCNBoundingVolume2.default;
exports.SCNBox = _SCNBox2.default;
exports.SCNBufferBindingBlock = _SCNBufferBindingBlock2.default;
exports.SCNBufferFrequency = _SCNBufferFrequency2.default;
exports.SCNBufferStream = _SCNBufferStream2.default;
exports.SCNCamera = _SCNCamera2.default;
exports.SCNCameraProjectionDirection = _SCNCameraProjectionDirection2.default;
exports.SCNCapsule = _SCNCapsule2.default;
exports.SCNChamferMode = _SCNChamferMode2.default;
exports.SCNColorMask = _SCNColorMask2.default;
exports.SCNCone = _SCNCone2.default;
exports.SCNConstraint = _SCNConstraint2.default;
exports.SCNCullMode = _SCNCullMode2.default;
exports.SCNCylinder = _SCNCylinder2.default;
exports.SCNDebugOptions = _SCNDebugOptions2.default;
exports.SCNDistanceConstraint = _SCNDistanceConstraint2.default;
exports.SCNFieldForceEvaluator = _SCNFieldForceEvaluator2.default;
exports.SCNFillMode = _SCNFillMode2.default;
exports.SCNFilterMode = _SCNFilterMode2.default;
exports.SCNFloor = _SCNFloor2.default;
exports.SCNGeometry = _SCNGeometry2.default;
exports.SCNGeometryElement = _SCNGeometryElement2.default;
exports.SCNGeometryPrimitiveType = _SCNGeometryPrimitiveType2.default;
exports.SCNGeometrySource = _SCNGeometrySource2.default;
exports.SCNGeometryTessellator = _SCNGeometryTessellator2.default;
exports.SCNHitTestOption = _SCNHitTestOption2.default;
exports.SCNHitTestResult = _SCNHitTestResult2.default;
exports.SCNIKConstraint = _SCNIKConstraint2.default;
exports.SCNLayer = _SCNLayer2.default;
exports.SCNLevelOfDetail = _SCNLevelOfDetail2.default;
exports.SCNLight = _SCNLight2.default;
exports.SCNLookAtConstraint = _SCNLookAtConstraint2.default;
exports.SCNMaterial = _SCNMaterial2.default;
exports.SCNMaterialProperty = _SCNMaterialProperty2.default;
exports.SCNMatrix4 = _SCNMatrix2.default;
exports.SCNMatrix4EqualToMatrix4 = _SCNMatrix4EqualToMatrix2.default;
exports.SCNMatrix4FromGLKMatrix4 = _SCNMatrix4FromGLKMatrix2.default;
exports.SCNMatrix4FromMat4 = _SCNMatrix4FromMat2.default;
exports.SCNMatrix4Invert = _SCNMatrix4Invert2.default;
exports.SCNMatrix4IsIdentity = _SCNMatrix4IsIdentity2.default;
exports.SCNMatrix4MakeRotation = _SCNMatrix4MakeRotation2.default;
exports.SCNMatrix4MakeScale = _SCNMatrix4MakeScale2.default;
exports.SCNMatrix4MakeTranslation = _SCNMatrix4MakeTranslation2.default;
exports.SCNMatrix4Mult = _SCNMatrix4Mult2.default;
exports.SCNMatrix4Rotate = _SCNMatrix4Rotate2.default;
exports.SCNMatrix4Scale = _SCNMatrix4Scale2.default;
exports.SCNMatrix4ToGLKMatrix4 = _SCNMatrix4ToGLKMatrix2.default;
exports.SCNMatrix4ToMat4 = _SCNMatrix4ToMat2.default;
exports.SCNMatrix4Translate = _SCNMatrix4Translate2.default;
exports.SCNMorpher = _SCNMorpher2.default;
exports.SCNMorpherCalculationMode = _SCNMorpherCalculationMode2.default;
exports.SCNMovabilityHint = _SCNMovabilityHint2.default;
exports.SCNNode = _SCNNode2.default;
exports.SCNNodeRendererDelegate = _SCNNodeRendererDelegate2.default;
exports.SCNOrderedDictionary = _SCNOrderedDictionary2.default;
exports.SCNParticleBirthDirection = _SCNParticleBirthDirection2.default;
exports.SCNParticleBirthLocation = _SCNParticleBirthLocation2.default;
exports.SCNParticleBlendMode = _SCNParticleBlendMode2.default;
exports.SCNParticleEvent = _SCNParticleEvent2.default;
exports.SCNParticleEventBlock = _SCNParticleEventBlock2.default;
exports.SCNParticleImageSequenceAnimationMode = _SCNParticleImageSequenceAnimationMode2.default;
exports.SCNParticleInputMode = _SCNParticleInputMode2.default;
exports.SCNParticleModifierBlock = _SCNParticleModifierBlock2.default;
exports.SCNParticleModifierStage = _SCNParticleModifierStage2.default;
exports.SCNParticleOrientationMode = _SCNParticleOrientationMode2.default;
exports.SCNParticlePropertyController = _SCNParticlePropertyController2.default;
exports.SCNParticleSortingMode = _SCNParticleSortingMode2.default;
exports.SCNParticleSystem = _SCNParticleSystem2.default;
exports.SCNPhysicsBallSocketJoint = _SCNPhysicsBallSocketJoint2.default;
exports.SCNPhysicsBehavior = _SCNPhysicsBehavior2.default;
exports.SCNPhysicsBody = _SCNPhysicsBody2.default;
exports.SCNPhysicsBodyType = _SCNPhysicsBodyType2.default;
exports.SCNPhysicsCollisionCategory = _SCNPhysicsCollisionCategory2.default;
exports.SCNPhysicsContact = _SCNPhysicsContact2.default;
exports.SCNPhysicsContactDelegate = _SCNPhysicsContactDelegate2.default;
exports.SCNPhysicsField = _SCNPhysicsField2.default;
exports.SCNPhysicsFieldScope = _SCNPhysicsFieldScope2.default;
exports.SCNPhysicsHingeJoint = _SCNPhysicsHingeJoint2.default;
exports.SCNPhysicsNoiseField = _SCNPhysicsNoiseField2.default;
exports.SCNPhysicsShape = _SCNPhysicsShape2.default;
exports.SCNPhysicsSliderJoint = _SCNPhysicsSliderJoint2.default;
exports.SCNPhysicsTurbulenceField = _SCNPhysicsTurbulenceField2.default;
exports.SCNPhysicsVehicle = _SCNPhysicsVehicle2.default;
exports.SCNPhysicsVehicleWheel = _SCNPhysicsVehicleWheel2.default;
exports.SCNPhysicsWorld = _SCNPhysicsWorld2.default;
exports.SCNPlane = _SCNPlane2.default;
exports.SCNProgram = _SCNProgram2.default;
exports.SCNProgramDelegate = _SCNProgramDelegate2.default;
exports.SCNPyramid = _SCNPyramid2.default;
exports.SCNQuaternion = _SCNQuaternion2.default;
exports.SCNReferenceLoadingPolicy = _SCNReferenceLoadingPolicy2.default;
exports.SCNReferenceNode = _SCNReferenceNode2.default;
exports.SCNRenderer = _SCNRenderer2.default;
exports.SCNRenderingAPI = _SCNRenderingAPI2.default;
exports.SCNScene = _SCNScene2.default;
exports.SCNSceneExportDelegate = _SCNSceneExportDelegate2.default;
exports.SCNSceneExportProgressHandler = _SCNSceneExportProgressHandler2.default;
exports.SCNSceneRenderer = _SCNSceneRenderer2.default;
exports.SCNSceneRendererDelegate = _SCNSceneRendererDelegate2.default;
exports.SCNSceneSource = _SCNSceneSource2.default;
exports.SCNSceneSourceStatus = _SCNSceneSourceStatus2.default;
exports.SCNSceneSourceStatusHandler = _SCNSceneSourceStatusHandler2.default;
exports.SCNShadable = _SCNShadable2.default;
exports.SCNShadableHelper = _SCNShadableHelper2.default;
exports.SCNShaderModifierEntryPoint = _SCNShaderModifierEntryPoint2.default;
exports.SCNShadowMode = _SCNShadowMode2.default;
exports.SCNShape = _SCNShape2.default;
exports.SCNSkinner = _SCNSkinner2.default;
exports.SCNSphere = _SCNSphere2.default;
exports.SCNTechnique = _SCNTechnique2.default;
exports.SCNTechniqueSupport = _SCNTechniqueSupport2.default;
exports.SCNTessellationSmoothingMode = _SCNTessellationSmoothingMode2.default;
exports.SCNText = _SCNText2.default;
exports.SCNTimingFunction = _SCNTimingFunction2.default;
exports.SCNTorus = _SCNTorus2.default;
exports.SCNTransaction = _SCNTransaction2.default;
exports.SCNTransformConstraint = _SCNTransformConstraint2.default;
exports.SCNTransparencyMode = _SCNTransparencyMode2.default;
exports.SCNTube = _SCNTube2.default;
exports.SCNVector3 = _SCNVector2.default;
exports.SCNVector3EqualToVector3 = _SCNVector3EqualToVector2.default;
exports.SCNVector3FromFloat3 = _SCNVector3FromFloat2.default;
exports.SCNVector3FromGLKVector3 = _SCNVector3FromGLKVector2.default;
exports.SCNVector3Make = _SCNVector3Make2.default;
exports.SCNVector3ToFloat3 = _SCNVector3ToFloat2.default;
exports.SCNVector3ToGLKVector3 = _SCNVector3ToGLKVector2.default;
exports.SCNVector3Zero = _SCNVector3Zero2.default;
exports.SCNVector4 = _SCNVector4.default;
exports.SCNVector4EqualToVector4 = _SCNVector4EqualToVector2.default;
exports.SCNVector4FromFloat4 = _SCNVector4FromFloat2.default;
exports.SCNVector4FromGLKVector4 = _SCNVector4FromGLKVector2.default;
exports.SCNVector4Make = _SCNVector4Make2.default;
exports.SCNVector4ToFloat4 = _SCNVector4ToFloat2.default;
exports.SCNVector4ToGLKVector4 = _SCNVector4ToGLKVector2.default;
exports.SCNView = _SCNView2.default;
exports.SCNWrapMode = _SCNWrapMode2.default;
exports.SKAction = _SKAction2.default;
exports.SKActionTimingMode = _SKActionTimingMode2.default;
exports.SKBlendMode = _SKBlendMode2.default;
exports.SKColor = _SKColor2.default;
exports.SKEffectNode = _SKEffectNode2.default;
exports.SKFade = _SKFade2.default;
exports.SKGroup = _SKGroup2.default;
exports.SKLabelHorizontalAlignmentMode = _SKLabelHorizontalAlignmentMode2.default;
exports.SKLabelNode = _SKLabelNode2.default;
exports.SKLabelVerticalAlignmentMode = _SKLabelVerticalAlignmentMode2.default;
exports.SKNode = _SKNode2.default;
exports.SKRepeat = _SKRepeat2.default;
exports.SKScale = _SKScale2.default;
exports.SKScene = _SKScene2.default;
exports.SKSceneScaleMode = _SKSceneScaleMode2.default;
exports.SKSequence = _SKSequence2.default;
exports.SKShapeNode = _SKShapeNode2.default;
exports.SKSpriteNode = _SKSpriteNode2.default;
exports.SKTexture = _SKTexture2.default;
exports.SKTextureFilteringMode = _SKTextureFilteringMode2.default;
exports.SKWait = _SKWait2.default;
exports._AjaxRequest = _AjaxRequest3.default;
exports._BinaryReader = _BinaryReader3.default;
exports._BinaryRequest = _BinaryRequest3.default;
exports._Buffer = _Buffer3.default;
exports._ClassList = _ClassList3.default;
exports._File = _File3.default;
exports._FileReader = _FileReader3.default;
exports._HTMLCanvasElement = _HTMLCanvasElement3.default;
exports._InstanceOf = _InstanceOf3.default;

// constants
/*global exports*/

// 
exports.kCAFillModeRemoved = 'removed';
exports.kCAFillModeForwards = 'forwards';
exports.kCAFillModeBackwards = 'backwards';
exports.kCAFillModeBoth = 'both';

// 
exports.kCAMediaTimingFunctionLinear = 'linear';
exports.kCAMediaTimingFunctionEaseIn = 'easeIn';
exports.kCAMediaTimingFunctionEaseOut = 'easeOut';
exports.kCAMediaTimingFunctionEaseInEaseOut = 'easeInEaseOut';
exports.kCAMediaTimingFunctionDefault = 'default';

// Value calculation modes
exports.kCAAnimationLinear = 'linear';
exports.kCAAnimationDiscrete = 'discrete';
exports.kCAAnimationPaced = 'paced';
exports.kCAAnimationCubic = 'cubic';
exports.kCAAnimationCubicPaced = 'cubicPaced';

// Rotation Mode Values
exports.kCAAnimationRotateAuto = 'auto';
exports.kCAAnimationRotateAutoReverse = 'autoReverse';

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSObject}
 */
var NSColor = function (_NSObject) {
  _inherits(NSColor, _NSObject);

  function NSColor() {
    _classCallCheck(this, NSColor);

    return _possibleConstructorReturn(this, (NSColor.__proto__ || Object.getPrototypeOf(NSColor)).apply(this, arguments));
  }

  _createClass(NSColor, null, [{
    key: 'initWithCoder',

    /**
     * @access public
     * @param {NSCoder} coder -
     * @returns {_Buffer} -
     */
    value: function initWithCoder(coder) {
      return _SKColor2.default.initWithCoder(coder);
    }
  }]);

  return NSColor;
}(_NSObject3.default);

exports.default = NSColor;

/***/ }),
/* 118 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 120 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 121 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The type of the color-space mode constants listed in Color Space Models.
 * @typedef {Object} NSColorSpaceModel
 * @property {number} CMYK - 
 * @property {number} LAB - 
 * @property {number} RGB - 
 * @property {number} deviceN - 
 * @property {number} gray - 
 * @property {number} indexed - 
 * @property {number} patterned - 
 * @property {number} unknown - 
 * @see https://developer.apple.com/documentation/appkit/nscolorspacemodel
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var NSColorSpaceModel = {
  gray: 0,
  RGB: 1,
  CMYK: 2,
  LAB: 3,
  deviceN: 4,
  indexed: 5,
  patterned: 6,
  unknown: -1
};

exports.default = NSColorSpaceModel;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var baseTime = Date.UTC(2001, 0, 1, 0, 0, 0, 0

/**
 * Returns the current system absolute time.
 * @access public
 * @returns {number} - The current absolute time.
 * @desc Absolute time is measured in seconds relative to the absolute reference date of Jan 1 2001 00:00:00 GMT. A positive value represents a date after the reference date, a negative value represents a date before it. For example, the absolute time -32940326 is equivalent to December 16th, 1999 at 17:54:34. Repeated calls to this function do not guarantee monotonically increasing results. The system time may decrease due to synchronization with external time references or due to an explicit user change of the clock.
 * @see https://developer.apple.com/documentation/corefoundation/1543542-cfabsolutetimegetcurrent
 */
);function CFAbsoluteTimeGetCurrent() {
  return (Date.now() - baseTime) * 0.001;
}

exports.default = CFAbsoluteTimeGetCurrent;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Compositing operations for images.
 * @typedef {Object} CGBlendMode
 * @property {number} normal - Paints the source image samples over the background image samples.
 * @property {number} multiply - Multiplies the source image samples with the background image samples. This results in colors that are at least as dark as either of the two contributing sample colors.
 * @property {number} screen - Multiplies  the inverse of the source image samples with the inverse of the background image samples. This results in colors that are at least as light as either of the two contributing sample colors.
 * @property {number} overlay - 
 * @property {number} darken - 
 * @property {number} lighten - 
 * @property {number} colorDodge - Brightens the background image samples to reflect the source image samples. Source image sample values that specify black do not produce a change.
 * @property {number} colorBurn - Darkens the background image samples to reflect the source image samples. Source image sample values that specify white do not produce a change.
 * @property {number} softLight - 
 * @property {number} hardLight - 
 * @property {number} difference - 
 * @property {number} exclusion - Produces an effect similar to that produced by difference, but with lower contrast. Source image sample values that are black don’t produce a change; white inverts the background color values.
 * @property {number} hue - Uses the luminance and saturation values of the background with the hue of the source image.
 * @property {number} saturation - Uses the luminance and hue values of the background with the saturation of the source image. Areas of the background that have no saturation (that is, pure gray areas) don’t produce a change.
 * @property {number} color - Uses the luminance values of the background with the hue and saturation values of the source image. This mode preserves the gray levels in the image. You can use this mode to color monochrome images or to tint color images.
 * @property {number} luminosity - Uses the hue and saturation of the background with the luminance of the source image. This mode creates an effect that is inverse to the effect created by color.
 * @property {number} clear - R = 0
 * @property {number} copy - R = S
 * @property {number} sourceIn - R = S*Da
 * @property {number} sourceOut - R = S*(1 - Da)
 * @property {number} sourceAtop - R = S*Da + D*(1 - Sa)
 * @property {number} destinationOver - R = S*(1 - Da) + D
 * @property {number} destinationIn - R = D*Sa
 * @property {number} destinationOut - R = D*(1 - Sa)
 * @property {number} destinationAtop - R = S*(1 - Da) + D*Sa
 * @property {number} xor - R = S*(1 - Da) + D*(1 - Sa). This XOR mode is only nominally related to the classical bitmap XOR operation, which is not supported by Core Graphics
 * @property {number} plusDarker - R = MAX(0, 1 - ((1 - D) + (1 - S)))
 * @property {number} plusLighter - R = MIN(1, S + D)
 * @see https://developer.apple.com/documentation/coregraphics/cgblendmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CGBlendMode = {
  normal: 0,
  multiply: 1,
  screen: 2,
  overlay: 3,
  darken: 4,
  lighten: 5,
  colorDodge: 6,
  colorBurn: 7,
  softLight: 8,
  hardLight: 9,
  difference: 10,
  exclusion: 11,
  hue: 12,
  saturation: 13,
  color: 14,
  luminosity: 15,
  clear: 16,
  copy: 17,
  sourceIn: 18,
  sourceOut: 19,
  sourceAtop: 20,
  destinationOver: 21,
  destinationIn: 22,
  destinationOut: 23,
  destinationAtop: 24,
  xor: 25,
  plusDarker: 26,
  plusLighter: 27
};

exports.default = CGBlendMode;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A mutable graphics path: a mathematical description of shapes or lines to be drawn in a graphics context.
 * @access public
 * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CGMutablePath = function () {

  // Creating Graphics Paths

  /**
   * Creates a mutable graphics path.
   * @access public
   * @constructor
   * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/1411209-init
   */
  function CGMutablePath() {
    _classCallCheck(this, CGMutablePath);
  }

  // Copying a Graphics Path

  /**
   * Creates a mutable copy of an existing graphics path.
   * @access public
   * @returns {?CGMutablePath} - 
   * @desc You can modify a mutable graphics path by calling the various path geometry functions, such as addArc(_:x:y:radius:startAngle:endAngle:clockwise:), addLineTo(_:x:y:), and moveTo(_:x:y:).
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411196-mutablecopy
   */


  _createClass(CGMutablePath, [{
    key: 'mutableCopy',
    value: function mutableCopy() {
      return null;
    }

    /**
     * Creates a mutable copy of a graphics path transformed by a transformation matrix.
     * @access public
     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
     * @returns {?CGMutablePath} - 
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411150-mutablecopy
     */

  }, {
    key: 'mutableCopyUsing',
    value: function mutableCopyUsing(transform) {
      return null;
    }

    // Constructing a Graphics Path

    /**
     * Begins a new subpath at the specified point.  
     * @access public
     * @param {CGPoint} point - The point, in user space coordinates, at which to start a new subpath.
     * @param {CGAffineTransform} transform - An affine transform to apply to the point before adding to the path. Defaults to the identity transform if not specified.
     * @returns {void}
     * @desc The specified point becomes the start point of a new subpath. The current point is set to this start point.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427143-move
     */

  }, {
    key: 'moveTo',
    value: function moveTo(point, transform) {}

    /**
     * Appends a straight line segment from the current point to the specified point. 
     * @access public
     * @param {CGPoint} point - The location, in user space coordinates, for the end of the new line segment.
     * @param {CGAffineTransform} transform - An affine transform to apply to the point before adding to the path. Defaults to the identity transform if not specified.
     * @returns {void}
     * @desc After adding the line segment, the current point is set to the endpoint of the line segment.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427121-addline
     */

  }, {
    key: 'addLineTo',
    value: function addLineTo(point, transform) {}

    /**
     * Adds a sequence of connected straight-line segments to the path. 
     * @access public
     * @param {CGPoint[]} points - An array of values that specify the start and end points of the line segments to draw. Each point in the array specifies a position in user space. The first point in the array specifies the initial starting point.
     * @param {CGAffineTransform} transform - An affine transform to apply to the points before adding to the path. Defaults to the identity transform if not specified.
     * @returns {void}
     * @desc Calling this convenience method is equivalent to calling the move(to:transform:) method with the first value in the points array, then calling the addLine(to:transform:) method for each subsequent point until the array is exhausted. After calling this method, the path's current point is the last point in the array.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427154-addlines
     */

  }, {
    key: 'addLinesBetween',
    value: function addLinesBetween(points, transform) {}

    /**
     * Adds a rectangular subpath to the path. 
     * @access public
     * @param {CGRect} rect - A rectangle, specified in user space coordinates.
     * @param {CGAffineTransform} transform - An affine transform to apply to the rectangle before adding to the path. Defaults to the identity transform if not specified.
     * @returns {void}
     * @desc This is a convenience function that adds a rectangle to a path, starting by moving to the bottom left corner and then adding lines counter-clockwise to create a rectangle, closing the subpath.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427119-addrect
     */

  }, {
    key: 'addRect',
    value: function addRect(rect, transform) {}

    /**
     * Adds a set of rectangular subpaths to the path. 
     * @access public
     * @param {CGRect[]} rects - An array of rectangles, specified in user space coordinates.
     * @param {CGAffineTransform} transform - An affine transform to apply to the rectangles before adding to the path. Defaults to the identity transform if not specified.
     * @returns {void}
     * @desc Calling this convenience method is equivalent to repeatedly calling the addRect(_:transform:) method for each rectangle in the array.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427131-addrects
     */

  }, {
    key: 'addRects',
    value: function addRects(rects, transform) {}

    /**
     * Adds an ellipse that fits inside the specified rectangle. 
     * @access public
     * @param {CGRect} rect - A rectangle that defines the area for the ellipse to fit in.
     * @param {CGAffineTransform} transform - An affine transform to apply to the ellipse before adding to the path. Defaults to the identity transform if not specified.
     * @returns {void}
     * @desc The ellipse is approximated by a sequence of Bézier curves. Its center is the midpoint of the rectangle defined by the rect parameter. If the rectangle is square, then the ellipse is circular with a radius equal to one-half the width (or height) of the rectangle. If the rect parameter specifies a rectangular shape, then the major and minor axes of the ellipse are defined by the width and height of the rectangle.The ellipse forms a complete subpath of the path—that is, the ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427120-addellipse
     */

  }, {
    key: 'addEllipseIn',
    value: function addEllipseIn(rect, transform) {}

    /**
     *  Adds a subpath to the path, in the shape of a rectangle with rounded corners.
     * @access public
     * @param {CGRect} rect - The rectangle to add, specified in user space coordinates.
     * @param {number} cornerWidth - The horizontal size, in user space coordinates, for rounded corner sections.
     * @param {number} cornerHeight - The vertical size, in user space coordinates, for rounded corner sections.
     * @param {CGAffineTransform} transform - An affine transform to apply to the rectangle before adding to the path. Defaults to the identity transform if not specified.
     * @returns {void}
     * @desc This convenience method is equivalent to a move operation to start the subpath followed by a series of arc and line operations that construct the rounded rectangle. Each corner of the rounded rectangle is one-quarter of an ellipse with axes equal to the cornerWidth and cornerHeight parameters. The rounded rectangle forms a closed subpath oriented in the clockwise direction.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427144-addroundedrect
     */

  }, {
    key: 'addRoundedRectIn',
    value: function addRoundedRectIn(rect, cornerWidth, cornerHeight, transform) {}

    /**
     * Adds an arc of a circle to the path, specified with a radius and angles. 
     * @access public
     * @param {CGPoint} center - The center of the arc, in user space coordinates.
     * @param {number} radius - The radius of the arc, in user space coordinates.
     * @param {number} startAngle - The angle to the starting point of the arc, measured in radians from the positive x-axis.
     * @param {number} endAngle - The angle to the end point of the arc, measured in radians from the positive x-axis.
     * @param {boolean} clockwise - true to make a clockwise arc; false to make a counterclockwise arc.
     * @param {CGAffineTransform} transform - An affine transform to apply to the arc before adding to the path. Defaults to the identity transform if not specified.
     * @returns {void}
     * @desc This method calculates starting and ending points using the radius and angles you specify, uses a sequence of cubic Bézier curves to approximate a segment of a circle between those points, and then appends those curves to the path.The clockwise parameter determines the direction in which the arc is created; the actual direction of the final path is dependent on the transform parameter and the current transform of a context where the path is drawn. In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.If the path already contains a subpath, this method adds a line connecting the current point to the starting point of the arc. If the current path is empty, his method creates a new subpath whose starting point is the starting point of the arc. The ending point of the arc becomes the new current point of the path.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427140-addarc
     */

  }, {
    key: 'addArc',
    value: function addArc(center, radius, startAngle, endAngle, clockwise, transform) {}

    /**
     * Adds an arc of a circle to the path, specified with a radius and a difference in angle.  
     * @access public
     * @param {CGPoint} center - The center of the arc, in user space coordinates.
     * @param {number} radius - The radius of the arc, in user space coordinates.
     * @param {number} startAngle - The angle to the starting point of the arc, measured in radians from the positive x-axis.
     * @param {number} delta - The difference, measured in radians, between the starting angle and ending angle of the arc. A positive value creates a counter-clockwise arc (in user space coordinates), and vice versa.
     * @param {CGAffineTransform} transform - An affine transform to apply to the arc before adding to the path. Defaults to the identity transform if not specified.
     * @returns {void}
     * @desc This method calculates starting and ending points using the radius and angles you specify, uses a sequence of cubic Bézier curves to approximate a segment of a circle between those points, and then appends those curves to the path.The delta parameter determines both the length of the arc the direction in which the arc is created; the actual direction of the final path is dependent on the transform parameter and the current transform of a context where the path is drawn. In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.If the path already contains a subpath, this method adds a line connecting the current point to the starting point of the arc. If the current path is empty, his method creates a new subpath whose starting point is the starting point of the arc. The ending point of the arc becomes the new current point of the path.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427147-addrelativearc
     */

  }, {
    key: 'addRelativeArc',
    value: function addRelativeArc(center, radius, startAngle, delta, transform) {}

    /**
     * Adds a cubic Bézier curve to the path, with the specified end point and control points. 
     * @access public
     * @param {CGPoint} end - The point, in user space coordinates, at which to end the curve.
     * @param {CGPoint} control1 - The first control point of the curve, in user space coordinates.
     * @param {CGPoint} control2 - The second control point of the curve, in user space coordinates.
     * @param {CGAffineTransform} transform - An affine transform to apply to the curve before adding to the path. Defaults to the identity transform if not specified.
     * @returns {void}
     * @desc This method constructs a curve starting from the path's current point and ending at the specified end point, with curvature defined by the two control points. After this method appends that curve to the current path, the end point of the curve becomes the path's current point.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427158-addcurve
     */

  }, {
    key: 'addCurveTo',
    value: function addCurveTo(end, control1, control2, transform) {}

    /**
     * Adds a quadratic Bézier curve to the path, with the specified end point and control point. 
     * @access public
     * @param {CGPoint} end - The point, in user space coordinates, at which to end the curve.
     * @param {CGPoint} control - The control point of the curve, in user space coordinates.
     * @param {CGAffineTransform} transform - An affine transform to apply to the curve before adding to the path. Defaults to the identity transform if not specified.
     * @returns {void}
     * @desc This method constructs a curve starting from the path's current point and ending at the specified end point, with curvature defined by the control point. After this method appends that curve to the current path, the end point of the curve becomes the path's current point.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427128-addquadcurve
     */

  }, {
    key: 'addQuadCurveTo',
    value: function addQuadCurveTo(end, control, transform) {}

    /**
     * Appends another path object to the path. 
     * @access public
     * @param {CGPath} path - The path to add.
     * @param {CGAffineTransform} transform - An affine transform to apply to the path parameter before adding to this path. Defaults to the identity transform if not specified.
     * @returns {void}
     * @desc If the path parameter is a non-empty empty path, its path elements are appended in order to this path. Afterward, the start point and current point of this path are those of the last subpath in the path parameter.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/2427150-addpath
     */

  }, {
    key: 'addPath',
    value: function addPath(path, transform) {}

    /**
     * Closes and completes a subpath in a mutable graphics path.
     * @access public
     * @returns {void}
     * @desc Appends a line from the current point to the starting point of the current subpath and ends the subpath. After closing the subpath, your application can begin a new subpath without first calling moveTo(_:x:y:). In this case, a new subpath is implicitly created with a starting and current point equal to the previous subpath’s starting point.
     * @see https://developer.apple.com/documentation/coregraphics/cgmutablepath/1411188-closesubpath
     */

  }, {
    key: 'closeSubpath',
    value: function closeSubpath() {}
  }]);

  return CGMutablePath;
}();

exports.default = CGMutablePath;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import CGRect from './CGRect'
//import CGLineCap from './CGLineCap'
//import CGLineJoin from './CGLineJoin'
//import CGMutablePath from './CGMutablePath'
//import CGPoint from './CGPoint'
//import CGPathFillRule from './CGPathFillRule'
//import CGPathApplierFunction from './CGPathApplierFunction'

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _typeID = null;

/**
 * An immutable graphics path: a mathematical description of shapes or lines to be drawn in a graphics context.
 * @access public
 * @see https://developer.apple.com/documentation/coregraphics/cgpath
 */

var CGPath = function () {

  // Creating Graphics Paths

  /**
   * Create an immutable path of a rectangle.
   * @access public
   * @constructor
   * @param {CGRect} rect - The rectangle to add.
   * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangle before it is added to the path.
   * @desc This is a convenience function that creates a path of an rectangle. Using this convenience function is more efficient than creating a mutable path and adding an rectangle to it.Calling this function is equivalent to using minX and related functions to find the corners of the rectangle, then using the moveTo(_:x:y:), addLineTo(_:x:y:), and closeSubpath() functions to draw the rectangle. 
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411155-init
   */
  function CGPath(rect, transform) {
    _classCallCheck(this, CGPath);

    // Examining a Graphics Path

    this._boundingBox = null;
    this._boundingBoxOfPath = null;
    this._currentPoint = null;
    this._isEmpty = false;
  }

  /**
   * Create an immutable path of an ellipse.
   * @access public
   * @param {CGRect} rect - The rectangle that bounds the ellipse.
   * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to the ellipse before it is added to the path.
   * @returns {void}
   * @desc This is a convenience function that creates a path of an ellipse. Using this convenience function is more efficient than creating a mutable path and adding an ellipse to it.The ellipse is approximated by a sequence of Bézier curves. Its center is the midpoint of the rectangle defined by the rect parameter. If the rectangle is square, then the ellipse is circular with a radius equal to one-half the width (or height) of the rectangle. If the rect parameter specifies a rectangular shape, then the major and minor axes of the ellipse are defined by the width and height of the rectangle. The ellipse forms a complete subpath of the path—that is, the ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction. If you supply an affine transform, then the constructed Bézier curves that define the ellipse are transformed before they are added to the path.
   * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411177-init
   */


  _createClass(CGPath, [{
    key: 'initEllipseIn',
    value: function initEllipseIn(rect, transform) {

      // Examining a Graphics Path

      this._boundingBox = null;
      this._boundingBoxOfPath = null;
      this._currentPoint = null;
      this._isEmpty = false;
    }

    /**
     * Create an immutable path of a rounded rectangle.
     * @access public
     * @param {CGRect} rect - The rectangle to add.
     * @param {number} cornerWidth - The width of the rounded corner sections.
     * @param {number} cornerHeight - The height of the rounded corner sections.
     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangle before it is added to the path.
     * @returns {void}
     * @desc This is a convenience function that creates a path of an rounded rectangle. Using this convenience function is more efficient than creating a mutable path and adding an rectangle to it.Each corner of the rounded rectangle is one-quarter of an ellipse with axes equal to the cornerWidth and cornerHeight parameters. The rounded rectangle forms a complete subpath and is oriented in the clockwise direction.
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411218-init
     */

  }, {
    key: 'initRoundedRect',
    value: function initRoundedRect(rect, cornerWidth, cornerHeight, transform) {

      // Examining a Graphics Path

      this._boundingBox = null;
      this._boundingBoxOfPath = null;
      this._currentPoint = null;
      this._isEmpty = false;
    }

    // Copying a Graphics Path

    /**
     * Creates an immutable copy of a graphics path.
     * @access public
     * @returns {?CGPath} - 
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411211-copy
     */

  }, {
    key: 'copy',
    value: function copy() {
      return null;
    }

    /**
     * Creates an immutable copy of a graphics path transformed by a transformation matrix.
     * @access public
     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
     * @returns {?CGPath} - 
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411161-copy
     */

  }, {
    key: 'copyUsing',
    value: function copyUsing(transform) {
      return null;
    }

    /**
     * Returns a new path equivalent to the results of drawing the path with a dashed stroke.
     * @access public
     * @param {number} phase - A value that specifies how far into the dash pattern the line starts, in units of the user space. For example, a value of 0 draws a line starting with the beginning of a dash pattern, and a value of 3 means the line is drawn with the dash pattern starting at three units from its beginning. 
     * @param {number[]} lengths - An array of values that specify the lengths, in user space coordinates, of the painted and unpainted segments  of the dash pattern.For example, the array [2,3] sets a dash pattern that alternates between a 2-unit-long painted segment and a 3-unit-long unpainted segment. The array [1,3,4,2] sets the pattern to a 1-unit painted segment, a 3-unit unpainted segment, a 4-unit painted segment, and a 2-unit unpainted segment.Pass an empty array to clear the dash pattern so that all stroke drawing in the context uses solid lines.
     * @param {CGAffineTransform} transform - An affine transform to apply to the path before dashing. Defaults to the identity transform if not specified.
     * @returns {CGPath} - 
     * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified dash parameters.
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/2427137-copy
     */

  }, {
    key: 'copyDashingWithPhase',
    value: function copyDashingWithPhase(phase, lengths, transform) {
      return null;
    }

    /**
     * Returns a new path equivalent to the results of drawing the path with a solid stroke. 
     * @access public
     * @param {number} lineWidth - The line width to use, in user space units. The value must be greater than 0.
     * @param {CGLineCap} lineCap - The line cap style to render. (For equivalent CGContext drawing methods, the default style is butt.) 
     * @param {CGLineJoin} lineJoin - The line join style to render. (For equivalent CGContext drawing methods, the default style is miter.) 
     * @param {number} miterLimit - A value that limits how sharp individual corners in the path can be when using the miter line join style. When the ratio of a the length required for a mitered corner to the line width exceeds this value, that corner uses the bevel style instead.
     * @param {CGAffineTransform} transform - An affine transform to apply to the path before dashing. Defaults to the identity transform if not specified.
     * @returns {CGPath} - 
     * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified line style.
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/2427133-copy
     */

  }, {
    key: 'copyStrokingWithWidth',
    value: function copyStrokingWithWidth(lineWidth, lineCap, lineJoin, miterLimit, transform) {
      return null;
    }

    /**
     * Creates a mutable copy of an existing graphics path.
     * @access public
     * @returns {?CGMutablePath} - 
     * @desc You can modify a mutable graphics path by calling the various path geometry functions, such as addArc(_:x:y:radius:startAngle:endAngle:clockwise:), addLineTo(_:x:y:), and moveTo(_:x:y:).
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411196-mutablecopy
     */

  }, {
    key: 'mutableCopy',
    value: function mutableCopy() {
      return null;
    }

    /**
     * Creates a mutable copy of a graphics path transformed by a transformation matrix.
     * @access public
     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
     * @returns {?CGMutablePath} - 
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411150-mutablecopy
     */

  }, {
    key: 'mutableCopyUsing',
    value: function mutableCopyUsing(transform) {
      return null;
    }

    // Examining a Graphics Path

    /**
     * Returns whether the specified point is interior to the path.
     * @access public
     * @param {CGPoint} point - The point to check.
     * @param {CGPathFillRule} rule - The rule for determining which areas to treat as the interior of the path. Defaults to the winding rule if not specified.
     * @param {CGAffineTransform} transform - An affine transform to apply to the point before checking for containment in the path. Defaults to the identity transform if not specified.
     * @returns {boolean} - 
     * @desc A point is contained in a path if it would be inside the painted region when the path is filled.
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/2427117-contains
     */

  }, {
    key: 'containsUsing',
    value: function containsUsing(point, rule, transform) {
      return false;
    }

    /**
     * Indicates whether or not a graphics path represents a rectangle.
     * @access public
     * @param {?UnsafeMutablePointer<CGRect>} rect - On input, a pointer to an uninitialized rectangle. If the specified path represents a rectangle, on return contains a copy of the rectangle. 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411163-isrect
     */

  }, {
    key: 'isRect',
    value: function isRect(rect) {
      return false;
    }
    /**
     * Returns the bounding box containing all points in a graphics path.
     * @type {CGRect}
     * @desc The bounding box is the smallest rectangle completely enclosing all points in the path, including control points for Bézier and quadratic curves. 
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411165-boundingbox
     */

  }, {
    key: 'apply',


    // Applying a Function to the Elements of a Path

    /**
     * For each element in a graphics path, calls a custom applier function.
     * @access public
     * @param {?Object} info - A pointer to the user data that Core Graphics will pass to the function being applied, or NULL.
     * @param {CGPathApplierFunction} _function - 
     * @returns {void}
     * @desc For each element in the specified path, Core Graphics calls the applier function, which can examine (but not modify) the element.
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411203-apply
     */
    value: function apply(info, _function) {}

    // Working with Core Foundation Types
    /**
     * Returns the Core Foundation type identifier for Core Graphics graphics paths.
     * @type {CFTypeID}
     * @desc 
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411192-typeid
     */

  }, {
    key: 'init__byDashing',


    // Initializers

    /**
     * Creates a dashed copy of another path.
     * @access public
     * @param {CGPath} path - The path to copy.
     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to elements of the converted path before adding them to the new path.
     * @param {number} phase - A value that specifies how far into the dash pattern the line starts, in units of the user space. For example, passing a value of 3 means the line is drawn with the dash pattern starting at three units from its beginning. Passing a value of 0 draws a line starting with the beginning of a dash pattern.
     * @param {?UnsafePointer<CGFloat>} lengths - An array of values that specify the lengths of the painted segments and unpainted segments, respectively, of the dash pattern—or NULL for no dash pattern.For example, passing an array with the values [2,3] sets a dash pattern that alternates between a 2-user-space-unit-long painted segment and a 3-user-space-unit-long unpainted segment. Passing the values [1,3,4,2] sets the pattern to a 1-unit painted segment, a 3-unit unpainted segment, a 4-unit painted segment, and a 2-unit unpainted segment.
     * @param {number} count - If the lengths parameter specifies an array, pass the number of elements in the array. Otherwise, pass 0.
     * @returns {void}
     * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified dash parameters.
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411134-init
     */
    value: function init__byDashing(path, transform, phase, lengths, count) {

      // Examining a Graphics Path

      this._boundingBox = null;
      this._boundingBoxOfPath = null;
      this._currentPoint = null;
      this._isEmpty = false;
    }

    /**
     * Creates a stroked copy of another path.
     * @access public
     * @param {CGPath} path - The path to copy.
     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to elements of the converted path before adding them to the new path.
     * @param {number} lineWidth - The line width to use, in user space units. The value must be greater than 0.
     * @param {CGLineCap} lineCap - A line cap style constant—butt (the default), round, or square. 
     * @param {CGLineJoin} lineJoin - A line join value—miter (the default), round, or bevel. 
     * @param {number} miterLimit - The miter limit to use.
     * @returns {void}
     * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path.If the line join style is set to kCGLineJoinMiter, Core Graphics uses the miter limit to determine whether the lines should be joined with a bevel instead of a miter. Core Graphics divides the length of the miter by the line width. If the result is greater than the miter limit, Core Graphics converts the style to a bevel. 
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411128-init
     */

  }, {
    key: 'init__byStroking',
    value: function init__byStroking(path, transform, lineWidth, lineCap, lineJoin, miterLimit) {

      // Examining a Graphics Path

      this._boundingBox = null;
      this._boundingBoxOfPath = null;
      this._currentPoint = null;
      this._isEmpty = false;
    }
  }, {
    key: 'boundingBox',
    get: function get() {
      return this._boundingBox;
    }
    /**
     * Returns the bounding box of a graphics path.
     * @type {CGRect}
     * @desc The path bounding box is the smallest rectangle completely enclosing all points in the path but not including control points for Bézier and quadratic curves. 
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411200-boundingboxofpath
     */

  }, {
    key: 'boundingBoxOfPath',
    get: function get() {
      return this._boundingBoxOfPath;
    }
    /**
     * Returns the current point in a graphics path.
     * @type {CGPoint}
     * @desc If the path is empty—that is, if it has no elements—this function returns CGPointZero (see CGGeometry). To determine whether a path is empty, use isEmpty.
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411132-currentpoint
     */

  }, {
    key: 'currentPoint',
    get: function get() {
      return this._currentPoint;
    }
    /**
     * Indicates whether or not a graphics path is empty.
     * @type {boolean}
     * @desc An empty path contains no elements.
     * @see https://developer.apple.com/documentation/coregraphics/cgpath/1411149-isempty
     */

  }, {
    key: 'isEmpty',
    get: function get() {
      return this._isEmpty;
    }
  }], [{
    key: 'typeID',
    get: function get() {
      return _typeID;
    }
  }]);

  return CGPath;
}();

exports.default = CGPath;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Defines a callback function that can view an element in a graphics path.
 * @type {function(): void}
 * @returns {void}
 * @see https://developer.apple.com/documentation/coregraphics/cgpathapplierfunction
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CGPathApplierFunction = function CGPathApplierFunction() {};

exports.default = CGPathApplierFunction;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Rules for determining which regions are interior to a path, used by the fillPath(using:) and clip(using:) methods.
 * @typedef {Object} CGPathFillRule
 * @property {number} evenOdd - A rule that considers a region to be interior to a path based on the number of times it is enclosed by path elements.
 * @property {number} winding - A rule that considers a region to be interior to a path if the winding number for that region is nonzero.
 * @see https://developer.apple.com/documentation/coregraphics/cgpathfillrule
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CGPathFillRule = {
  evenOdd: 1,
  winding: 0
};

exports.default = CGPathFillRule;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DispatchObject2 = __webpack_require__(61);

var _DispatchObject3 = _interopRequireDefault(_DispatchObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import __OS_dispatch_queue_attr from './__OS_dispatch_queue_attr'
//import DispatchQoS from '.i/DispatchQoS'
//import DispatchWorkItem from './DispatchWorkItem'
//import DispatchGroup from './DispatchGroup'
//import DispatchWorkItemFlags from './DispatchWorkItemFlags'
//import DispatchTime from './DispatchTime'
//import DispatchWallTime from './DispatchWallTime'
//import DispatchSpecificKey from './DispatchSpecificKey'

var _AutoreleaseFrequency = {
  inherit: 0,
  never: 2,
  workItem: 1

  /**
   * @deprecated
   */
};var _GlobalQueuePriority = {
  background: 3,
  default: 1,
  high: 0,
  low: 2
};

var _main = null;

/**
 * DispatchQueue manages the execution of work items. Each work item submitted to a queue is processed on a pool of threads managed by the system.
 * @access public
 * @extends {DispatchObject}
 * @see https://developer.apple.com/documentation/dispatch/dispatchqueue
 */

var DispatchQueue = function (_DispatchObject) {
  _inherits(DispatchQueue, _DispatchObject);

  // Initializers

  /**
   * 
   * @access public
   * @param {string} label - 
   * @param {DispatchQoS} qos - 
   * @param {DispatchQueue.Attributes} attributes - 
   * @param {DispatchQueue.AutoreleaseFrequency} autoreleaseFrequency - 
   * @param {?DispatchQueue} target - 
   * @constructor
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2300059-init
   */
  function DispatchQueue(label, qos, attributes, autoreleaseFrequency, target) {
    _classCallCheck(this, DispatchQueue);

    /**
     * @access private
     * @type {string}
     */
    var _this = _possibleConstructorReturn(this, (DispatchQueue.__proto__ || Object.getPrototypeOf(DispatchQueue)).call(this));

    _this._label = label;

    /**
     * @access private
     * @type {DispatchQoS}
     */
    _this._qos = qos;

    /**
     * @access private
     * @type {DispatchQueue.Attributes}
     */
    _this._attributes = attributes;

    /**
     * @access private
     * @type {DispatchQueue.AutoreleaseFrequency}
     */
    _this._target = target;
    return _this;
  }

  /**
   * Creates a new dispatch queue to which blocks can be submitted.
   * @access public
   * @param {?UnsafePointer<Int8>} label - A string label to attach to the queue to uniquely identify it in debugging tools such as Instruments, sample, stackshots, and crash reports.  Because applications, libraries, and frameworks can all create their own dispatch queues, a reverse-DNS naming style (com.example.myqueue) is recommended.  This parameter is optional and can be NULL.
   * @param {?__OS_dispatch_queue_attr} attr - In macOS 10.7 and later or iOS 4.3 and later, specify DISPATCH_QUEUE_SERIAL (or NULL) to create a serial queue or specify DISPATCH_QUEUE_CONCURRENT to create a concurrent queue. In earlier versions, you must specify NULL for this parameter.
   * @returns {void}
   * @desc Blocks submitted to a serial queue are executed one at a time in FIFO order. Note, however, that blocks submitted to independent queues may be executed concurrently with respect to each other. Blocks submitted to a concurrent queue are dequeued in FIFO order but may run concurrently if resources are available to do so.If your app isn’t using ARC, you should call dispatch_release on a dispatch queue when it’s no longer needed. Any pending blocks submitted to a queue hold a reference to that queue, so the queue is not deallocated until all pending blocks have completed.
   * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1453030-init
   */


  _createClass(DispatchQueue, [{
    key: 'init__label',
    value: function init__label(label, attr) {

      // Instance Properties

      this._label = '';
      this._qos = null;
    }

    /**
     * 
     * @access public
     * @param {?UnsafePointer<Int8>} label - 
     * @param {?__OS_dispatch_queue_attr} attr - 
     * @param {?DispatchQueue} target - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1642205-init
     */

  }, {
    key: 'init__labelQueue',
    value: function init__labelQueue(label, attr, target) {

      // Instance Properties

      this._label = '';
      this._qos = null;
    }

    // Instance Methods

    /**
     * 
     * @access public
     * @param {DispatchWorkItem} workItem - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1452870-sync
     */

  }, {
    key: 'syncExecute',
    value: function syncExecute(workItem) {}

    /**
     * 
     * @access public
     * @param {DispatchWorkItem} workItem - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2016103-async
     */

  }, {
    key: 'asyncExecute',
    value: function asyncExecute(workItem) {}

    /**
     * 
     * @access public
     * @param {DispatchTime} deadline - 
     * @param {DispatchWorkItem} execute - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2300020-asyncafter
     */

  }, {
    key: 'asyncAfter',
    value: function asyncAfter(deadline, execute) {
      var delay = deadline - Date.now();
      window.setTimeout(function () {
        execute();
      }, delay);
    }

    /**
     * 
     * @access public
     * @param {DispatchTime} deadline - 
     * @param {DispatchQoS} qos - 
     * @param {DispatchWorkItemFlags} flags - 
     * @param {function(): void} work - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2300100-asyncafter
     */

  }, {
    key: 'asyncAfterExecute',
    value: function asyncAfterExecute(deadline, qos, flags, work) {}

    /**
     * 
     * @access public
     * @param {DispatchSpecificKey<T>} key - 
     * @returns {?T} - 
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1780751-getspecific
     */

  }, {
    key: 'getSpecific',
    value: function getSpecific(key) {
      return null;
    }

    /**
     * 
     * @access public
     * @param {DispatchSpecificKey<T>} key - 
     * @param {T} value - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1780629-setspecific
     */

  }, {
    key: 'setSpecific',
    value: function setSpecific(key, value) {}

    /**
     * 
     * @access public
     * @param {DispatchWorkItemFlags} flags - 
     * @returns {void}
     * @throws {Error}
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2016077-sync
     */

  }, {
    key: 'sync',
    value: function sync(flags) {}

    // Instance Properties
    /**
     * 
     * @type {string}
     * @desc 
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1780825-label
     */

  }, {
    key: 'label',
    get: function get() {
      return this._label;
    }
    /**
     * 
     * @type {DispatchQoS}
     * @desc 
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1781008-qos
     */

  }, {
    key: 'qos',
    get: function get() {
      return this._qos;
    }

    // Type Properties
    /**
     * 
     * @type {DispatchQueue}
     * @desc 
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/1781006-main
     */

  }], [{
    key: 'concurrentPerformExecute',


    // Type Methods

    /**
     * 
     * @access public
     * @param {number} iterations - 
     * @param {function(arg1: number): void} work - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2016088-concurrentperform
     */
    value: function concurrentPerformExecute(iterations, work) {}

    /**
     * 
     * @deprecated
     * @access public
     * @param {DispatchQueue.GlobalQueuePriority} priority - 
     * @returns {DispatchQueue} - 
     * @see https://developer.apple.com/documentation/dispatch/dispatchqueue/2300070-global
     */

  }, {
    key: 'global',
    value: function global(priority) {
      return null;
    }
  }, {
    key: 'main',
    get: function get() {
      return _main;
    }
  }]);

  return DispatchQueue;
}(_DispatchObject3.default);

//_main = new DispatchQueue("com.apple.main-thread", new DispatchQoS(DispatchQoS.userInteractive, 0))


exports.default = DispatchQueue;
_main = new DispatchQueue('com.apple.main-thread', null);

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * DispatchTime represents a point in time relative to the default clock with nanosecond precision. On Apple platforms, the default clock is based on the Mach absolute time unit.
 * @access public
 * @see https://developer.apple.com/documentation/dispatch/dispatchtime
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DispatchTime = function () {

  // Initializers

  /**
   * Creates a time relative to the system clock that ticks since boot.
   * @access public
   * @constructor
   * @param {UInt64} uptimeNanoseconds - The number of nanoseconds since boot, excluding any time the system spent asleep.
   * @desc On Apple platforms, this clock is the same as the value returned by mach_absolute_time when converted into nanoseconds.
   * @see https://developer.apple.com/documentation/dispatch/dispatchtime/2300057-init
   */
  function DispatchTime(uptimeNanoseconds) {
    _classCallCheck(this, DispatchTime);

    // Instance Properties

    this._uptimeNanoseconds = uptimeNanoseconds;
  }

  // Instance Properties

  /**
   * Returns the number of nanoseconds since boot, excluding any time the system spent asleep.
   * @type {UInt64}
   * @desc 
   * @see https://developer.apple.com/documentation/dispatch/dispatchtime/2300047-uptimenanoseconds
   */


  _createClass(DispatchTime, [{
    key: 'uptimeNanoseconds',
    get: function get() {
      throw new Error('uptimeNanoseconds: not implemented');
    }

    // Type Properties

    /**
     * Returns a time in the distant future.
     * @access public
     * @returns {DispatchTime} -
     * @desc You can pass this value to methods that schedule work to have the system wait indefinitely for a particular event to occur or condition to be met.
     * @see https://developer.apple.com/documentation/dispatch/dispatchtime/1780795-distantfuture
     */

  }], [{
    key: 'now',


    // Type Methods

    /**
     * Returns the current time.
     * @access public
     * @returns {DispatchTime} - 
     * @see https://developer.apple.com/documentation/dispatch/dispatchtime/1780853-now
     */
    value: function now() {
      return Date.now();
    }
  }, {
    key: 'distantFuture',
    get: function get() {}
  }]);

  return DispatchTime;
}();

exports.default = DispatchTime;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * DispatchTimeInterval represents a number of seconds, millisconds, microseconds, or nanoseconds. You use DispatchTimeInterval values to specify the interval at which a DispatchSourceTimer fires or I/O handlers are invoked for a DispatchIO channel, as well as to increment and decrement DispatchTime values.
 * @typedef {Object} DispatchTimeInterval
 * @property {function} seconds - A number of seconds.
 * @property {function} milliseconds - A number of milliseconds.
 * @property {function} microseconds - A number of microseconds.
 * @property {function} nanoseconds - A number of nanoseconds.
 * @see https://developer.apple.com/documentation/dispatch/dispatchtimeinterval
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var DispatchTimeInterval = {
  seconds: function seconds(value) {
    return value * 1000.0;
  },
  milliseconds: function milliseconds(value) {
    return value;
  },
  microseconds: function microseconds(value) {
    return value * 0.001;
  },
  nanoseconds: function nanoseconds(value) {
    return value * 0.000001;
  }
};

exports.default = DispatchTimeInterval;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _NSNotification = __webpack_require__(62);

var _NSNotification2 = _interopRequireDefault(_NSNotification);

var _GCController = __webpack_require__(29);

var _GCController2 = _interopRequireDefault(_GCController);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _default = null;

/**
 * A notification dispatch mechanism that enables the broadcast of information to registered observers.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/foundation/notificationcenter
 */

var NotificationCenter = function (_NSObject) {
  _inherits(NotificationCenter, _NSObject);

  function NotificationCenter() {
    _classCallCheck(this, NotificationCenter);

    return _possibleConstructorReturn(this, (NotificationCenter.__proto__ || Object.getPrototypeOf(NotificationCenter)).apply(this, arguments));
  }

  _createClass(NotificationCenter, [{
    key: 'addObserverForNameObjectUsing',


    // Managing Notification Observers

    /**
     * Adds an entry to the receiver’s dispatch table with a notification queue and a block to add to the queue, and optional criteria: notification name and sender.
     * @access public
     * @param {?NSNotification.Name} name - The name of the notification for which to register the observer; that is, only notifications with this name are used to add the block to the operation queue.If you pass nil, the notification center doesn’t use a notification’s name to decide whether to add the block to the operation queue.
     * @param {?Object} obj - The object whose notifications the observer wants to receive; that is, only notifications sent by this sender are delivered to the observer.If you pass nil, the notification center doesn’t use a notification’s sender to decide whether to deliver it to the observer.
     * @param {?OperationQueue} queue - The operation queue to which block should be added.If you pass nil, the block is run synchronously on the posting thread.
     * @param {function(arg1: Notification): void} block - The block to be executed when the notification is received.The block is copied by the notification center and (the copy) held until the observer registration is removed. The block takes one argument:notificationThe notification.
     * @returns {NSObjectProtocol} - 
     * @desc If a given notification triggers more than one observer block, the blocks may all be executed concurrently with respect to one another (but on their given queue or on the current thread).The following example shows how you can register to receive locale change notifications.let center = NSNotificationCenter.defaultCenter()
    let mainQueue = NSOperationQueue.mainQueue()
    self.localeChangeObserver = center.addObserverForName(NSCurrentLocaleDidChangeNotification, object: nil, queue: mainQueue) { (note) in
      print("The user's locale changed to: \(NSLocale.currentLocale().localeIdentifier)")
    }
    To unregister observations, you pass the object returned by this method to removeObserver(_:). You must invoke removeObserver(_:) or removeObserver(_:name:object:) before any object specified by addObserverForName:object:queue:usingBlock: is deallocated.let center = NSNotificationCenter.defaultCenter()
    center.removeObserver(self.localeChangeObserver)
    Another common pattern is to create a one-time notification by removing the observer from within the observation block, as in the following example.let center = NSNotificationCenter.defaultCenter()
    let mainQueue = NSOperationQueue.mainQueue()
    var token: NSObjectProtocol?
    token = center.addObserverForName("OneTimeNotification", object: nil, queue: mainQueue) { (note) in
      print("Received the notification!")
      center.removeObserver(token!)
    }
    let center = NSNotificationCenter.defaultCenter()
    let mainQueue = NSOperationQueue.mainQueue()
    self.localeChangeObserver = center.addObserverForName(NSCurrentLocaleDidChangeNotification, object: nil, queue: mainQueue) { (note) in
      print("The user's locale changed to: \(NSLocale.currentLocale().localeIdentifier)")
    }
    let center = NSNotificationCenter.defaultCenter()
    center.removeObserver(self.localeChangeObserver)
    let center = NSNotificationCenter.defaultCenter()
    let mainQueue = NSOperationQueue.mainQueue()
    var token: NSObjectProtocol?
    token = center.addObserverForName("OneTimeNotification", object: nil, queue: mainQueue) { (note) in
      print("Received the notification!")
      center.removeObserver(token!)
    }
      * @see https://developer.apple.com/documentation/foundation/notificationcenter/1411723-addobserver
     */
    value: function addObserverForNameObjectUsing(name, obj, queue, block) {
      return null;
    }

    /**
     * Adds an entry to the receiver’s dispatch table with an observer, a notification selector and optional criteria: notification name and sender.
     * @access public
     * @param {Object} observer - Object registering as an observer. This value must not be nil.
     * @param {function} aSelector - Selector that specifies the message the receiver sends observer to notify it of the notification posting. The method specified by aSelector must have one and only one argument (an instance of NSNotification).
     * @param {?NSNotification.Name} aName - The name of the notification for which to register the observer; that is, only notifications with this name are delivered to the observer.If you pass nil, the notification center doesn’t use a notification’s name to decide whether to deliver it to the observer.
     * @param {?Object} anObject - The object whose notifications the observer wants to receive; that is, only notifications sent by this sender are delivered to the observer.If you pass nil, the notification center doesn’t use a notification’s sender to decide whether to deliver it to the observer.
     * @returns {void}
     * @desc If your app targets iOS 9.0 and later or macOS 10.11 and later, you don't need to unregister an observer in its deallocation method. If your app targets earlier releases, be sure to invoke removeObserver(_:name:object:) before observer or any object specified in addObserver:selector:name:object: is deallocated.
     * @see https://developer.apple.com/documentation/foundation/notificationcenter/1415360-addobserver
     */

  }, {
    key: 'addObserverSelectorNameObject',
    value: function addObserverSelectorNameObject(observer, aSelector, aName, anObject) {
      var f = aSelector.bind(observer);
      if (aName === _NSNotification2.default.Name.GCControllerDidConnect) {
        window.addEventListener('gamepadconnected', function (e) {
          var controller = _GCController2.default.getController(e.gamepad);
          if (controller) {
            f(new _NSNotification2.default(aName, controller, anObject));
          }
        });
        window.addEventListener('gamepaddisconnected', function (e) {
          var controller = _GCController2.default.getController(e.gamepad);
          if (controller) {
            f(new _NSNotification2.default(aName, controller, anObject));
          }
        });
      }
    }

    /**
     * Removes all the entries specifying a given observer from the receiver’s dispatch table.
     * @access public
     * @param {Object} observer - The observer to remove. Must not be nil.
     * @returns {void}
     * @desc Be sure to invoke this method (or removeObserver(_:name:object:)) before observer or any object specified in addObserver(_:selector:name:object:) is deallocated.You should not use this method to remove all observers from an object that is going to be long-lived, because your code may not be the only code adding observers that involve the object. The following example illustrates how to unregister someObserver for all notifications for which it had previously registered. This is safe to do in the dealloc method, but should not otherwise be used—use removeObserver(_:name:object:) instead.[[NSNotificationCenter defaultCenter] removeObserver:someObserver];
    [[NSNotificationCenter defaultCenter] removeObserver:someObserver];
      * @see https://developer.apple.com/documentation/foundation/notificationcenter/1413994-removeobserver
     */

  }, {
    key: 'removeObserver',
    value: function removeObserver(observer) {}

    /**
     * Removes matching entries from the receiver’s dispatch table.
     * @access public
     * @param {Object} observer - Observer to remove from the dispatch table. Specify an observer to remove only entries for this observer. Must not be nil, or message will have no effect.
     * @param {?NSNotification.Name} aName - Name of the notification to remove from dispatch table. Specify a notification name to remove only entries that specify this notification name. When nil, the receiver does not use notification names as criteria for removal.
     * @param {?Object} anObject - Sender to remove from the dispatch table. Specify a notification sender to remove only entries that specify this sender. When nil, the receiver does not use notification senders as criteria for removal.
     * @returns {void}
     * @desc Be sure to invoke this method (or removeObserver(_:)) before the observer object or any object specified in addObserver(_:selector:name:object:) is deallocated.
     * @see https://developer.apple.com/documentation/foundation/notificationcenter/1407263-removeobserver
     */

  }, {
    key: 'removeObserverNameObject',
    value: function removeObserverNameObject(observer, aName, anObject) {}

    // Posting Notifications

    /**
     * Posts a given notification to the receiver.
     * @access public
     * @param {Notification} notification - The notification to post. This value must not be nil.
     * @returns {void}
     * @desc You can create a notification with the NSNotification class method init(name:object:) or notificationWithName:object:userInfo:. An exception is raised if notification is nil.
     * @see https://developer.apple.com/documentation/foundation/notificationcenter/1410472-post
     */

  }, {
    key: 'post',
    value: function post(notification) {}

    /**
     * Creates a notification with a given name and sender and posts it to the receiver.
     * @access public
     * @param {NSNotification.Name} aName - The name of the notification.
     * @param {?Object} anObject - The object posting the notification.
     * @returns {void}
     * @desc This method invokes post(name:object:userInfo:) with an aUserInfo argument of nil.
     * @see https://developer.apple.com/documentation/foundation/notificationcenter/1415812-post
     */

  }, {
    key: 'postNameObject',
    value: function postNameObject(aName, anObject) {}

    /**
     * Creates a notification with a given name, sender, and information and posts it to the receiver.
     * @access public
     * @param {NSNotification.Name} aName - The name of the notification.
     * @param {?Object} anObject - The object posting the notification.
     * @param {?Map<AnyHashable, Object>} [aUserInfo = null] - Information about the the notification. May be nil.
     * @returns {void}
     * @desc This method is the preferred method for posting notifications.
     * @see https://developer.apple.com/documentation/foundation/notificationcenter/1410608-post
     */

  }, {
    key: 'postNameObjectUserInfo',
    value: function postNameObjectUserInfo(aName, anObject) {
      var aUserInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    }
  }], [{
    key: 'default',


    /**
     * constructor
     * @access public
     * @constructor
     */
    //constructor() {
    //  super()
    //}

    // Getting the Notification Center

    /**
     * Returns the process’s default notification center.
     * @type {NotificationCenter}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/notificationcenter/1414169-default
     */
    get: function get() {
      if (_default === null) {
        _default = new NotificationCenter();
      }
      return _default;
    }
  }]);

  return NotificationCenter;
}(_NSObject3.default);

exports.default = NotificationCenter;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * dummy class for NSColorSpace
 * @access public
 * @extends {NSObject}
 */
var NSColorSpace = function (_NSObject) {
  _inherits(NSColorSpace, _NSObject);

  _createClass(NSColorSpace, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        NSICC: ['NSMutableData', '_icc'],
        NSSpaceID: ['integer', '_spaceID'],
        NSID: ['integer', '_id']
      };
    }
  }]);

  function NSColorSpace() {
    _classCallCheck(this, NSColorSpace);

    var _this = _possibleConstructorReturn(this, (NSColorSpace.__proto__ || Object.getPrototypeOf(NSColorSpace)).call(this));

    _this._icc = null;
    _this._spaceID = null;
    _this._id = null;
    return _this;
  }

  return NSColorSpace;
}(_NSObject3.default);

exports.default = NSColorSpace;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSCoder2 = __webpack_require__(39);

var _NSCoder3 = _interopRequireDefault(_NSCoder2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import NSMutableData from './NSMutableData'
//import NSKeyedArchiverDelegate from '../undefined/NSKeyedArchiverDelegate'


/**
 * NSKeyedArchiver, a concrete subclass of NSCoder, provides a way to encode objects (and scalar values) into an architecture-independent format that can be stored in a file. When you archive a set of objects, the class information and instance variables for each object are written to the archive. NSKeyedArchiver’s companion class, NSKeyedUnarchiver, decodes the data in an archive and creates a set of objects equivalent to the original set.
 * @access public
 * @extends {NSCoder}
 * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver
 */
var NSKeyedArchiver = function (_NSCoder) {
  _inherits(NSKeyedArchiver, _NSCoder);

  // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1642790-init
   */
  function NSKeyedArchiver() {
    _classCallCheck(this, NSKeyedArchiver);

    // Archiving Data

    /**
     * The format in which the receiver encodes its data.
     * @type {PropertyListSerialization.PropertyListFormat}
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1417520-outputformat
     */
    var _this = _possibleConstructorReturn(this, (NSKeyedArchiver.__proto__ || Object.getPrototypeOf(NSKeyedArchiver)).call(this));

    _this.outputFormat = null;

    /**
     * Indicates whether the receiver requires all archived classes to conform to NSSecureCoding.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1417084-requiressecurecoding
     */
    _this.requiresSecureCoding = false;

    // Managing the Delegate

    /**
     * The archiver’s delegate.
     * @type {?NSKeyedArchiverDelegate}
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1412809-delegate
     */
    _this.delegate = null;

    // Instance Properties

    _this._encodedData = null;
    return _this;
  }

  // Initializing an NSKeyedArchiver Object

  /**
   * Returns the receiver, initialized for encoding an archive into a given a mutable-data object.
   * @access public
   * @param {NSMutableData} data - The mutable-data object into which the archive is written.
   * @returns {NSKeyedArchiver}
   * @desc When you finish encoding data, you must invoke finishEncoding() at which point data is filled. The format of the receiver is NSPropertyListBinaryFormat_v1_0.
   * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1409579-init
   */
  //initForWritingWith(data) {


  _createClass(NSKeyedArchiver, [{
    key: 'finishEncoding',


    /**
     * Instructs the receiver to construct the final data stream.
     * @access public
     * @returns {void}
     * @desc No more values can be encoded after this method is called. You must call this method when finished.
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1413904-finishencoding
     */
    value: function finishEncoding() {}

    // Encoding Data and Objects

    /**
     * Encodes a given float value and associates it with a given key.
     * @access public
     * @param {number} realv - The value to encode.
     * @param {string} key - The key with which to associate realv. This value must not be nil.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1416972-encode
     */

  }, {
    key: 'encodeForKey',
    value: function encodeForKey(realv, key) {}

    /**
     * Encodes a given number of bytes from a given C array of bytes and associates them with the a given key.
     * @access public
     * @param {?UnsafePointer<UInt8>} bytesp - A C array of bytes to encode.
     * @param {number} lenv - The number of bytes from bytesp to encode.
     * @param {string} key - The key with which to associate the encoded value. This value must not be nil.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1417696-encodebytes
     */

  }, {
    key: 'encodeBytesLengthForKey',
    value: function encodeBytesLengthForKey(bytesp, lenv, key) {}

    /**
     * Encodes a reference to a given object and associates it with a given key only if it has been unconditionally encoded elsewhere in the archive with encode(_:forKey:).
     * @access public
     * @param {?Object} objv - The object to encode. 
     * @param {string} key - The key with which to associate the encoded value. This value must not be nil.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1413677-encodeconditionalobject
     */

  }, {
    key: 'encodeConditionalObjectForKey',
    value: function encodeConditionalObjectForKey(objv, key) {}

    // Managing Classes and Class Names

    /**
     * Adds a class translation mapping to the receiver whereby instances of of a given class are encoded with a given class name instead of their real class names.
     * @access public
     * @param {?string} codedName - 
     * @param {Object} cls - The class for which to set up a translation mapping.
     * @returns {void}
     * @desc When encoding, the receiver’s translation map overrides any translation that may also be present in the class’s map.
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1414746-setclassname
     */

  }, {
    key: 'encodedData',


    // Instance Properties
    /**
     * Returns the encoded data for the archiver.
     * @type {Data}
     * @desc If encoding has not yet finished, invoking this property calls finishEncoding() and returns the data. If you initialized the keyed archiver with a specific mutable data instance, then that data is returned by the property after finishEncoding() is called.
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1643042-encodeddata
     */
    get: function get() {
      return this._encodedData;
    }
  }], [{
    key: 'archiverForWritingWithData',
    value: function archiverForWritingWithData(data) {
      var instance = new NSKeyedArchiver();

      // TODO: implement

      return instance;
    }

    // Archiving Data

    /**
     * Returns an NSData object containing the encoded form of the object graph whose root object is given.
     * @access public
     * @param {Object} rootObject - 
     * @returns {Data} - 
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1413189-archiveddata
     */

  }, {
    key: 'archivedDataWithRootObject',
    value: function archivedDataWithRootObject(rootObject) {
      return null;
    }

    /**
     * Archives an object graph rooted at a given object by encoding it into a data object then atomically writes the resulting data object to a file at a given path, and returns a Boolean value that indicates whether the operation was successful.
     * @access public
     * @param {Object} rootObject - 
     * @param {string} path - The path of the file in which to write the archive.
     * @returns {boolean} - 
     * @desc The format of the archive is NSPropertyListBinaryFormat_v1_0.
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1410621-archiverootobject
     */

  }, {
    key: 'archiveRootObjectToFile',
    value: function archiveRootObjectToFile(rootObject, path) {
      return false;
    }
  }, {
    key: 'setClassNameFor',
    value: function setClassNameFor(codedName, cls) {}

    /**
     * Returns the class name with which the receiver encodes instances of a given class.
     * @access public
     * @param {Object} cls - The class for which to determine the translation mapping.
     * @returns {?string} - 
     * @see https://developer.apple.com/documentation/foundation/nskeyedarchiver/1407245-classname
     */

  }, {
    key: 'classNameFor',
    value: function classNameFor(cls) {
      return null;
    }
  }]);

  return NSKeyedArchiver;
}(_NSCoder3.default);

exports.default = NSKeyedArchiver;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _NSArray2 = __webpack_require__(67);

var _NSArray3 = _interopRequireDefault(_NSArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSArray}
 */
var NSMutableArray = function (_NSArray) {
  _inherits(NSMutableArray, _NSArray);

  function NSMutableArray() {
    _classCallCheck(this, NSMutableArray);

    return _possibleConstructorReturn(this, (NSMutableArray.__proto__ || Object.getPrototypeOf(NSMutableArray)).apply(this, arguments));
  }

  return NSMutableArray;
}(_NSArray3.default);

exports.default = NSMutableArray;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _NSData2 = __webpack_require__(40);

var _NSData3 = _interopRequireDefault(_NSData2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSData}
 */
var NSMutableData = function (_NSData) {
  _inherits(NSMutableData, _NSData);

  function NSMutableData() {
    _classCallCheck(this, NSMutableData);

    return _possibleConstructorReturn(this, (NSMutableData.__proto__ || Object.getPrototypeOf(NSMutableData)).apply(this, arguments));
  }

  return NSMutableData;
}(_NSData3.default);

exports.default = NSMutableData;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _NSDictionary2 = __webpack_require__(68);

var _NSDictionary3 = _interopRequireDefault(_NSDictionary2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * dummy class for NSKeyedArchiver/Unarchiver
 * @access public
 * @extends {NSDictionary}
 */
var NSMutableDictionary = function (_NSDictionary) {
  _inherits(NSMutableDictionary, _NSDictionary);

  function NSMutableDictionary() {
    _classCallCheck(this, NSMutableDictionary);

    return _possibleConstructorReturn(this, (NSMutableDictionary.__proto__ || Object.getPrototypeOf(NSMutableDictionary)).apply(this, arguments));
  }

  return NSMutableDictionary;
}(_NSDictionary3.default);

exports.default = NSMutableDictionary;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * dummy class for NSURL
 * @access public
 * @extends {NSObject}
 */
var NSURL = function (_NSObject) {
  _inherits(NSURL, _NSObject);

  function NSURL() {
    _classCallCheck(this, NSURL);

    return _possibleConstructorReturn(this, (NSURL.__proto__ || Object.getPrototypeOf(NSURL)).apply(this, arguments));
  }

  _createClass(NSURL, null, [{
    key: 'initWithCoder',

    /**
     * @access public
     * @param {NSCoder} coder -
     * @returns {string} -
     */
    value: function initWithCoder(coder) {
      var base = coder._refObj['NS.base'].obj;
      var relative = coder._refObj['NS.relative'].obj;
      var url = relative; // Should I add the base url?

      if (url.indexOf(':') < 0) {
        url = coder._directoryPath + url;
      }

      return url;
    }
  }]);

  return NSURL;
}(_NSObject3.default);

exports.default = NSURL;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import CGPoint from '../CoreGraphics/CGPoint'
//import CGVector from '../CoreGraphics/CGVector'


//import CGRect from '../CoreGraphics/CGRect'
//import CATransform3D from '../QuartzCore/CATransform3D'
//import SCNVector3 from '../SceneKit/SCNVector3'
//import SCNVector4 from '../SceneKit/SCNVector4'
//import SCNMatrix4 from '../SceneKit/SCNMatrix4'


/**
 * An NSValue object is a simple container for a single C or Objective-C data item. It can hold any of the scalar types such as int, float, and char, as well as pointers, structures, and object id references. Use this class to work with such data types in collections (such as NSArray and NSSet), Key-value coding, and other APIs that require Objective-C objects. NSValue objects are always immutable.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/foundation/nsvalue
 */
var NSValue = function (_NSObject) {
  _inherits(NSValue, _NSObject);

  _createClass(NSValue, [{
    key: 'initBytesObjCType',


    // Working with Raw Values

    /**
     * Initializes a value object to contain the specified value, interpreted with the specified Objective-C type.
     * @access public
     * @param {UnsafeRawPointer} value - A pointer to data to be stored in the new value object.
     * @param {UnsafePointer<Int8>} type - The Objective-C type of value, as provided by the @encode() compiler directive. Do not hard-code this parameter as a C string. 
     * @returns {void}
     * @desc See Number and Value Programming Topics for other considerations in creating a value object.This is the designated initializer for the NSValue class.
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1411621-init
     */
    value: function initBytesObjCType(value, type) {}

    /**
     * Creates a value object containing the specified value, interpreted with the specified Objective-C type.
     * @access public
     * @param {UnsafeRawPointer} value - A pointer to data to be stored in the new value object.
     * @param {UnsafePointer<Int8>} type - The Objective-C type of value, as provided by the @encode() compiler directive. Do not hard-code this parameter as a C string. 
     * @returns {void}
     * @desc This method has the same effect as valueWithBytes:objCType: and may be deprecated in a future release. You should use valueWithBytes:objCType: instead.
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1417400-init
     */

  }, {
    key: 'initWithObjCType',
    value: function initWithObjCType(value, type) {}

    /**
     * Copies the value into the specified buffer.
     * @access public
     * @param {Object} value - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1415141-getvalue
     */

  }, {
    key: 'getValue',
    value: function getValue(value) {}

    /**
     * A C string containing the Objective-C type of the data contained in the value object.
     * @type {UnsafePointer<Int8>}
     * @desc This property provides the same string produced by the @encode() compiler directive.
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1412365-objctype
     */

  }, {
    key: 'objCType',
    get: function get() {
      return this._objCType;
    }

    // Working with Pointer and Object Values

    /**
     * Creates a value object containing the specified pointer.
     * @access public
     * @constructor
     * @param {?UnsafeRawPointer} pointer - 
     * @desc This method is equivalent to invoking init(_:withObjCType:) in this manner:NSValue *theValue = [NSValue value:&aPointer withObjCType:@encode(void *)];
    This method does not copy the contents of aPointer, so you must not to free the memory at the pointer destination while the NSValue object exists. NSData objects may be more suited for arbitrary pointers than NSValue objects.NSValue *theValue = [NSValue value:&aPointer withObjCType:@encode(void *)];
      * @see https://developer.apple.com/documentation/foundation/nsvalue/1415975-init
     */

  }], [{
    key: 'initWithCoder',

    /**
     * @access public
     * @param {NSCoder} coder -
     * @returns {Object} -
     */
    value: function initWithCoder(coder) {
      var special = coder._refObj['NS.special'];

      var size = coder._refObj['NS.sizeval'].obj;
      if (size) {
        if (size.charAt(0) !== '{' || size.charAt(size.length - 1) !== '}') {
          throw new Error('unknown NSValue size format: ' + size);
        }
        var values = size.slice(1, -1).split(',').map(parseFloat);
        return new _CGSize2.default(values[0], values[1]);
      }
      throw new Error('unknown NSValue type');
    }
  }]);

  function NSValue(pointer) {
    _classCallCheck(this, NSValue);

    // Working with Raw Values

    var _this = _possibleConstructorReturn(this, (NSValue.__proto__ || Object.getPrototypeOf(NSValue)).call(this));

    _this._objCType = null;

    // Working with Pointer and Object Values

    _this._pointerValue = null;
    _this._nonretainedObjectValue = null;

    // Working with Range Values

    _this._rangeValue = null;

    // Working with Foundation Geometry Values

    _this._pointValue = null;
    _this._sizeValue = null;
    _this._rectValue = null;

    // Working with CoreGraphics Geometry Values

    _this._cgPointValue = null;
    _this._cgVectorValue = null;
    _this._cgSizeValue = null;
    _this._cgRectValue = null;
    _this._cgAffineTransformValue = null;

    // Working with UIKit Geometry Values

    _this._uiEdgeInsetsValue = null;
    _this._uiOffsetValue = null;

    // Working with CoreAnimation Transform Values

    _this._caTransform3DValue = null;

    // Working with Media Time Values

    _this._timeValue = null;
    _this._timeRangeValue = null;
    _this._timeMappingValue = null;

    // Working with Geographic Coordinate Values

    _this._mkCoordinateValue = null;
    _this._mkCoordinateSpanValue = null;

    // Working with SceneKit Vector and Matrix Values

    _this._scnVector3Value = null;
    _this._scnVector4Value = null;
    _this._scnMatrix4Value = null;

    // Instance Properties

    _this._edgeInsetsValue = null;
    return _this;
  }

  /**
   * Creates a value object containing the specified object.
   * @access public
   * @param {?Object} anObject - The value for the new object.
   * @returns {void}
   * @desc  This method is equivalent to invoking init(_:withObjCType:) in this manner:NSValue *theValue = [NSValue value:&anObject withObjCType:@encode(void *)];
  This method is useful if you want to add an object to a Collection but don’t want the collection to create a strong reference to it.NSValue *theValue = [NSValue value:&anObject withObjCType:@encode(void *)];
    * @see https://developer.apple.com/documentation/foundation/nsvalue/1408098-init
   */


  _createClass(NSValue, [{
    key: 'initNonretainedObject',
    value: function initNonretainedObject(anObject) {}

    /**
     * Returns the value as an untyped pointer.
     * @type {?Object}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1410668-pointervalue
     */

  }, {
    key: 'initCgPoint',


    // Working with CoreGraphics Geometry Values

    /**
     * Creates a new value object containing the specified CoreGraphics point structure.
     * @access public
     * @param {CGPoint} point - The value for the new object.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624531-init
     */
    value: function initCgPoint(point) {}

    /**
     * Creates a new value object containing the specified CoreGraphics vector structure.
     * @access public
     * @param {CGVector} vector - The value for the new object.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624493-init
     */

  }, {
    key: 'initCgVector',
    value: function initCgVector(vector) {}

    /**
     * Creates a new value object containing the specified CoreGraphics size structure.
     * @access public
     * @param {CGSize} size - The value for the new object.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624511-init
     */

  }, {
    key: 'initCgSize',
    value: function initCgSize(size) {}

    /**
     * Creates a new value object containing the specified CoreGraphics rectangle structure.
     * @access public
     * @param {CGRect} rect - The value for the new object.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624529-init
     */

  }, {
    key: 'initCgRect',
    value: function initCgRect(rect) {}

    /**
     * Creates a new value object containing the specified CoreGraphics affine transform structure.
     * @access public
     * @param {CGAffineTransform} transform - The value for the new object.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624503-init
     */

  }, {
    key: 'initCgAffineTransform',
    value: function initCgAffineTransform(transform) {}

    /**
     * Returns the CoreGraphics point structure representation of the value.
     * @type {CGPoint}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624534-cgpointvalue
     */

  }, {
    key: 'initUiEdgeInsets',


    // Working with UIKit Geometry Values

    /**
     * Creates a new value object containing the specified UIKit edge insets structure.
     * @access public
     * @param {UIEdgeInsets} insets - The value for the new object.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624485-init
     */
    value: function initUiEdgeInsets(insets) {}

    /**
     * Creates a new value object containing the specified UIKit offset structure.
     * @access public
     * @param {UIOffset} insets - The value for the new object.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624530-init
     */

  }, {
    key: 'initUiOffset',
    value: function initUiOffset(insets) {}

    /**
     * Returns the UIKit edge insets structure representation of the value.
     * @type {UIEdgeInsets}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624517-uiedgeinsetsvalue
     */

  }, {
    key: 'initCaTransform3D',


    // Working with CoreAnimation Transform Values

    /**
     * Creates a new value object containing the specified CoreAnimation transform structure.
     * @access public
     * @param {CATransform3D} t - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1436556-init
     */
    value: function initCaTransform3D(t) {}

    /**
     * The CoreAnimation transform structure representation of the value.
     * @type {CATransform3D}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1436572-catransform3dvalue
     */

  }, {
    key: 'initMkCoordinate',


    // Working with Geographic Coordinate Values

    /**
     * Creates a new value object containing the specified CoreLocation geographic coordinate structure.
     * @access public
     * @param {CLLocationCoordinate2D} coordinate - The value for the new object.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1452193-init
     */
    value: function initMkCoordinate(coordinate) {}

    /**
     * Creates a new value object containing the specified MapKit coordinate span structure.
     * @access public
     * @param {MKCoordinateSpan} span - The value for the new object.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1452333-init
     */

  }, {
    key: 'initMkCoordinateSpan',
    value: function initMkCoordinateSpan(span) {}

    /**
     * The CoreLocation geographic coordinate structure representation of the value.
     * @type {CLLocationCoordinate2D}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1452495-mkcoordinatevalue
     */

  }, {
    key: 'initScnVector3',


    // Working with SceneKit Vector and Matrix Values

    /**
     * Creates a value object that contains the specified three-element SceneKit vector.
     * @access public
     * @param {SCNVector3} v - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1409671-init
     */
    value: function initScnVector3(v) {}

    /**
     * Creates a value object that contains the specified four-element SceneKit vector.
     * @access public
     * @param {SCNVector4} v - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1409688-init
     */

  }, {
    key: 'initScnVector4',
    value: function initScnVector4(v) {}

    /**
     * Creates a value object that contains the specified SceneKit 4 x 4 matrix.
     * @access public
     * @param {SCNMatrix4} v - The value for the new object.
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1409680-init
     */

  }, {
    key: 'initScnMatrix4',
    value: function initScnMatrix4(v) {}

    /**
     * The three-element Scene Kit vector representation of the value.
     * @type {SCNVector3}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1409669-scnvector3value
     */

  }, {
    key: 'isEqualTo',


    // Comparing Value Objects

    /**
     * Returns a Boolean value that indicates whether the value object and another value object are equal.
     * @access public
     * @param {NSValue} value - 
     * @returns {boolean} - 
     * @desc The NSValue class compares the type and contents of each value object to determine equality.
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1409038-isequal
     */
    value: function isEqualTo(value) {
      return false;
    }

    // Initializers

    /**
     * 
     * @access public
     * @param {NSCoder} aDecoder - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1417896-init
     */

  }, {
    key: 'initCoder',
    value: function initCoder(aDecoder) {}

    /**
     * 
     * @access public
     * @param {EdgeInsets} insets - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1391181-init
     */

  }, {
    key: 'initEdgeInsets',
    value: function initEdgeInsets(insets) {}

    // Instance Properties
    /**
     * 
     * @type {EdgeInsets}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1391123-edgeinsetsvalue
     */

  }, {
    key: 'pointerValue',
    get: function get() {
      return this._pointerValue;
    }

    /**
     * The value as a non-retained pointer to an object.
     * @type {?Object}
     * @desc If the value was not created to hold a pointer-sized data item, the result is undefined.
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1412287-nonretainedobjectvalue
     */

  }, {
    key: 'nonretainedObjectValue',
    get: function get() {
      return this._nonretainedObjectValue;
    }

    // Working with Range Values
    /**
     * The Foundation range structure representation of the value.
     * @type {NSRange}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1413902-rangevalue
     */

  }, {
    key: 'rangeValue',
    get: function get() {
      return this._rangeValue;
    }

    // Working with Foundation Geometry Values
    /**
     * The Foundation point structure representation of the value.
     * @type {CGPoint}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1391255-pointvalue
     */

  }, {
    key: 'pointValue',
    get: function get() {
      return this._pointValue;
    }

    /**
     * The Foundation size structure representation of the value.
     * @type {CGSize}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1391301-sizevalue
     */

  }, {
    key: 'sizeValue',
    get: function get() {
      return this._sizeValue;
    }

    /**
     * The Foundation rectangle structure representation of the value.
     * @type {CGRect}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1391171-rectvalue
     */

  }, {
    key: 'rectValue',
    get: function get() {
      return this._rectValue;
    }
  }, {
    key: 'cgPointValue',
    get: function get() {
      return this._cgPointValue;
    }

    /**
     * Returns the CoreGraphics vector structure representation of the value.
     * @type {CGVector}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624486-cgvectorvalue
     */

  }, {
    key: 'cgVectorValue',
    get: function get() {
      return this._cgVectorValue;
    }

    /**
     * Returns the CoreGraphics size structure representation of the value.
     * @type {CGSize}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624489-cgsizevalue
     */

  }, {
    key: 'cgSizeValue',
    get: function get() {
      return this._cgSizeValue;
    }
    /**
     * Returns the CoreGraphics rectangle structure representation of the value.
     * @type {CGRect}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624506-cgrectvalue
     */

  }, {
    key: 'cgRectValue',
    get: function get() {
      return this._cgRectValue;
    }

    /**
     * Returns the CoreGraphics affine transform representation of the value.
     * @type {CGAffineTransform}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624512-cgaffinetransformvalue
     */

  }, {
    key: 'cgAffineTransformValue',
    get: function get() {
      return this._cgAffineTransformValue;
    }
  }, {
    key: 'uiEdgeInsetsValue',
    get: function get() {
      return this._uiEdgeInsetsValue;
    }

    /**
     * Returns the UIKit offset structure representation of the value.
     * @type {UIOffset}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1624526-uioffsetvalue
     */

  }, {
    key: 'uiOffsetValue',
    get: function get() {
      return this._uiOffsetValue;
    }
  }, {
    key: 'caTransform3DValue',
    get: function get() {
      return this._caTransform3DValue;
    }

    // Working with Media Time Values
    /**
     * The CoreMedia time structure representation of the value.
     * @type {CMTime}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1388151-timevalue
     */

  }, {
    key: 'timeValue',
    get: function get() {
      return this._timeValue;
    }
    /**
     * The CoreMedia time range structure representation of the value.
     * @type {CMTimeRange}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1385930-timerangevalue
     */

  }, {
    key: 'timeRangeValue',
    get: function get() {
      return this._timeRangeValue;
    }
    /**
     * The CoreMedia time mapping structure representation of the value.
     * @type {CMTimeMapping}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1387277-timemappingvalue
     */

  }, {
    key: 'timeMappingValue',
    get: function get() {
      return this._timeMappingValue;
    }
  }, {
    key: 'mkCoordinateValue',
    get: function get() {
      return this._mkCoordinateValue;
    }
    /**
     * The MapKit coordinate span structure representation of the value.
     * @type {MKCoordinateSpan}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1452516-mkcoordinatespanvalue
     */

  }, {
    key: 'mkCoordinateSpanValue',
    get: function get() {
      return this._mkCoordinateSpanValue;
    }
  }, {
    key: 'scnVector3Value',
    get: function get() {
      return this._scnVector3Value;
    }
    /**
     * The four-element Scene Kit vector representation of the value.
     * @type {SCNVector4}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1409725-scnvector4value
     */

  }, {
    key: 'scnVector4Value',
    get: function get() {
      return this._scnVector4Value;
    }
    /**
     * The Scene Kit 4 x 4 matrix representation of the value.
     * @type {SCNMatrix4}
     * @desc 
     * @see https://developer.apple.com/documentation/foundation/nsvalue/1409684-scnmatrix4value
     */

  }, {
    key: 'scnMatrix4Value',
    get: function get() {
      return this._scnMatrix4Value;
    }
  }, {
    key: 'edgeInsetsValue',
    get: function get() {
      return this._edgeInsetsValue;
    }
  }]);

  return NSValue;
}(_NSObject3.default);

exports.default = NSValue;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _GKAgent2 = __webpack_require__(44);

var _GKAgent3 = _interopRequireDefault(_GKAgent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An agent that operates in a two-dimensional space. 
 * @access public
 * @extends {GKAgent}
 * @see https://developer.apple.com/documentation/gameplaykit/gkagent2d
 */
var GKAgent2D = function (_GKAgent) {
  _inherits(GKAgent2D, _GKAgent);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function GKAgent2D() {
    _classCallCheck(this, GKAgent2D);

    // Managing an Agent’s Position and Orientation

    /**
     * The current position of the agent in 2D space.
     * @type {CGPoint}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent2d/1501043-position
     */
    var _this = _possibleConstructorReturn(this, (GKAgent2D.__proto__ || Object.getPrototypeOf(GKAgent2D)).call(this));

    _this.position = new _CGPoint2.default(0, 0);

    /**
     * The rotation of the agent around the z-axis.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent2d/1501045-rotation
     */
    _this.rotation = 0;

    // Running the Agent Simulation

    /**
     * @access private
     * @type {CGPoint}
     */
    _this._velocity = new _CGPoint2.default();
    return _this;
  }

  // Running the Agent Simulation

  /**
   * Causes the agent to evaluate its goals and update its position, rotation, and velocity accordingly.
   * @access public
   * @param {number} seconds - 
   * @returns {void}
   * @desc You call this method directly on an individual agent, or on all the agents in your game through a GKComponentSystem object, whenever you want to run a step of the agent simulation. Typically, a game updates its agent simulation whenever it prepares to draw a new frame—for example, in the update(_:) method of a SpriteKit SKScene object.
   * @see https://developer.apple.com/documentation/gameplaykit/gkagent2d/1501242-update
   */


  _createClass(GKAgent2D, [{
    key: 'updateDeltaTime',
    value: function updateDeltaTime(seconds) {}

    /**
     * The current velocity of the agent in 2D space.
     * @type {CGPoint}
     * @desc An agent’s velocity is a calculated property—the velocity vector is determined by an agent’s facing direction (its rotation property) and its speed property.
     * @see https://developer.apple.com/documentation/gameplaykit/gkagent2d/1501186-velocity
     */

  }, {
    key: 'velocity',
    get: function get() {
      return this._velocity;
    }
  }]);

  return GKAgent2D;
}(_GKAgent3.default);

exports.default = GKAgent2D;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A polygonal path that can be followed by an agent.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gameplaykit/gkpath
 */
var GKPath = function (_NSObject) {
  _inherits(GKPath, _NSObject);

  /**
   * @access public
   * @constructor
   */
  function GKPath() {
    _classCallCheck(this, GKPath);

    // Managing a Path’s Attributes

    /**
     * The radius of the path.
     * @type {number}
     * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1501281-radius
     */
    var _this = _possibleConstructorReturn(this, (GKPath.__proto__ || Object.getPrototypeOf(GKPath)).call(this));

    _this.radius = 0;

    /**
     * A Boolean value that determines whether the path loops around on itself (that is, the path’s end point connects to its start point).
     * @type {boolean}
     * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1501244-iscyclical
     */
    _this.isCyclical = false;

    // Inspecting a Path’s Shape

    _this._points = [];
    return _this;
  }

  // Creating a Path

  /**
   * Initializes a path with the specified array of 2D points.
   * @access public
   * @param {UnsafeMutablePointer<vector_float2>} points - An array of 2D points representing the vertices in the path. The order of points in this array determines the order in which an agent follows the path.
   * @param {number} count - The number of elements in the pointsarray.
   * @param {number} radius - The radius of the path.
   * @param {boolean} cyclical - true if the path’s end point should connect to its start point; otherwise false.
   * @return {GKPath}
   * @desc The radius parameter defines the space occupied by the path—think of this space as the area created by sweeping a circle of the specified radius along the path from vertex to vertex. Agents with path-related goals will attempt to move to or stay within this area.The cyclical parameter determines whether the path loops around on itself. If the path is cyclical, an agent with a follow-path goal will proceed around the path indefinitely. If the path is not cyclical, an agent following the path will stop at the last point in the path.To use the newly created path to constrain an agent’s behavior, create a goal with the init(toStayOn:maxPredictionTime:) or init(toFollow:maxPredictionTime:forward:) method.
   * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1501048-init
   */


  _createClass(GKPath, [{
    key: 'float2At',


    // Inspecting a Path’s Shape

    /**
     * Returns the 2D point at the specified index in the path’s list of vertices.
     * @access public
     * @param {number} index - The index of the vertex to return, between 0 and the numPoints value.
     * @returns {number[]} - 
     * @desc You define a path’s vertices when creating it, either directly with the init(__float3Points:count:radius:cyclical:) initializer or indirectly with the init(graphNodes:radius:) initializer.If the path is a 3D path, this method is still functional but returns only 2D vectors, ignoring the z-component of each point on the path.
     * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1778285-float2
     */
    value: function float2At(index) {
      return this.pointAt(index);
    }

    /**
     * Returns the 3D point at the specified index in the path’s list of vertices.
     * @access public
     * @param {number} index - The index of the vertex to return, between 0 and the numPoints value.
     * @returns {number[]} - 
     * @desc You define a path’s vertices when creating it, either directly with the init(__float3Points:count:radius:cyclical:) initializer or indirectly with the init(graphNodes:radius:) initializer.If the path is a 2D path, this method is still functional, but returns 3D vectors whose z-component is always zero.
     * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1778310-float3
     */

  }, {
    key: 'float3At',
    value: function float3At(index) {
      var point = this._points[index];
      if (point) {
        return new _SCNVector2.default(point.x, point.y, point.z);
      }
      return null;
    }

    /**
     * Returns the 2D point at the specified index in the path’s list of vertices.
     * @access public
     * @param {number} index - The index of the vertex to return, between 0 and the numPoints value.
     * @returns {number[]} - 
     * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1501172-point
     */

  }, {
    key: 'pointAt',
    value: function pointAt(index) {
      var point = this._points[index];
      if (point) {
        return new _CGPoint2.default(point.x, point.y);
      }
      return null;
    }

    /**
     * The number of vertices in the path.
     * @type {number}
     * @desc You define a path’s vertices when creating it, either directly with the init(__points:count:radius:cyclical:) initializer or indirectly with the init(graphNodes:radius:) initializer.
     * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1501071-numpoints
     */

  }, {
    key: 'numPoints',
    get: function get() {
      return this._points.length();
    }
  }], [{
    key: 'pathWithPointsCountRadiusCyclical',
    value: function pathWithPointsCountRadiusCyclical(points, count, radius, cyclical) {
      var _path$_points;

      var path = new GKPath();

      (_path$_points = path._points).push.apply(_path$_points, _toConsumableArray(points.slice(0, count)));
      path.radius = radius;
      path.isCyclical = cyclical;

      return path;
    }

    /**
     * Initializes a path with the specified array of 3D points.
     * @access public
     * @param {UnsafeMutablePointer<vector_float3>} points - An array of points representing the vertices in the path. The order of points in this array determines the order in which an agent follows the path.
     * @param {number} count - The number of elements in the pointsarray.
     * @param {number} radius - The radius of the path.
     * @param {boolean} cyclical - true if the path’s end point (the last element of the points array) should connect to its start point (the first element in the points array); otherwise false.
     * @returns {GKPath}
     * @desc The radius parameter defines the space occupied by the path—think of this space as the volume created by sweeping a sphere of the specified radius along the path from vertex to vertex. Agents with path-related goals will attempt to move to or stay within this volume.The cyclical parameter determines whether the path loops around on itself. If the path is cyclical, an agent with a follow-path goal will proceed around the path indefinitely. If the path is not cyclical, an agent following the path will stop at the last point in the path.To use the newly created path to constrain an agent’s behavior, create a goal with the init(toStayOn:maxPredictionTime:) or init(toFollow:maxPredictionTime:forward:) method.
     * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1778297-init
     */

  }, {
    key: 'pathWithFloat3PointsCountRadiusCyclical',
    value: function pathWithFloat3PointsCountRadiusCyclical(points, count, radius, cyclical) {
      var _path$_points2;

      var path = new GKPath();

      (_path$_points2 = path._points).push.apply(_path$_points2, _toConsumableArray(points.slice(0, count)));
      path.radius = radius;
      path.isCyclical = cyclical;

      return path;
    }

    /**
     * Initializes a path using the positions of the specified graph nodes.
     * @access public
     * @param {GKGraphNode[]} graphNodes - An array of graph node objects containing 2D points.
     * @param {number} radius - The radius of the path.
     * @returns {GKPath}
     * @desc Use this initializer to turn a list of nodes from a navigation graph (as returned by the GKGraphfindPath(from:to:) method) into a path-following goal for an agent. If the nodes are GKGraphNode2D objects, this initializer creates a 2D path; if the nodes are GKGraphNode3D objects, this initializer creates a 3D path.The radius parameter defines the space occupied by the path—think of this space as the area created by sweeping a circle (or sphere, for 3D paths) of the specified radius along the path from vertex to vertex. Agents with path-related goals will attempt to move to or stay within this area.To use the newly created path to constrain an agent’s behavior, create a goal with the init(toStayOn:maxPredictionTime:) or init(toFollow:maxPredictionTime:forward:) method.
     * @see https://developer.apple.com/documentation/gameplaykit/gkpath/1501138-init
     */

  }, {
    key: 'pathWithGraphNodesRadius',
    value: function pathWithGraphNodesRadius(graphNodes, radius) {
      var path = new GKPath();
      // TODO: implement
      path.radius = radius;

      return path;
    }

    /**
     *
     * @access public
     * @param {float2[]|float3[]} points -
     * @param {number} radius -
     * @param {boolean} cyclical -
     * @returns {GKPath}
     */

  }, {
    key: 'pathWithPointsRadiusCyclical',
    value: function pathWithPointsRadiusCyclical(points, radius, cyclical) {
      var _path$_points3;

      var path = new GKPath();

      (_path$_points3 = path._points).push.apply(_path$_points3, _toConsumableArray(points));
      path.radius = radius;
      path.isCyclical = cyclical;

      return path;
    }
  }]);

  return GKPath;
}(_NSObject3.default);

exports.default = GKPath;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import GKSceneRootNodeType from './GKSceneRootNodeType'
//import GKEntity from './GKEntity'
//import GKGraph from './GKGraph'

/**
 * A container for associating GameplayKit objects with a SpriteKit scene.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/gameplaykit/gkscene
 */
var GKScene = function (_NSObject) {
  _inherits(GKScene, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function GKScene() {
    _classCallCheck(this, GKScene);

    // Accessing the SpriteKit Scene

    /**
     * The SpriteKit scene managed by this GKScene object.
     * @type {?GKSceneRootNodeType}
     * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640947-rootnode
     */
    var _this = _possibleConstructorReturn(this, (GKScene.__proto__ || Object.getPrototypeOf(GKScene)).call(this));

    _this.rootNode = null;

    // Managing Entities and Components

    _this._entities = [];

    // Managing Pathfinding Graphs

    _this._graphs = {};
    return _this;
  }

  // Loading a Scene File

  /**
   * Loads the specified SpriteKit scene file, creating a GKScene object containing the SpriteKit scene and associated GameplayKit objects.
   * @access public
   * @param {string} filename - The name of a scene file in your app’s main bundle.
   * @returns {void}
   * @desc Use this initializer to load SpriteKit scenes (.sks files) created in the Xcode SpriteKit scene editor that contain associated GameplayKit entities, components, and pathfinding graphs.
   * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640935-init
   */


  _createClass(GKScene, [{
    key: 'addEntity',


    // Managing Entities and Components

    /**
     * Adds a GameplayKit entity to the list of entities managed by the scene.
     * @access public
     * @param {GKEntity} entity - The entity to be added to the scene.
     * @returns {void}
     * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640954-addentity
     */
    value: function addEntity(entity) {
      if (this._entities.indexOf(entity) < 0) {
        this._entities.push(entity);
      }
    }

    /**
     * Removes a GameplayKit entity from the list of entities managed by the scene.
     * @access public
     * @param {GKEntity} entity - The entity to be removed from the scene.
     * @returns {void}
     * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640686-removeentity
     */

  }, {
    key: 'removeEntity',
    value: function removeEntity(entity) {
      var index = this._entities.indexOf(entity);
      this._entities.splice(index, 1);
    }

    /**
     * The list of GameplayKit entities managed by the scene.
     * @type {GKEntity[]}
     * @desc When you add entities (and their components) to a scene in the Xcode SpriteKit scene editor, Xcode automatically adds them to this array.
     * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640795-entities
     */

  }, {
    key: 'removeGraph',


    // Managing Pathfinding Graphs

    /**
     * Removes a pathfinding graph from the list of graphs managed by the scene.
     * @access public
     * @param {string} name - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640663-removegraph
     */
    value: function removeGraph(name) {
      if (this._graphs[name]) {
        delete this._graphs[name];
      }
    }

    /**
     * The list of pathfinding graph objects managed by the scene.
     * @type {Map<string, GKGraph>}
     * @desc When you define pathfinding graphs in the Xcode SpriteKit scene editor, Xcode automatically adds them to this array.
     * @see https://developer.apple.com/documentation/gameplaykit/gkscene/1640940-graphs
     */

  }, {
    key: 'addGraph',


    // Instance Methods

    /**
     * 
     * @access public
     * @param {GKGraph} graph - 
     * @param {string} name - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/gameplaykit/gkscene/2143063-addgraph
     */
    value: function addGraph(graph, name) {
      this._graphs[name] = graph;
    }
  }, {
    key: 'entities',
    get: function get() {
      return this._entities.slice();
    }
  }, {
    key: 'graphs',
    get: function get() {
      return this._graphs;
    }
  }], [{
    key: 'sceneWithFileNamed',
    value: function sceneWithFileNamed(filename) {
      var scene = new GKScene();
      // TODO: implement
      return scene;
    }
  }]);

  return GKScene;
}(_NSObject3.default);

exports.default = GKScene;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GKComponent2 = __webpack_require__(32);

var _GKComponent3 = _interopRequireDefault(_GKComponent2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * 
 * @access public
 * @extends {GKComponent}
 * @see https://developer.apple.com/documentation/gameplaykit/gkscnnodecomponent
 */
var GKSCNNodeComponent = function (_GKComponent) {
  _inherits(GKSCNNodeComponent, _GKComponent);

  // Initializers

  /**
   * 
   * @access public
   * @constructor
   * @param {SCNNode} node - 
   * @see https://developer.apple.com/documentation/gameplaykit/gkscnnodecomponent/2873248-init
   */
  function GKSCNNodeComponent(node) {
    _classCallCheck(this, GKSCNNodeComponent);

    // Instance Properties

    var _this = _possibleConstructorReturn(this, (GKSCNNodeComponent.__proto__ || Object.getPrototypeOf(GKSCNNodeComponent)).call(this));

    _this._node = node;
    return _this;
  }

  // Instance Properties

  /**
   * 
   * @type {SCNNode}
   * @desc 
   * @see https://developer.apple.com/documentation/gameplaykit/gkscnnodecomponent/2873245-node
   */


  _createClass(GKSCNNodeComponent, [{
    key: 'node',
    get: function get() {
      return this._node;
    }
  }]);

  return GKSCNNodeComponent;
}(_GKComponent3.default);

exports.default = GKSCNNodeComponent;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * An interface that allows objects to respond to actions triggered by a CALayer.
 * @interface
 * @see https://developer.apple.com/documentation/quartzcore/caaction
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CAAction = function () {
  function CAAction() {
    _classCallCheck(this, CAAction);
  }

  _createClass(CAAction, [{
    key: 'runForKeyObjectArguments',


    /**
     * constructor
     * @access public
     * @constructor
     */
    //constructor() {
    //}

    // Responding to an action

    /**
     * Required. Called to trigger the action specified by the identifier.
     * @access public
     * @param {string} event - 
     * @param {Object} anObject - The layer on which the action should occur.
     * @param {?Map<AnyHashable, Object>} dict - A dictionary containing parameters associated with this event. May be nil.
     * @returns {void}
     * @see https://developer.apple.com/documentation/quartzcore/caaction/1410806-run
     */
    value: function runForKeyObjectArguments(event, anObject, dict) {}
  }]);

  return CAAction;
}();

exports.default = CAAction;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CAAnimation = __webpack_require__(24);

var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Methods your app can implement to respond when animations start and stop.
 * @interface
 * @see https://developer.apple.com/documentation/quartzcore/caanimationdelegate
 */
var CAAnimationDelegate = function () {
  function CAAnimationDelegate() {
    _classCallCheck(this, CAAnimationDelegate);
  }

  _createClass(CAAnimationDelegate, [{
    key: 'animationDidStart',


    /**
     * constructor
     * @access public
     * @constructor
     */
    //constructor() {
    //}

    // Instance Methods

    /**
     * Tells the delegate the animation has started. 
     * @access public
     * @param {CAAnimation} anim - The CAAnimation object that has started.
     * @returns {void}
     * @see https://developer.apple.com/documentation/quartzcore/caanimationdelegate/2097265-animationdidstart
     */
    value: function animationDidStart(anim) {}

    /**
     * Tells the delegate the animation has ended. 
     * @access public
     * @param {CAAnimation} anim - The CAAnimation object that has ended.
     * @param {boolean} flag - A flag indicating whether the animation has completed by reaching the end of its duration.
     * @returns {void}
     * @desc The animation may have ended because it has completed its active duration or because it has been removed from the layer it is attached to. flag is true if the animation reached the end of its duration without being removed.
     * @see https://developer.apple.com/documentation/quartzcore/caanimationdelegate/2097259-animationdidstop
     */

  }, {
    key: 'animationDidStopFinished',
    value: function animationDidStopFinished(anim, flag) {}
  }]);

  return CAAnimationDelegate;
}();

exports.default = CAAnimationDelegate;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Returns the current absolute time, in seconds.
 * @access public
 * @returns {number} - 
 * @see https://developer.apple.com/documentation/quartzcore/1395996-cacurrentmediatime
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CACurrentMediaTime = function CACurrentMediaTime() {
  return Date.now() * 0.001;
};

exports.default = CACurrentMediaTime;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Methods that model a hierarchical timing system, allowing objects to map time between their parent and local time. 
 * @interface
 * @see https://developer.apple.com/documentation/quartzcore/camediatiming
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CAMediaTiming =

/**
 * constructor
 * @access public
 * @constructor
 */
function CAMediaTiming() {
  _classCallCheck(this, CAMediaTiming);

  // Animation Start Time

  /**
   * Required. Specifies the begin time of the receiver in relation to its parent object, if applicable.
   * @type {number}
   * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427654-begintime
   */
  this.beginTime = 0;

  /**
   * Required. Specifies an additional time offset in active local time.
   * @type {number}
   * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427650-timeoffset
   */
  this.timeOffset = 0;

  // Repeating Animations

  /**
   * Required. Determines the number of times the animation will repeat.
   * @type {number}
   * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427666-repeatcount
   */
  this.repeatCount = 0;

  /**
   * Required. Determines how many seconds the animation will repeat for.
   * @type {number}
   * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427643-repeatduration
   */
  this.repeatDuration = 0;

  // Duration and Speed

  /**
   * Required. Specifies the basic duration of the animation, in seconds.
   * @type {number}
   * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427652-duration
   */
  this.duration = 0;

  /**
   * Required. Specifies how time is mapped to receiver’s time space from the parent time space. 
   * @type {number}
   * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427647-speed
   */
  this.speed = 0;

  // Playback Modes

  /**
   * Required. Determines if the receiver plays in the reverse upon completion.
   * @type {boolean}
   * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427645-autoreverses
   */
  this.autoreverses = false;

  /**
   * Required. Determines if the receiver’s presentation is frozen or removed once its active duration has completed.
   * @type {string}
   * @see https://developer.apple.com/documentation/quartzcore/camediatiming/1427656-fillmode
   */
  this.fillMode = '';
};

exports.default = CAMediaTiming;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Defines the standard transform matrix used throughout Core Animation.
 * @access public
 * @see https://developer.apple.com/documentation/quartzcore/catransform3d
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CATransform3D =

// Initializers

/**
 * 
 * @access public
 * @constructor
 * @param {number[][]} m - 
 * @see https://developer.apple.com/documentation/quartzcore/catransform3d/1523734-init
 */
function CATransform3D(m) {
  _classCallCheck(this, CATransform3D);

  // Instance Properties

  this._m11 = 1;
  this._m12 = 0;
  this._m13 = 0;
  this._m14 = 0;
  this._m21 = 0;
  this._m22 = 1;
  this._m23 = 0;
  this._m24 = 0;
  this._m31 = 0;
  this._m32 = 0;
  this._m33 = 1;
  this._m34 = 0;
  this._m41 = 0;
  this._m42 = 0;
  this._m43 = 0;
  this._m44 = 1;
}

// Instance Properties
;

exports.default = CATransform3D;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNConstraint2 = __webpack_require__(17);

var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * 
 * @access public
 * @extends {SCNConstraint}
 * @see https://developer.apple.com/documentation/scenekit/scnaccelerationconstraint
 */
var SCNAccelerationConstraint = function (_SCNConstraint) {
  _inherits(SCNAccelerationConstraint, _SCNConstraint);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNAccelerationConstraint() {
    _classCallCheck(this, SCNAccelerationConstraint);

    // Instance Properties

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaccelerationconstraint/2873359-damping
     */
    var _this = _possibleConstructorReturn(this, (SCNAccelerationConstraint.__proto__ || Object.getPrototypeOf(SCNAccelerationConstraint)).call(this));

    _this.damping = 0;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaccelerationconstraint/2873367-decelerationdistance
     */
    _this.decelerationDistance = 0;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaccelerationconstraint/2873355-maximumlinearacceleration
     */
    _this.maximumLinearAcceleration = 0;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaccelerationconstraint/2873384-maximumlinearvelocity
     */
    _this.maximumLinearVelocity = 0;

    return _this;
  }

  return SCNAccelerationConstraint;
}(_SCNConstraint3.default);

exports.default = SCNAccelerationConstraint;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNAction from './SCNAction'

/**
 * Methods for running actions on nodes.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnactionable
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNActionable = function () {

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNActionable() {
    _classCallCheck(this, SCNActionable);

    // Inspecting a Node’s Running Actions

    this._hasActions = false;
    this._actionKeys = null;
  }

  // Running Actions

  /**
   * Required. Adds an action to the list of actions executed by the node.
   * @access public
   * @param {SCNAction} action - The action to be performed.
   * @returns {void}
   * @desc SceneKit begins running a newly added action when it prepares to render the next frame.
   * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523164-runaction
   */


  _createClass(SCNActionable, [{
    key: 'runAction',
    value: function runAction(action) {}

    /**
     * Required. Adds an action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
     * @access public
     * @param {SCNAction} action - The action to be performed.
     * @param {?function(): void} [block = null] - A completion block that SceneKit calls when the action completes.
     * @returns {void}
     * @desc The new action is processed the next time SceneKit prepares to render a frame.SceneKit calls your block after the action’s duration is complete. For example, in a game you could use this method to show a Game Over message after performing a fade-out action on a node that displays a player character.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1524219-runaction
     */

  }, {
    key: 'runActionCompletionHandler',
    value: function runActionCompletionHandler(action) {
      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    }

    /**
     * Required. Adds an identifiable action to the list of actions executed by the node.
     * @access public
     * @param {SCNAction} action - The action to be performed.
     * @param {?string} key - A unique key used to identify the action.
     * @returns {void}
     * @desc This method is identical to runAction(_:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1524222-runaction
     */

  }, {
    key: 'runActionForKey',
    value: function runActionForKey(action, key) {}

    /**
     * Required. Adds an identifiable action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
     * @access public
     * @param {SCNAction} action - The action to be performed.
     * @param {?string} key - A unique key used to identify the action.
     * @param {?function(): void} [block = null] - A completion block called when the action completes.
     * @returns {void}
     * @desc This method is identical to runAction(_:completionHandler:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.SceneKit calls your block after the action’s duration is complete. For example, you can use this method with a wait action to execute some code after a timed delay. If during the delay period you need to prevent the code from running, use the removeAction(forKey:) method to cancel it.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1522791-runaction
     */

  }, {
    key: 'runActionForKeyCompletionHandler',
    value: function runActionForKeyCompletionHandler(action, key) {
      var block = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    }

    // Inspecting a Node’s Running Actions

    /**
     * Required. Returns an action associated with a specific key.
     * @access public
     * @param {string} key - A string that uniquely identifies a action.
     * @returns {?SCNAction} - 
     * @desc Use this method to retrieve actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523287-action
     */

  }, {
    key: 'actionForKey',
    value: function actionForKey(key) {
      return null;
    }
    /**
     * Required. A Boolean value that indicates whether the node is currently executing any actions.
     * @type {boolean}
     * @desc This value is true if the node has any executing actions; otherwise the value is false.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523794-hasactions
     */

  }, {
    key: 'removeActionForKey',


    // Canceling a Node’s Running Actions

    /**
     * Required. Removes an action associated with a specific key.
     * @access public
     * @param {string} key - A string that uniquely identifies a action.
     * @returns {void}
     * @desc If the node is currently running an action that matches the key, SceneKit removes that action from the node, skipping any remaining animation it would perform but keeping any changes already made to the node.Use this method to cancel actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523617-removeaction
     */
    value: function removeActionForKey(key) {}

    /**
     * Required. Ends and removes all actions from the node.
     * @access public
     * @returns {void}
     * @desc When SceneKit removes an action from a node, it skips any remaining animation the action would perform. However, any changes the action has already made to the node’s state remain in effect.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1524181-removeallactions
     */

  }, {
    key: 'removeAllActions',
    value: function removeAllActions() {}
  }, {
    key: 'hasActions',
    get: function get() {
      return this._hasActions;
    }
    /**
     * Required. The list of keys for which the node has attached actions.
     * @type {string[]}
     * @desc Use this property to list actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnactionable/1523036-actionkeys
     */

  }, {
    key: 'actionKeys',
    get: function get() {
      return this._actionKeys;
    }
  }]);

  return SCNActionable;
}();

exports.default = SCNActionable;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionCustom = function (_SCNAction) {
  _inherits(SCNActionCustom, _SCNAction);

  _createClass(SCNActionCustom, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float'
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionCustom() {
    _classCallCheck(this, SCNActionCustom);

    var _this = _possibleConstructorReturn(this, (SCNActionCustom.__proto__ || Object.getPrototypeOf(SCNActionCustom)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  return SCNActionCustom;
}(_SCNAction3.default);

exports.default = SCNActionCustom;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

var _SCNNode = __webpack_require__(14);

var _SCNNode2 = _interopRequireDefault(_SCNNode);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionFade = function (_SCNAction) {
  _inherits(SCNActionFade, _SCNAction);

  _createClass(SCNActionFade, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float',

        name: ['string', null]
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionFade() {
    _classCallCheck(this, SCNActionFade);

    var _this = _possibleConstructorReturn(this, (SCNActionFade.__proto__ || Object.getPrototypeOf(SCNActionFade)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;

    _this._toValue = null;
    _this._byValue = null;
    return _this;
  }

  /**
   * Creates an action that changes the opacity of the node to 1.0.
   * @access public
   * @param {number} sec - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s opacity property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOutWithDuration: sec];
  [SCNAction fadeOutWithDuration: sec];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1522777-fadein
   */


  _createClass(SCNActionFade, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SCNActionFade} -
     */
    value: function copy() {
      var action = _get(SCNActionFade.prototype.__proto__ || Object.getPrototypeOf(SCNActionFade.prototype), 'copy', this).call(this);

      action._toValue = this._toValue;
      action._byValue = this._byValue;
      action._duration = this._duration;

      return action;
    }

    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAction',
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var t = this._getTime(time, needTimeConversion);
      if (!(0, _InstanceOf3.default)(obj, _SCNNode2.default)) {
        throw new Error('unsupported class for SCNActionFade: ' + obj.constructor.name);
      }

      var baseValue = obj._opacity;
      var toValue = 0;
      if (this._toValue !== null) {
        toValue = this._toValue;
      } else if (this._byValue !== null) {
        toValue = baseValue + this._byValue;
      } else {
        throw new Error('both toValue and byValue are null');
      }

      var value = this._lerp(baseValue, toValue, t
      //console.warn(`opacity time: ${time}, t: ${t}, base: ${baseValue}, to: ${toValue}, val: ${value}`)
      );obj.presentation._opacity = value;

      if (this._finished) {
        obj._opacity = toValue;
      }
    }
  }], [{
    key: 'fadeInDuration',
    value: function fadeInDuration(sec) {
      var action = new SCNActionFade();
      action._toValue = 1;
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that changes the opacity of the node to 0.0.
     * @access public
     * @param {number} sec - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s opacity property animates from its current value to 0.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeInWithDuration: sec];
    [SCNAction fadeInWithDuration: sec];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1523922-fadeout
     */

  }, {
    key: 'fadeOutDuration',
    value: function fadeOutDuration(sec) {
      var action = new SCNActionFade();
      action._toValue = 0;
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that adjusts the opacity of a node by a relative value.
     * @access public
     * @param {number} factor - The amount to change the node’s opacity by.
     * @param {number} sec - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s opacity property animates to its new value.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOpacityBy: -factor duration: sec];
    [SCNAction fadeOpacityBy: -factor duration: sec];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1523595-fadeopacity
     */

  }, {
    key: 'fadeOpacityByDuration',
    value: function fadeOpacityByDuration(factor, sec) {
      var action = new SCNActionFade();
      action._byValue = factor;
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that adjusts the opacity of a node to a new value.
     * @access public
     * @param {number} opacity - The new opacity value of the node.
     * @param {number} sec - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s opacity property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1523875-fadeopacity
     */

  }, {
    key: 'fadeOpacityToDuration',
    value: function fadeOpacityToDuration(opacity, sec) {
      var action = new SCNActionFade();
      action._toValue = opacity;
      action._duration = sec;
      return action;
    }
  }]);

  return SCNActionFade;
}(_SCNAction3.default);

exports.default = SCNActionFade;


_SCNAction3.default.fadeInDuration = SCNActionFade.fadeInDuration;
_SCNAction3.default.fadeOutDuration = SCNActionFade.fadeOutDuration;
_SCNAction3.default.fadeOpacityByDuration = SCNActionFade.fadeOpacityByDuration;
_SCNAction3.default.fadeOpacityToDuration = SCNActionFade.fadeOpacityToDuration;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNActionTimingMode from './SCNActionTimingMode'

var SCNActionGroup = function (_SCNAction) {
  _inherits(SCNActionGroup, _SCNAction);

  _createClass(SCNActionGroup, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float',

        name: ['string', null]
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionGroup() {
    _classCallCheck(this, SCNActionGroup);

    var _this = _possibleConstructorReturn(this, (SCNActionGroup.__proto__ || Object.getPrototypeOf(SCNActionGroup)).call(this));

    _this._actions = [];
    return _this;
  }

  /**
   * Creates an action that runs a collection of actions in parallel.
   * @access public
   * @param {SCNAction[]} actions - An array of SCNAction objects.
   * @returns {SCNAction} - 
   * @desc When the action executes, the actions that make up the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the group’s duration, the action completes and then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522779-group
   */


  _createClass(SCNActionGroup, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SCNActionGroup} -
     */
    value: function copy() {
      var action = _get(SCNActionGroup.prototype.__proto__ || Object.getPrototypeOf(SCNActionGroup.prototype), 'copy', this).call(this);

      action._actions = [];
      this._actions.forEach(function (act) {
        action._actions.push(act.copy());
      });

      return action;
    }
  }, {
    key: '_applyAction',


    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      //const dt = this._getTime(time, needTimeConversion) * this.duration
      //this._actions.forEach((action) => {
      //  if(!action._finished){
      //    action._applyAction(obj, dt, false)
      //  }
      //})
      var duration = this._activetimeFromTime(time);

      var finished = true;
      this._actions.forEach(function (action) {
        if (!action._finished) {
          action._applyAction(obj, duration, needTimeConversion);
          if (!action._finished) {
            finished = false;
          }
        }
      });
      this._finished = finished;
    }
  }, {
    key: '_resetFinished',
    value: function _resetFinished() {
      this._actions.forEach(function (action) {
        action._resetFinished();
      });
      this._finished = false;
    }
  }, {
    key: 'duration',
    get: function get() {
      var d = 0;
      this._actions.forEach(function (act) {
        if (d < act.duration) {
          d = act.duration;
        }
      });
      return d;
    }
  }], [{
    key: 'group',
    value: function group(actions) {
      var action = new SCNActionGroup();
      action._actions = actions;
      return action;
    }
  }]);

  return SCNActionGroup;
}(_SCNAction3.default);

exports.default = SCNActionGroup;


_SCNAction3.default.group = SCNActionGroup.group;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionHide = function (_SCNAction) {
  _inherits(SCNActionHide, _SCNAction);

  _createClass(SCNActionHide, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float',

        name: ['string', null]
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionHide() {
    _classCallCheck(this, SCNActionHide);

    var _this = _possibleConstructorReturn(this, (SCNActionHide.__proto__ || Object.getPrototypeOf(SCNActionHide)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  return SCNActionHide;
}(_SCNAction3.default);

exports.default = SCNActionHide;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionJavaScript = function (_SCNAction) {
  _inherits(SCNActionJavaScript, _SCNAction);

  _createClass(SCNActionJavaScript, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float'
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionJavaScript() {
    _classCallCheck(this, SCNActionJavaScript);

    var _this = _possibleConstructorReturn(this, (SCNActionJavaScript.__proto__ || Object.getPrototypeOf(SCNActionJavaScript)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  return SCNActionJavaScript;
}(_SCNAction3.default);

exports.default = SCNActionJavaScript;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

var _SCNNode = __webpack_require__(14);

var _SCNNode2 = _interopRequireDefault(_SCNNode);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionMove = function (_SCNAction) {
  _inherits(SCNActionMove, _SCNAction);

  _createClass(SCNActionMove, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float'
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionMove() {
    _classCallCheck(this, SCNActionMove);

    var _this = _possibleConstructorReturn(this, (SCNActionMove.__proto__ || Object.getPrototypeOf(SCNActionMove)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;

    _this._toValue = null;
    _this._byValue = null;
    return _this;
  }

  /**
   * Creates an action that moves a node relative to its current position.
   * @access public
   * @param {number} deltaX - The distance to move the node in the X direction of its parent node’s local coordinate space.
   * @param {number} deltaY - The distance to move the node in the Y direction of its parent node’s local coordinate space.
   * @param {number} deltaZ - The distance to move the node in the Z direction of its parent node’s local coordinate space.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];
  [SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523238-moveby
   */


  _createClass(SCNActionMove, [{
    key: 'reversed',


    // Reversing an Action

    /**
     * Creates an action that reverses the behavior of another action.
     * @access public
     * @returns {SCNAction} - 
     * @desc This method always returns an action object; however, not all actions are reversible. When reversed, some actions return an object that either does nothing or performs the same action as the original action. For details on how an action is reversed, see the description of the class method used to create that action.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522815-reversed
     */
    value: function reversed() {
      var action = this.copy();
      if (action._toValue) {
        action._toValue = null;
        action._byValue = new _SCNVector2.default(0, 0, 0);
      } else if (this._byValue) {
        action._byValue = this._byValue.mul(-1);
      }
      return action;
    }

    /**
     * @access public
     * @returns {SCNActionMove} -
     */

  }, {
    key: 'copy',
    value: function copy() {
      var action = _get(SCNActionMove.prototype.__proto__ || Object.getPrototypeOf(SCNActionMove.prototype), 'copy', this).call(this);

      action._toValue = this._toValue ? this._toValue._copy() : null;
      action._byValue = this._byValue ? this._byValue._copy() : null;

      return action;
    }

    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAction',
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var t = this._getTime(time, needTimeConversion);
      if (!(0, _InstanceOf3.default)(obj, _SCNNode2.default)) {
        throw new Error('unsupported class for SCNActionMove: ' + obj.constructor.name);
      }

      var baseValue = obj.position;
      var toValue = null;
      if (this._toValue !== null) {
        toValue = this._toValue;
      } else if (this._byValue !== null) {
        toValue = baseValue.add(this._byValue);
      } else {
        throw new Error('both toValue and byValue are null');
      }

      var value = this._lerp(baseValue, toValue, t);
      obj.presentation.position = value;

      if (this._finished) {
        obj.position = toValue;
      }
    }
  }], [{
    key: 'moveByXYZ',
    value: function moveByXYZ(deltaX, deltaY, deltaZ, duration) {
      var action = new SCNActionMove();
      action._byValue = new _SCNVector2.default(deltaX, deltaY, deltaZ);
      action._duration = duration;
      return action;
    }

    /**
     * Creates an action that moves a node relative to its current position.
     * @access public
     * @param {SCNVector3} delta - A vector that describes the change to be applied to the node’s position.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code had been executed:SCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);
    [SCNAction moveBy: reverseDelta duration: duration];
    SCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);
    [SCNAction moveBy: reverseDelta duration: duration];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1522605-move
     */

  }, {
    key: 'moveBy',
    value: function moveBy(delta, duration) {
      var action = new SCNActionMove();
      action._byValue = delta._copy();
      action._duration = duration;
      return action;
    }

    /**
     * Creates an action that moves a node to a new position.
     * @access public
     * @param {SCNVector3} location - The coordinates for the node’s new position in its parent node’s local coordinate space.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is not reversible; the reverse of this action has the same duration but does not move the node.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522826-move
     */

  }, {
    key: 'moveTo',
    value: function moveTo(location, duration) {
      var action = new SCNActionMove();
      action._toValue = location._copy();
      action._duration = duration;
      return action;
    }
  }]);

  return SCNActionMove;
}(_SCNAction3.default);

exports.default = SCNActionMove;


_SCNAction3.default.moveByXYZ = SCNActionMove.moveByXYZ;
_SCNAction3.default.moveBy = SCNActionMove.moveBy;
_SCNAction3.default.moveTo = SCNActionMove.moveTo;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionPerformSelector = function (_SCNAction) {
  _inherits(SCNActionPerformSelector, _SCNAction);

  _createClass(SCNActionPerformSelector, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float'
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionPerformSelector() {
    _classCallCheck(this, SCNActionPerformSelector);

    var _this = _possibleConstructorReturn(this, (SCNActionPerformSelector.__proto__ || Object.getPrototypeOf(SCNActionPerformSelector)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  return SCNActionPerformSelector;
}(_SCNAction3.default);

exports.default = SCNActionPerformSelector;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionPlaySound = function (_SCNAction) {
  _inherits(SCNActionPlaySound, _SCNAction);

  _createClass(SCNActionPlaySound, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float',

        name: ['string', null]
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionPlaySound() {
    _classCallCheck(this, SCNActionPlaySound);

    var _this = _possibleConstructorReturn(this, (SCNActionPlaySound.__proto__ || Object.getPrototypeOf(SCNActionPlaySound)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;

    _this._source = null;
    _this._wait = false;
    return _this;
  }

  /**
   * Creates an action that plays an audio source.
   * @access public
   * @param {SCNAudioSource} source - The audio source to play.
   * @param {boolean} wait - If true, the duration of this action is the same as the length of the audio playback. If false, the action is considered to have completed immediately.
   * @returns {SCNAction} - 
   * @desc When the action executes, SceneKit plays the audio source on the target node—any positional audio effects are based on the node’s position. For more information about positional audio in SceneKit, see SCNAudioPlayer.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523651-playaudio
   */


  _createClass(SCNActionPlaySound, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SCNActionPlaySound} -
     */
    value: function copy() {
      var action = _get(SCNActionPlaySound.prototype.__proto__ || Object.getPrototypeOf(SCNActionPlaySound.prototype), 'copy', this).call(this);

      action._source = this._source;
      action._wait = this._wait;

      return action;
    }

    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAction',
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (!this._isRunning) {
        this._source._play();
        this._isRunning = true;
      }
      if (this._duration <= 0 || this._source._duration > 0) {
        this._duration = this._source._duration;
      }
      var t = this._getTime(time, needTimeConversion);

      if (!this._wait) {
        this._finished = true;
      } else if (!this._source.loops && t >= 1) {
        this._finished = true;
      } else {
        this._finished = false;
      }
    }
  }], [{
    key: 'playAudioWaitForCompletion',
    value: function playAudioWaitForCompletion(source, wait) {
      var action = new SCNActionPlaySound();
      action._source = source;
      action._wait = wait;
      return action;
    }
  }]);

  return SCNActionPlaySound;
}(_SCNAction3.default);

exports.default = SCNActionPlaySound;


_SCNAction3.default.playAudioWaitForCompletion = SCNActionPlaySound.playAudioWaitForCompletion;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionReference = function (_SCNAction) {
  _inherits(SCNActionReference, _SCNAction);

  _createClass(SCNActionReference, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float'
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionReference() {
    _classCallCheck(this, SCNActionReference);

    var _this = _possibleConstructorReturn(this, (SCNActionReference.__proto__ || Object.getPrototypeOf(SCNActionReference)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  return SCNActionReference;
}(_SCNAction3.default);

exports.default = SCNActionReference;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

var _SCNNode = __webpack_require__(14);

var _SCNNode2 = _interopRequireDefault(_SCNNode);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionRemove = function (_SCNAction) {
  _inherits(SCNActionRemove, _SCNAction);

  _createClass(SCNActionRemove, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float'
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionRemove() {
    _classCallCheck(this, SCNActionRemove);

    var _this = _possibleConstructorReturn(this, (SCNActionRemove.__proto__ || Object.getPrototypeOf(SCNActionRemove)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  /**
   * Creates an action that removes the node from its parent.
   * @access public
   * @returns {SCNAction} - 
   * @desc When the action executes, the node is immediately removed from its parent.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522966-removefromparentnode
   */


  _createClass(SCNActionRemove, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SCNActionRotate} -
     */
    value: function copy() {
      var action = _get(SCNActionRemove.prototype.__proto__ || Object.getPrototypeOf(SCNActionRemove.prototype), 'copy', this).call(this);
      return action;
    }

    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAction',
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (!(0, _InstanceOf3.default)(obj, _SCNNode2.default)) {
        throw new Error('unsupported class for SCNActionRemove: ' + obj.constructor.name);
      }
      obj.removeFromParentNode();
      this._finished = true;
    }
  }], [{
    key: 'removeFromParentNode',
    value: function removeFromParentNode() {
      var action = new SCNActionRemove();
      return action;
    }
  }]);

  return SCNActionRemove;
}(_SCNAction3.default);

exports.default = SCNActionRemove;


_SCNAction3.default.removeFromParentNode = SCNActionRemove.removeFromParentNode;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionRepeat = function (_SCNAction) {
  _inherits(SCNActionRepeat, _SCNAction);

  _createClass(SCNActionRepeat, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _timesToRepeat: 'float',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _repeatedAction: 'SCNAction',
        _forever: 'boolean',
        _timesRepeated: 'integer',
        _pausedTime: 'float',

        name: ['string', null]
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionRepeat() {
    _classCallCheck(this, SCNActionRepeat);

    var _this = _possibleConstructorReturn(this, (SCNActionRepeat.__proto__ || Object.getPrototypeOf(SCNActionRepeat)).call(this));

    _this._timesToRepeat = 0;
    _this._repeatedAction = null;
    _this._forever = false;
    _this._timesRepeated = 0;
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  /**
   * Creates an action that repeats another action a specified number of times.
   * @access public
   * @param {SCNAction} action - The action to be executed.
   * @param {number} count - The number of times to execute the action.
   * @returns {SCNAction} - 
   * @desc When the action executes, the associated action runs to completion and then repeats, until the count is reached.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1522764-repeat
   */


  _createClass(SCNActionRepeat, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SCNActionRepeat} -
     */
    value: function copy() {
      var action = _get(SCNActionRepeat.prototype.__proto__ || Object.getPrototypeOf(SCNActionRepeat.prototype), 'copy', this).call(this);

      action._timesToRepeat = this._timesToRepeat;
      action._repeatedAction = this._repeatedAction.copy();
      action._forever = this._forever;
      action._timesRepeated = this._timesRepeated;

      return action;
    }
  }, {
    key: '_getTime',
    value: function _getTime(time, needTimeConversion) {
      if (!needTimeConversion) {
        return time;
      }

      var baseTime = this._basetimeFromTime(time);
      if (this.timingFunction === null) {
        return baseTime;
      }

      var n = Math.floor(baseTime);
      var t = this.timingFunction._getValueAtTime(baseTime - n);
      return n + t;
    }

    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAction',
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var dt = this._getTime(time, needTimeConversion);
      var timesRepeated = Math.floor(dt);
      while (timesRepeated > this._timesRepeated) {
        this._timesRepeated += 1;
        this._repeatedAction._applyAction(obj, 1.0, false);
        if (!this._forever && this._timesRepeated >= this._timesToRepeat) {
          this._finished = true;
          return;
        }
        this._repeatedAction._resetFinished();
      }
      var t = dt - this._timesRepeated;
      this._repeatedAction._applyAction(obj, t, false);
      this._finished = false;
    }
  }, {
    key: '_resetFinished',
    value: function _resetFinished() {
      this._repeatedAction._resetFinished();
      this._timesRepeated = 0;
      this._finished = false;
    }
  }, {
    key: 'duration',
    get: function get() {
      if (this._forever) {
        return Infinity;
      }
      return this._repeatedAction.duration * this._timesToRepeat;
    }
  }], [{
    key: 'repeat',
    value: function repeat(action, count) {
      var _action = new SCNActionRepeat();
      _action._repeatedAction = action;
      _action._duration = action.duration;
      _action._timesToRepeat = count;
      _action._forever = count === Infinity;
      return _action;
    }

    /**
     * Creates an action that repeats another action forever.
     * @access public
     * @param {SCNAction} action - The action to execute.
     * @returns {SCNAction} - 
     * @desc When the action executes, the associated action runs to completion and then repeats.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.NoteThe action to be repeated must have a non-instantaneous duration.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522908-repeatforever
     */

  }, {
    key: 'repeatForever',
    value: function repeatForever(action) {
      return this.repeat(action, Infinity);
    }
  }]);

  return SCNActionRepeat;
}(_SCNAction3.default);

exports.default = SCNActionRepeat;


_SCNAction3.default.repeat = SCNActionRepeat.repeat;
_SCNAction3.default.repeatForever = SCNActionRepeat.repeatForever;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

var _SCNNode = __webpack_require__(14);

var _SCNNode2 = _interopRequireDefault(_SCNNode);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _SCNVector3 = __webpack_require__(11);

var _SCNVector4 = _interopRequireDefault(_SCNVector3);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionRotate = function (_SCNAction) {
  _inherits(SCNActionRotate, _SCNAction);

  _createClass(SCNActionRotate, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _rotX: 'float',
        _rotY: 'float',
        _rotZ: 'float',
        _lastRotX: 'float',
        _lastRotY: 'float',
        _lastRotZ: 'float',
        _axisRot: 'SCNVector4',
        _isRelative: 'boolean',
        _isReversed: 'boolean',
        _isUnitArc: 'boolean',
        _isAxisAngle: 'boolean',
        _isRunning: 'boolean',
        _finished: 'boolean',
        _duration: 'float',
        _pausedTime: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',

        name: ['string', null]
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionRotate() {
    _classCallCheck(this, SCNActionRotate);

    var _this = _possibleConstructorReturn(this, (SCNActionRotate.__proto__ || Object.getPrototypeOf(SCNActionRotate)).call(this));

    _this._rotX = 0;
    _this._rotY = 0;
    _this._rotZ = 0;
    _this._lastRotX = 0;
    _this._lastRotY = 0;
    _this._lastRotZ = 0;
    _this._axisRot = new _SCNVector4.default();
    _this._isRelative = false;
    _this._isReversed = false;
    _this._isUnitArc = false;
    _this._isAxisAngle = false;
    _this._isRunning = false;
    _this._finished = false;
    _this._duration = 0;
    _this._pausedTime = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    return _this;
  }

  /**
   * Creates an action that rotates the node in each of the three principal axes by angles relative to its current orientation.
   * @access public
   * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
   * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
   * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
   * @param {number} duration - The duration, in seconds, of the animation.
   * @returns {SCNAction} - 
   * @desc When the action executes, the node’s rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
  [SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1523522-rotateby
   */


  _createClass(SCNActionRotate, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SCNActionRotate} -
     */
    value: function copy() {
      var action = _get(SCNActionRotate.prototype.__proto__ || Object.getPrototypeOf(SCNActionRotate.prototype), 'copy', this).call(this);

      action._rotX = this._rotX;
      action._rotY = this._rotY;
      action._rotZ = this._rotZ;
      action._lastRotX = this._lastRotX;
      action._lastRotY = this._lastRotY;
      action._lastRotZ = this._lastRotZ;
      action._axisRot = this._axisRot;
      action._isRelative = this._isRelative;
      action._isReveresed = this._isReversed;
      action._isUnitArc = this._isUnitArc;
      action._isAxisAngle = this._isAxisAngle;
      action._isRunning = this._isRunning;
      action._finished = this._finished;
      action._duration = this._duration;
      action._pausedTime = this._pausedTime;
      action._timingMode = this._timingMode;

      return action;
    }

    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAction',
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (!(0, _InstanceOf3.default)(obj, _SCNNode2.default)) {
        throw new Error('unsupported class for SCNActionRotate: ' + obj.constructor.name);
      }
      var t = this._getTime(time, needTimeConversion
      //console.warn(`SCNActionRotate._applyAction t: ${t}`)

      );if (this._isAxisAngle) {
        // rotation
        var baseValue = obj.rotation;
        var toValue = this._axisRot;
        if (this._isRelative) {
          var baseQuat = baseValue.rotationToQuat;
          var byQuat = this._axisRot.rotationToQuat;
          toValue = baseQuat.cross(byQuat).quatToRotation;
        }
        if (this._isUnitArc) {
          var value = this._slerp(baseValue.rotationToQuat(), toValue.rotationToQuat(), t);
          obj.presentation.orientation = value;
        } else {
          var _value = this._lerp(baseValue, toValue, t);
          obj.presentation.rotation = _value;
        }
        if (this._finished) {
          obj.rotation = toValue;
        }
      } else {
        // eulerAngles
        var _toValue = new _SCNVector2.default(this._rotX, this._rotY, this._rotZ);
        var _value2 = null;
        if (this._isRelative) {
          var _baseValue = obj.orientation;
          _value2 = _baseValue.cross(_toValue.mul(t).eulerAnglesToQuat());
          obj.presentation.orientation = _value2;
        } else if (this._isUnitArc) {
          var _baseValue2 = obj.orientation;
          _value2 = this._slerp(_baseValue2, _toValue.eulerAnglesToQuat(), t);
          obj.presentation.orientation = _value2;
        } else {
          var _baseValue3 = obj.eulerAngles;
          _value2 = this._lerp(_baseValue3, _toValue, t);
          obj.presentation.eulerAngles = _value2;
        }

        //obj.presentation.eulerAngles = value
        if (this._finished) {
          if (this._isRelative) {
            _toValue = obj.orientation.cross(_toValue.eulerAnglesToQuat());
            obj.orientation = _toValue;
          } else {
            obj.eulerAngles = _toValue;
          }
        }
      }
    }
  }], [{
    key: 'rotateByXYZ',
    value: function rotateByXYZ(xAngle, yAngle, zAngle, duration) {
      var action = new SCNActionRotate();
      // TODO: Do research the reason why I need to turn around X and Y axes.
      action._rotX = -xAngle;
      action._rotY = -yAngle;
      action._rotZ = zAngle;
      action._duration = duration;
      action._isRelative = true;
      return action;
    }

    /**
     * Creates an action that rotates the node to absolute angles in each of the three principal axes.
     * @access public
     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s rotation property animates to the new angle. Calling this method is equivalent to calling rotateTo(x:y:z:duration:usesShortestUnitArc:) and passing false for the shortestUnitArc parameter.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1524044-rotateto
     */

  }, {
    key: 'rotateToXYZ',
    value: function rotateToXYZ(xAngle, yAngle, zAngle, duration) {
      var action = new SCNActionRotate();
      action._rotX = xAngle;
      action._rotY = yAngle;
      action._rotZ = zAngle;
      action._duration = duration;
      return action;
    }

    /**
     * Creates an action that rotates the node to absolute angles in each of the three principal axes.
     * @access public
     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @param {boolean} shortestUnitArc - If false (the default), the animation interpolates each component of the node’s rotation between its current value and the new value. If true, the animation makes the most direct rotation possible from the node’s current orientation to the new orientation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1522808-rotateto
     */

  }, {
    key: 'rotateToXYZUsesShortestUnitArc',
    value: function rotateToXYZUsesShortestUnitArc(xAngle, yAngle, zAngle, duration, shortestUnitArc) {
      var action = new SCNActionRotate();
      action._rotX = xAngle;
      action._rotY = yAngle;
      action._rotZ = zAngle;
      action._duration = duration;
      action._isUnitArc = shortestUnitArc;
      return action;
    }

    /**
     * Creates an action that rotates the node by an angle around a specified axis.
     * @access public
     * @param {number} angle - The amount to rotate the node counterclockwise around the specified axis, in radians.
     * @param {SCNVector3} axis - A vector in the node’s local coordinate space whose direction specifies the axis of rotation.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
    [SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1523805-rotate
     */

  }, {
    key: 'rotateByAround',
    value: function rotateByAround(angle, axis, duration) {
      var action = new SCNActionRotate();
      action._axisRot.w = angle;
      action._axisRot.x = axis.x;
      action._axisRot.y = axis.y;
      action._axisRot.z = axis.z;
      action._duration = duration;
      action._isRelative = true;
      action._isAxisAngle = true;
      return action;
    }

    /**
     * Creates an action that rotates the node to an absolute angle around a specified axis.
     * @access public
     * @param {SCNVector4} axisAngle - A four-component vector whose first three components are a vector in the node’s local coordinate space specifying an axis and whose fourth component is the amount to rotate the node counterclockwise around that axis, in radians.
     * @param {number} duration - The duration, in seconds, of the animation.
     * @returns {SCNAction} - 
     * @desc When the action executes, the node’s rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1524191-rotate
     */

  }, {
    key: 'rotateToAxisAngle',
    value: function rotateToAxisAngle(axisAngle, duration) {
      var action = new SCNActionRotate();
      action._axisRot = axisAngle;
      action._duration = duration;
      action._isAxisAngle = true;
      return action;
    }
  }]);

  return SCNActionRotate;
}(_SCNAction3.default);

exports.default = SCNActionRotate;


_SCNAction3.default.rotateByXYZ = SCNActionRotate.rotateByXYZ;
_SCNAction3.default.rotateToXYZ = SCNActionRotate.rotateToXYZ;
_SCNAction3.default.rotateToXYZUsesShortestUnitArc = SCNActionRotate.rotateToXYZUsesShortestUnitArc;
_SCNAction3.default.rotateByAround = SCNActionRotate.rotateByAround;
_SCNAction3.default.rotateToAxisAngle = SCNActionRotate.rotateToAxisAngle;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionRunAction = function (_SCNAction) {
  _inherits(SCNActionRunAction, _SCNAction);

  _createClass(SCNActionRunAction, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float'
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionRunAction() {
    _classCallCheck(this, SCNActionRunAction);

    var _this = _possibleConstructorReturn(this, (SCNActionRunAction.__proto__ || Object.getPrototypeOf(SCNActionRunAction)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  return SCNActionRunAction;
}(_SCNAction3.default);

exports.default = SCNActionRunAction;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionRunBlock = function (_SCNAction) {
  _inherits(SCNActionRunBlock, _SCNAction);

  _createClass(SCNActionRunBlock, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float',

        name: ['string', null]
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionRunBlock() {
    _classCallCheck(this, SCNActionRunBlock);

    var _this = _possibleConstructorReturn(this, (SCNActionRunBlock.__proto__ || Object.getPrototypeOf(SCNActionRunBlock)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  /**
   * @access public
   * @returns {SCNActionFade} -
   */


  _createClass(SCNActionRunBlock, [{
    key: 'copy',
    value: function copy() {
      var action = _get(SCNActionRunBlock.prototype.__proto__ || Object.getPrototypeOf(SCNActionRunBlock.prototype), 'copy', this).call(this);

      action._block = this._block;

      return action;
    }

    /**
     * Creates an action that executes a block.
     * @access public
     * @param {function(arg1: SCNNode): void} block - The block to run. The block takes a single parameter:nodeThe node on which the action is running.
     * @returns {SCNAction} - 
     * @desc When the action executes, SceneKit calls the block. This action takes place instantaneously.This action is not reversible; the reverse action executes the same block.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1523637-run
     */

  }, {
    key: '_applyAction',


    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      this._block(obj);
      this._finished = true;
    }
  }], [{
    key: 'run',
    value: function run(block) {
      var action = new SCNActionRunBlock();
      action._block = block;
      return action;
    }
  }]);

  return SCNActionRunBlock;
}(_SCNAction3.default);

exports.default = SCNActionRunBlock;


_SCNAction3.default.run = SCNActionRunBlock.run;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionScale = function (_SCNAction) {
  _inherits(SCNActionScale, _SCNAction);

  _createClass(SCNActionScale, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float'
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionScale() {
    _classCallCheck(this, SCNActionScale);

    var _this = _possibleConstructorReturn(this, (SCNActionScale.__proto__ || Object.getPrototypeOf(SCNActionScale)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  return SCNActionScale;
}(_SCNAction3.default);

exports.default = SCNActionScale;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionSequence = function (_SCNAction) {
  _inherits(SCNActionSequence, _SCNAction);

  _createClass(SCNActionSequence, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        '_mycaction->_animIndex': ['integer', '_animIndex'],
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float',

        name: ['string', null]
      };
    }

    /**
     * Creates an action that runs a collection of actions sequentially.
     * @access public
     * @constructor
     * @param {SCNAction[]} actions - An array of SCNAction objects.
     * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, the actions reverseSequence and sequenceReverse in the code example below are equivalent:SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
    SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
                                                      [actionB reversedAction],
                                                      [actionA reversedAction] ]];
    SCNAction *sequenceReverse = [sequence reversedAction];
    SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
    SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
                                                      [actionB reversedAction],
                                                      [actionA reversedAction] ]];
    SCNAction *sequenceReverse = [sequence reversedAction];
      * @see https://developer.apple.com/documentation/scenekit/scnaction/1522793-sequence
     */

  }]);

  function SCNActionSequence() {
    _classCallCheck(this, SCNActionSequence);

    var _this = _possibleConstructorReturn(this, (SCNActionSequence.__proto__ || Object.getPrototypeOf(SCNActionSequence)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._animIndex = 0;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  /**
   * Creates an action that runs a collection of actions sequentially.
   * @access public
   * @param {SCNAction[]} actions - An array of SCNAction objects.
   * @returns {SCNAction} - 
   * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, the actions reverseSequence and sequenceReverse in the code example below are equivalent:SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
  SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
                                                    [actionB reversedAction],
                                                    [actionA reversedAction] ]];
  SCNAction *sequenceReverse = [sequence reversedAction];
  SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
  SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
                                                    [actionB reversedAction],
                                                    [actionA reversedAction] ]];
  SCNAction *sequenceReverse = [sequence reversedAction];
    * @see https://developer.apple.com/documentation/scenekit/scnaction/1522793-sequence
   */


  _createClass(SCNActionSequence, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SCNActionSequence} -
     */
    value: function copy() {
      var action = _get(SCNActionSequence.prototype.__proto__ || Object.getPrototypeOf(SCNActionSequence.prototype), 'copy', this).call(this);

      action._actions = this._actions.slice(0);
      action._animIndex = this._animIndex;

      return action;
    }

    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAction',
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var total = this.duration;
      var duration = 0;
      if (total <= 0 || total === Infinity) {
        duration = this._activetimeFromTime(time);
      } else {
        duration = this._getTime(time, needTimeConversion) * total;
      }

      for (var i = 0; i < this._animIndex; i++) {
        duration -= this._actions[i].duration / this._actions[i].speed;
      }
      for (; this._animIndex < this._actions.length; this._animIndex++) {
        var action = this._actions[this._animIndex];
        //action._applyAction(obj, duration, needTimeConversion)
        action._applyAction(obj, duration, true);
        duration -= action.duration / action.speed;
        if (duration < 0) {
          break;
        }
      }
      if (this._animIndex >= this._actions.length) {
        this._finished = true;
      }
    }
  }, {
    key: '_resetFinished',
    value: function _resetFinished() {
      this._actions.forEach(function (action) {
        action._resetFinished();
      });
      this._finished = false;
      this._animIndex = 0;
    }
  }, {
    key: 'duration',
    get: function get() {
      var d = 0;
      this._actions.forEach(function (act) {
        if (act.speed > 0) {
          d += act.duration / act.speed;
        }
      });
      return d;
    }
  }], [{
    key: 'sequence',
    value: function sequence(actions) {
      var action = new SCNActionSequence();
      action._actions = actions;
      action._duration = 0;
      return action;
    }
  }]);

  return SCNActionSequence;
}(_SCNAction3.default);

exports.default = SCNActionSequence;


_SCNAction3.default.sequence = SCNActionSequence.sequence;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The signature for a block that manages animation timing, used by the timingFunction property.
 * @type {function(time: number): number}
 * @param {number} time - A fraction of the action’s The input value for the timing function, as determined by the timingMode property and the action’s current progress.
 * @returns {number} -
 * @desc Your block must return a floating-point value between 0.0 and 1.0, where 0.0 represents the starting state of the action’s animation and 1.0 represents the end state.
 * @see https://developer.apple.com/documentation/scenekit/scnactiontimingfunction
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNActionTimingFunction = function SCNActionTimingFunction(time) {};

exports.default = SCNActionTimingFunction;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNAction2 = __webpack_require__(4);

var _SCNAction3 = _interopRequireDefault(_SCNAction2);

var _SCNActionTimingMode = __webpack_require__(5);

var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNActionWait = function (_SCNAction) {
  _inherits(SCNActionWait, _SCNAction);

  _createClass(SCNActionWait, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        _actions: 'NSArray',
        _finished: 'boolean',
        _duration: 'float',
        _timingMode: 'integer',
        _beginTime: 'float',
        _isRunning: 'boolean',
        _pausedTime: 'float',

        name: ['string', null]
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNActionWait() {
    _classCallCheck(this, SCNActionWait);

    var _this = _possibleConstructorReturn(this, (SCNActionWait.__proto__ || Object.getPrototypeOf(SCNActionWait)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SCNActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  /**
   * Creates an action that idles for a specified period of time.
   * @access public
   * @param {number} sec - The amount of time to wait.
   * @returns {SCNAction} - 
   * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/scenekit/scnaction/1523915-wait
   */


  _createClass(SCNActionWait, null, [{
    key: 'waitDuration',
    value: function waitDuration(sec) {
      var action = new SCNActionWait();
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that idles for a randomized period of time.
     * @access public
     * @param {number} sec - The average amount of time to wait.
     * @param {number} durationRange - The range of possible values for the duration.
     * @returns {SCNAction} - 
     * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
     * @see https://developer.apple.com/documentation/scenekit/scnaction/1523086-wait
     */

  }, {
    key: 'waitDurationWithRange',
    value: function waitDurationWithRange(sec, durationRange) {
      var duration = Math.max(0, sec + (Math.random() - 0.5) * durationRange);
      var action = new SCNActionWait();
      action._duration = duration;
      return action;
    }
  }]);

  return SCNActionWait;
}(_SCNAction3.default);

exports.default = SCNActionWait;


_SCNAction3.default.waitDuration = SCNActionWait.waitDuration;
_SCNAction3.default.waitDurationWithRange = SCNActionWait.waitDurationWithRange;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CAAnimation = __webpack_require__(24);

var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The common interface for attaching animations to nodes, geometries, materials, and other SceneKit objects.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnanimatable
 */
var SCNAnimatable = function () {
  function SCNAnimatable() {
    _classCallCheck(this, SCNAnimatable);
  }

  _createClass(SCNAnimatable, [{
    key: 'init',


    /**
     * constructor
     * @access public
     * @returns {void}
     */
    value: function init() {

      // Managing Animations

      this._animationKeys = null;
    }

    // Managing Animations

    /**
     * Required. Adds an animation object for the specified key.
     * @access public
     * @param {CAAnimation} animation - The animation object to be added.
     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
     * @returns {void}
     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation
     */

  }, {
    key: 'addAnimationForKey',
    value: function addAnimationForKey(animation, key) {}

    /**
     * Required. Returns the animation with the specified key.
     * @access public
     * @param {string} key - A string identifying a previously added animation.
     * @returns {?CAAnimation} - 
     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation
     */

  }, {
    key: 'animationForKey',
    value: function animationForKey(key) {
      return null;
    }

    /**
     * Required. Removes all the animations currently attached to the object.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations
     */

  }, {
    key: 'removeAllAnimations',
    value: function removeAllAnimations() {}

    /**
     * Required. Removes the animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation to remove.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation
     */

  }, {
    key: 'removeAnimationForKey',
    value: function removeAnimationForKey(key) {}

    /**
     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
     * @access public
     * @param {string} key - A string identifying an attached animation to remove.
     * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
     * @returns {void}
     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation
     */

  }, {
    key: 'removeAnimationForKeyFadeOutDuration',
    value: function removeAnimationForKeyFadeOutDuration(key, duration) {}
    /**
     * Required. An array containing the keys of all animations currently attached to the object.
     * @type {string[]}
     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys
     */

  }, {
    key: 'pauseAnimationForKey',


    // Pausing and Resuming Animations

    /**
     * Required. Pauses the animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {void}
     * @desc This method has no effect if no animation is attached to the object with the specified key.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation
     */
    value: function pauseAnimationForKey(key) {}

    /**
     * Required. Resumes a previously paused animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {void}
     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation
     */

  }, {
    key: 'resumeAnimationForKey',
    value: function resumeAnimationForKey(key) {}

    /**
     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused
     */

  }, {
    key: 'isAnimationPausedForKey',
    value: function isAnimationPausedForKey(key) {
      return false;
    }

    // Instance Methods

    /**
     * Required. 
     * @access public
     * @param {number} speed - 
     * @param {string} key - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed
     */

  }, {
    key: 'setAnimationSpeedForKey',
    value: function setAnimationSpeedForKey(speed, key) {}
  }, {
    key: 'animationKeys',
    get: function get() {
      return this._animationKeys;
    }
  }]);

  return SCNAnimatable;
}();

exports.default = SCNAnimatable;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNAnimationEventBlock from './SCNAnimationEventBlock'

/**
 * A container for a closure to be executed at a specific time during playback of an animation.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnanimationevent
 */
var SCNAnimationEvent = function (_NSObject) {
  _inherits(SCNAnimationEvent, _NSObject);

  // Creating an Animation Event

  /**
   * Creates an animation event.
   * @access public
   * @param {number} time - A number between 0.0 and 1.0 specifying the relative time for triggering the event.
   * @param {SCNAnimationEventBlock} eventBlock - A block to call at the specified time.
   * @constructor
   * @desc The time parameter is relative to the duration of the animation the event is attached to. For example, an event with a time of 0.5 triggers when the animation is halfway complete, and an event with a time of 1.0 triggers when the animation ends.
   * @see https://developer.apple.com/documentation/scenekit/scnanimationevent/1524004-init
   */
  function SCNAnimationEvent(time, eventBlock) {
    _classCallCheck(this, SCNAnimationEvent);

    var _this = _possibleConstructorReturn(this, (SCNAnimationEvent.__proto__ || Object.getPrototypeOf(SCNAnimationEvent)).call(this));

    _this._time = time;
    _this._eventBlock = eventBlock;
    return _this;
  }

  _createClass(SCNAnimationEvent, null, [{
    key: 'eventWithTimeEventBlock',
    value: function eventWithTimeEventBlock(time, eventBlock) {
      return new SCNAnimationEvent(time, eventBlock);
    }
  }]);

  return SCNAnimationEvent;
}(_NSObject3.default);

exports.default = SCNAnimationEvent;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import CAAnimation from '../QuartzCore/CAAnimation'

/**
 * Signature for the block called when an animation event triggers.
 * @type {function(animation: CAAnimation, animatedObject: Object, playingBackward: boolean): void}
 * @param {CAAnimation} animation - The animation triggering the animation event.
 * @param {Object} animatedObject - The Scene Kit object affected by the animation.
 * @param {boolean} playingBackward - true if the animation is playing in reverse; otherwise, false.
 * @returns {void}
 * @see https://developer.apple.com/documentation/scenekit/scnanimationeventblock
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNAnimationEventBlock = function SCNAnimationEventBlock(animation, animatedObject, playingBackward) {};

exports.default = SCNAnimationEventBlock;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNAnimation = __webpack_require__(86);

var _SCNAnimation2 = _interopRequireDefault(_SCNAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * 
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer
 */
var SCNAnimationPlayer = function (_NSObject) {
  _inherits(SCNAnimationPlayer, _NSObject);

  _createClass(SCNAnimationPlayer, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        speed: 'float',
        weight: ['float', '_weight'],
        paused: 'boolean'
      };
    }

    // Initializers

    /**
     * 
     * @access public
     * @constructor
     * @param {SCNAnimation} animation - 
     * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2866046-init
     */

  }]);

  function SCNAnimationPlayer(animation) {
    _classCallCheck(this, SCNAnimationPlayer);

    // Instance Properties

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2881688-blendfactor
     */
    var _this = _possibleConstructorReturn(this, (SCNAnimationPlayer.__proto__ || Object.getPrototypeOf(SCNAnimationPlayer)).call(this));

    _this.blendFactor = 0;

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2866058-paused
     */
    _this.paused = false;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2866041-speed
     */
    _this.speed = 0;

    /**
     * @access private
     * @type {number}
     */
    _this._weight = 0;

    /**
     * @access private
     * @type {SCNAnimation}
     */
    _this._animation = animation;
    return _this;
  }

  // Instance Properties
  /**
   * 
   * @type {SCNAnimation}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2866065-animation
   */


  _createClass(SCNAnimationPlayer, [{
    key: 'play',


    // Instance Methods

    /**
     * 
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2866049-play
     */
    value: function play() {}

    /**
     * 
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2866055-stop
     */

  }, {
    key: 'stop',
    value: function stop() {}

    /**
     * 
     * @access public
     * @param {number} duration - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimationplayer/2887037-stop
     */

  }, {
    key: 'stopWithBlendOutDuration',
    value: function stopWithBlendOutDuration(duration) {}
  }, {
    key: 'animation',
    get: function get() {
      return this._animation;
    }
  }]);

  return SCNAnimationPlayer;
}(_NSObject3.default);

exports.default = SCNAnimationPlayer;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _AVAudioMixerNode = __webpack_require__(56);

var _AVAudioMixerNode2 = _interopRequireDefault(_AVAudioMixerNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNAudioSource from './SCNAudioSource'


/**
 * A controller for playback of a positional audio source in a SceneKit scene.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer
 */
var SCNAudioPlayer = function (_NSObject) {
  _inherits(SCNAudioPlayer, _NSObject);

  // Creating an Audio Player

  /**
   * Initializes an audio player for playing the specified simple audio source.
   * @access public
   * @constructor
   * @param {SCNAudioSource} source - An audio source object.
   * @desc Using this initializer is typically not necessary. Instead, call the audioPlayerWithSource: method, which returns a cached audio player object if one for the specified audio source has already been created and is available for use.
   * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1522736-init
   */
  function SCNAudioPlayer(source) {
    _classCallCheck(this, SCNAudioPlayer);

    // Working with Audio Sources

    var _this = _possibleConstructorReturn(this, (SCNAudioPlayer.__proto__ || Object.getPrototypeOf(SCNAudioPlayer)).call(this));

    _this._audioSource = source;
    _this._audioNode = new _AVAudioMixerNode2.default();
    _this._audioNode._gainNode = source._gainNode;

    // Responding to Playback

    /**
     * A block called by SceneKit when playback of the player’s audio source is about to begin.
     * @type {?function(): void}
     * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1524115-willstartplayback
     */
    _this.willStartPlayback = null;

    /**
     * A block called by SceneKit when playback of the player’s audio source has completed.
     * @type {?function(): void}
     * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1522818-didfinishplayback
     */
    _this.didFinishPlayback = null;
    return _this;
  }

  /**
   * Initializes an audio player for playing the specified AVFoundation audio node.
   * @access public
   * @param {AVAudioNode} audioNode - An audio node object.
   * @returns {void}
   * @desc Using this initializer is typically not necessary. Instead, call the audioPlayerWithAVAudioNode: method, which returns a cached audio player object if one for the specified AVAudioNode object has already been created and is available for use.
   * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1523010-init
   */


  _createClass(SCNAudioPlayer, [{
    key: 'initAvAudioNode',
    value: function initAvAudioNode(audioNode) {

      // Working with Audio Sources

      this._audioSource = null;
      this._audioNode = null;

      // Responding to Playback

      /**
       * A block called by SceneKit when playback of the player’s audio source is about to begin.
       * @type {?function(): void}
       * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1524115-willstartplayback
       */
      this.willStartPlayback = null;

      /**
       * A block called by SceneKit when playback of the player’s audio source has completed.
       * @type {?function(): void}
       * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1522818-didfinishplayback
       */
      this.didFinishPlayback = null;
    }

    // Working with Audio Sources

    /**
     * The source of audio played by this player.
     * @type {?SCNAudioSource}
     * @desc An SCNAudioSource object represents a distinct source of audio—for example, a sound file—that can be reused and shared by many player objects. Use a player’s audio source to configure the default values for playback parameters such as volume and reverb. To vary those parameters in real time during playback, use the audioNode property to work with the underlying AVAudioNode object.If the player was created with the audioPlayerWithAVAudioNode: method, this property’s value is nil.
     * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1523059-audiosource
     */

  }, {
    key: '_play',
    value: function _play() {
      this._audioSource._play();
    }
  }, {
    key: '_stop',
    value: function _stop() {
      this._audioSource._stop();
    }

    /**
     * @access private
     * @returns {Promise} -
     */

  }, {
    key: '_getLoadedPromise',
    value: function _getLoadedPromise() {
      if (this._audioSource) {
        return this._audioSource._getLoadedPromise();
      }

      return Promise.resolve();
    }

    /**
     * @access public
     * @type {Promise} -
     */

  }, {
    key: 'audioSource',
    get: function get() {
      return this._audioSource;
    }

    /**
     * The audio node SceneKit uses for mixing audio from this player.
     * @type {?AVAudioNode}
     * @desc SceneKit uses this AVAudioNode object to perform 3D positional mixing during playback. Use this object to vary parameters such as volume and reverb in real time during playback. To set default values for those parameters, use the audioSource property.
     * @see https://developer.apple.com/documentation/scenekit/scnaudioplayer/1522747-audionode
     */

  }, {
    key: 'audioNode',
    get: function get() {
      return this._audioNode;
    }
  }, {
    key: 'didLoad',
    get: function get() {
      return this._getLoadedPromise();
    }
  }]);

  return SCNAudioPlayer;
}(_NSObject3.default);

exports.default = SCNAudioPlayer;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AjaxRequest2 = __webpack_require__(54);

var _AjaxRequest3 = _interopRequireDefault(_AjaxRequest2);

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*global AudioContext*/
var _AudioContext = function _AudioContext() {};
if (typeof AudioContext !== 'undefined') {
  _AudioContext = AudioContext;
} else {
  console.error('error: AudioContext is not supported');
}
var _context = new _AudioContext();

/**
 * A simple, reusable audio source—music or sound effects loaded from a file—for use in positional audio playback.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnaudiosource
 */

var SCNAudioSource = function (_NSObject) {
  _inherits(SCNAudioSource, _NSObject);

  _createClass(SCNAudioSource, null, [{
    key: 'sourceNamed',


    // Creating an Audio Source

    /**
     * Returns the audio source associated with the specified filename.
     * @access public
     * @param {string} fileName - The name of an audio file. If this filename has not been previously requested, the method looks for an audio file with the specified name in the application’s main bundle.
     * @returns {void}
     * @desc This method looks in the system caches for an audio source with the specified name and returns that object if it exists. If a matching audio source is not already in the cache, this method locates the audio file with the specified name in the application’s main bundle, then creates a new audio source and caches it for reuse.
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524138-init
     */
    value: function sourceNamed(fileName) {
      return new SCNAudioSource(fileName);
    }

    /**
     * Initializes an audio source from an audio file in the application’s main bundle.
     * @access public
     * @param {string} name - The name of an audio file in the application’s main bundle.
     * @returns {void}
     * @desc Calling this method is equivalent to using the Bundle class to locate an audio file in the application’s main bundle and then passing the resulting URL to the init(url:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524225-init
     */

  }, {
    key: 'sourceWithFileNamed',
    value: function sourceWithFileNamed(name) {
      return new SCNAudioSource(name);
    }

    /**
     * Initializes an audio source from the specified audio file.
     * @access public
     * @constructor
     * @param {string} url - A URL locating an audio file.
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1523264-init
     */

  }]);

  function SCNAudioSource(url) {
    _classCallCheck(this, SCNAudioSource);

    // Controlling 3D Audio Spatialization

    /**
     * A Boolean value that determines whether audio from this source uses 3D positional mixing.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524185-ispositional
     */
    var _this = _possibleConstructorReturn(this, (SCNAudioSource.__proto__ || Object.getPrototypeOf(SCNAudioSource)).call(this));

    _this.isPositional = false;

    // Setting Default Playback Parameters

    /**
     * The default playback volume for the audio source.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524106-volume
     */
    //this.volume = 0

    /**
     * The default playback rate for the audio source.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524189-rate
     */
    _this.rate = 0;

    /**
     * The default blend of blend of unmodified and reverb-processed (also called dry and wet) audio for playback of the audio source.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1523450-reverbblend
     */
    _this.reverbBlend = 0;

    /**
     * A Boolean value that determines whether the audio source should play repeatedly.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524183-loops
     */
    //this.loops = false

    /**
     * A Boolean value that determines whether the audio source should stream content from its source URL when playing.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1523475-shouldstream
     */
    _this.shouldStream = false;

    _this._loading = false;
    _this._loadedPromise = new Promise(function (resolve, reject) {
      _this._resolve = resolve;
      _this._reject = reject;
    });
    _this._url = url;
    _this._buffer = null;
    _this._gainNode = _context.createGain();
    _this._loops = false;
    _this._source = null;
    //this._source = _context.createBufferSource()
    //this._source.connect(this._gainNode)
    //this._gainNode.connect(_context.destination)
    return _this;
  }

  /**
   * The default playback volume for the audio source.
   * @type {number}
   * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524106-volume
   */


  _createClass(SCNAudioSource, [{
    key: 'load',


    // Preloading Audio Data

    /**
     * Loads audio data from the source and prepares it for playing.
     * @access public
     * @returns {void}
     * @desc This method reads audio data from the source file (specified when initializing the audio source) and performs any decompression necessary to prepare for playing audio. Use this method to control when your app or game incurs the run-time performance cost of such work—for example, you can load all audio source before starting a game level, instead of suffering a frame rate drop upon playing a new audio source during gameplay.This method has no effect if the shouldStream property’s value is true.
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1523399-load
     */
    value: function load() {
      var _this2 = this;

      if (this._loading) {
        return;
      }
      this._loading = true;

      var promise = _AjaxRequest3.default.get(this._url, { responseType: 'arraybuffer' }).then(function (data) {
        _context.decodeAudioData(data, function (buffer) {
          _this2._buffer = buffer;
          _this2._resolve();
        });
      });
    }
  }, {
    key: '_play',
    value: function _play() {
      var _this3 = this;

      var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      this.load();
      this._loadedPromise.then(function () {
        _this3._source = _context.createBufferSource();
        _this3._source.buffer = _this3._buffer;
        _this3._source.connect(_this3._gainNode);
        _this3._gainNode.connect(_context.destination);
        _this3._source.loop = _this3._loops;
        _this3._source.start(when);
      });
    }
  }, {
    key: '_stop',
    value: function _stop() {
      var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this._source) {
        this._source.stop(when);
        this._source = null;
      }
    }
  }, {
    key: '_getLoadedPromise',


    /**
     * @access private
     * @returns {Promise} -
     */
    value: function _getLoadedPromise() {
      if (this._loadedPromise) {
        return this._loadedPromise;
      }

      return Promise.resolve();
    }

    /**
     * @access public
     * @type {Promise} -
     */

  }, {
    key: 'volume',
    get: function get() {
      return this._gainNode.gain.value;
    },
    set: function set(newValue) {
      this._gainNode.gain.value = newValue;
    }

    /**
     * A Boolean value that determines whether the audio source should play repeatedly.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnaudiosource/1524183-loops
     */

  }, {
    key: 'loops',
    get: function get() {
      return this._loops;
    },
    set: function set(newValue) {
      this._loops = newValue;
      if (this._source !== null) {
        this._source.loop = newValue;
      }
    }
  }, {
    key: '_duration',
    get: function get() {
      if (this._buffer) {
        return this._buffer.duration;
      }
      return null;
    }
  }, {
    key: 'didLoad',
    get: function get() {
      return this._getLoadedPromise();
    }
  }]);

  return SCNAudioSource;
}(_NSObject3.default);

exports.default = SCNAudioSource;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for locking the orientation of nodes affected by a billboard constraint.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scnbillboardaxis
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNBillboardAxis = function () {
  _createClass(SCNBillboardAxis, [{
    key: 'X',


    // Constants

    /**
     * Align an affected node such that its x-axis is always parallel to that of the view, leaving it free to rotate otherwise.
     * @type {SCNBillboardAxis}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnbillboardaxis/1468664-x
     */
    get: function get() {
      return this._X;
    }

    /**
     * Align an affected node such that its y-axis is always parallel to that of the view, leaving it free to rotate otherwise.
     * @type {SCNBillboardAxis}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnbillboardaxis/1468668-y
     */

  }, {
    key: 'Y',
    get: function get() {
      return this._Y;
    }

    /**
     * Align an affected node such that its z-axis is always perpendicular to the viewing plane, leaving it free to rotate otherwise.
     * @type {SCNBillboardAxis}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnbillboardaxis/1468647-z
     */

  }, {
    key: 'Z',
    get: function get() {
      return this._Z;
    }

    /**
     * Align an affected node such that its orientation always matches that of the view.
     * @type {SCNBillboardAxis}
     * @desc This is the default option for newly created billboard constraints.
     * @see https://developer.apple.com/documentation/scenekit/scnbillboardaxis/1468666-all
     */

  }, {
    key: 'all',
    get: function get() {
      return this._all;
    }

    // Initializers

    /**
     * 
     * @access public
     * @constructor
     * @param {number} rawValue - 
     * @see https://developer.apple.com/documentation/scenekit/scnbillboardaxis/1524212-init
     */

  }]);

  function SCNBillboardAxis(rawValue) {
    _classCallCheck(this, SCNBillboardAxis);

    // Constants

    this._X = null;
    this._Y = null;
    this._Z = null;
    this._all = null;
  }

  return SCNBillboardAxis;
}();

exports.default = SCNBillboardAxis;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNConstraint2 = __webpack_require__(17);

var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNBillboardAxis from './SCNBillboardAxis'

/**
 * A constraint that orients a node to always point toward the current camera.
 * @access public
 * @extends {SCNConstraint}
 * @see https://developer.apple.com/documentation/scenekit/scnbillboardconstraint
 */
var SCNBillboardConstraint = function (_SCNConstraint) {
  _inherits(SCNBillboardConstraint, _SCNConstraint);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNBillboardConstraint() {
    _classCallCheck(this, SCNBillboardConstraint);

    // Working with a Constraint’s Degrees of Freedom

    /**
     * An option that specifies which degrees of freedom the constraint affects.
     * @type {SCNBillboardAxis}
     * @see https://developer.apple.com/documentation/scenekit/scnbillboardconstraint/1468685-freeaxes
     */
    var _this = _possibleConstructorReturn(this, (SCNBillboardConstraint.__proto__ || Object.getPrototypeOf(SCNBillboardConstraint)).call(this));

    _this.freeAxes = null;

    return _this;
  }

  return SCNBillboardConstraint;
}(_SCNConstraint3.default);

exports.default = SCNBillboardConstraint;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNNode from './SCNNode'
//import SCNRenderer from './SCNRenderer'

/**
 * The signature for a block called for binding or unbinding a GLSL symbol in a custom program.
 * @type {function(programID: number, location: number, renderedNode: ?SCNNode, renderer: SCNRenderer): void}
 * @param {number} programID - The OpenGL program identifier for the current SCNProgram instance, as used by OpenGL functions such as glValidateProgram.
 * @param {number} location - The OpenGL location index for the symbol to be bound or unbound, as used by OpenGL functions such as glUniform.
 * @param {?SCNNode} renderedNode - The SCNNode object being rendered.
 * @param {SCNRenderer} renderer - The SCNRenderer object responsible for rendering.
 * @returns {void}
 * @desc Call handleBinding(ofSymbol:handler:) or handleUnbinding(ofSymbol:handler:) to associate a handler block with a GLSL symbol for a SceneKit geometry or material.
 * @see https://developer.apple.com/documentation/scenekit/scnbindingblock
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNBindingBlock = function SCNBindingBlock(programID, location, renderedNode, renderer) {};

exports.default = SCNBindingBlock;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNVector3 from './SCNVector3'

/**
 * Properties for measuring an object's location and size, expressed as either a box or a sphere.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNBoundingVolume = function () {

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNBoundingVolume() {
    _classCallCheck(this, SCNBoundingVolume);

    // Working with Bounding Volumes

    /**
     * The minimum and maximum corner points of the object’s bounding box.
     * @type {{min: SCNVector3, max: SCNVector3}}
     * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034705-boundingbox
     */
    this.boundingBox = null;

    this._boundingSphere = null;
  }

  // Working with Bounding Volumes

  /**
   * The center point and radius of the object’s bounding sphere.
   * @type {{center: SCNVector3, radius: number}}
   * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a node’s bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of node’s geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
   * @see https://developer.apple.com/documentation/scenekit/scnboundingvolume/2034707-boundingsphere
   */


  _createClass(SCNBoundingVolume, [{
    key: 'boundingSphere',
    get: function get() {
      return this._boundingSphere;
    }
  }]);

  return SCNBoundingVolume;
}();

exports.default = SCNBoundingVolume;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNBufferStream from './SCNBufferStream'
//import SCNNode from './SCNNode'
//import SCNShadable from './SCNShadable'
//import SCNRenderer from './SCNRenderer'

/**
 * A block SceneKit calls at render time for working with buffers in a Metal shader, used by the handleBinding(ofBufferNamed:frequency:handler:) method.
 * @type {function(buffer: SCNBufferStream, node: SCNNode, shadable: SCNShadable, renderer: SCNRenderer): void}
 * @param {SCNBufferStream} buffer - An object that provides write access to the buffer. Use the writeBytes(_:count:) method on this object to write data for use by the shader.
 * @param {SCNNode} node - The node to be rendered using the shader program.
 * @param {SCNShadable} shadable - The material or geometry to be rendered using the shader program.
 * @param {SCNRenderer} renderer - The view (or other SceneKit renderer) responsible for rendering.
 * @returns {void}
 * @see https://developer.apple.com/documentation/scenekit/scnbufferbindingblock
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNBufferBindingBlock = function SCNBufferBindingBlock(buffer, node, shadable, renderer) {};

exports.default = SCNBufferBindingBlock;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for how often SceneKit should execute the binding handler you provide with the handleBinding(ofBufferNamed:frequency:handler:) method.
 * @typedef {Object} SCNBufferFrequency
 * @property {number} perFrame - Execute the binding handler once for each frame to be rendered using the shader.
 * @property {number} perNode - Execute the binding handler once for each frame, for each node to be rendered using the shader.
 * @property {number} perShadable - Execute the binding handler once for each frame, for each node, for each material or geometry to be rendered using the shader.
 * @see https://developer.apple.com/documentation/scenekit/scnbufferfrequency
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNBufferFrequency = {
  perFrame: 0,
  perNode: 1,
  perShadable: 2
};

exports.default = SCNBufferFrequency;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * An object that manages a Metal buffer used by a custom shader program. 
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnbufferstream
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNBufferStream = function () {
  function SCNBufferStream() {
    _classCallCheck(this, SCNBufferStream);
  }

  _createClass(SCNBufferStream, [{
    key: 'writeBytesCount',


    /**
     * constructor
     * @access public
     * @constructor
     */
    //constructor() {
    //}

    // Writing Data to a Buffer

    /**
     * Required. Copies the specified data bytes into the underlying Metal buffer for use by a shader.
     * @access public
     * @param {Object} bytes - The memory address from which to copy data.
     * @param {number} length - The number of bytes to copy into the Metal buffer.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnbufferstream/1523175-writebytes
     */
    value: function writeBytesCount(bytes, length) {}
  }]);

  return SCNBufferStream;
}();

exports.default = SCNBufferStream;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for which edges of an extruded shape are chamfered, used by the chamferMode property.
 * @typedef {Object} SCNChamferMode
 * @property {number} both - Apply a chamfer to both front and back edges of the extruded shape.
 * @property {number} front - Apply a chamfer to only the front edge of the extruded shape.
 * @property {number} back - Apply a chamfer to only the back edge of the extruded shape.
 * @see https://developer.apple.com/documentation/scenekit/scnchamfermode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNChamferMode = {
  both: 0,
  front: 1,
  back: 2
};

exports.default = SCNChamferMode;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNGeometry2 = __webpack_require__(9);

var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

var _SCNGeometryElement = __webpack_require__(15);

var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A right circular cone or frustum geometry.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scncone
 */
var SCNCone = function (_SCNGeometry) {
  _inherits(SCNCone, _SCNGeometry);

  // Creating a Cone

  /**
   * Creates a cone geometry with the given top radius, bottom radius, and height.
   * @constructor
   * @access public
   * @param {number} topRadius - The radius of the cone’s top, forming a circle in the x- and z-axis dimensions of its local coordinate space.
   * @param {number} bottomRadius - The radius of the cone’s base, forming a circle in the x- and z-axis dimensions of its local coordinate space.
   * @param {number} height - The height of the cone along the y-axis of its local coordinate space.
   * @desc The cone is centered in its local coordinate system. For example, if you create a cone whose bottom radius is 5.0, top radius is 0.0, and height is 10.0, its apex is at the point {0, 5.0, 0}, and its base lies in the plane whose y-coordinate is -5.0, extending from -5.0 to 5.0 along both the x- and z-axes.Pass zero for topRadius or bottomRadius or parameter to create a cone whose sides taper to a single point, or a different value to create a frustum with a circular top.
   * @see https://developer.apple.com/documentation/scenekit/scncone/1522863-init
   */
  function SCNCone() {
    var topRadius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;
    var bottomRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;

    _classCallCheck(this, SCNCone);

    // Adjusting a Cone’s Dimensions

    /**
     * The radius of the cone’s circular top. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncone/1524240-topradius
     */
    var _this = _possibleConstructorReturn(this, (SCNCone.__proto__ || Object.getPrototypeOf(SCNCone)).call(this, [], []));

    _this.topRadius = topRadius;

    /**
     * The radius of the cone’s circular base. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncone/1523198-bottomradius
     */
    _this.bottomRadius = bottomRadius;

    /**
     * The extent of the cylinder along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncone/1523219-height
     */
    _this.height = height;

    // Adjusting Geometric Detail

    /**
     * The number of subdivisions around the circumference of the cone. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncone/1523942-radialsegmentcount
     */
    _this.radialSegmentCount = 48;

    /**
     * The number of subdivisions in the sides of the cone along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncone/1524113-heightsegmentcount
     */
    _this.heightSegmentCount = 1;

    _this._createGeometry();
    _this.materials.push(new _SCNMaterial2.default());
    return _this;
  }

  _createClass(SCNCone, [{
    key: '_createGeometry',
    value: function _createGeometry() {
      var sourceData = [];

      var top = this.height * 0.5;
      var bottom = -this.height * 0.5;

      var sideData = [];
      var topData = [];
      var bottomData = [];

      var rStep = 2.0 * Math.PI / this.radialSegmentCount;
      var tStep = 1.0 / this.radialSegmentCount;
      for (var i = 0; i <= this.radialSegmentCount; i++) {
        var x = -Math.sin(rStep * i);
        var z = -Math.cos(rStep * i);
        var tvx = x * this.topRadius;
        var tvz = z * this.topRadius;
        var bvx = x * this.bottomRadius;
        var bvz = z * this.bottomRadius;

        // vertex
        sideData.push(bvx, bottom, bvz);
        bottomData.push(-bvx, bottom, bvz

        // normal
        );sideData.push(x, 0, z);
        bottomData.push(0, -1, 0

        // texcoord
        );var tx = tStep * i;
        sideData.push(tx, 1.0);

        var ttx = (1 + Math.cos(i * rStep)) * 0.5;
        var tty = (1 + Math.sin(i * rStep)) * 0.5;
        bottomData.push(ttx, tty

        // vertex
        );sideData.push(tvx, top, tvz);
        bottomData.push(0, bottom, 0

        // normal
        );sideData.push(x, 0, z);
        bottomData.push(0, -1, 0

        // texcoord
        );sideData.push(tx, 0.0);
        bottomData.push(0.5, 0.5);
      }
      sourceData.push.apply(sourceData, sideData.concat(bottomData));

      var vectorCount = (this.radialSegmentCount + 1) * 4; // TODO: use heightSegmentCount
      var vertexSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.vertex, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      32 // sride
      );

      var normalSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.normal, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      12, // offset
      32 // stride
      );

      var texcoordSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.texcoord, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      24, // offset
      32 // stride
      );

      var elements = [];
      var indexData0 = [];
      var indexData1 = [];
      var offset1 = (this.radialSegmentCount + 1) * 2;
      for (var _i = 0; _i < this.radialSegmentCount; _i++) {
        var base0 = _i * 2;
        indexData0.push(base0, base0 + 2, base0 + 3);
        var base1 = offset1 + base0;
        indexData1.push(base1, base1 + 2, base1 + 3);
      }
      elements.push(new _SCNGeometryElement2.default(indexData0, _SCNGeometryPrimitiveType2.default.triangles));
      elements.push(new _SCNGeometryElement2.default(indexData1, _SCNGeometryPrimitiveType2.default.triangles));

      this._geometryElements = elements;
      this._geometrySources = [vertexSource, normalSource, texcoordSource];
      this.boundingBox = {
        min: new _SCNVector2.default(-this.radius, bottom, -this.radius),
        max: new _SCNVector2.default(this.radius, top, this.radius)
      };
    }
  }]);

  return SCNCone;
}(_SCNGeometry3.default);

exports.default = SCNCone;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNGeometry2 = __webpack_require__(9);

var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

var _SCNGeometryElement = __webpack_require__(15);

var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNGeometryTessellator from './SCNGeometryTessellator'


/**
 * A right circular cylinder geometry.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scncylinder
 */
var SCNCylinder = function (_SCNGeometry) {
  _inherits(SCNCylinder, _SCNGeometry);

  _createClass(SCNCylinder, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        $constructor: function $constructor(propNames, propValues) {
          var cylinder = new SCNCylinder(propValues.cylinderradius, propValues.cylinderheight);
          cylinder.radialSegmentCount = propValues.cylinderradialSegmentCount;
          cylinder.heightSegmentCount = propValues.cylinderheightSegmentCount;
          cylinder.materials = propValues.materials;
          cylinder.tessellator = propValues.tessellator;
          cylinder.subdivisionLevel = propValues.subdivisionLevel;
          return cylinder;
        },
        name: ['string', null],
        cylinderradius: ['float', null],
        cylinderheight: ['float', null],
        cylinderradialSegmentCount: ['integer', null],
        cylinderheightSegmentCount: ['integer', null],
        cylinderradialSpan: ['float', null],
        cylinderprimitiveType: ['integer', null],
        materials: ['NSArray', null],
        tessellator: ['SCNGeometryTessellator', null],
        subdivisionLevel: ['integer', null],

        subdivisionSettings: ['bytes', null],
        wantsAdaptiveSubdivision: ['boolean', null]
      };
    }

    // Creating a Cylinder

    /**
     * Creates a cylinder geometry with the specified radius and height.
     * @access public
     * @constructor
     * @param {number} radius - The radius of the cylinder’s circular cross section in the x- and z-axis dimensions of its local coordinate space.
     * @param {number} height - The height of the cylinder along the y-axis of its local coordinate space.
     * @desc The cylinder is centered in its local coordinate system. For example, if you create a cylinder whose radius is 5.0 and height is 10.0, its circular cross section extends from -5.0 to 5.0 along the x- and z-axes, and the y-coordinates of its base and top are -5.0 and 5.0, respectively.
     * @see https://developer.apple.com/documentation/scenekit/scncylinder/1523685-init
     */

  }]);

  function SCNCylinder() {
    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;

    _classCallCheck(this, SCNCylinder);

    // Adjusting a Cylinder’s Dimensions

    /**
     * The radius of the cylinder’s circular cross section. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncylinder/1522674-radius
     */
    var _this = _possibleConstructorReturn(this, (SCNCylinder.__proto__ || Object.getPrototypeOf(SCNCylinder)).call(this, [], []));

    _this.radius = radius;

    /**
     * The extent of the cylinder along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncylinder/1523678-height
     */
    _this.height = height;

    // Adjusting Geometric Detail

    /**
     * The number of subdivisions around the circumference of the cylinder. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncylinder/1524002-radialsegmentcount
     */
    _this.radialSegmentCount = 48;

    /**
     * The number of subdivisions in the sides of the cylinder along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scncylinder/1523330-heightsegmentcount
     */
    _this.heightSegmentCount = 1;

    _this._createGeometry();
    _this.materials.push(new _SCNMaterial2.default());
    return _this;
  }

  _createClass(SCNCylinder, [{
    key: '_createGeometry',
    value: function _createGeometry() {
      var sourceData = [];

      var top = this.height * 0.5;
      var bottom = -this.height * 0.5;

      var sideData = [];
      var topData = [];
      var bottomData = [];

      var rStep = 2.0 * Math.PI / this.radialSegmentCount;
      var tStep = 1.0 / this.radialSegmentCount;
      for (var i = 0; i <= this.radialSegmentCount; i++) {
        var x = -Math.sin(rStep * i);
        var z = -Math.cos(rStep * i);
        var vx = x * this.radius;
        var vz = z * this.radius;

        // vertex
        sideData.push(vx, bottom, vz);
        topData.push(vx, top, vz);
        bottomData.push(-vx, bottom, vz

        // normal
        );sideData.push(x, 0, z);
        topData.push(0, 1, 0);
        bottomData.push(0, -1, 0

        // texcoord
        );var tx = tStep * i;
        sideData.push(tx, 1.0);

        var ttx = (1 + Math.cos(i * rStep)) * 0.5;
        var tty = (1 + Math.sin(i * rStep)) * 0.5;
        topData.push(ttx, tty);
        bottomData.push(ttx, tty

        // vertex
        );sideData.push(vx, top, vz);
        topData.push(0, top, 0);
        bottomData.push(0, bottom, 0

        // normal
        );sideData.push(x, 0, z);
        topData.push(0, 1, 0);
        bottomData.push(0, -1, 0

        // texcoord
        );sideData.push(tx, 0.0);
        topData.push(0.5, 0.5);
        bottomData.push(0.5, 0.5);
      }
      sourceData.push.apply(sourceData, sideData.concat(topData, bottomData));

      var vectorCount = (this.radialSegmentCount + 1) * 6;
      var vertexSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.vertex, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      32 // sride
      );

      var normalSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.normal, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      12, // offset
      32 // stride
      );

      var texcoordSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.texcoord, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      24, // offset
      32 // stride
      );

      var elements = [];
      var indexData0 = [];
      var indexData1 = [];
      var indexData2 = [];
      var offset1 = (this.radialSegmentCount + 1) * 2;
      var offset2 = (this.radialSegmentCount + 1) * 4;
      for (var _i = 0; _i < this.radialSegmentCount; _i++) {
        var base0 = _i * 2;
        indexData0.push(base0, base0 + 3, base0 + 1);
        indexData0.push(base0, base0 + 2, base0 + 3);

        var base1 = offset1 + base0;
        indexData1.push(base1, base1 + 2, base1 + 3);

        var base2 = offset2 + base0;
        indexData2.push(base2, base2 + 2, base2 + 3);
      }
      elements.push(new _SCNGeometryElement2.default(indexData0, _SCNGeometryPrimitiveType2.default.triangles));
      elements.push(new _SCNGeometryElement2.default(indexData1, _SCNGeometryPrimitiveType2.default.triangles));
      elements.push(new _SCNGeometryElement2.default(indexData2, _SCNGeometryPrimitiveType2.default.triangles));

      this._geometryElements = elements;
      this._geometrySources = [vertexSource, normalSource, texcoordSource];
      this.boundingBox = {
        min: new _SCNVector2.default(-this.radius, bottom, -this.radius),
        max: new _SCNVector2.default(this.radius, top, this.radius)
      };
    }
  }, {
    key: '_updateBoundingBoxForSkinner',
    value: function _updateBoundingBoxForSkinner() {
      var skinner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (skinner === null) {
        return this.boundingBox;
      }
      return _get(SCNCylinder.prototype.__proto__ || Object.getPrototypeOf(SCNCylinder.prototype), '_updateBoundingBoxForSkinner', this).call(this, skinner);
    }
  }]);

  return SCNCylinder;
}(_SCNGeometry3.default);

exports.default = SCNCylinder;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scndebugoptions
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNDebugOptions = function () {
  function SCNDebugOptions() {
    _classCallCheck(this, SCNDebugOptions);
  }

  _createClass(SCNDebugOptions, [{
    key: 'init',


    // Initializers

    /**
     * 
     * @access public
     * @param {number} rawValue - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1523870-init
     */
    value: function init(rawValue) {

      // Constants

      this._showPhysicsShapes = null;
      this._showBoundingBoxes = null;
      this._showLightInfluences = null;
      this._showLightExtents = null;
      this._showPhysicsFields = null;
      this._showWireframe = null;
    }
  }, {
    key: 'showPhysicsShapes',


    // Constants
    /**
     * Display the physics shapes for any nodes with attached SCNPhysicsBody objects.
     * @type {SCNDebugOptions}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1522896-showphysicsshapes
     */
    get: function get() {
      return this._showPhysicsShapes;
    }
    /**
     * Display the bounding boxes for any nodes with content.
     * @type {SCNDebugOptions}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1523258-showboundingboxes
     */

  }, {
    key: 'showBoundingBoxes',
    get: function get() {
      return this._showBoundingBoxes;
    }
    /**
     * Display the locations of each SCNLight object in the scene.
     * @type {SCNDebugOptions}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1522606-showlightinfluences
     */

  }, {
    key: 'showLightInfluences',
    get: function get() {
      return this._showLightInfluences;
    }
    /**
     * Display the regions affected by each SCNLight object in the scene.
     * @type {SCNDebugOptions}
     * @desc Only lights whose type is omni or spot have an area of effect; directional and ambient lights affect the entire scene.
     * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1522894-showlightextents
     */

  }, {
    key: 'showLightExtents',
    get: function get() {
      return this._showLightExtents;
    }
    /**
     * Display the regions affected by each SCNPhysicsField object in the scene.
     * @type {SCNDebugOptions}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1523589-showphysicsfields
     */

  }, {
    key: 'showPhysicsFields',
    get: function get() {
      return this._showPhysicsFields;
    }
    /**
     * Display geometries in the scene with wireframe rendering.
     * @type {SCNDebugOptions}
     * @desc When this option is enabled, SceneKit still renders scene geometry with all associated materials, then overlays a wireframe rendering of the same geometry. You can use this option, for example, to debug material rendering issues.
     * @see https://developer.apple.com/documentation/scenekit/scndebugoptions/1523384-showwireframe
     */

  }, {
    key: 'showWireframe',
    get: function get() {
      return this._showWireframe;
    }
  }]);

  return SCNDebugOptions;
}();

exports.default = SCNDebugOptions;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNConstraint2 = __webpack_require__(17);

var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

var _SCNNode = __webpack_require__(14);

var _SCNNode2 = _interopRequireDefault(_SCNNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * 
 * @access public
 * @extends {SCNConstraint}
 * @see https://developer.apple.com/documentation/scenekit/scndistanceconstraint
 */
var SCNDistanceConstraint = function (_SCNConstraint) {
  _inherits(SCNDistanceConstraint, _SCNConstraint);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNDistanceConstraint() {
    _classCallCheck(this, SCNDistanceConstraint);

    // Instance Properties

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scndistanceconstraint/2873358-maximumdistance
     */
    var _this = _possibleConstructorReturn(this, (SCNDistanceConstraint.__proto__ || Object.getPrototypeOf(SCNDistanceConstraint)).call(this));

    _this.maximumDistance = 0;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scndistanceconstraint/2873385-minimumdistance
     */
    _this.minimumDistance = 0;

    /**
     * 
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scndistanceconstraint/2873381-target
     */
    _this.target = null;

    return _this;
  }

  // Initializers

  /**
   * 
   * @access public
   * @param {?SCNNode} target - 
   * @returns {SCNDistanceConstraint}
   * @see https://developer.apple.com/documentation/scenekit/scndistanceconstraint/2873360-init
   */


  _createClass(SCNDistanceConstraint, null, [{
    key: 'constraintWithTarget',
    value: function constraintWithTarget(target) {
      var constraint = new SCNDistanceConstraint();
      // TODO: implement
      return constraint;
    }
  }]);

  return SCNDistanceConstraint;
}(_SCNConstraint3.default);

exports.default = SCNDistanceConstraint;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNVector3 from './SCNVector3'

/**
 * The signature for a block that SceneKit calls to determine the effect of a custom field on an object.
 * @type {function(position: SCNVector3, velocity: SCNVector3, mass: number, charge: number, time: number): SCNVector3}
 * @param {SCNVector3} position - The position of the object affected by the field, in the local coordinate space of the node containing the field.
 * @param {SCNVector3} velocity - The velocity of the object affected by the field, relative to the local coordinate space of the node containing the field.
 * @param {number} mass - The mass of the object affected by the field. (See the mass property for physics bodies and the particleMass property for particle systems.) 
 * @param {number} charge - The electrical charge of the object affected by the field. (See the charge property for physics bodies and the particleCharge property for particle systems.)
 * @param {number} time - The elapsed time, in seconds, since the last simulation step.
 * @returns {SCNVector3} -
 * @desc Your block uses these parameters to compute and return an SCNVector3 force vector, which SceneKit then applies to the object affected by the field.
 * @see https://developer.apple.com/documentation/scenekit/scnfieldforceevaluator
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNFieldForceEvaluator = function SCNFieldForceEvaluator(position, velocity, mass, charge, time) {};

exports.default = SCNFieldForceEvaluator;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNGeometry2 = __webpack_require__(9);

var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

var _SCNGeometryElement = __webpack_require__(15);

var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An infinite plane that can optionally display a reflection of the scene above it.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scnfloor
 */
var SCNFloor = function (_SCNGeometry) {
  _inherits(SCNFloor, _SCNGeometry);

  /**
   * constructor
   * @constructor
   * @access public
   */
  function SCNFloor() {
    _classCallCheck(this, SCNFloor);

    // Adding Reflections to a Floor

    /**
     * The intensity of the scene’s reflection on the floor. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/1524175-reflectivity
     */
    var _this = _possibleConstructorReturn(this, (SCNFloor.__proto__ || Object.getPrototypeOf(SCNFloor)).call(this, [], []));

    _this.reflectivity = 0.25;

    /**
     * The distance from the floor at which scene contents are no longer reflected. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/1522781-reflectionfalloffend
     */
    _this.reflectionFalloffEnd = 0.0;

    /**
     * The distance from the floor at which scene contents are reflected at full intensity. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/1524237-reflectionfalloffstart
     */
    _this.reflectionFalloffStart = 0.0;

    /**
     * The resolution scale factor of the offscreen buffer that SceneKit uses to render reflections.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/1522809-reflectionresolutionscalefactor
     */
    _this.reflectionResolutionScaleFactor = 1.0;

    // Instance Properties

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/2091890-length
     */
    _this.length = 2.0;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/1845281-reflectioncategorybitmask
     */
    _this.reflectionCategoryBitMask = -1;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnfloor/1845280-width
     */
    _this.width = 2.0;

    _this._createGeometry();
    _this.materials.push(new _SCNMaterial2.default());
    return _this;
  }

  _createClass(SCNFloor, [{
    key: '_createGeometry',
    value: function _createGeometry() {
      var sourceData = [];
      var indexData = [];
      var segmentCount = 10;
      var xStep = this.width / segmentCount;
      var yStep = -this.length / segmentCount;
      var txStep = 1.0 / segmentCount;
      var tyStep = -1.0 / segmentCount;

      var y = this.length * 0.5;
      var ty = 1.0;
      for (var h = 0; h <= segmentCount; h++) {
        var x = -this.width * 0.5;
        var tx = 0.0;
        for (var w = 0; w <= segmentCount; w++) {
          // vector
          sourceData.push(x, y, 0

          // normal
          );sourceData.push(0, 0, 1

          // texcoord
          );sourceData.push(tx, ty);

          x += xStep;
          tx += txStep;
        }
        y += yStep;
        ty += tyStep;
      }

      var offset = segmentCount + 1;
      for (var i = 0; i < segmentCount; i++) {
        var base0 = i * 11;
        for (var j = 0; j < segmentCount; j++) {
          var base = base0 + j;
          var i2 = base + offset;
          indexData.push(base, base + 1, i2 + 1);
          indexData.push(base, i2 + 1, i2);
        }
      }

      var vectorCount = (segmentCount + 1) * (segmentCount + 1);
      var vertexSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.vertex, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      32 // sride
      );

      var normalSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.normal, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      12, // offset
      32 // stride
      );

      var texcoordSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.texcoord, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      24, // offset
      32 // stride
      );

      var element = new _SCNGeometryElement2.default(indexData, _SCNGeometryPrimitiveType2.default.triangles);

      this._geometryElements = [element];
      this._geometrySources = [vertexSource, normalSource, texcoordSource];
      this.boundingBox = {
        min: new _SCNVector2.default(-this.width * 0.5, -this.length * 0.5, 0),
        max: new _SCNVector2.default(this.width * 0.5, this.length * 0.5, 0)
      };
    }
  }]);

  return SCNFloor;
}(_SCNGeometry3.default);

exports.default = SCNFloor;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNTessellationSmoothingMode = __webpack_require__(90);

var _SCNTessellationSmoothingMode2 = _interopRequireDefault(_SCNTessellationSmoothingMode);

var _MTLTessellationPartitionMode = __webpack_require__(75);

var _MTLTessellationPartitionMode2 = _interopRequireDefault(_MTLTessellationPartitionMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator
 */
var SCNGeometryTessellator = function (_NSObject) {
  _inherits(SCNGeometryTessellator, _NSObject);

  /**
   * constructor
   * @constructor
   * @access public
   */
  function SCNGeometryTessellator() {
    _classCallCheck(this, SCNGeometryTessellator);

    // Instance Properties

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889886-edgetessellationfactor
     */
    var _this = _possibleConstructorReturn(this, (SCNGeometryTessellator.__proto__ || Object.getPrototypeOf(SCNGeometryTessellator)).call(this));

    _this.edgeTessellationFactor = 0;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889878-insidetessellationfactor
     */
    _this.insideTessellationFactor = 0;

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889881-isadaptive
     */
    _this.isAdaptive = false;

    /**
     * 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889879-isscreenspace
     */
    _this.isScreenSpace = false;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889888-maximumedgelength
     */
    _this.maximumEdgeLength = 0;

    /**
     * 
     * @type {SCNTessellationSmoothingMode}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889889-smoothingmode
     */
    _this.smoothingMode = _SCNTessellationSmoothingMode2.default.none;

    /**
     * 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889887-tessellationfactorscale
     */
    _this.tessellationFactorScale = 0;

    /**
     * 
     * @type {MTLTessellationPartitionMode}
     * @see https://developer.apple.com/documentation/scenekit/scngeometrytessellator/2889882-tessellationpartitionmode
     */
    _this.tessellationPartitionMode = _MTLTessellationPartitionMode2.default.none;

    return _this;
  }

  return SCNGeometryTessellator;
}(_NSObject3.default);

exports.default = SCNGeometryTessellator;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNConstraint2 = __webpack_require__(17);

var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNNode from './SCNNode'
//import SCNVector3 from './SCNVector3'


/**
 * A constraint that applies inverse kinematics to make a chain of nodes “reach” toward a target point.
 * @access public
 * @extends {SCNConstraint}
 * @see https://developer.apple.com/documentation/scenekit/scnikconstraint
 */
var SCNIKConstraint = function (_SCNConstraint) {
  _inherits(SCNIKConstraint, _SCNConstraint);

  function SCNIKConstraint() {
    _classCallCheck(this, SCNIKConstraint);

    return _possibleConstructorReturn(this, (SCNIKConstraint.__proto__ || Object.getPrototypeOf(SCNIKConstraint)).apply(this, arguments));
  }

  _createClass(SCNIKConstraint, [{
    key: 'init',


    // Creating an Inverse Kinematics Constraint

    /**
     * Initializes an inverse kinematics constraint whose chain of nodes begins with the specified node.
     * @access public
     * @param {SCNNode} chainRootNode - 
     * @returns {void}
     * @desc The root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.The node you apply the constraint to (using that node’s constraints property) is the end effector of the chain—the lowest node in the hierarchy. When you set the constraint’s targetPosition property, SceneKit attempts to move this node toward the target point by rotating it relative to its parent node (and rotating its parent and ancestor nodes, up the chain ending with the chainRoot node). Continuing the above example, the end effector of the robot arm is its hand.
     * @see https://developer.apple.com/documentation/scenekit/scnikconstraint/1468694-init
     */
    value: function init(chainRootNode) {

      // Adjusting the Constraint’s Limits of Motion

      this._chainRootNode = null;

      // Applying Inverse Kinematics to the Constrained Node

      /**
       * The desired position for the constrained node, in the scene’s world coordinate space. Animatable.
       * @type {SCNVector3}
       * @see https://developer.apple.com/documentation/scenekit/scnikconstraint/1468651-targetposition
       */
      this.targetPosition = null;
    }

    /**
     * Creates an inverse kinematics constraint whose chain of nodes begins with the specified node.
     * @access public
     * @param {SCNNode} chainRootNode - 
     * @returns {SCNIKConstraint} - 
     * @desc The root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.The node you apply the constraint to (using that node’s constraints property) is the end effector of the chain—the lowest node in the hierarchy. When you set the constraint’s targetPosition property, SceneKit attempts to move this node toward the target point by rotating it relative to its parent node (and rotating its parent and ancestor nodes, up the chain ending with the chainRoot node). Continuing the above example, the end effector of the robot arm is its hand.
     * @see https://developer.apple.com/documentation/scenekit/scnikconstraint/1468653-inversekinematicsconstraint
     */

  }, {
    key: 'maxAllowedRotationAngleForJoint',


    // Adjusting the Constraint’s Limits of Motion

    /**
     * Returns the rotation limit, in degrees, for the specified node.
     * @access public
     * @param {SCNNode} node - A node affected by the constraint—either the node whose constraints property references the constraint or one of that node’s parent or ancestor nodes, up to the node specified by the constraint’s chainRootNode property.
     * @returns {number} - 
     * @desc When SceneKit evaluates the IK constraint, it checks the target orientations of each node in the chain relative to their initial orientations (as of when the constraint was applied to a node). For each node in the chain, SceneKit limits the rotation (in any direction) between the initial and target orientations to the value returned by this method.The default rotation limit for each joint is 180 degrees in either direction, allowing unconstrained rotation.
     * @see https://developer.apple.com/documentation/scenekit/scnikconstraint/1468681-maxallowedrotationangle
     */
    value: function maxAllowedRotationAngleForJoint(node) {
      return 0;
    }

    /**
     * Sets the rotation limit, in degrees, for the specified node.
     * @access public
     * @param {number} angle - The maximum rotation, in degrees, that SceneKit should apply to the specified node when evaluating the constraint.
     * @param {SCNNode} node - A node affected by the constraint—either the node whose constraints property references the constraint, or one of that node’s parent or ancestor nodes up to the node specified by the constraint’s chainRootNode property.
     * @returns {void}
     * @desc When SceneKit evaluates the IK constraint, it checks the target orientations of each node in the chain relative to their initial orientations (as of when the constraint was applied to a node). For each node in the chain, SceneKit limits the rotation (in any direction) between the initial and target orientations to the angle value specified with this method.The default rotation limit for each joint is 180 degrees in either direction, allowing unconstrained rotation.
     * @see https://developer.apple.com/documentation/scenekit/scnikconstraint/1468649-setmaxallowedrotationangle
     */

  }, {
    key: 'setMaxAllowedRotationAngleForJoint',
    value: function setMaxAllowedRotationAngleForJoint(angle, node) {}
    /**
     * The parent node of the hierarchy affected by the constraint.
     * @type {SCNNode}
     * @desc The root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.
     * @see https://developer.apple.com/documentation/scenekit/scnikconstraint/1468690-chainrootnode
     */

  }, {
    key: 'chainRootNode',
    get: function get() {
      return this._chainRootNode;
    }
  }], [{
    key: 'inverseKinematicsConstraint',
    value: function inverseKinematicsConstraint(chainRootNode) {
      return null;
    }
  }]);

  return SCNIKConstraint;
}(_SCNConstraint3.default);

exports.default = SCNIKConstraint;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNScene from './SCNScene'

/**
 * A Core Animation layer that renders a SceneKit scene as its content.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scnlayer
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNLayer =

/**
 * constructor
 * @access public
 * @constructor
 */
function SCNLayer() {
  _classCallCheck(this, SCNLayer);

  // Specifying a Scene

  /**
   * The scene to be displayed in the layer.
   * @type {?SCNScene}
   * @see https://developer.apple.com/documentation/scenekit/scnlayer/1393188-scene
   */
  this.scene = null;
};

exports.default = SCNLayer;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNGeometry = __webpack_require__(9);

var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An object that defines alternate resolutions for a geometry that SceneKit can automatically substitute to improve rendering performance.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnlevelofdetail
 */
var SCNLevelOfDetail = function (_NSObject) {
  _inherits(SCNLevelOfDetail, _NSObject);

  _createClass(SCNLevelOfDetail, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        mode: ['integer', null],
        threshold: ['float', null]
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */

  }]);

  function SCNLevelOfDetail() {
    _classCallCheck(this, SCNLevelOfDetail);

    // Inspecting a Level of Detail

    var _this = _possibleConstructorReturn(this, (SCNLevelOfDetail.__proto__ || Object.getPrototypeOf(SCNLevelOfDetail)).call(this));

    _this._geometry = null;
    _this._screenSpaceRadius = 0;
    _this._worldSpaceDistance = 0;
    return _this;
  }

  // Creating a Level of Detail

  /**
   * Creates a level of detail with the specified geometry and threshold pixel radius.
   * @access public
   * @param {?SCNGeometry} geometry - The geometry to render for this level of detail.
   * @param {number} radius - The maximum radius (in pixels) of the geometry’s bounding sphere for this level of detail to appear.
   * @returns {void}
   * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the radius in pixels of the circle covered by a geometry’s bounding sphere, then renders the geometry for the SCNLevelOfDetail object with the largest radius parameter smaller than that circle.If you pass nil for the geometry parameter, SceneKit renders no geometry for the level of detail. Creating a level-of-detail object with no geometry allows you to skip rendering costs entirely for an object when it would appear very far away or very small.
   * @see https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1523557-init
   */


  _createClass(SCNLevelOfDetail, [{
    key: 'initScreenSpaceRadius',
    value: function initScreenSpaceRadius(geometry, radius) {}

    /**
     * Creates a level of detail with the specified geometry and threshold camera distance.
     * @access public
     * @param {?SCNGeometry} geometry - The geometry to render for this level of detail, or nil if SceneKit should render no geometry at this level of detail.
     * @param {number} distance - The minimum distance from the current point of view for this level of detail to appear.
     * @returns {void}
     * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the distance from the current point of view to the geometry’s parent node, then renders the geometry for the SCNLevelOfDetail object with the smallest distance parameter greater than that distance.If you pass nil for the geometry parameter, SceneKit renders no geometry for the level of detail. Creating a level-of-detail object with no geometry allows you to skip rendering costs entirely for an object when it would appear very far away or very small.
     * @see https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1522802-init
     */

  }, {
    key: 'initWorldSpaceDistance',
    value: function initWorldSpaceDistance(geometry, distance) {}

    // Inspecting a Level of Detail
    /**
     * The geometry associated with this level of detail.
     * @type {?SCNGeometry}
     * @desc SceneKit renders this geometry instead of the original geometry when the level of detail is appropriate. Generally, levels of detail with larger worldSpaceDistance values or smaller screenSpaceRadius values should contain less complex geometries.If the value of this property is nil, SceneKit renders no geometry at this level of detail.
     * @see https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1522819-geometry
     */

  }, {
    key: 'geometry',
    get: function get() {
      return this._geometry;
    }

    /**
     * The maximum radius (in pixels) of the geometry’s bounding sphere for this level of detail to appear.
     * @type {number}
     * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the radius in pixels of the circle covered by a geometry’s bounding sphere, then renders the geometry for the SCNLevelOfDetail object with the smallest radius parameter larger than that circle.
     * @see https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1523554-screenspaceradius
     */

  }, {
    key: 'screenSpaceRadius',
    get: function get() {
      return this._screenSpaceRadius;
    }

    /**
     * The minimum distance from the current point of view for this level of detail to appear.
     * @type {number}
     * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the distance from the current point of view to the geometry’s parent node, then renders the geometry for the SCNLevelOfDetail object with the largest distance parameter less than that distance.
     * @see https://developer.apple.com/documentation/scenekit/scnlevelofdetail/1524159-worldspacedistance
     */

  }, {
    key: 'worldSpaceDistance',
    get: function get() {
      return this._worldSpaceDistance;
    }
  }]);

  return SCNLevelOfDetail;
}(_NSObject3.default);

exports.default = SCNLevelOfDetail;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNConstraint2 = __webpack_require__(17);

var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

var _SCNNode = __webpack_require__(14);

var _SCNNode2 = _interopRequireDefault(_SCNNode);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A constraint that orients a node to always point toward a specified other node. 
 * @access public
 * @extends {SCNConstraint}
 * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint
 */
var SCNLookAtConstraint = function (_SCNConstraint) {
  _inherits(SCNLookAtConstraint, _SCNConstraint);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNLookAtConstraint() {
    _classCallCheck(this, SCNLookAtConstraint);

    // Modifying a Constraint

    /**
     * A Boolean value that specifies whether constrained nodes are allowed to rotate.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint/1468675-isgimballockenabled
     */
    var _this = _possibleConstructorReturn(this, (SCNLookAtConstraint.__proto__ || Object.getPrototypeOf(SCNLookAtConstraint)).call(this));

    _this.isGimbalLockEnabled = false;

    /**
     * The node toward which constrained nodes will point after being reoriented.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint/1468677-target
     */
    _this.target = null;

    // Instance Properties

    /**
     * 
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint/2867570-localfront
     */
    _this.localFront = null;

    /**
     * 
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint/2867488-targetoffset
     */
    _this.targetOffset = null;

    /**
     * 
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint/2902240-worldup
     */
    _this.worldUp = null;

    return _this;
  }

  // Creating a Look-At Constraint

  /**
   * Creates a look-at constraint for a specified target node.
   * @access public
   * @param {?SCNNode} target - The node that constrained nodes will be reoriented to point toward.
   * @returns {void}
   * @desc To attach constraints to an SCNNode object, use its constraints property.
   * @see https://developer.apple.com/documentation/scenekit/scnlookatconstraint/1468683-init
   */


  _createClass(SCNLookAtConstraint, null, [{
    key: 'constraintWithTarget',
    value: function constraintWithTarget(target) {
      var constraint = new SCNLookAtConstraint();
      // TODO: implement
      return constraint;
    }
  }]);

  return SCNLookAtConstraint;
}(_SCNConstraint3.default);

exports.default = SCNLookAtConstraint;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a Boolean value that indicates whether the corresponding elements of two matrices are equal.
 * @access public
 * @param {SCNMatrix4} a - 
 * @param {SCNMatrix4} b - 
 * @returns {boolean} - 
 * @desc This function performs a numeric (not bitwise) comparison of each pair of elements.
 * @see https://developer.apple.com/documentation/scenekit/1409665-scnmatrix4equaltomatrix4
 */
var SCNMatrix4EqualToMatrix4 = function SCNMatrix4EqualToMatrix4(a, b) {
  if (!(0, _InstanceOf3.default)(a, _SCNMatrix2.default)) {
    return false;
  }
  return a.equalTo(b);
};

exports.default = SCNMatrix4EqualToMatrix4;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNMatrix4 from './SCNMatrix4'
//import GLKMatrix4 from '../undefined/GLKMatrix4'

/**
 * Returns a SceneKit matrix corresponding to a GLKit matrix.
 * @access public
 * @param {GLKMatrix4} mat - A GLKit matrix.
 * @returns {SCNMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409699-scnmatrix4fromglkmatrix4
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNMatrix4FromGLKMatrix4 = function SCNMatrix4FromGLKMatrix4(mat) {
  return null;
};

exports.default = SCNMatrix4FromGLKMatrix4;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 
 * @access public
 * @param {number[][]} m - 
 * @returns {SCNMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1522632-scnmatrix4frommat4
 */
var SCNMatrix4FromMat4 = function SCNMatrix4FromMat4(m) {
  return null;
};

exports.default = SCNMatrix4FromMat4;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNMatrix4 from './SCNMatrix4'

/**
 * Returns the inverse of the specified matrix.
 * @access public
 * @param {SCNMatrix4} m - 
 * @returns {SCNMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409682-scnmatrix4invert
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNMatrix4Invert = function SCNMatrix4Invert(m) {
  return m.invert();
};

exports.default = SCNMatrix4Invert;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import SCNMatrix4EqualToMatrix4 from './SCNMatrix4EqualToMatrix4'

var _identity = new _SCNMatrix2.default();

/**
 * Returns a Boolean value that indicates whether the specified matrix is equal to the identity matrix.
 * @access public
 * @param {SCNMatrix4} m - 
 * @returns {boolean} - 
 * @see https://developer.apple.com/documentation/scenekit/1409715-scnmatrix4isidentity
 */
var SCNMatrix4IsIdentity = function SCNMatrix4IsIdentity(m) {
  return m.isIdentity();
};

exports.default = SCNMatrix4IsIdentity;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a matrix describing a rotation transformation.
 * @access public
 * @param {number} angle - The amount of rotation, in radians, measured counterclockwise around the rotation axis.
 * @param {number} x - The x-component of the rotation axis.
 * @param {number} y - The y-component of the rotation axis.
 * @param {number} z - The z-component of the rotation axis.
 * @returns {SCNMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409686-scnmatrix4makerotation
 */
var SCNMatrix4MakeRotation = function SCNMatrix4MakeRotation(angle, x, y, z) {
  var c = Math.cos(angle);
  var s = Math.sin(angle);
  var v = new _SCNVector2.default(x, y, z);
  var m = new _SCNMatrix2.default();

  var nx = v.x;
  var ny = v.y;
  var nz = v.z;

  m.m11 = nx * nx * (1.0 - c) + c;
  m.m12 = nx * ny * (1.0 - c) - nz * s;
  m.m13 = nx * nz * (1.0 - c) + ny * s;
  m.m14 = 0.0;
  m.m21 = ny * nx * (1.0 - c) + nz * s;
  m.m22 = ny * ny * (1.0 - c) + c;
  m.m23 = ny * nz * (1.0 - c) - nx * s;
  m.m24 = 0.0;
  m.m31 = nz * nx * (1.0 - c) - ny * s;
  m.m32 = nz * ny * (1.0 - c) + nx * s;
  m.m33 = nz * nz * (1.0 - c) + c;
  m.m34 = 0.0;
  m.m41 = 0.0;
  m.m42 = 0.0;
  m.m43 = 0.0;
  m.m44 = 1.0;

  return m;
};

exports.default = SCNMatrix4MakeRotation;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNMatrix4 from './SCNMatrix4'

/**
 * Returns the product of two matrices.
 * @access public
 * @param {SCNMatrix4} a - 
 * @param {SCNMatrix4} b - 
 * @returns {SCNMatrix4} - 
 * @desc Matrix multiplication is not commutative. As a transformation, the result of multiplying a matrix A by a matrix B is the transformation represented by B followed by the transformation represented by A.
 * @see https://developer.apple.com/documentation/scenekit/1409697-scnmatrix4mult
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNMatrix4Mult = function SCNMatrix4Mult(a, b) {
  return a.mult(b);
};

exports.default = SCNMatrix4Mult;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNMatrix4 from './SCNMatrix4'

/**
 * Returns a new matrix created by concatenating the specified matrix with a rotation transformation.
 * @access public
 * @param {SCNMatrix4} m - 
 * @param {number} angle - The amount of rotation, in radians, measured counterclockwise around the rotation axis.
 * @param {number} x - The x-component of the rotation axis.
 * @param {number} y - The y-component of the rotation axis.
 * @param {number} z - The z-component of the rotation axis.
 * @returns {SCNMatrix4} - 
 * @desc The resulting transformation consists of the specified rotation followed by the transformation represented by the mat parameter.
 * @see https://developer.apple.com/documentation/scenekit/1409659-scnmatrix4rotate
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNMatrix4Rotate = function SCNMatrix4Rotate(m, angle, x, y, z) {
  return m.rotation(x, y, z, angle);
};

exports.default = SCNMatrix4Rotate;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNMatrix4 from './SCNMatrix4'

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNMatrix4MakeScale = __webpack_require__(93);

var _SCNMatrix4MakeScale2 = _interopRequireDefault(_SCNMatrix4MakeScale);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a new matrix created by concatenating the specified matrix with a scale transformation.
 * @access public
 * @param {SCNMatrix4} m - 
 * @param {number} sx - 
 * @param {number} sy - 
 * @param {number} sz - 
 * @returns {SCNMatrix4} - 
 * @desc The resulting transformation consists of the specified scale followed by the transformation represented by the mat parameter.
 * @see https://developer.apple.com/documentation/scenekit/1409653-scnmatrix4scale
 */
var SCNMatrix4Scale = function SCNMatrix4Scale(m, sx, sy, sz) {
  return m.mult((0, _SCNMatrix4MakeScale2.default)(sx, sy, sz));
};exports.default = SCNMatrix4Scale;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import GLKMatrix4 from '../undefined/GLKMatrix4'
//import SCNMatrix4 from './SCNMatrix4'

/**
 * Returns a GLKit matrix corresponding to a SceneKit matrix.
 * @access public
 * @param {SCNMatrix4} mat - A SceneKit matrix.
 * @returns {GLKMatrix4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409703-scnmatrix4toglkmatrix4
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNMatrix4ToGLKMatrix4 = function SCNMatrix4ToGLKMatrix4(mat) {
  return null;
};

exports.default = SCNMatrix4ToGLKMatrix4;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNMatrix4 from './SCNMatrix4'

/**
 * @access public
 * @type {function}
 * @param {SCNMatrix4} m - 
 * @returns {number[][]} - 
 * @see https://developer.apple.com/documentation/scenekit/1523928-scnmatrix4tomat4
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNMatrix4ToMat4 = function SCNMatrix4ToMat4(m) {
  return null;
};

exports.default = SCNMatrix4ToMat4;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNMatrix4 from './SCNMatrix4'

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNMatrix4MakeTranslation = __webpack_require__(18);

var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a new matrix created by concatenating the specified matrix with a translation transformation.
 * @access public
 * @param {SCNMatrix4} m - 
 * @param {number} tx - 
 * @param {number} ty - 
 * @param {number} tz - 
 * @returns {SCNMatrix4} - 
 * @desc The resulting transformation consists of the specified translation followed by the transformation represented by the mat parameter.
 * @see https://developer.apple.com/documentation/scenekit/1409717-scnmatrix4translate
 */
var SCNMatrix4Translate = function SCNMatrix4Translate(m, tx, ty, tz) {
  return m.mult((0, _SCNMatrix4MakeTranslation2.default)(tx, ty, tz));
};exports.default = SCNMatrix4Translate;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNMorpherCalculationMode = __webpack_require__(94);

var _SCNMorpherCalculationMode2 = _interopRequireDefault(_SCNMorpherCalculationMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNAnimatable from './SCNAnimatable'
//import SCNGeometry from './SCNGeometry'


var _weightsPattern = new RegExp(/^weights\[(\d+)\]$/);

/**
 * An object that manages smooth transitions between a node's base geometry and one or more target geometries.
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @see https://developer.apple.com/documentation/scenekit/scnmorpher
 */

var SCNMorpher = function (_NSObject) {
  _inherits(SCNMorpher, _NSObject);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNMorpher() {
    _classCallCheck(this, SCNMorpher);

    // Specifying Morph Targets

    /**
     * The array of target geometries to morph between.
     * @type {SCNGeometry[]}
     * @see https://developer.apple.com/documentation/scenekit/scnmorpher/1523572-targets
     */
    var _this = _possibleConstructorReturn(this, (SCNMorpher.__proto__ || Object.getPrototypeOf(SCNMorpher)).call(this));

    _this.targets = [];

    /**
     * @type {number[]}
     */
    _this._weights = [];

    // Changing Interpolation Mode

    /**
     * The interpolation formula for blending between target geometries.
     * @type {SCNMorpherCalculationMode}
     * @see https://developer.apple.com/documentation/scenekit/scnmorpher/1523754-calculationmode
     */
    _this.calculationMode = _SCNMorpherCalculationMode2.default.normalized;
    return _this;
  }

  // Blending between Morph Targets

  /**
   * Returns the weight value for the specified target index.
   * @access public
   * @param {number} targetIndex - The index of a geometry in the morpher’s targets array.
   * @returns {number} - 
   * @desc Target geometries and their weights determine the current form of the surface produced by the morpher. For example, if a morpher has one target whose weight is 0.5, the form of the resulting surface will be halfway between those of the base geometry and the target geometry.
   * @see https://developer.apple.com/documentation/scenekit/scnmorpher/1522940-weight
   */


  _createClass(SCNMorpher, [{
    key: 'weightForTargetAt',
    value: function weightForTargetAt(targetIndex) {
      return this._weights[targetIndex];
    }

    /**
     * Specifies a weight value at a specified target index.
     * @access public
     * @param {number} weight - A number specifying the contribution of the target geometry to the blended surface, generally between 0.0 and 1.0.
     * @param {number} targetIndex - The index of a geometry in the morpher’s targets array.
     * @returns {void}
     * @desc Target geometries and their weights determine the current form of the surface produced by the morpher. For example, if a morpher has one target whose weight is 0.5, the form of the resulting surface will be halfway between those of the base geometry and the target geometry.You can also animate weights implicitly or explicitly using the keypath weights[index], where index corresponds to the targetIndex parameter of this method.
     * @see https://developer.apple.com/documentation/scenekit/scnmorpher/1522886-setweight
     */

  }, {
    key: 'setWeightForTargetAt',
    value: function setWeightForTargetAt(weight, targetIndex) {
      this._weights[targetIndex] = weight;
    }
  }, {
    key: 'setValueForKey',
    value: function setValueForKey(value, key) {
      //console.log(`SCNMorpher.setValueForKey: ${key}: ${value}`)
      var weightsMatch = key.match(_weightsPattern);
      if (weightsMatch !== null) {
        if (weightsMatch.length > 1) {
          var index = weightsMatch[1];
          if (typeof this._weights[index] !== 'undefined') {
            //console.log(`_weights[ ${index} ] = ${value}`)
            this._weights[index] = value;
          }
        }
        return;
      }

      _get(SCNMorpher.prototype.__proto__ || Object.getPrototypeOf(SCNMorpher.prototype), 'setValueForKey', this).call(this, value, key);
    }

    /*
    setValueForKeyPath(value, keyPath) {
      console.log(`SCNMorpher.setValueForKeyPath: ${keyPath}: ${value}`)
      const paths = keyPath.split('.')
      const key = paths.shift()
      const restPath = paths.join('.')
       const weightsMatch = key.match(_weightsPattern)
      if(weightsMatch !== null){
        if(weightsMatch.length > 1){
          //const targetIndex = this.targets.findIndex((target) => target.name === restPath)
          //if(targetIndex >= 0){
          //  this._weights[targetIndex] = value
          //}
          const index = weightsMatch[1]
          if(typeof this._weights[index] !== 'undefined'){
            console.log(`_weights[ ${index} ] = ${value}`)
            this._weights[index] = value
          }
        }
      }else{
        super.setValueForKeyPath(value, keyPath)
      }
    }
    */

    /**
     * @access private
     * @param {SCNNode} node -
     * @returns {void}
     */

  }, {
    key: '_morph',
    value: function _morph(node) {
      var _this2 = this;

      //console.log(`SCNMorpher._morph ${node.name}`)
      var p = node.presentation;
      if (node.geometry === null || p === null || p.geometry === null) {
        // data is not ready
        return;
      }
      var pg = p.geometry;
      var totalWeightForSemantic = new Map();

      // reset presentation geometry
      node.geometry.geometrySources.forEach(function (source) {
        // FIXME: copy more than 1 source.
        var pSource = pg.getGeometrySourcesForSemantic(source.semantic)[0];
        pSource.fill(0
        //newData.set(source.semantic, Array(source._data.length).fill(0))
        );totalWeightForSemantic.set(source.semantic, 0.0);
      }

      // should I morph elements?
      //node.geometry.geometryElements().forEach((element) => {
      //})

      );var targetCount = this.targets.length;
      //console.log(`targetCount: ${targetCount}`)

      var _loop = function _loop(i) {
        var target = _this2.targets[i];
        var weight = _this2._weights[i];
        if (weight === 0 || typeof weight === 'undefined') {
          return 'continue';
        }
        //console.log(`morph ${target.name} weight ${weight}`)
        target.geometrySources.forEach(function (source) {
          var pSource = pg.getGeometrySourcesForSemantic(source.semantic)[0];
          if (typeof pSource === 'undefined') {
            return;
          }
          totalWeightForSemantic.set(source.semantic, totalWeightForSemantic.get(source.semantic) + weight

          // FIXME: don't access private properties
          );var srcIndex = source._dataOffset / source._bytesPerComponent;
          var srcStride = source._dataStride / source._bytesPerComponent;
          var dstIndex = pSource._dataOffset / pSource._bytesPerComponent;
          var dstStride = pSource._dataStride / pSource._bytesPerComponent;
          var componentCount = source._componentsPerVector;
          var vectorCount = source._vectorCount;
          for (var j = 0; j < vectorCount; j++) {
            for (var k = 0; k < componentCount; k++) {
              pSource._data[dstIndex + k] += source._data[srcIndex + k] * weight;
            }
            srcIndex += srcStride;
            dstIndex += dstStride;
          }
        });
      };

      for (var i = 0; i < targetCount; i++) {
        var _ret = _loop(i);

        if (_ret === 'continue') continue;
      }

      //console.log(`node.geometry.geometrySources.length: ${node.geometry.geometrySources.length}`)
      node.geometry.geometrySources.forEach(function (source) {
        //console.log(`add baseGeometry`)
        // FIXME: copy more than 1 source.
        var pSource = pg.getGeometrySourcesForSemantic(source.semantic)[0];
        var srcIndex = source._dataOffset / source._bytesPerComponent;
        var srcStride = source._dataStride / source._bytesPerComponent;
        var dstIndex = pSource._dataOffset / pSource._bytesPerComponent;
        var dstStride = pSource._dataStride / pSource._bytesPerComponent;
        var componentCount = source._componentsPerVector;
        var vectorCount = source._vectorCount;

        if (_this2.calculationMode === _SCNMorpherCalculationMode2.default.normalized) {
          var _weight = 1.0 - totalWeightForSemantic.get(source.semantic
          // FIXME: don't access private properties
          );for (var i = 0; i < vectorCount; i++) {
            for (var j = 0; j < componentCount; j++) {
              pSource._data[dstIndex + j] += source._data[srcIndex + j] * _weight;
            }
            srcIndex += srcStride;
            dstIndex += dstStride;
          }
        } else {
          //console.log(`additive: vector: ${vectorCount}, component: ${componentCount}`)
          // calculationMode: additive
          // FIXME: don't access private properties
          for (var _i = 0; _i < vectorCount; _i++) {
            for (var _j = 0; _j < componentCount; _j++) {
              pSource._data[dstIndex + _j] += source._data[srcIndex + _j];
            }
            srcIndex += srcStride;
            dstIndex += dstStride;
          }
        }
      }

      // TODO: needs to update normal vector?

      //console.log(`_morph done`)
      );
    }
  }]);

  return SCNMorpher;
}(_NSObject3.default);

exports.default = SCNMorpher;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNNode from './SCNNode'
//import SCNRenderer from './SCNRenderer'

/**
 * Methods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node. 
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnnoderendererdelegate
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNNodeRendererDelegate = function () {
  function SCNNodeRendererDelegate() {
    _classCallCheck(this, SCNNodeRendererDelegate);
  }

  _createClass(SCNNodeRendererDelegate, [{
    key: 'renderNode',


    /**
     * constructor
     * @access public
     * @constructor
     */
    //construtor() {
    //}

    // Customizing the Rendering of a Node

    /**
     * Tells the delegate to perform rendering for a node.
     * @access public
     * @param {SCNNode} node - The node to render.
     * @param {SCNRenderer} renderer - The SceneKit object (such as an SCNView instance) responsible for rendering the scene. 
     * @param {Map<string, Object>} _arguments - 
     * @returns {void}
     * @desc Implement this method to perform custom rendering for a node. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this method—the results of modifying SceneKit objects in this method are undefined.To render using Metal, use the renderer parameter to retrieve the scene renderer’s currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.To render using OpenGL, simply call the relevant OpenGL drawing commands—SceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.You must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use. 
     * @see https://developer.apple.com/documentation/scenekit/scnnoderendererdelegate/1407993-rendernode
     */
    value: function renderNode(node, renderer, _arguments) {}
  }]);

  return SCNNodeRendererDelegate;
}();

exports.default = SCNNodeRendererDelegate;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Significant events in the life spans of simulate particles, used by the handle(_:forProperties:handler:) method.
 * @typedef {Object} SCNParticleEvent
 * @property {number} birth - Occurs when new particles spawn.
 * @property {number} death - Occurs when particles reach the end of their life span.
 * @property {number} collision - Occurs when particles collide with scene geometry.
 * @see https://developer.apple.com/documentation/scenekit/scnparticleevent
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNParticleEvent = {
  birth: 0,
  death: 1,
  collision: 2
};

exports.default = SCNParticleEvent;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The signature for blocks called by SceneKit in response to significant events during particle simulation, used by the handle(_:forProperties:handler:) method.
 * @type {function(data: UnsafeMutablePointer<UnsafeMutableRawPointer>, dataStride: UnsafeMutablePointer<Int>, indices: ?UnsafeMutablePointer<UInt32>, count: number): void}
 * @param {UnsafeMutablePointer<UnsafeMutableRawPointer>} data - An array of floating-point values containing stripes of property data for the system’s particles. The width and format of each data stripe depend on the properties you specify when calling the handle(_:forProperties:handler:) method.
 * @param {UnsafeMutablePointer<Int>} dataStride - An array identifying the offset, in bytes, of each property’s value in the data stripe for each particle. The order of offsets in this array corresponds to the order of the properties array you specify when calling the handle(_:forProperties:handler:) method.
 * @param {?UnsafeMutablePointer<UInt32>} indices - An array in which each element is an index that identifies (in the data array) the data stripe for each particle affected by the event that caused SceneKit to call the handler block.When SceneKit calls your handler block for the birth event, you need not use this parameter—at that time, the affected particles are indexed from 0 to the count parameter’s value.
 * @param {number} count - The number of particles affected by the current event.
 * @returns {void}
 * @desc Use this block to change properties of individual particles when they are spawned, when they collide with scene geometry, or when they die (that is, reach the end of their life spans and are removed from the scene). The following example illustrates setting up a handler block for particle collision events:[system handleEvent:SCNParticleEventCollision
      forProperties:@[SCNParticlePropertyAngle,
                      SCNParticlePropertyRotationAxis,
                      SCNParticlePropertyContactNormal]
          withBlock:^(void **data, size_t *dataStride, uint32_t *indices, NSInteger count) {
              // For each particle affected by the collision event,
              // calculate pointers in the data to each property's value.
              for (NSInteger i = 0; i < count; ++i) {
                  // SCNParticlePropertyAngle (float)
                  float *angle = (float *)((char *)data[0] + dataStride[0] * indices[i]);
                  // angle[0] is the particle's rotation angle in radians.
 
                  // SCNParticlePropertyRotationAxis (float3)
                  float *axis = (float *)((char *)data[1] + dataStride[1] * indices[i]);
                  // axis[0..2] are the xyz components of the particle's rotation axis.
 
                  // SCNParticlePropertyContactNormal (float3)
                  float *norm = (float *)((char *)data[2] + dataStride[2] * indices[i]);
                  // norm[0..2] are the xyz components of the contact normal vector.
 
                  // Now, use the norm vector to rotate the particle's axis/angle (not shown).
              }
          }];

 * @see https://developer.apple.com/documentation/scenekit/scnparticleeventblock
 */

Object.defineProperty(exports, "__esModule", {
                 value: true
});
var SCNParticleEventBlock = function SCNParticleEventBlock(data, dataStride, indices, count) {};

exports.default = SCNParticleEventBlock;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for the input value of the property controller’s animation, used by the inputMode property.
 * @typedef {Object} SCNParticleInputMode
 * @property {number} overLife - The controller’s effect on a particle property is a function of the time since the particle’s birth.
 * @property {number} overDistance - The controller’s effect on a particle property is a function of the particle’s distance from the position of a specified node.
 * @property {number} overOtherProperty - The controller’s effect on a particle property is a function of another of the particle’s properties.
 * @see https://developer.apple.com/documentation/scenekit/scnparticleinputmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNParticleInputMode = {
  overLife: 0,
  overDistance: 1,
  overOtherProperty: 2
};

exports.default = SCNParticleInputMode;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The signature for blocks called by SceneKit to modify particle properties on each frame of simulation, used by the addModifier(forProperties:at:modifier:) method.
 * @type {function(data: UnsafeMutablePointer<UnsafeMutableRawPointer>, dataStride: UnsafeMutablePointer<Int>, start: number, end: number, deltaTime: number): void}
 * @param {UnsafeMutablePointer<UnsafeMutableRawPointer>} data - An array of floating-point values containing stripes of property data for the system’s particles. The width and format of each data stripe depend on the properties you specify when calling the addModifier(forProperties:at:modifier:) method.
 * @param {UnsafeMutablePointer<Int>} dataStride - An array identifying the offset, in bytes, of each property’s value in the data stripe for each particle. The order of offsets in this array corresponds to the order of the properties array you specify when calling the addModifier(forProperties:at:modifier:) method.
 * @param {number} start - The index of the first particle’s data stripe in the data array.
 * @param {number} end - The index of the last particle’s data stripe in the data array.
 * @param {number} deltaTime - The elapsed time, in seconds, since the last frame of simulation.
 * @returns {void}
 * @desc Use this block to change properties of individual particles on each frame of simulation.ImportantRunning your own code to update particle properties every frame can have a severe impact on rendering performance. If the behavior over time that you want for your particle system can be described more declaratively, use the propertyControllers property and SCNParticlePropertyController class instead. If you need to change particle properties only at certain times (rather than continuously), add a handler block for an event using the handle(_:forProperties:handler:) method.The following example illustrates setting up a modifier block that alters particle’s position and velocity:[system addModifierForProperties:@[SCNParticlePropertyPosition,
                                   SCNParticlePropertyVelocity]
                         atStage:SCNParticleModifierStagePostDynamics
                       withBlock:^(void **data, size_t *dataStride, NSInteger start, NSInteger end, float deltaTime) {
                           // For each particle to be processed,
                           // calculate pointers in the data to each property's value:
                           for (NSInteger i = start; i < end; ++i) {
                               // SCNParticlePropertyPosition (float3)
                               float *pos = (float *)((char *)data[0] + dataStride[0] * i);
                               // pos[0..2] are the xyz components of the particle's position.
 
                               // SCNParticlePropertyVelocity (float3)
                               float *vel = (float *)((char *)data[1] + dataStride[1] * i);
                               // vel[0..2] are the xyz components of the particle's position.
 
                               // Now, compute a new position and velocity (not shown).
                           }
                       }];

 * @see https://developer.apple.com/documentation/scenekit/scnparticlemodifierblock
 */

Object.defineProperty(exports, "__esModule", {
    value: true
});
var SCNParticleModifierBlock = function SCNParticleModifierBlock(data, dataStride, start, end, deltaTime) {};

exports.default = SCNParticleModifierBlock;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Stages of SceneKit’s particle simulation process into which you can insert modifier blocks, used by the addModifier(forProperties:at:modifier:) method.
 * @typedef {Object} SCNParticleModifierStage
 * @property {number} preDynamics - The stage before SceneKit simulates the motion of particles.
 * @property {number} postDynamics - The stage after SceneKit simulates the motion of particles.
 * @property {number} preCollision - The stage before SceneKit simulates the results of collisions between particles and scene geometry.
 * @property {number} postCollision - The stage after SceneKit simulates the results of collisions between particles and scene geometry.
 * @see https://developer.apple.com/documentation/scenekit/scnparticlemodifierstage
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNParticleModifierStage = {
  preDynamics: 0,
  postDynamics: 1,
  preCollision: 2,
  postCollision: 3
};

exports.default = SCNParticleModifierStage;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNNode = __webpack_require__(14);

var _SCNNode2 = _interopRequireDefault(_SCNNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import CAAnimation from '../QuartzCore/CAAnimation'
//import SCNParticleInputMode from './SCNParticleInputMode'


/**
 * An animation for a single property of the individual particles rendered by a particle system.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller
 */
var SCNParticlePropertyController = function (_NSObject) {
  _inherits(SCNParticlePropertyController, _NSObject);

  _createClass(SCNParticlePropertyController, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        animation: ['NSMutableDictionary', function (obj, anim) {
          obj.animation = _SCNNode2.default._loadAnimationData(anim, null);
        }],
        inputMode: 'integer',
        inputBias: 'float',
        inputScale: 'float',
        inputOrigin: 'SCNNode'
        // inputProperty: 'string' ?
      };
    }

    // Creating a Property Controller

    /**
     * Creates a particle property controller with the specified Core Animation animation.
     * @access public
     * @constructor
     * @param {CAAnimation} animation - A Core Animation object specifying the behavior of the property animation. Must not be nil.You can use different CAAnimation subclasses to animate effects in different ways. For example, a CABasicAnimation instance transitions a property from one value to another, and a CAKeyframeAnimation instance transitions a property through a series of values. You use properties of the animation object to define its timing curve, repeat mode, and other options.SceneKit ignores the keyPath, duration, and repeatCount properties of this animation object.
     * @desc To set up a particle property animation:Create a CAAnimation object defining how a property of each particle in the system changes over time.Create a particle property controller using the init(animation:) method.Attach the property controller to a particle system using the propertyControllers dictionary, choosing a key listed in Particle Property Keys to identify the particle property it animates.For example, the following code sets up a controller to animate particle sizes:// 1. Create and configure an animation object.
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.values = @[ @0.1, @1.0, @3.0, @0.5 ];
    // 2. Create a property controller from the animation object.
    SCNParticlePropertyController *controller =
      [SCNParticlePropertyController controllerWithAnimation:animation];
    // 3. Assign the controller to a particle system, associating it with a particle property.
    particleSystem.propertyControllers = @{ SCNParticlePropertySize: controller };
    // 1. Create and configure an animation object.
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.values = @[ @0.1, @1.0, @3.0, @0.5 ];
    // 2. Create a property controller from the animation object.
    SCNParticlePropertyController *controller =
      [SCNParticlePropertyController controllerWithAnimation:animation];
    // 3. Assign the controller to a particle system, associating it with a particle property.
    particleSystem.propertyControllers = @{ SCNParticlePropertySize: controller };
      * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1523579-init
     */

  }]);

  function SCNParticlePropertyController(animation) {
    _classCallCheck(this, SCNParticlePropertyController);

    // Managing the Controller’s Animation

    /**
     * The Core Animation object defining the behavior of the property animation.
     * @type {CAAnimation}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1523707-animation
     */
    var _this = _possibleConstructorReturn(this, (SCNParticlePropertyController.__proto__ || Object.getPrototypeOf(SCNParticlePropertyController)).call(this));

    _this.animation = animation;

    /**
     * The mode that determines input values for the property controller’s animation.
     * @type {SCNParticleInputMode}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1522852-inputmode
     */
    _this.inputMode = null;

    /**
     * An offset to add to the input value of the controller’s animation.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1523994-inputbias
     */
    _this.inputBias = 0;

    /**
     * A factor for multiplying the input value of the controller’s animation. 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1522903-inputscale
     */
    _this.inputScale = 0;

    /**
     * A node whose distance to each particle provides input values for the controller’s animation.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1522895-inputorigin
     */
    _this.inputOrigin = null;

    /**
     * A particle property that provides input values for this property controller’s animation.
     * @type {?SCNParticleSystem.ParticleProperty}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlepropertycontroller/1522973-inputproperty
     */
    _this.inputProperty = null;
    return _this;
  }

  return SCNParticlePropertyController;
}(_NSObject3.default);

exports.default = SCNParticlePropertyController;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BinaryRequest2 = __webpack_require__(36);

var _BinaryRequest3 = _interopRequireDefault(_BinaryRequest2);

var _NSKeyedUnarchiver = __webpack_require__(41);

var _NSKeyedUnarchiver2 = _interopRequireDefault(_NSKeyedUnarchiver);

var _NSObject3 = __webpack_require__(0);

var _NSObject4 = _interopRequireDefault(_NSObject3);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

var _SCNParticleBirthLocation = __webpack_require__(96);

var _SCNParticleBirthLocation2 = _interopRequireDefault(_SCNParticleBirthLocation);

var _SCNParticleBirthDirection = __webpack_require__(95);

var _SCNParticleBirthDirection2 = _interopRequireDefault(_SCNParticleBirthDirection);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _SCNVector3 = __webpack_require__(11);

var _SCNVector4 = _interopRequireDefault(_SCNVector3);

var _SCNOrderedDictionary = __webpack_require__(22);

var _SCNOrderedDictionary2 = _interopRequireDefault(_SCNOrderedDictionary);

var _SCNParticleImageSequenceAnimationMode = __webpack_require__(98);

var _SCNParticleImageSequenceAnimationMode2 = _interopRequireDefault(_SCNParticleImageSequenceAnimationMode);

var _SCNParticleBlendMode = __webpack_require__(97);

var _SCNParticleBlendMode2 = _interopRequireDefault(_SCNParticleBlendMode);

var _SCNParticleOrientationMode = __webpack_require__(99);

var _SCNParticleOrientationMode2 = _interopRequireDefault(_SCNParticleOrientationMode);

var _SCNParticleSortingMode = __webpack_require__(100);

var _SCNParticleSortingMode2 = _interopRequireDefault(_SCNParticleSortingMode);

var _SCNTransaction = __webpack_require__(35);

var _SCNTransaction2 = _interopRequireDefault(_SCNTransaction);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _InstanceOf2 = __webpack_require__(3);

var _InstanceOf3 = _interopRequireDefault(_InstanceOf2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNAnimatable from './SCNAnimatable'
//import SCNGeometry from './SCNGeometry'

//import SCNNode from './SCNNode'

//import SCNParticleEvent from './SCNParticleEvent'
//import SCNParticleEventBlock from './SCNParticleEventBlock'
//import SCNParticlePropertyController from './SCNParticlePropertyController'
//import SCNParticleModifierStage from './SCNParticleModifierStage'
//import SCNParticleModifierBlock from './SCNParticleModifierBlock'


var _ParticleProperty = {
  angle: 'Angle',
  angularVelocity: 'AngularVelocity',
  bounce: 'Bounce',
  charge: 'Charge',
  color: 'Color',
  contactNormal: 'ContactNormal',
  contactPoint: 'ContactPoint',
  frame: 'Frame',
  frameRate: 'FrameRate',
  friction: 'Friction',
  life: 'Life',
  opacity: 'Opacity',
  position: 'Position',
  rotationAxis: 'RotationAxis',
  size: 'Size',
  velocity: 'Velocity'
};

var _Particle = function (_NSObject) {
  _inherits(_Particle, _NSObject);

  /**
   * @access public
   * @constructor
   */
  function _Particle() {
    _classCallCheck(this, _Particle);

    /**
     * @type {SCNVector3}
     */
    var _this = _possibleConstructorReturn(this, (_Particle.__proto__ || Object.getPrototypeOf(_Particle)).call(this));

    _this.position = null;

    /**
     * @type {SCNVector3}
     */
    _this.axis = null;

    /**
     * @type {number}
     */
    _this.angle = 0;

    /**
     * @type {number}
     */
    _this.size = 1;

    _this.baseSize = 1;

    /**
     * @type {SKColor}
     */
    _this.color = null;

    /**
     * @type {SCNVector3}
     */
    _this.velocity = null;

    /**
     * @type {number}
     */
    _this.angularVelocity = 0;

    /**
     * @type {SCNVector3}
     */
    _this.acceleration = null;

    /**
     * @type {number}
     */
    _this.birthTime = 0;

    /**
     * @type {number}
     */
    _this.lifeSpan = 0;

    /**
     * @type {number}
     */
    _this.imageFrameRate = 0;

    /**
     * @type {number}
     */
    _this.initialImageFrame = 0;

    /**
     * @type {number}
     */
    _this.texLeft = 0;

    /**
     * @type {number}
     */
    _this.texRight = 0;

    /**
     * @type {number}
     */
    _this.texTop = 0;

    /**
     * @type {number}
     */
    _this.texBottom = 0;

    _this._maxParticleIndex = 0;
    return _this;
  }

  /**
   * @access public
   * @returns {number[]} -
   */


  _createClass(_Particle, [{
    key: 'floatArray',
    value: function floatArray() {
      var baseArray = [].concat(_toConsumableArray(this.position.floatArray()), _toConsumableArray(this.velocity.floatArray()), _toConsumableArray(this.axis.floatArray()), [this.angle], _toConsumableArray(this.color.floatArray()), [this.size]);
      return [].concat(_toConsumableArray(baseArray), [-1.0, -1.0, this.texLeft, this.texTop], _toConsumableArray(baseArray), [1.0, -1.0, this.texRight, this.texTop], _toConsumableArray(baseArray), [-1.0, 1.0, this.texLeft, this.texBottom], _toConsumableArray(baseArray), [1.0, 1.0, this.texRight, this.texBottom]);
    }
  }, {
    key: 'valueForKeyPath',
    value: function valueForKeyPath(keyPath) {
      if (keyPath === 'size') {
        return this.baseSize;
      }
      return _get(_Particle.prototype.__proto__ || Object.getPrototypeOf(_Particle.prototype), 'valueForKeyPath', this).call(this, keyPath);
    }

    /**
     * @access public
     * @returns {Float32Array} -
     */

  }, {
    key: 'float32Array',
    value: function float32Array() {
      return new Float32Array(this.floatArray());
    }
  }]);

  return _Particle;
}(_NSObject4.default);

/**
 * Manages the animation and rendering of a system of small image sprites, or particles, using a high-level simulation whose general behavior you specify.
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem
 */


var SCNParticleSystem = function (_NSObject2) {
  _inherits(SCNParticleSystem, _NSObject2);

  _createClass(SCNParticleSystem, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        emissionDuration: 'float',
        emissionDurationVariation: 'float',
        idleDuration: 'float',
        idleDurationVariation: 'float',
        loops: 'boolean',
        warmupDuration: 'float',
        birthRate: ['float', '_birthRate'],
        birthRateVariation: 'float',
        emitterShape: 'SCNGeometry',
        birthLocation: 'integer',
        birthDirection: 'integer',
        emittingDirection: 'SCNVector3',
        spreadingAngle: 'float',
        particleAngle: 'float',
        particleAngleVariation: 'float',
        particleVelocity: 'float',
        particleVelocityVariation: 'float',
        particleAngularVelocity: 'float',
        particleAngularVelocityVariation: 'float',
        particleLifeSpan: 'float',
        particleLifeSpanVariation: 'float',
        particleSize: 'float',
        particleSizeVariation: 'float',
        particleColor: 'plist',
        particleColorVariation: 'SCNVector4',
        particleImage: ['NSMutableDictionary', function (obj, dict, key, coder) {
          var path = '';
          if (typeof dict.path !== 'undefined') {
            path = dict.path;
          } else if (typeof dict.URL !== 'undefined') {
            path = dict.URL;
          }
          obj._loadParticleImage(path, coder._directoryPath);
        }],
        fresnelExponent: 'float',
        stretchFactor: 'float',
        imageSequenceRowCount: 'integer',
        imageSequenceColumnCount: 'integer',
        imageSequenceInitialFrame: 'float',
        imageSequenceInitialFrameVariation: 'float',
        imageSequenceFrameRate: 'float',
        imageSequenceFrameRateVariation: 'float',
        imageSequenceAnimationMode: 'integer',
        affectedByGravity: ['boolean', 'isAffectedByGravity'],
        affectedByPhysicsFields: ['boolean', 'isAffectedByPhysicsFields'],
        colliderNodes: 'NSArray',
        particleDiesOnCollision: 'boolean',
        acceleration: 'SCNVector3',
        dampingFactor: 'float',
        particleMass: 'float',
        particleMassVariation: 'float',
        particleCharge: 'float',
        particleChargeVariation: 'float',
        particleBounce: 'float',
        particleBounceVariation: 'float',
        particleFriction: 'float',
        particleFrictionVariation: 'float',
        systemSpawnedOnCollision: 'SCNParticleSystem',
        systemSpawnedOnDying: 'SCNParticleSystem',
        systemSpawnedOnLiving: 'SCNParticleSystem',
        blendMode: 'integer',
        orientationMode: 'integer',
        sortingMode: 'integer',
        lightingEnabled: ['boolean', 'isLightingEnabled'],
        blackPassEnabled: ['boolean', 'isBlackPassEnabled'],
        isLocal: 'boolean',
        speedFactor: 'float',
        propertyControllers: ['NSMutableDictionary', function (obj, dict) {
          Object.keys(_ParticleProperty).forEach(function (key) {
            var d = dict[_ParticleProperty[key]];
            if (typeof d !== 'undefined') {
              d.animation.keyPath = key;
              //console.error(`SCNParticleSystem key: ${key}, ${d.animation.className}`)
              if (key === 'size') {
                d.animation._isMultiplicative = true;
              }
            }
          });
          obj.propertyControllers = dict;
        }],

        seed: ['integer', null],
        softParticlesEnabled: ['boolean', null],
        fixedTimeStep: ['float', null],
        renderingMode: ['integer', null],
        physicsCollisionsEnabled: ['boolean', null],
        orientationDirection: ['SCNVector3', null],
        particleIntensity: ['float', null],
        particleIntensityVariation: ['float', null]
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     * @param {string} name - The name of a particle system file in the app’s bundle resources directory, with or without the .scnp extension.
     * @param {?string} directory - The subdirectory path in the app’s bundle resources directory.
     */

  }]);

  function SCNParticleSystem() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var directory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, SCNParticleSystem);

    // Managing Particle Emission Timing

    /**
     * The duration, in seconds, over which the system spawns new particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523998-emissionduration
     */
    var _this2 = _possibleConstructorReturn(this, (SCNParticleSystem.__proto__ || Object.getPrototypeOf(SCNParticleSystem)).call(this));

    _this2.emissionDuration = 1.0;

    /**
     * The range, in seconds, of randomized emission duration values. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523842-emissiondurationvariation
     */
    _this2.emissionDurationVariation = 0.0;

    /**
     * The duration, in seconds, of periods when the system emits no particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522998-idleduration
     */
    _this2.idleDuration = 0.0;

    /**
     * The range, in seconds, of randomized idle duration values. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523018-idledurationvariation
     */
    _this2.idleDurationVariation = 0.0;

    /**
     * A Boolean value that determines whether the system repeats its emission and idle periods.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522618-loops
     */
    _this2.loops = true;

    /**
     * The duration, in seconds, for which particles are spawned before the system is first rendered. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522597-warmupduration
     */
    _this2.warmupDuration = 0.0;

    /**
     * The number of particles spawned during each emission period. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522857-birthrate
     */
    _this2._birthRate = 0.0;

    /**
     * The range of randomized particle birth rate values. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524147-birthratevariation
     */
    _this2.birthRateVariation = 0.0;

    // Managing Particle Emission Locations

    /**
     * The shape of the region of space where the system spawns new particles.
     * @type {?SCNGeometry}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522737-emittershape
     */
    _this2.emitterShape = null;

    /**
     * The possible locations for newly spawned particles, relative to the emitter shape.
     * @type {SCNParticleBirthLocation}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522899-birthlocation
     */
    _this2.birthLocation = _SCNParticleBirthLocation2.default.surface;

    /**
     * The possible initial directions for newly spawned particles, relative to the emitter shape.
     * @type {SCNParticleBirthDirection}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523361-birthdirection
     */
    _this2.birthDirection = _SCNParticleBirthDirection2.default.constant;

    /**
     * The initial direction for newly spawned particles. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523600-emittingdirection
     */
    _this2.emittingDirection = new _SCNVector2.default(0, 1, 0);

    /**
     * The range, in degrees, of randomized initial particle directions. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522862-spreadingangle
     */
    _this2.spreadingAngle = 0.0;

    // Managing Particle Motion

    /**
     * The rotation angle, in degrees, of newly spawned particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523896-particleangle
     */
    _this2.particleAngle = 0.0;

    /**
     * The range, in degrees of randomized initial particle angles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522828-particleanglevariation
     */
    _this2.particleAngleVariation = 0.0;

    /**
     * The initial speed, in units per second, for newly spawned particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523946-particlevelocity
     */
    _this2.particleVelocity = 0.0;

    /**
     * The range, in units per second, of randomized initial particle speeds. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524157-particlevelocityvariation
     */
    _this2.particleVelocityVariation = 0.0;

    /**
     * The initial spin rate, in degrees per second, of newly spawned particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522757-particleangularvelocity
     */
    _this2.particleAngularVelocity = 0.0;

    /**
     * The range, in degrees per second, of randomized initial angular velocities for particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523590-particleangularvelocityvariation
     */
    _this2.particleAngularVelocityVariation = 0.0;

    /**
     * The duration, in seconds, for which each particle is rendered before being removed from the scene. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523575-particlelifespan
     */
    _this2.particleLifeSpan = 1.0;

    /**
     * The range, in seconds, of randomized particle life spans. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523567-particlelifespanvariation
     */
    _this2.particleLifeSpanVariation = 0.0;

    // Specifying Particle Appearance

    /**
     * The rendered size, in units of the scene’s world coordinate space, of the particle image. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523508-particlesize
     */
    _this2.particleSize = 1.0;

    /**
     * The range of randomized particle sizes. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522716-particlesizevariation
     */
    _this2.particleSizeVariation = 0.0;

    /**
     * The color of newly spawned particles. Animatable.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523248-particlecolor
     */
    _this2.particleColor = _SKColor2.default.white;

    /**
     * The ranges of randomized particle color components. Animatable.
     * @type {SCNVector4}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523639-particlecolorvariation
     */
    _this2.particleColorVariation = new _SCNVector4.default(0, 0, 0, 0);

    /**
     * The texture image SceneKit uses to render each particle.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524153-particleimage
     */
    _this2.particleImage = null;

    /**
     * The reflectivity exponent SceneKit uses when rendering the particle’s image as a cube map. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523317-fresnelexponent
     */
    _this2.fresnelExponent = 0.0;

    /**
     * A multiplier for stretching particle images along their direction of motion. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523338-stretchfactor
     */
    _this2.stretchFactor = 0.0;

    // Animating Particle Images

    /**
     * The number of rows for treating the particle image as a grid of animation frames.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523340-imagesequencerowcount
     */
    _this2.imageSequenceRowCount = 1;

    /**
     * The number of columns for treating the particle image as a grid of animation frames.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523462-imagesequencecolumncount
     */
    _this2.imageSequenceColumnCount = 1;

    /**
     * The index of the first frame in a particle image animation. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523511-imagesequenceinitialframe
     */
    _this2.imageSequenceInitialFrame = 0.0;

    /**
     * The range of randomized initial frames for particle image animation. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523821-imagesequenceinitialframevariati
     */
    _this2.imageSequenceInitialFrameVariation = 0.0;

    /**
     * The rate, in frames per second, of particle image animation. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524075-imagesequenceframerate
     */
    _this2.imageSequenceFrameRate = 0.0;

    /**
     * The range, in frames per second, of randomized frame rates for particle image animation. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523667-imagesequenceframeratevariation
     */
    _this2.imageSequenceFrameRateVariation = 0.0;

    /**
     * The animation mode for particle image animation.
     * @type {SCNParticleImageSequenceAnimationMode}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522816-imagesequenceanimationmode
     */
    _this2.imageSequenceAnimationMode = _SCNParticleImageSequenceAnimationMode2.default.repeat;

    // Simulating Physics for Particles

    /**
     * A Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523452-isaffectedbygravity
     */
    _this2.isAffectedByGravity = false;

    /**
     * A Boolean value that determines whether physics fields in the scene affect the motion of particles.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523353-isaffectedbyphysicsfields
     */
    _this2.isAffectedByPhysicsFields = false;

    /**
     * The nodes whose geometry the system’s particles can collide with.
     * @type {?SCNNode[]}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523516-collidernodes
     */
    _this2.colliderNodes = null;

    /**
     * A Boolean value that determines whether particles are removed from the scene upon colliding with another object.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523357-particlediesoncollision
     */
    _this2.particleDiesOnCollision = false;

    /**
     * The constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522766-acceleration
     */
    _this2.acceleration = new _SCNVector2.default(0, 0, 0);

    /**
     * A factor that slows particles relative to their velocity. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522931-dampingfactor
     */
    _this2.dampingFactor = 0.0;

    /**
     * The mass, in kilograms, of each particle in the system. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522607-particlemass
     */
    _this2.particleMass = 1.0;

    /**
     * The range, in kilograms, of randomized particle masses. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523408-particlemassvariation
     */
    _this2.particleMassVariation = 0.0;

    /**
     * The electric charge, in coulombs, of each particle in the system. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523156-particlecharge
     */
    _this2.particleCharge = 0.0;

    /**
     * The range, in coulombs, of randomized particle charges. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523377-particlechargevariation
     */
    _this2.particleChargeVariation = 0.0;

    /**
     * The restitution coefficient of each particle in the system. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522637-particlebounce
     */
    _this2.particleBounce = 0.7;

    /**
     * The range of randomized restitution coefficients for particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522662-particlebouncevariation
     */
    _this2.particleBounceVariation = 0.0;

    /**
     * The friction coefficient of each particle in the system. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524010-particlefriction
     */
    _this2.particleFriction = 1.0;

    /**
     * The range of randomized friction coefficients for particles. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522868-particlefrictionvariation
     */
    _this2.particleFrictionVariation = 0.0;

    // Spawning Additional Particle Systems

    /**
     * Another particle system to be added to the scene when a particle collides with scene geometry.
     * @type {?SCNParticleSystem}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524068-systemspawnedoncollision
     */
    _this2.systemSpawnedOnCollision = null;

    /**
     * Another particle system to be added to the scene when a particle dies.
     * @type {?SCNParticleSystem}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524091-systemspawnedondying
     */
    _this2.systemSpawnedOnDying = null;

    /**
     * Another particle system to be added to the scene for each living particle in the system.
     * @type {?SCNParticleSystem}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522751-systemspawnedonliving
     */
    _this2.systemSpawnedOnLiving = null;

    // Managing Particle Rendering

    /**
     * The blending mode for compositing particle images into the rendered scene.
     * @type {SCNParticleBlendMode}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523728-blendmode
     */
    _this2.blendMode = _SCNParticleBlendMode2.default.additive;

    /**
     * The mode defining whether and how particles may rotate.
     * @type {SCNParticleOrientationMode}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523131-orientationmode
     */
    _this2.orientationMode = _SCNParticleOrientationMode2.default.billboardScreenAligned;

    /**
     * The mode defining the order in which SceneKit renders the system’s particles.
     * @type {SCNParticleSortingMode}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522795-sortingmode
     */
    _this2.sortingMode = _SCNParticleSortingMode2.default.none;

    /**
     * A Boolean value that determines whether SceneKit applies lighting to particle images when rendering.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522794-islightingenabled
     */
    _this2.isLightingEnabled = false;

    /**
     * A Boolean value that determines whether SceneKit renders particles in black before rendering the particle image.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523901-isblackpassenabled
     */
    _this2.isBlackPassEnabled = false;

    // Controlling Particle Simulation

    /**
     * A Boolean value that specifies whether the particle simulation runs in the local coordinate space of the node containing it.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522855-islocal
     */
    _this2.isLocal = false;

    /**
     * A multiplier for the speed at which SceneKit runs the particle simulation. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522988-speedfactor
     */
    _this2.speedFactor = 1.0;

    // Modifying Particles Over Time

    /**
     * A dictionary that optionally associates particle properties with objects that animate a property’s value for each particle.
     * @type {?Map<SCNParticleSystem.ParticleProperty, SCNParticlePropertyController>}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522775-propertycontrollers
     */
    _this2.propertyControllers = null;

    _this2._program = null;
    _this2._vertexArray = null;
    _this2._vertexBuffer = null;
    _this2._indexBuffer = null;
    _this2._particles = [];
    _this2._glIndexSize = null;
    _this2._particleTexture = null;

    _this2._finished = false;
    _this2._startTime = null;
    _this2._prevTime = 0;
    _this2._nextBirthTime = 0;
    _this2._emissionEndTime = 0;
    _this2._idleEndTime = 0;
    _this2._numImages = null;
    _this2._imageWidth = null;
    _this2._imageHeight = null;

    _this2.__presentation = null;

    ///////////////////
    // SCNAnimatable //
    ///////////////////

    /**
     * @access private
     * @type {SCNOrderedDictionary}
     */
    _this2._animations = new _SCNOrderedDictionary2.default();

    /**
     * @access private
     * @type {Promise}
     */
    _this2._loadedPromise = null;
    return _this2;
  }

  // Creating a Particle System

  /**
   * Loads a particle system from a file in the app’s bundle resources.
   * @access public
   * @param {string} name - The name of a particle system file in the app’s bundle resources directory, with or without the .scnp extension.
   * @param {?string} directory - The subdirectory path in the app’s bundle resources directory.
   * @returns {void}
   * @desc A SceneKit particle file created by Xcode contains an archived SCNParticleSystem instance, so you can also use the NSKeyedArchiver and NSKeyedUnarchiver classes to write and read particle files.
   * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522772-init
   */


  _createClass(SCNParticleSystem, [{
    key: 'reset',


    // Controlling Particle Simulation

    /**
     * Returns the particle system to its initial state.
     * @access public
     * @returns {void}
     * @desc Calling this method removes all currently live particles from the scene.
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522968-reset
     */
    value: function reset() {
      this._finished = false;
      this._startTime = null;
      this._prevTime = 0;
      this._nextBirthTime = 0;
      this._emissionEndTime = 0;
      this._idleEndTime = 0;

      this._particles = [];
    }

    // Modifying Particles in Response to Particle System Events

    /**
     * Adds a block that modifies particle properties, to be executed at a specified event in the lifetimes of particles in the system.
     * @access public
     * @param {SCNParticleEvent} event - The event at which to call the block. See SCNParticleEvent for allowed values.
     * @param {SCNParticleSystem.ParticleProperty[]} properties - An array containing one or more of the constants listed in Particle Property Keys, each of which specifies a property of the appearance or behaviors of particles in the particle system.
     * @param {SCNParticleEventBlock} block - A SCNParticleEventBlock block to be called every time SceneKit renders a frame. In this block you can modify the properties of particles in the system.
     * @returns {void}
     * @desc By associating a block with one or more particle properties, you can run arbitrary code that modifies those properties when a significant event in the particle simulation occurs for one or more particles. For example, you can use the following code with a confetti effect to randomly switch between two distinct colors for each spawned particle:[system handleEvent:SCNParticleEventBirth
        forProperties:@[SCNParticlePropertyColor]
            withBlock:^(void **data, size_t *dataStride, uint32_t *indices , NSInteger count) {
                for (NSInteger i = 0; i < count; ++i) {
                    float *color = (float *)((char *)data[0] + dataStride[0] * i);
                    if (rand() & 0x1) { // Switch the green and red color components.
                        color[0] = color[1];
                        color[1] = 0;
                    }
                }
            }];
    [system handleEvent:SCNParticleEventBirth
        forProperties:@[SCNParticlePropertyColor]
            withBlock:^(void **data, size_t *dataStride, uint32_t *indices , NSInteger count) {
                for (NSInteger i = 0; i < count; ++i) {
                    float *color = (float *)((char *)data[0] + dataStride[0] * i);
                    if (rand() & 0x1) { // Switch the green and red color components.
                        color[0] = color[1];
                        color[1] = 0;
                    }
                }
            }];
      * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523251-handle
     */

  }, {
    key: 'handleForPropertiesHandler',
    value: function handleForPropertiesHandler(event, properties, block) {}

    // Modifying Particles Over Time

    /**
     * Adds a block that modifies particle properties, to be executed each time SceneKit renders a frame.
     * @access public
     * @param {SCNParticleSystem.ParticleProperty[]} properties - An array containing one or more of the constants listed in Particle Property Keys, each of which specifies a property of the appearance or behaviors of particles in the particle system.
     * @param {SCNParticleModifierStage} stage - The stage of SceneKit’s particle simulation during which to call the block. See SCNParticleModifierStage for allowed values.
     * @param {SCNParticleModifierBlock} block - A SCNParticleModifierBlock block to be called every time SceneKit renders a frame. In this block you can modify the properties of all particles in the system.
     * @returns {void}
     * @desc By associating a block with one or more particle properties, you can run arbitrary code that modifies those properties during each frame of animation. This option provides maximum flexibility for changing the appearance or behavior of particles over time. ImportantRunning your own code to update particle properties every frame can have a severe impact on rendering performance. If the behavior over time that you want for your particle system can be described more declaratively, use the propertyControllers property and SCNParticlePropertyController class instead. If you need to change particle properties only at certain times (rather than continuously), add a handler block for an event using the handle(_:forProperties:handler:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522635-addmodifier
     */

  }, {
    key: 'addModifierForPropertiesAtModifier',
    value: function addModifierForPropertiesAtModifier(properties, stage, block) {}

    /**
     * Removes particle modifier blocks for the specified stage of the particle simulation.
     * @access public
     * @param {SCNParticleModifierStage} stage - The stage of SceneKit’s particle simulation during which to call the block. See SCNParticleModifierStage for allowed values.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1524077-removemodifiers
     */

  }, {
    key: 'removeModifiersAt',
    value: function removeModifiersAt(stage) {}

    /**
     * Removes all particle modifier blocks associated with the particle system.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1523614-removeallmodifiers
     */

  }, {
    key: 'removeAllModifiers',
    value: function removeAllModifiers() {}

    // Structures
    /**
     * @type {Object} ParticleProperty
     * @property {string} angle The rotation angle, in radians, of the particle about its axis.
     * @property {string} angularVelocity The particle’s angular velocity (or rate of spin), in radians per second.
     * @property {string} bounce The particle’s restitution coefficient.
     * @property {string} charge The particle’s electric charge, in coulombs.
     * @property {string} color The particle’s tint color, as a vector of red, green, blue, and alpha component values.
     * @property {string} contactNormal The normal vector, in scene coordinate space, of a collision between a particle and a geometry in the scene.
     * @property {string} contactPoint The location, in scene coordinate space, of a collision between a particle and a geometry in the scene.
     * @property {string} frame The current frame index of the particle’s image animation.
     * @property {string} frameRate The rate, in frames per second, of the particle’s image animation.
     * @property {string} friction The particle’s friction coefficient.
     * @property {string} life The remaining time in the particle’s life span, in seconds.
     * @property {string} opacity The particle’s opacity (or alpha value).
     * @property {string} position The particle’s position vector in scene coordinate space.
     * @property {string} rotationAxis The particle’s axis of rotation, expressed as a vector in the particle’s local coordinate space.
     * @property {string} size The width and height of the rendered particle image, in units of scene coordinate space.
     * @property {string} velocity The particle’s velocity vector in units (of scene coordinate space) per second.
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem.particleproperty
     */

  }, {
    key: '_loadParticleImage',


    /**
     * @access private
     * @param {string} path -
     * @param {string} directoryPath -
     * @returns {Image} -
     */
    value: function _loadParticleImage(path, directoryPath) {
      var _this3 = this;

      var image = new Image();
      var __path = path;
      if (__path.indexOf('file:///') === 0) {
        __path = __path.slice(8);
      }
      // TODO: load OpenEXR File
      __path = __path.replace(/\.exr$/, '.png');

      this._loadedPromise = new Promise(function (resolve, reject) {
        var paths = __path.split('/');
        var pathCount = 1;
        var _path = directoryPath + paths.slice(-pathCount).join('/');
        image.onload = function () {
          _this3.particleImage = image;
          resolve();
        };
        image.onerror = function () {
          pathCount += 1;
          if (pathCount > paths.length) {
            // try the root path
            image.onerror = function () {
              // give up
              reject();
            };
            image.src = __path;
          } else {
            // retry
            _path = directoryPath + paths.slice(-pathCount).join('/');
            image.src = _path;
          }
        };
        image.src = _path;
      });
      return image;
    }
  }, {
    key: '_initializeVAO',
    value: function _initializeVAO(gl, program) {
      if (this._vertexArray !== null) {
        return;
      }
      this._vertexArray = gl.createVertexArray();
      gl.bindVertexArray(this._vertexArray);

      this._vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer

      // prepare vertex array data
      // TODO: retain attribute locations
      );var positionLoc = gl.getAttribLocation(program, 'position');
      var velocityLoc = gl.getAttribLocation(program, 'velocity');
      var rotationLoc = gl.getAttribLocation(program, 'rotation');
      var colorLoc = gl.getAttribLocation(program, 'color');
      var sizeLoc = gl.getAttribLocation(program, 'size'
      //const lifeLoc = gl.getAttribLocation(program, 'life')
      );var cornerLoc = gl.getAttribLocation(program, 'corner');
      var texcoordLoc = gl.getAttribLocation(program, 'texcoord'

      // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)
      );var stride = 76;
      gl.enableVertexAttribArray(positionLoc);
      gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, stride, 0);
      gl.enableVertexAttribArray(velocityLoc);
      gl.vertexAttribPointer(velocityLoc, 3, gl.FLOAT, false, stride, 12);
      gl.enableVertexAttribArray(rotationLoc);
      gl.vertexAttribPointer(rotationLoc, 4, gl.FLOAT, false, stride, 24);
      gl.enableVertexAttribArray(colorLoc);
      gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, stride, 40);
      gl.enableVertexAttribArray(sizeLoc);
      gl.vertexAttribPointer(sizeLoc, 1, gl.FLOAT, false, stride, 56);
      gl.enableVertexAttribArray(cornerLoc);
      gl.vertexAttribPointer(cornerLoc, 2, gl.FLOAT, false, stride, 60);
      gl.enableVertexAttribArray(texcoordLoc);
      gl.vertexAttribPointer(texcoordLoc, 2, gl.FLOAT, false, stride, 68

      /*
      const arr = []
      this._particles.forEach((particle) => {
        arr.push(...particle.floatArray())
      })
      const particleData = new Float32Array(arr)
      gl.bufferData(gl.ARRAY_BUFFER, particleData, gl.DYNAMIC_DRAW)
      */

      );var len = this._maxParticles + 5;
      this._updateIndexBuffer(gl, len

      // initialize parameters
      );this._numImages = this.imageSequenceRowCount * this.imageSequenceColumnCount;
      this._imageWidth = 1.0 / this.imageSequenceColumnCount;
      this._imageHeight = 1.0 / this.imageSequenceRowCount;
    }
  }, {
    key: '_updateIndexBuffer',
    value: function _updateIndexBuffer(context, length) {
      var gl = context;
      var indexData = [];
      var index = 0;
      for (var i = 0; i < length; i++) {
        indexData.push(index + 0);
        indexData.push(index + 3);
        indexData.push(index + 2);
        indexData.push(index + 0);
        indexData.push(index + 1);
        indexData.push(index + 3);
        index += 4;
      }
      var glIndexData = null;
      if (index < 256) {
        glIndexData = new Uint8Array(indexData);
        this._glIndexSize = gl.UNSIGNED_BYTE;
      } else if (index < 65536) {
        glIndexData = new Uint16Array(indexData);
        this._glIndexSize = gl.UNSIGNED_SHORT;
      } else {
        glIndexData = new Uint32Array(indexData);
        this._glIndexSize = gl.UNSIGNED_INT;
      }

      if (this._indexBuffer === null) {
        this._indexBuffer = gl.createBuffer();
      }
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, glIndexData, gl.STATIC_DRAW);

      this._maxParticleIndex = length;
    }

    /**
     * @access private
     * @param {number} birthTime -
     * @param {SCNVector3} position -
     * @param {SCNVector4} orientation -
     * @returns {_Particle} -
     */
    //_createParticle(birthTime, position, orientation) {

  }, {
    key: '_createParticle',
    value: function _createParticle(birthTime, transform) {
      var p = new _Particle();

      var position = transform.getTranslation();
      var velocity = this.particleVelocity + this.particleVelocityVariation * (Math.random() - 0.5);
      var spreadingAngle = this.spreadingAngle / 180.0 * Math.PI * Math.random();
      var spreadingAngleRot = 2.0 * Math.PI * Math.random();
      var angleMat = _SCNMatrix2.default.matrixWithRotation(this._normal.x, this._normal.y, this._normal.z, spreadingAngle);
      var rotMat = _SCNMatrix2.default.matrixWithRotation(this._direction.x, this._direction.y, this._direction.z, spreadingAngleRot

      // emitterShape, birthLocation, emittingDirection, spreadingAngle, particleAngle/Variation, particleVelocity
      );if (this.emitterShape === null) {
        p.position = position;
        p.velocity = new _SCNVector2.default(0, 0, velocity); // TODO: use spreadingAngle
      } else if (this.birthLocation === _SCNParticleBirthLocation2.default.surface) {
        var pVec = null;
        var vVec = null;
        switch (this.emitterShape.className) {
          case 'SCNBox':
            {
              var rnd = Math.random();
              var rnd1 = Math.random() - 0.5;
              var rnd2 = Math.random() - 0.5;
              var w = this.emitterShape.width;
              var h = this.emitterShape.height;
              var l = this.emitterShape.length;
              var rx = h * l;
              var ry = l * w;
              var rz = w * h;
              var r = 1.0 / (rx + ry + rz);
              var tx = rx * r;
              var ty = ry * r;
              var tz = rz * r;

              // TODO: chamferRadius
              if (rnd < tx * 0.5) {
                // right
                pVec = new _SCNVector2.default(w * 0.5, h * rnd1, l * rnd2);
                vVec = new _SCNVector2.default(1, 0, 0);
              } else if (rnd < tx) {
                // left
                pVec = new _SCNVector2.default(-w * 0.5, h * rnd1, l * rnd2);
                vVec = new _SCNVector2.default(-1, 0, 0);
              } else if (rnd < tx + ty * 0.5) {
                // top
                pVec = new _SCNVector2.default(w * rnd1, h * 0.5, l * rnd2);
                vVec = new _SCNVector2.default(0, 1, 0);
              } else if (rnd < tx + ty) {
                // bottom
                pVec = new _SCNVector2.default(w * rnd1, -h * 0.5, l * rnd2);
                vVec = new _SCNVector2.default(0, -1, 0);
              } else if (rnd < tx + ty + tz * 0.5) {
                // front
                pVec = new _SCNVector2.default(w * rnd1, h * rnd2, l * 0.5);
                vVec = new _SCNVector2.default(0, 0, 1);
              } else {
                // back
                pVec = new _SCNVector2.default(w * rnd1, h * rnd2, -l * 0.5);
                vVec = new _SCNVector2.default(0, 0, -1);
              }
              break;
            }
          case 'SCNSphere':
            {
              var v = new _SCNVector2.default(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
              pVec = v.mul(this.emitterShape.radius);
              vVec = v;
              break;
            }
          case 'SCNPlane':
            {
              pVec = new _SCNVector2.default((Math.random() - 0.5) * this.emitterShape.width, (Math.random() - 0.5) * this.emitterShape.height, 0.0);
              vVec = new _SCNVector2.default(0, 0, 1);
              break;
            }
          case 'SCNCylinder':
            {
              var y = (Math.random() - 0.5) * this.emitterShape.height;
              var _r = Math.random() * Math.PI * 2.0;
              var x = Math.sin(_r);
              var z = Math.cos(_r);
              pVec = new _SCNVector2.default(x * this.emitterShape.radius, y, z * this.emitterShape.radius);
              vVec = new _SCNVector2.default(x, 0, z);
              break;
            }
          case 'SCNGeometry':
            {
              var element = this.emitterShape.geometryElementAtIndex(0);
              var vertexSrc = this.emitterShape.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
              var normalSrc = this.emitterShape.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];

              var elemIndex = Math.floor(Math.random() * element.primitiveCount);
              var indices = element._indexAt(elemIndex);
              var vertices = indices.map(function (index) {
                return vertexSrc._scnVectorAt(index);
              });
              var normals = indices.map(function (index) {
                return normalSrc._scnVectorAt(index);
              });

              var pos = vertices[0].add(vertices[1]).add(vertices[2]).mul(1 / 3);
              var nom = normals[0].add(normals[1]).add(normals[2]).normalize();

              pVec = pos;
              vVec = nom;
              break;
            }
          default:
            // TODO: implement
            throw new Error('surface emitter for ' + this.emitterShape.className + ' is not implemented');
        }
        pVec = pVec.rotate(transform);
        p.position = position.add(pVec);
        if (this.birthDirection === _SCNParticleBirthDirection2.default.surfaceNormal) {
          p.velocity = vVec.rotate(transform).normalize().mul(velocity);
        }
      } else if (this.birthLocation === _SCNParticleBirthLocation2.default.volume) {
        var _pVec = null;
        switch (this.emitterShape.className) {
          case 'SCNBox':
            {
              var _x3 = (Math.random() - 0.5) * this.emitterShape.width;
              var _y = (Math.random() - 0.5) * this.emitterShape.height;
              var _z = (Math.random() - 0.5) * this.emitterShape.length;
              _pVec = new _SCNVector2.default(_x3, _y, _z);
              break;
            }
          case 'SCNSphere':
            {
              var _r2 = Math.random() * this.emitterShape.radius;
              var s = Math.random() * Math.PI;
              var t = Math.random() * Math.PI * 2.0;
              var rsins = _r2 * Math.sin(s);
              var _x4 = rsins * Math.cos(t);
              var _y2 = rsins * Math.sin(t);
              var _z2 = _r2 * Math.cos(s);
              _pVec = new _SCNVector2.default(_x4, _y2, _z2);
              break;
            }
          default:
            // TODO: implement
            throw new Error('volume emitter for ' + this.emitterShape.className + ' is not implemented');
        }
        _pVec = _pVec.rotate(transform);
        p.position = position.add(_pVec);
        if (this.birthDirection === _SCNParticleBirthDirection2.default.surfaceNormal) {
          throw new Error('combination of birthLocation=volume and birthDirection=surfaceNormal is not implemented.');
        }
      } else {
        // TODO: implement
        throw new Error('birthLocation ' + this.birthLocation + ' is not implemented.');
      }

      if (this.orientationMode === _SCNParticleOrientationMode2.default.billboardScreenAligned) {
        p.axis = new _SCNVector2.default(0, 0, 1);
      } else {
        p.axis = new _SCNVector2.default(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
      }
      p.angle = (this.particleAngle + this.particleAngleVariation * (Math.random() - 0.5)) / 180.0 * Math.PI;
      p.size = this.particleSize + this.particleSizeVariation * (Math.random() - 0.5);
      p.baseSize = p.size;
      p.color = this._createColor();

      switch (this.birthDirection) {
        case _SCNParticleBirthDirection2.default.constant:
          {
            p.velocity = this._direction.rotate(angleMat).rotate(rotMat).rotate(transform).mul(velocity);
            break;
          }
        case _SCNParticleBirthDirection2.default.surfaceNormal:
          {
            break;
          }
        case _SCNParticleBirthDirection2.default.random:
          {
            var rndAngle = 2.0 * Math.PI * Math.random();
            var rndMat = _SCNMatrix2.default.matrixWithRotation(this._normal.x, this._normal.y, this._normal.z, rndAngle);
            p.velocity = this._direction.rotate(rndMat).rotate(rotMat).rotate(transform).mul(velocity);
            break;
          }
        default:
          {
            throw new Error('unknown birth direction: ' + this.birthDirection);
          }
      }
      p.angularVelocity = (this.particleAngularVelocity + this.particleAngularVelocityVariation * (Math.random() - 0.5)) / 180.0 * Math.PI;
      p.acceleration = this.acceleration._copy();
      p.birthTime = birthTime;
      p.lifeSpan = this.particleLifeSpan + this.particleLifeSpanVariation * (Math.random() * 2.0 - 1.0);

      p.imageFrameRate = this.imageSequenceFrameRate + this.imageSequenceFrameRateVariation * (Math.random() - 0.5);
      if (p.imageFrameRate < 0) {
        p.imageFrameRate = 0;
      }

      var numImages = this.imageSequenceRowCount * this.imageSequenceColumnCount;
      p.initialImageFrame = (this.imageSequenceInitialFrame + this.imageSequenceInitialFrameVariation * (Math.random() - 0.5)) % numImages;
      if (p.initialImageFrame < 0) {
        p.initialImageFrame += numImages;
      }

      return p;
    }

    /**
     * @access private
     * @param {SCNMatrix4} transform -
     * @param {?SCNVector3} gravity -
     * @param {number} currentTime -
     * @returns {void}
     */

  }, {
    key: '_updateParticles',
    value: function _updateParticles(transform, gravity, currentTime) {
      var _this4 = this;

      if (this._prevTime <= 0) {
        this._prevTime = currentTime;
        this._nextBirthTime = currentTime;
        this._startTime = currentTime;

        this._direction = this.emittingDirection.normalize();
        var u = new _SCNVector2.default(this._direction.z, this._direction.x, this._direction.y);
        this._normal = this._direction.cross(u);

        this._updateEndTime();
      }

      // generate particles
      if (this._presentation._birthRate + this.birthRateVariation > 0) {
        while (this._nextBirthTime <= currentTime) {
          var p = this._createParticle(this._nextBirthTime, transform);
          this._particles.push(p);
          var rate = this._presentation._birthRate + this.birthRateVariation * (Math.random() - 0.5);
          if (rate < 0.0000001) {
            rate = 0.0000001;
          }
          this._nextBirthTime += 1.0 / rate;
          if (this._nextBirthTime > this._emissionEndTime) {
            this._nextBirthTime = this._idleEndTime;
            if (!this.loops) {
              this._finished = true;
            }
            this._updateEndTime();
          }
        }
      }

      var dt = (currentTime - this._prevTime) * this.speedFactor;
      var damping = 1;
      if (this.dampingFactor > 0) {
        damping = Math.pow((100 - this.dampingFactor) * 0.01, dt * 60.0);
      }

      this._particles.forEach(function (p) {
        var _dt = dt;
        var pdt = (currentTime - p.birthTime) * _this4.speedFactor;
        if (p.birthTime > _this4._prevTime) {
          _dt = pdt;
        }
        var t = pdt / p.lifeSpan;
        p.life = t;
        if (t > 1) {
          return;
        }
        var acceleration = p.acceleration;
        if (gravity !== null && _this4.isAffectedByGravity) {
          acceleration = acceleration.add(gravity);
        }
        //p.position.x += (0.5 * acceleration.x * dt + p.velocity.x) * dt
        //p.position.y += (0.5 * acceleration.y * dt + p.velocity.y) * dt
        //p.position.z += (0.5 * acceleration.z * dt + p.velocity.z) * dt
        //p.velocity.x += acceleration.x * dt
        //p.velocity.y += acceleration.y * dt
        //p.velocity.z += acceleration.z * dt
        p.angle += p.angularVelocity * _dt;
        p.velocity.x = (p.velocity.x + acceleration.x * _dt) * damping;
        p.velocity.y = (p.velocity.y + acceleration.y * _dt) * damping;
        p.velocity.z = (p.velocity.z + acceleration.z * _dt) * damping;
        p.position.x += p.velocity.x * _dt;
        p.position.y += p.velocity.y * _dt;
        p.position.z += p.velocity.z * _dt;
        if (_this4.propertyControllers !== null) {
          Object.keys(_this4.propertyControllers).forEach(function (key) {
            _this4.propertyControllers[key].animation._applyAnimation(p, t, false // should I use p.life instead of t?
            );
          });
        }

        var frame = p.initialImageFrame + p.imageFrameRate * pdt;
        var imageFrame = 0;
        switch (_this4.imageSequenceAnimationMode) {
          case _SCNParticleImageSequenceAnimationMode2.default.repeat:
            {
              imageFrame = Math.floor(frame % _this4._numImages);
              break;
            }
          case _SCNParticleImageSequenceAnimationMode2.default.clamp:
            {
              var fr = Math.floor(frame % _this4._numImages);
              if (fr >= _this4._numImages - 1) {
                imageFrame = _this4._numImages - 1;
              } else {
                imageFrame = fr;
              }
              break;
            }
          case _SCNParticleImageSequenceAnimationMode2.default.autoReverse:
            {
              var _fr = Math.floor(frame % (_this4._numImages * 2 - 2));
              if (_fr >= _this4._numImages) {
                _fr = _this4._numImages * 2 - 2 - _fr;
              }
              imageFrame = _fr;
              break;
            }
          default:
            throw new Error('unknown SCNParticleImageSequenceAnimationMode: ' + _this4.imageSequenceAnimationMode);
        }
        var imageY = Math.floor(imageFrame / _this4.imageSequenceRowCount);
        var imageX = imageFrame % _this4.imageSequenceColumnCount;

        p.texLeft = imageX * _this4._imageWidth;
        p.texTop = (imageY + 1) * _this4._imageHeight;
        p.texRight = (imageX + 1) * _this4._imageWidth;
        p.texBottom = imageY * _this4._imageHeight;
      });
      this._particles = this._particles.filter(function (p) {
        return p.life <= 1;
      });
      this._prevTime = currentTime;
    }
  }, {
    key: '_updateEndTime',
    value: function _updateEndTime() {
      var startTime = this._idleEndTime === 0 ? this._startTime : this._idleEndTime;
      var emissionDuration = this.emissionDuration + (Math.random() - 0.5) * this.emissionDurationVariation;
      if (emissionDuration < 0) {
        emissionDuration = 0;
      }
      this._emissionEndTime = startTime + emissionDuration;

      var idleDuration = this.idleDuration + (Math.random() - 0.5) * this.idleDurationVariation;
      if (idleDuration < 0) {
        idleDuration = 0;
      }
      this._idleEndTime = this._emissionEndTime + idleDuration;
    }

    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @param {WebGLProgram} program -
     * @returns {void}
     */

  }, {
    key: '_bufferMaterialData',
    value: function _bufferMaterialData(gl, program) {
      // particleTexture
      if (this._particleTexture === null && this.particleImage !== null) {
        this._particleTexture = this._createTexture(gl, this.particleImage);
      }
      if (this._particleTexture !== null) {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._particleTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      }

      gl.uniform1i(gl.getUniformLocation(program, 'orientationMode'), this.orientationMode);
      gl.uniform1f(gl.getUniformLocation(program, 'stretchFactor'), this.stretchFactor

      // buffer particle data
      );gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, this._particleData, gl.DYNAMIC_DRAW);

      if (this._particles.length > this._maxParticleIndex) {
        this._updateIndexBuffer(gl, this._particles.length + 10);
      }

      var blendFuncSrc = [gl.ONE, // additive
      gl.ZERO, // subtract
      gl.ZERO, // multiply
      gl.SRC_ALPHA, // screen
      gl.SRC_ALPHA, // alpha
      gl.ONE // replace
      ];
      var blendFuncDst = [gl.ONE, // additive
      gl.ONE_MINUS_SRC_COLOR, // subtract
      gl.SRC_COLOR, // multiply
      gl.ONE, // screen
      gl.ONE_MINUS_SRC_ALPHA, // alpha
      gl.ZERO // replace
      ];
      gl.blendFunc(blendFuncSrc[this.blendMode], blendFuncDst[this.blendMode]);
    }
  }, {
    key: '_createTexture',
    value: function _createTexture(gl, image) {
      var texture = gl.createTexture();

      var canvas = document.createElement('canvas');
      canvas.width = image.naturalWidth;
      canvas.height = image.naturalHeight;
      //console.warn(`image size: ${image.naturalWidth} ${image.naturalHeight}`)
      canvas.getContext('2d').drawImage(image, 0, 0);

      gl.bindTexture(gl.TEXTURE_2D, texture
      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
      // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
      );gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.bindTexture(gl.TEXTURE_2D, null);

      return texture;
    }

    /**
     * @access private
     * @returns {SKColor} -
     */

  }, {
    key: '_createColor',
    value: function _createColor() {
      var hsb = this._rgb2hsb(this.particleColor

      // Hue
      //hsb.x = (hsb.x + this.particleColorVariation.x * (Math.random() - 0.5)) % 360.0
      );hsb.x = (hsb.x + this.particleColorVariation.x * (Math.random() * 2.0 - 1.0)) % 360.0;
      if (hsb.x < 0) {
        hsb.x += 360.0;
      }

      // Saturation
      hsb.y = Math.max(0, Math.min(1.0, hsb.y + this.particleColorVariation.y * (Math.random() - 0.5))

      // Brightness
      );hsb.z = Math.max(0, Math.min(1.0, hsb.z + this.particleColorVariation.z * (Math.random() - 0.5))

      // Alpha
      );hsb.w = Math.max(0, Math.min(1.0, hsb.w + this.particleColorVariation.w * (Math.random() - 0.5)));

      return this._hsb2rgb(hsb);
    }

    /**
     * @access private
     * @param {SKColor} rgb -
     * @returns {SCNVector4} -
     */

  }, {
    key: '_rgb2hsb',
    value: function _rgb2hsb(rgb) {
      var hsb = new _SCNVector4.default();
      var min = Math.min(rgb.red, Math.min(rgb.green, rgb.blue));
      var max = Math.max(rgb.red, Math.max(rgb.green, rgb.blue));
      var delta = max - min;
      hsb.w = rgb.alpha;
      hsb.z = max;

      if (hsb.z === 0) {
        hsb.x = 0;
        hsb.y = 0;
        return hsb;
      }

      hsb.y = delta / max;
      if (hsb.y === 0) {
        hsb.x = 0;
        return hsb;
      }

      if (max === rgb.red) {
        hsb.x = (60.0 * (rgb.green - rgb.blue) / delta + 360.0) % 360.0;
      } else if (max === rgb.green) {
        hsb.x = 60.0 * (rgb.blue - rgb.red) / delta + 120.0;
      } else {
        hsb.x = 60.0 * (rgb.red - rgb.green) / delta + 240.0;
      }

      return hsb;
    }

    /**
     * @access private
     * @param {SCNVector4} hsb -
     * @returns {SKColor} -
     */

  }, {
    key: '_hsb2rgb',
    value: function _hsb2rgb(hsb) {
      //const rgb = new SKColor(0, 0, 0, hsb.w)

      if (hsb.y === 0) {
        //rgb.red = hsb.z
        //rgb.green = hsb.z
        //rgb.blue = hsb.z
        return new _SKColor2.default(hsb.z, hsb.z, hsb.z, hsb.w);
      }

      var region = Math.floor(hsb.x / 60.0
      /*
      const c = hsb.z * hsb.y
      const x = c * (region % 2)
      const m = hsb.z - c
       let r = 0
      let g = 0
      let b = 0
      switch(region){
        case 0:
          r = c
          g = x
          break
        case 1:
          r = x
          g = c
          break
        case 2:
          g = c
          b = x
          break
        case 3:
          g = x
          b = c
          break
        case 4:
          r = x
          b = c
          break
        default:
          r = c
          b = x
          break
      }
      rgb.red = r + m
      rgb.green = g + m
      rgb.blue = b + m
      
      return rgb
      */
      );var v = hsb.z;
      var f = hsb.x / 60.0 - region;
      var m = v * (1.0 - hsb.y);
      var n = v * (1.0 - hsb.y * f);
      var k = v * (1.0 - hsb.y * (1.0 - f));
      switch (region) {
        case 0:
          return new _SKColor2.default(v, k, m, hsb.w);
        case 1:
          return new _SKColor2.default(n, v, m, hsb.w);
        case 2:
          return new _SKColor2.default(m, v, k, hsb.w);
        case 3:
          return new _SKColor2.default(m, n, v, hsb.w);
        case 4:
          return new _SKColor2.default(k, m, v, hsb.w);
        default:
          return new _SKColor2.default(v, m, n, hsb.w);
      }
    }
  }, {
    key: '_copy',
    value: function _copy() {
      var s = new SCNParticleSystem();
      var params = ['_birthRate'
      // TODO: add other parameters... 
      ];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var param = _step.value;

          s[param] = this[param];
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return s;
    }
  }, {
    key: '_createPresentation',
    value: function _createPresentation() {
      if (this.__presentation) {
        return this.__presentation;
      }
      var s = this._copy();
      this.__presentation = s;
      return s;
    }

    /// Animatable parameters

    /**
     * The number of particles spawned during each emission period. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnparticlesystem/1522857-birthrate
     */

  }, {
    key: 'addAnimationForKey',


    ///////////////////
    // SCNAnimatable //
    ///////////////////

    // Managing Animations

    /**
     * Required. Adds an animation object for the specified key.
     * @access public
     * @param {CAAnimation} animation - The animation object to be added.
     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
     * @returns {void}
     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523386-addanimation
     */
    value: function addAnimationForKey(animation, key) {
      if (typeof key === 'undefined' || key === null) {
        key = Symbol();
      }
      var anim = animation.copy
      // FIXME: use current frame time
      ();anim._animationStartTime = Date.now() * 0.001;

      this._animations.set(key, anim);
    }

    /**
     * Required. Returns the animation with the specified key.
     * @access public
     * @param {string} key - A string identifying a previously added animation.
     * @returns {?CAAnimation} - 
     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1524020-animation
     */

  }, {
    key: 'animationForKey',
    value: function animationForKey(key) {
      return this._animations.get(key);
    }

    /**
     * Required. Removes all the animations currently attached to the object.
     * @access public
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522762-removeallanimations
     */

  }, {
    key: 'removeAllAnimations',
    value: function removeAllAnimations() {
      // TODO: stop animations
      this._animations.clear();
    }

    /**
     * Required. Removes the animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation to remove.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522880-removeanimation
     */

  }, {
    key: 'removeAnimationForKey',
    value: function removeAnimationForKey(key) {
      this._animations.delete(key);
      this._copyTransformToPresentationRecursive();
    }

    /**
     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
     * @access public
     * @param {string} key - A string identifying an attached animation to remove.
     * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
     * @returns {void}
     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1522841-removeanimation
     */

  }, {
    key: 'removeAnimationForKeyFadeOutDuration',
    value: function removeAnimationForKeyFadeOutDuration(key, duration) {
      // FIXME: use fadeout duration
      this.removeAnimationForKey(key);
    }

    /**
     * Required. An array containing the keys of all animations currently attached to the object.
     * @type {string[]}
     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523610-animationkeys
     */

  }, {
    key: 'pauseAnimationForKey',


    // Pausing and Resuming Animations

    /**
     * Required. Pauses the animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {void}
     * @desc This method has no effect if no animation is attached to the object with the specified key.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523592-pauseanimation
     */
    value: function pauseAnimationForKey(key) {}

    /**
     * Required. Resumes a previously paused animation attached to the object with the specified key.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {void}
     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523332-resumeanimation
     */

  }, {
    key: 'resumeAnimationForKey',
    value: function resumeAnimationForKey(key) {}

    /**
     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
     * @access public
     * @param {string} key - A string identifying an attached animation.
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1523703-isanimationpaused
     */

  }, {
    key: 'isAnimationPausedForKey',
    value: function isAnimationPausedForKey(key) {
      return false;
    }

    // Instance Methods

    /**
     * Required. 
     * @access public
     * @param {number} speed - 
     * @param {string} key - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnanimatable/1778343-setanimationspeed
     */

  }, {
    key: 'setAnimationSpeedForKey',
    value: function setAnimationSpeedForKey(speed, key) {}
  }, {
    key: 'valueForKeyPath',
    value: function valueForKeyPath(keyPath) {
      var usePresentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var target = usePresentation && this._presentation ? this._presentation : this;
      var paths = keyPath.split('.');
      var key = paths[0];
      var key2 = paths[1];

      if (key === '_birthRate') {
        return target[key];
      }
      return _get(SCNParticleSystem.prototype.__proto__ || Object.getPrototypeOf(SCNParticleSystem.prototype), 'valueForKeyPath', this).call(this, keyPath, usePresentation);
    }
  }, {
    key: 'setValueForKeyPath',
    value: function setValueForKeyPath(value, keyPath) {
      var target = this._presentation ? this._presentation : this;

      var paths = keyPath.split('.');
      var key = paths.shift();
      var restPath = paths.join('.');

      if (key === '_birthRate') {
        target[key] = value;
        return;
      }
      _get(SCNParticleSystem.prototype.__proto__ || Object.getPrototypeOf(SCNParticleSystem.prototype), 'setValueForKeyPath', this).call(this, value, keyPath);
    }
  }, {
    key: '_getLoadedPromise',


    /**
     * @access private
     * @returns {Promise} -
     */
    value: function _getLoadedPromise() {
      if (this._loadedPromise) {
        return this._loadedPromise;
      }

      return Promise.resolve();
    }

    /**
     * @access public
     * @returns {Promise} -
     */

  }, {
    key: '_particleData',
    get: function get() {
      var arr = [];
      this._particles.forEach(function (particle) {
        arr.push.apply(arr, _toConsumableArray(particle.floatArray()));
      });
      return new Float32Array(arr);
    }
  }, {
    key: '_maxParticles',
    get: function get() {
      var maxRate = this._birthRate + this.birthRateVariation * 0.5;
      var maxLifeSpan = this.particleLifeSpan + this.particleLifeSpanVariation * 0.5;
      return Math.ceil(maxRate * maxLifeSpan);
    }
  }, {
    key: 'birthRate',
    get: function get() {
      return this._birthRate;
    },
    set: function set(newValue) {
      var oldValue = this._birthRate;
      this._birthRate = newValue;
      _SCNTransaction2.default._addChange(this, '_birthRate', oldValue, newValue);
    }
  }, {
    key: 'animationKeys',
    get: function get() {
      var keys = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._animations.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var key = _step2.value;

          keys.push(key);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return keys;
    }
  }, {
    key: '_presentation',
    get: function get() {
      return this.__presentation ? this.__presentation : this;
    }
  }, {
    key: 'didLoad',
    get: function get() {
      return this._getLoadedPromise();
    }
  }], [{
    key: 'systemNamedInDirectory',
    value: function systemNamedInDirectory(name) {
      var directory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      //const system = new SCNParticleSystem(name, directory)
      if (name !== null) {
        var path = name;
        if (directory !== null) {
          path = directory + '/' + name;
        }
        return _BinaryRequest3.default.get(path).then(function (data) {
          var system = _NSKeyedUnarchiver2.default.unarchiveObjectWithData(data, path);
          if (!(0, _InstanceOf3.default)(system, SCNParticleSystem)) {
            throw new Error('file ' + path + ' is not an instance of SCNParticleSystem');
          }
          // FIXME: wait for images
          system._loadedPromise = Promise.resolve(system);
          return system;
        });
      }
      return null;
    }
  }, {
    key: 'ParticleProperty',
    get: function get() {
      return _ParticleProperty;
    }
  }]);

  return SCNParticleSystem;
}(_NSObject4.default);

exports.default = SCNParticleSystem;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNPhysicsBehavior2 = __webpack_require__(27);

var _SCNPhysicsBehavior3 = _interopRequireDefault(_SCNPhysicsBehavior2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNPhysicsBody from './SCNPhysicsBody'
//import SCNVector3 from './SCNVector3'

/**
 * A physics behavior that connects two physics bodies and allows them to pivot around each other in any direction.
 * @access public
 * @extends {SCNPhysicsBehavior}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint
 */
var SCNPhysicsBallSocketJoint = function (_SCNPhysicsBehavior) {
  _inherits(SCNPhysicsBallSocketJoint, _SCNPhysicsBehavior);

  // Creating a Ball and Socket Joint

  /**
   * Creates a ball and socket joint connecting two physics bodies.
   * @access public
   * @constructor
   * @param {SCNPhysicsBody} bodyA - The first physics body to be connected by the joint.
   * @param {SCNVector3} anchorA - The point at which the joint connects, relative to the node containing the first body.
   * @param {SCNPhysicsBody} bodyB - The second physics body to be connected by the joint.
   * @param {SCNVector3} anchorB - The point at which the joint connects, relative to the node containing the second body.
   * @desc For a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387926-init
   */
  function SCNPhysicsBallSocketJoint(bodyA, anchorA, bodyB, anchorB) {
    _classCallCheck(this, SCNPhysicsBallSocketJoint);

    // Managing the Characteristics of a Ball and Socket Joint

    /**
     * The point at which the joint connects, relative to the node containing the first body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387956-anchora
     */
    var _this = _possibleConstructorReturn(this, (SCNPhysicsBallSocketJoint.__proto__ || Object.getPrototypeOf(SCNPhysicsBallSocketJoint)).call(this));

    _this.anchorA = null;

    /**
     * The point at which the joint connects, relative to the node containing the second body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387965-anchorb
     */
    _this.anchorB = null;

    _this._bodyA = null;
    _this._bodyB = null;
    return _this;
  }

  // Managing the Characteristics of a Ball and Socket Joint

  /**
   * The first physics body connected by the joint.
   * @type {SCNPhysicsBody}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387981-bodya
   */


  _createClass(SCNPhysicsBallSocketJoint, [{
    key: 'bodyA',
    get: function get() {
      return this._bodyA;
    }

    /**
     * The second physics body connected by the joint.
     * @type {?SCNPhysicsBody}
     * @desc This property’s value is nil if the joint was created using the init(body:anchor:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsballsocketjoint/1387902-bodyb
     */

  }, {
    key: 'bodyB',
    get: function get() {
      return this._bodyB;
    }
  }]);

  return SCNPhysicsBallSocketJoint;
}(_SCNPhysicsBehavior3.default);

exports.default = SCNPhysicsBallSocketJoint;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNPhysicsBodyType = __webpack_require__(51);

var _SCNPhysicsBodyType2 = _interopRequireDefault(_SCNPhysicsBodyType);

var _SCNPhysicsShape = __webpack_require__(52);

var _SCNPhysicsShape2 = _interopRequireDefault(_SCNPhysicsShape);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _SCNVector3 = __webpack_require__(11);

var _SCNVector4 = _interopRequireDefault(_SCNVector3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNBox from './SCNBox'


/**
 * A set of physics simulation attributes attached to a scene graph node. 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody
 */
var SCNPhysicsBody = function (_NSObject) {
  _inherits(SCNPhysicsBody, _NSObject);

  _createClass(SCNPhysicsBody, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        physicsShape: 'SCNPhysicsShape',
        type: 'integer',
        velocityFactor: 'SCNVector3',
        angularVelocityFactor: 'SCNVector3',
        ignoreGravity: ['boolean', function (obj, value) {
          obj.isAffectedByGravity = !value;
        }],
        mass: 'float',
        charge: 'float',
        friction: 'float',
        rollingFriction: 'float',
        restitution: 'float',
        damping: 'float',
        angularDamping: 'float',
        momentOfInertia: 'SCNVector3',
        explicitMomentOfInertia: ['boolean', function (obj, value) {
          obj.usesDefaultMomentOfInertia = !value;
        }],
        categoryBitMask: 'integer',
        contactTestBitMask: 'integer',
        collisionBitMask: 'integer',
        velocity: 'SCNVector3',
        angularVelocity: 'SCNVector4',
        allowsResting: 'boolean',

        isDefaultShape: ['boolean', null]
      };
    }

    // Creating Physics Bodies

    /**
     * Creates a physics body with the specified type and shape.
     * @access public
     * @constructor
     * @param {SCNPhysicsBodyType} type - A constant that determines how a body responds to forces and collisions. See SCNPhysicsBodyType.
     * @param {?SCNPhysicsShape} shape - A physics shape defining the volume of the body for collision detection purposes.
     * @desc For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.If you pass nil for the shape parameter, SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514797-init
     */

  }]);

  function SCNPhysicsBody() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _SCNPhysicsBodyType2.default.static;
    var shape = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, SCNPhysicsBody);

    // Defining How Forces Affect a Physics Body

    /**
     * An object that defines the solid volume of the physics body for use in collision detection.
     * @type {?SCNPhysicsShape}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514789-physicsshape
     */
    var _this = _possibleConstructorReturn(this, (SCNPhysicsBody.__proto__ || Object.getPrototypeOf(SCNPhysicsBody)).call(this));

    _this.physicsShape = shape;

    /**
     * A constant that determines how the physics body responds to forces and collisions.
     * @type {SCNPhysicsBodyType}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514787-type
     */
    _this.type = type;

    /**
     * A multiplier affecting how SceneKit applies translations computed by the physics simulation to the node containing the physics body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514753-velocityfactor
     */
    _this.velocityFactor = new _SCNVector2.default(0, 0, 0);

    /**
     * A multiplier affecting how SceneKit applies rotations computed by the physics simulation to the node containing the physics body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514748-angularvelocityfactor
     */
    _this.angularVelocityFactor = new _SCNVector2.default(0, 0, 0);

    /**
     * A Boolean value that determines whether the constant gravity of a scene accelerates the body.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514738-isaffectedbygravity
     */
    _this.isAffectedByGravity = true;

    // Defining a Body’s Physical Properties

    /**
     * The mass of the body, in kilograms.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514755-mass
     */
    _this.mass = 0;

    /**
     * The electric charge of the body, in coulombs.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514786-charge
     */
    _this.charge = 0;

    /**
     * The body’s resistance to sliding motion.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514794-friction
     */
    _this.friction = 0;

    /**
     * The body’s resistance to rolling motion.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514737-rollingfriction
     */
    _this.rollingFriction = 0;

    /**
     * A factor that determines how much kinetic energy the body loses or gains in collisions.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514740-restitution
     */
    _this.restitution = 0;

    /**
     * A factor that reduces the body’s linear velocity.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514763-damping
     */
    _this.damping = 0;

    /**
     * A factor that reduces the body’s angular velocity.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514792-angulardamping
     */
    _this.angularDamping = 0;

    /**
     * The body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514777-momentofinertia
     */
    _this.momentOfInertia = new _SCNVector2.default(0, 0, 0);

    /**
     * A Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514761-usesdefaultmomentofinertia
     */
    _this.usesDefaultMomentOfInertia = true;

    // Working with Contacts and Collisions

    /**
     * A mask that defines which categories this physics body belongs to.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514768-categorybitmask
     */
    _this.categoryBitMask = 0;

    /**
     * A mask that defines which categories of bodies cause intersection notifications with this physics body.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514746-contacttestbitmask
     */
    _this.contactTestBitMask = 0;

    /**
     * A mask that defines which categories of physics bodies can collide with this physics body.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514772-collisionbitmask
     */
    _this.collisionBitMask = 0;

    // Managing a Body’s Motion

    /**
     * A vector describing both the current speed (in meters per second) and direction of motion of the physics body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514757-velocity
     */
    _this.velocity = new _SCNVector2.default(0, 0, 0);

    /**
     * A vector describing both the current rotation axis and rotational speed (in radians per second) of the physics body.
     * @type {SCNVector4}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514770-angularvelocity
     */
    _this.angularVelocity = new _SCNVector4.default(0, 0, 0, 0);

    /**
     * A Boolean value that specifies whether SceneKit can automatically mark the physics body at rest.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514742-allowsresting
     */
    _this.allowsResting = false;

    _this._isResting = false;

    _this._node = null;
    _this._btRigidBody = null;
    _this._updateRigidBody();

    _this._position = null;
    _this._radius = null;
    _this._transform = null;
    _this._invTransform = null;
    _this._shape = null;

    _this._prevPosition = null;
    _this._positionDiff = new _SCNVector2.default();
    return _this;
  }

  /**
   * Creates a physics body that is unaffected by forces or collisions and that cannot move.
   * @access public
   * @returns {SCNPhysicsBody} - 
   * @desc Use static bodies to construct fixtures in your scene that other bodies need to collide with but that do not themselves move, such as floors, walls, and terrain.For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514791-static
   */


  _createClass(SCNPhysicsBody, [{
    key: 'applyForceAsImpulse',


    // Applying Forces, Impulses, and Torques

    /**
     * Applies a force or impulse to the body at its center of mass.
     * @access public
     * @param {SCNVector3} direction - The direction and magnitude of the force (in newtons) or of the impulse (in newton-seconds).
     * @param {boolean} impulse - true to apply an instantaneous change in momentum; false to apply a force that affects the body at the end of the simulation step.
     * @returns {void}
     * @desc Applying a force or impulse to a body imparts a linear acceleration proportional to its mass.The impulse parameter determines how this method contributes to the physics simulation:If you specify true, SceneKit treats the direction parameter as an impulse, measured in newton-seconds, and accelerates the physics body immediately. Use this option to simulate instantaneous effects such as launching a projectile.If you specify false, SceneKit treats the direction parameter as a force, measured in newtons. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces applied to the physics body during that step and accelerates the body according to the net effect of those forces. Use this option when you want to simulate continuous forces on the body by calling applyForce(_:asImpulse:) on each simulation step.NoteThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.As with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514801-applyforce
     */
    value: function applyForceAsImpulse(direction, impulse) {}

    /**
     * Applies a force or impulse to the body at a specific point.
     * @access public
     * @param {SCNVector3} direction - The direction and magnitude of the force (in newtons) or of the impulse (in newton-seconds).
     * @param {SCNVector3} position - The point on the body where the force or impulse should be applied, in the local coordinate system of the SCNNode object containing the physics body.
     * @param {boolean} impulse - true to apply an instantaneous change in momentum; false to apply a force that affects the body at the end of the simulation step.
     * @returns {void}
     * @desc Applying a force or impulse to a body at a position other than its center of mass may impart both linear and angular acceleration, depending on how the body is situated in the physics world and the other forces acting upon it.The impulse parameter determines how this method contributes to the physics simulation:If you specify true, SceneKit treats the direction parameter as an impulse, measured in newton-seconds, and accelerates the physics body immediately. Use this option to simulate instantaneous effects such as launching a projectile.If you specify false, SceneKit treats the direction parameter as a force, measured in newtons. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces applied to the physics body during that step and accelerates the body according to the net effect of those forces. Use this option when you want to simulate continuous forces on the body by calling applyForce(_:at:asImpulse:) on each simulation step.NoteThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.As with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514750-applyforce
     */

  }, {
    key: 'applyForceAtAsImpulse',
    value: function applyForceAtAsImpulse(direction, position, impulse) {}

    /**
     * Applies a net torque or a change in angular momentum to the body.
     * @access public
     * @param {SCNVector4} torque - The direction and magnitude of the torque (in newton-meters) or of the change of angular momentum (in newton-meter-seconds), relative to the world coordinate space of the scene. 
     * @param {boolean} impulse - true to apply an instantaneous change in angular momentum; false to apply a torque that affects the body at the end of the simulation step.
     * @returns {void}
     * @desc Applying a torque to a body changes its angular velocity by an amount related to its mass and shape, rotating it without affecting its linear acceleration. Each component of the torque vector relates to rotation about the corresponding axis in the local coordinate system of the SCNNode object containing the physics body. For example, applying a torque of {0.0, 0.0, 1.0} causes a node to spin counterclockwise around the world-space z-axis.The impulse parameter determines how this method contributes to the physics simulation:If you specify true, SceneKit treats the direction parameter as an instantaneous change in angular momentum, measured in newton-meter-seconds.If you specify false, SceneKit treats the direction parameter as a torque, measured in newton-meters. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces and torques applied to the physics body during that step and accelerates the body according to the net effect of those forces and torques. Use this option when you want to simulate gradual acceleration by calling applyTorque(_:asImpulse:) on each simulation step.NoteThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.As with all physical quantities in SceneKit, you need not use realistic force and torque measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514752-applytorque
     */

  }, {
    key: 'applyTorqueAsImpulse',
    value: function applyTorqueAsImpulse(torque, impulse) {}

    /**
     * Cancels all continuous forces and torques acting on the physics body during the current simulation step.
     * @access public
     * @returns {void}
     * @desc When you pass false for the impulse parameter in the applyForce(_:asImpulse:), applyForce(_:at:asImpulse:), or applyTorque(_:asImpulse:) method, SceneKit waits until the end of the current simulation step before applying its effect. At that time, SceneKit sums all forces and torques applied during that simulation step and changes the velocity or angular velocity of the body according to the net effect of those forces and torques.Call clearAllForces() to cancel any forces and torques previously applied during the current simulation step.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514735-clearallforces
     */

  }, {
    key: 'clearAllForces',
    value: function clearAllForces() {}

    // Managing a Body’s Motion
    /**
     * A Boolean value that indicates whether the physics body is at rest.
     * @type {boolean}
     * @desc This property’s default value is false, but SceneKit’s physics simulation may automatically set it to true if the body is not moving and not affected by any forces. A resting body does not participate in the simulation until another body collides with it or you change its position or velocity or apply a force to it.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514795-isresting
     */

  }, {
    key: 'resetTransform',


    // Synchronizing a Physics Body with its Node

    /**
     * Updates the position and orientation of a body in the physics simulation to match that of the node to which the body is attached.
     * @access public
     * @returns {void}
     * @desc If you change the position or orientation of a node with an attached static or dynamic physics body, call this method afterward to ensure that the physics simulation incorporates the change. You need not call this method for kinematic bodies.Note that dynamic and physics bodies are designed to be moved only by the physics simulation or not at all. You may use this method to move them regardless of this restriction, but at a cost to performance.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514782-resettransform
     */
    value: function resetTransform() {
      this._resetTransform(true);
    }
  }, {
    key: '_resetTransform',
    value: function _resetTransform() {
      var updateWorldTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this._node !== null) {
        if (updateWorldTransform) {
          this._node._updateWorldTransform();
        }
        if (this._node._presentation) {
          this._transform = this._node._presentation._worldTransform;
        } else {
          this._transform = this._node._worldTransform;
        }
      }

      this._radius = 0;
      if (!this.physicsShape && this._node && this._node.geometry) {
        this.physicsShape = new _SCNPhysicsShape2.default(this._node.geometry);
      }
      if (this.physicsShape) {
        if (!this.physicsShape._sourceObject) {
          this.physicsShape._setSourceObject(this._node);
        }
        if (!this.physicsShape._sourceGeometry) {
          this.physicsShape._setSourceObject(this._sourceObject);
        }
        if (!this.physicsShape._shape) {
          this.physicsShape._createShape();
        }
        var center = this.physicsShape._center;
        this._transform = this._transform.translation(center.x, center.y, center.z);

        if (this.physicsShape._shape) {
          this._radius = this.physicsShape._shape.getBoundingSphere().radius;
        }
      }

      this._position = this._transform.getTranslation();
      this._invTransform = this._transform.invert();
    }

    /**
     * @access private
     * @returns {void}
     */

  }, {
    key: '_updateRigidBody',
    value: function _updateRigidBody() {
      if (this._btRigidBody !== null) {}
      //Ammo.destroy(this._btRigidBody)

      //this._btRigidBody = this._createRigidBody()
    }

    /**
     * @access private
     * @returns {Ammo.btRigidBody} -
     * @desc call Ammo.destroy(rigidBody) after using it.
     */

  }, {
    key: '_createRigidBody',
    value: function _createRigidBody() {
      //let btTransform = null
      //if(this.physicsShape === null){
      //  return null
      //}
      //if(this._node !== null){
      //  btTransform = this._node._createBtTransform()
      //}else{
      //  btTransform = new Ammo.btTransform()
      //  btTransform.setIdentity()
      //}
      //const btShape = this.physicsShape._createBtCollisionShape()
      //const inertia = this.momentOfInertia._createBtVector3()

      //const info = new Ammo.btRigidBodyConstructionInfo(btTransform, btShape, inertia)
      //const rigidBody = new Ammo.btRigidBody(info)

      //return rigidBody
    }
  }, {
    key: '_execDestroy',
    value: function _execDestroy() {}
    //if(this.physicsShape !== null){
    //  this.physicsShape._destroy()
    //  this.physicsShape = null
    //}
    //if(this._btRigidBody !== null){
    //  Ammo.destroy(this._btRigidBody)
    //  this._btRigidBody = null
    //}


    // FIXME: use physics library

  }, {
    key: '_getPosition',
    value: function _getPosition() {
      var pos = new _SCNVector2.default(0, 0, 0);
      if (this._node !== null) {
        pos = this._node._worldTranslation;
      }
      if (this.physicsShape !== null && this.physicsShape._sourceGeometry !== null) {
        var c = this.physicsShape._sourceGeometry.getBoundingSphere().center;
        pos = pos.add(c);
      }
      return pos;
    }
  }, {
    key: '_getRadius',
    value: function _getRadius() {
      if (this.physicsShape === null || this.physicsShape._sourceGeometry === null) {
        return 0;
      }
      return this.physicsShape._sourceGeometry.getBoundingSphere().radius;
    }
  }, {
    key: 'isResting',
    get: function get() {
      return this._isResting;
    }
  }], [{
    key: 'static',
    value: function _static() {
      return new SCNPhysicsBody(_SCNPhysicsBodyType2.default.static);
    }

    /**
     * Creates a physics body that can be affected by forces and collisions.
     * @access public
     * @returns {SCNPhysicsBody} - 
     * @desc Use dynamic bodies for the elements of your scene that are moved by the physics simulation.For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514766-dynamic
     */

  }, {
    key: 'dynamic',
    value: function dynamic() {
      return new SCNPhysicsBody(_SCNPhysicsBodyType2.default.dynamic);
    }

    /**
     * Creates a physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.
     * @access public
     * @returns {SCNPhysicsBody} - 
     * @desc Use kinematic bodies for scene elements that you want to control directly but whose movement manipulates other elements. For example, to allow the user to push objects around with a finger, you might create a kinematic body and attach it to an invisible node that you move follow touch events. (In macOS, use the same technique to allow the user to move objects with the mouse pointer.)For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsbody/1514776-kinematic
     */

  }, {
    key: 'kinematic',
    value: function kinematic() {
      return new SCNPhysicsBody(_SCNPhysicsBodyType2.default.kinematic);
    }
  }]);

  return SCNPhysicsBody;
}(_NSObject3.default);

exports.default = SCNPhysicsBody;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Default values for a physics body’s categoryBitMask and collisionBitMask properties.
 * @access public
 * @see https://developer.apple.com/documentation/scenekit/scnphysicscollisioncategory
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNPhysicsCollisionCategory = function () {
  function SCNPhysicsCollisionCategory() {
    _classCallCheck(this, SCNPhysicsCollisionCategory);
  }

  _createClass(SCNPhysicsCollisionCategory, [{
    key: 'init',


    // Initializers

    /**
     * 
     * @access public
     * @param {number} rawValue - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicscollisioncategory/1523649-init
     */
    value: function init(rawValue) {

      // Constants

      this._default = null;
      this._static = null;
      this._all = null;
    }
  }, {
    key: 'default',


    // Constants
    /**
     * The default categoryBitMask value for dynamic and kinematic bodies.
     * @type {SCNPhysicsCollisionCategory}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnphysicscollisioncategory/1514799-default
     */
    get: function get() {
      return this._default;
    }
    /**
     * The default categoryBitMask value for static bodies.
     * @type {SCNPhysicsCollisionCategory}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnphysicscollisioncategory/1514778-static
     */

  }, {
    key: 'static',
    get: function get() {
      return this._static;
    }
    /**
     * This is the default value for a physics body’s collisionBitMask property.
     * @type {SCNPhysicsCollisionCategory}
     * @desc With this collision mask, a physics body can collide with all other physics bodies.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicscollisioncategory/1514784-all
     */

  }, {
    key: 'all',
    get: function get() {
      return this._all;
    }
  }]);

  return SCNPhysicsCollisionCategory;
}();

exports.default = SCNPhysicsCollisionCategory;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNPhysicsWorld from './SCNPhysicsWorld'
//import SCNPhysicsContact from './SCNPhysicsContact'

/**
 * Methods you can implement to respond when a contact or collision occurs between two physics bodies in a scene.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnphysicscontactdelegate
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNPhysicsContactDelegate = function () {
  function SCNPhysicsContactDelegate() {
    _classCallCheck(this, SCNPhysicsContactDelegate);
  }

  _createClass(SCNPhysicsContactDelegate, [{
    key: 'physicsWorldDidBegin',


    /**
     * constructor
     * @access public
     * @constructor
     */
    //construtor() {
    //}

    // Responding to Contact Events

    /**
     * Tells the delegate that two bodies have come into contact.
     * @access public
     * @param {SCNPhysicsWorld} world - The physics world that is processing the contact.
     * @param {SCNPhysicsContact} contact - An object that describes the contact.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicscontactdelegate/1512835-physicsworld
     */
    value: function physicsWorldDidBegin(world, contact) {}

    /**
     * Tells the delegate that new information is available about an ongoing contact.
     * @access public
     * @param {SCNPhysicsWorld} world - The physics world that is processing the contact.
     * @param {SCNPhysicsContact} contact - An object that describes the contact.
     * @returns {void}
     * @desc SceneKit calls this method on each step of the physics simulation (see the timeStep property) if information about the contact changes—for example, if two bodies are sliding against one another.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicscontactdelegate/1512865-physicsworld
     */

  }, {
    key: 'physicsWorldDidUpdate',
    value: function physicsWorldDidUpdate(world, contact) {}

    /**
     * Tells the delegate that a contact has ended.
     * @access public
     * @param {SCNPhysicsWorld} world - The physics world that is processing the contact.
     * @param {SCNPhysicsContact} contact - An object that describes the contact.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicscontactdelegate/1512883-physicsworld
     */

  }, {
    key: 'physicsWorldDidEnd',
    value: function physicsWorldDidEnd(world, contact) {}
  }]);

  return SCNPhysicsContactDelegate;
}();

exports.default = SCNPhysicsContactDelegate;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for defining the region of space affected by a physics field, used by the scope property.
 * @typedef {Object} SCNPhysicsFieldScope
 * @property {number} insideExtent - The field’s effect applies only to objects within the region of space defined by its position and extent.
 * @property {number} outsideExtent - The field’s effect applies only to objects outside the region of space defined by its position and extent.
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsfieldscope
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNPhysicsFieldScope = {
  insideExtent: 0,
  outsideExtent: 1
};

exports.default = SCNPhysicsFieldScope;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNPhysicsBehavior2 = __webpack_require__(27);

var _SCNPhysicsBehavior3 = _interopRequireDefault(_SCNPhysicsBehavior2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNPhysicsBody from './SCNPhysicsBody'
//import SCNVector3 from './SCNVector3'

/**
 * A physics behavior that connects two bodies and allows them to pivot around each other on a single axis.
 * @access public
 * @extends {SCNPhysicsBehavior}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint
 */
var SCNPhysicsHingeJoint = function (_SCNPhysicsBehavior) {
  _inherits(SCNPhysicsHingeJoint, _SCNPhysicsBehavior);

  // Creating a Hinge Joint

  /**
   * Creates a hinge joint connecting two physics bodies.
   * @access public
   * @constructor
   * @param {SCNPhysicsBody} bodyA - The first physics body to be connected by the joint.
   * @param {SCNVector3} axisA - The axis that the hinge pivots around, relative to the node containing the first body.
   * @param {SCNVector3} anchorA - The point at which the hinge connects, relative to the node containing the first body.
   * @param {SCNPhysicsBody} bodyB - The second physics body to be connected by the joint.
   * @param {SCNVector3} axisB - The axis that the hinge pivots around, relative to the node containing the second body.
   * @param {SCNVector3} anchorB - The point at which the hinge connects, relative to the node containing the second body.
   * @desc For a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387898-init
   */
  function SCNPhysicsHingeJoint(bodyA, axisA, anchorA, bodyB, axisB, anchorB) {
    _classCallCheck(this, SCNPhysicsHingeJoint);

    // Managing the Characteristics of a Hinge Joint

    /**
     * The axis that the hinge pivots around, relative to the node containing the first body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387888-axisa
     */
    var _this = _possibleConstructorReturn(this, (SCNPhysicsHingeJoint.__proto__ || Object.getPrototypeOf(SCNPhysicsHingeJoint)).call(this));

    _this.axisA = null;

    /**
     * The point at which the hinge connects, relative to the node containing the first body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387936-anchora
     */
    _this.anchorA = null;

    /**
     * The axis that the hinge pivots around, relative to the node containing the second body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387914-axisb
     */
    _this.axisB = null;

    /**
     * The point at which the hinge connects, relative to the node containing the second body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387979-anchorb
     */
    _this.anchorB = null;

    _this._bodyA = null;
    _this._bodyB = null;
    return _this;
  }

  // Managing the Characteristics of a Hinge Joint

  /**
   * The first physics body connected by the joint.
   * @type {SCNPhysicsBody}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387973-bodya
   */


  _createClass(SCNPhysicsHingeJoint, [{
    key: 'bodyA',
    get: function get() {
      return this._bodyA;
    }

    /**
     * The second physics body connected by the joint.
     * @type {?SCNPhysicsBody}
     * @desc This property’s value is nil if the joint was created using the init(body:axis:anchor:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicshingejoint/1387918-bodyb
     */

  }, {
    key: 'bodyB',
    get: function get() {
      return this._bodyB;
    }
  }]);

  return SCNPhysicsHingeJoint;
}(_SCNPhysicsBehavior3.default);

exports.default = SCNPhysicsHingeJoint;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNPhysicsBehavior2 = __webpack_require__(27);

var _SCNPhysicsBehavior3 = _interopRequireDefault(_SCNPhysicsBehavior2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNPhysicsBody from './SCNPhysicsBody'
//import SCNVector3 from './SCNVector3'

/**
 * A physics behavior that connects two bodies and allows them to slide against each other and rotate around their connecting points.
 * @access public
 * @extends {SCNPhysicsBehavior}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint
 */
var SCNPhysicsSliderJoint = function (_SCNPhysicsBehavior) {
  _inherits(SCNPhysicsSliderJoint, _SCNPhysicsBehavior);

  // Creating a Slider Joint

  /**
   * Creates a slider joint connecting two physics bodies.
   * @access public
   * @constructor
   * @param {SCNPhysicsBody} bodyA - The first physics body to be connected by the joint.
   * @param {SCNVector3} axisA - The axis along which the first body can slide, relative to the node containing it.
   * @param {SCNVector3} anchorA - The point at which the joint connects, relative to the node containing the first body.
   * @param {SCNPhysicsBody} bodyB - The second physics body to be connected by the joint.
   * @param {SCNVector3} axisB - The axis along which the second body can slide, relative to the node containing it.
   * @param {SCNVector3} anchorB - The point at which the joint connects, relative to the node containing the second body.
   * @desc This method defines the location where the bodies are pinned together. To define their sliding or rotation motion relative to that point, use the properties listed in Limiting the Motion of a Slider Joint.For a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387922-init
   */
  function SCNPhysicsSliderJoint(bodyA, axisA, anchorA, bodyB, axisB, anchorB) {
    _classCallCheck(this, SCNPhysicsSliderJoint);

    // Managing the Characteristics of a Slider Joint

    /**
     * The axis along which the first body can slide, relative to the node containing it.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387900-axisa
     */
    var _this = _possibleConstructorReturn(this, (SCNPhysicsSliderJoint.__proto__ || Object.getPrototypeOf(SCNPhysicsSliderJoint)).call(this));

    _this.axisA = null;

    /**
     * The point at which the joint connects, relative to the node containing the first body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387958-anchora
     */
    _this.anchorA = null;

    /**
     * The axis along which the second body can slide, relative to the node containing it.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387948-axisb
     */
    _this.axisB = null;

    /**
     * The point at which the joint connects, relative to the node containing the second body.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387916-anchorb
     */
    _this.anchorB = null;

    _this._bodyA = null;
    _this._bodyB = null;

    // Limiting the Motion of a Slider Joint

    /**
     * The minimum distance between the anchor points of the two bodies, relative to their initial positions.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387920-minimumlinearlimit
     */
    _this.minimumLinearLimit = 0;

    /**
     * The maximum distance between the anchor points of the two bodies, relative to their initial positions.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387890-maximumlinearlimit
     */
    _this.maximumLinearLimit = 0;

    /**
     * The minimum rotation angle between the two bodies, measured in radians relative to their initial orientations.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387967-minimumangularlimit
     */
    _this.minimumAngularLimit = 0;

    /**
     * The maximum rotation angle between the two bodies, measured in radians relative to their initial orientations.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387924-maximumangularlimit
     */
    _this.maximumAngularLimit = 0;

    // Applying Forces and Torques

    /**
     * The velocity at which the joint’s connected bodies should slide.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387938-motortargetlinearvelocity
     */
    _this.motorTargetLinearVelocity = 0;

    /**
     * The maximum linear force that the joint can apply to its connected bodies, in newtons.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387954-motormaximumforce
     */
    _this.motorMaximumForce = 0;

    /**
     * The angular velocity at which the joint’s connected bodies should rotate around it.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387908-motortargetangularvelocity
     */
    _this.motorTargetAngularVelocity = 0;

    /**
     * The maximum torque that the joint can apply to its connected bodies, in newton-meters.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387961-motormaximumtorque
     */
    _this.motorMaximumTorque = 0;

    return _this;
  }

  // Managing the Characteristics of a Slider Joint

  /**
   * The first physics body connected by the joint.
   * @type {SCNPhysicsBody}
   * @desc 
   * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387987-bodya
   */


  _createClass(SCNPhysicsSliderJoint, [{
    key: 'bodyA',
    get: function get() {
      return this._bodyA;
    }

    /**
     * The second physics body connected by the joint.
     * @type {?SCNPhysicsBody}
     * @desc This property’s value is nil if the joint was created using the init(body:axis:anchor:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicssliderjoint/1387896-bodyb
     */

  }, {
    key: 'bodyB',
    get: function get() {
      return this._bodyB;
    }
  }]);

  return SCNPhysicsSliderJoint;
}(_SCNPhysicsBehavior3.default);

exports.default = SCNPhysicsSliderJoint;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNPhysicsNoiseField2 = __webpack_require__(102);

var _SCNPhysicsNoiseField3 = _interopRequireDefault(_SCNPhysicsNoiseField2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 * @access public
 * @extends {SCNPhysicsField}
 *
 */
var SCNPhysicsTurbulenceField = function (_SCNPhysicsNoiseField) {
  _inherits(SCNPhysicsTurbulenceField, _SCNPhysicsNoiseField);

  function SCNPhysicsTurbulenceField() {
    _classCallCheck(this, SCNPhysicsTurbulenceField);

    return _possibleConstructorReturn(this, (SCNPhysicsTurbulenceField.__proto__ || Object.getPrototypeOf(SCNPhysicsTurbulenceField)).apply(this, arguments));
  }

  _createClass(SCNPhysicsTurbulenceField, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        halfExtent: 'SCNVector3',
        scope: 'integer', // SCNPhysicsFieldScope
        usesEllipsoidalExtent: 'boolean',
        offset: 'SCNVector3',
        // direction: 'SCNVector3',
        strength: 'float',
        falloffExponent: 'float',
        minimumDistance: 'float',
        active: ['boolean', 'isActive'],
        exclusive: ['boolean', 'isExclusive'],
        // categoryBitMask: 'integer',
        smoothness: ['float', '_smoothness'],
        animationSpeed: ['float', '_animationSpeed']
      };
    }

    /**
     * constructor
     * @access public
     * @constructor
     */
    //constructor() {
    //  super()
    //}

  }]);

  return SCNPhysicsTurbulenceField;
}(_SCNPhysicsNoiseField3.default);

exports.default = SCNPhysicsTurbulenceField;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNPhysicsBehavior2 = __webpack_require__(27);

var _SCNPhysicsBehavior3 = _interopRequireDefault(_SCNPhysicsBehavior2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNPhysicsBody from './SCNPhysicsBody'
//import SCNPhysicsVehicleWheel from './SCNPhysicsVehicleWheel'

/**
 * A physics behavior that modifies a physics body to behave like a car, motorcycle, or other wheeled vehicle.
 * @access public
 * @extends {SCNPhysicsBehavior}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle
 */
var SCNPhysicsVehicle = function (_SCNPhysicsBehavior) {
  _inherits(SCNPhysicsVehicle, _SCNPhysicsBehavior);

  // Creating a Vehicle

  /**
   * Creates a vehicle behavior.
   * @access public
   * @constructor
   * @param {SCNPhysicsBody} chassisBody - A physics body to serve as the vehicle’s chassis.
   * @param {SCNPhysicsVehicleWheel[]} wheels - An array of SCNPhysicsVehicleWheel objects representing the vehicle’s wheels. A vehicle must have at least one wheel.
   * @desc Each object in the wheels array associates a node with the wheel to serve as its visual representation and defines properties for the wheel’s physical characteristics. Each wheel object must reference a unique node, which should be a child of the node containing the physics body used for the vehicle’s chassis. Typically, you load a node hierarchy representing the vehicle and all of its wheels from a scene file and then designate which nodes serve as the body and wheels.For a behavior to take effect, you must add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387943-init
   */
  function SCNPhysicsVehicle(chassisBody, wheels) {
    _classCallCheck(this, SCNPhysicsVehicle);

    // Working with a Vehicle’s Physical Characteristics

    var _this = _possibleConstructorReturn(this, (SCNPhysicsVehicle.__proto__ || Object.getPrototypeOf(SCNPhysicsVehicle)).call(this));

    _this._chassisBody = null;
    _this._wheels = null;

    // Driving a Vehicle

    _this._speedInKilometersPerHour = 0;
    return _this;
  }

  // Working with a Vehicle’s Physical Characteristics

  /**
   * The physics body representing the vehicle’s chassis.
   * @type {SCNPhysicsBody}
   * @desc The vehicle’s chassis must be a dynamic body.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387985-chassisbody
   */


  _createClass(SCNPhysicsVehicle, [{
    key: 'applyEngineForceForWheelAt',


    // Driving a Vehicle

    /**
     * Applies a force between the specified wheel and the ground under the vehicle.
     * @access public
     * @param {number} value - The magnitude of the force, in newtons.
     * @param {number} index - The index of the wheel applying the force.
     * @returns {void}
     * @desc Applying a positive force turns the wheel in a direction that would move the vehicle forward; applying a negative force moves the vehicle in reverse.As with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.Calling this method applies a force for one step (or frame) of the physics simulation. To continuously accelerate a vehicle, call this method again on subequent simulation steps (for example, from your scene renderer delegate’s renderer(_:updateAtTime:) method) until the vehicle reaches your desired speed.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387963-applyengineforce
     */
    value: function applyEngineForceForWheelAt(value, index) {}

    /**
     * Applies a force between the specified wheel and the ground under the vehicle.
     * @access public
     * @param {number} value - The magnitude of the torque, in newton-meters.
     * @param {number} index - The index of the wheel applying the force.
     * @returns {void}
     * @desc Applying a braking force causes the wheel to slow down regardless of the direction it’s currently spinning in.As with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.Calling this method applies a braking force for one step (or frame) of the physics simulation. To continuously decelerate a vehicle, call this method again on subequent simulation steps (for example, from your scene renderer delegate’s renderer(_:updateAtTime:) method) until the vehicle stops or reaches your desired speed.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387894-applybrakingforce
     */

  }, {
    key: 'applyBrakingForceForWheelAt',
    value: function applyBrakingForceForWheelAt(value, index) {}

    /**
     * Pivots the specified wheel around its steering axis.
     * @access public
     * @param {number} value - The angle to set the wheel at relative to its steering axis, in radians.
     * @param {number} index - The index, in the vehicle’s wheels array, of the wheel to be pivoted.
     * @returns {void}
     * @desc Steering angles are relative to the wheel’s steeringAxis vector. With the default steering axis of {0.0, -1.0, 0.0}, a steering angle of 0.0 represents neutral steering, positive values steer the vehicle to the right, and negative values steer to the left.
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387952-setsteeringangle
     */

  }, {
    key: 'setSteeringAngleForWheelAt',
    value: function setSteeringAngleForWheelAt(value, index) {}

    /**
     * The vehicle’s ground speed, in kilometers per hour.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387910-speedinkilometersperhour
     */

  }, {
    key: 'chassisBody',
    get: function get() {
      return this._chassisBody;
    }

    /**
     * An array of SCNPhysicsVehicleWheel objects representing the vehicle’s wheels.
     * @type {SCNPhysicsVehicleWheel[]}
     * @desc You can dynamically change the suspension and traction properties of a wheel connected to the vehicle by using the corresponding SCNPhysicsVehicleWheel object or by using Key-value coding with a keypath of the form wheels[index].propertyName. For example, the following code changes the size of the first wheel attached to the vehicle, simulating a failed tire:SCNPhysicsVehicle *vehicle = [SCNPhysicsVehicle vehicleWithChassisBody:car wheels:wheels];
    [vehicle setValue:@0.1 forKeyPath:@"wheels[0].radius"];
    SCNPhysicsVehicle *vehicle = [SCNPhysicsVehicle vehicleWithChassisBody:car wheels:wheels];
    [vehicle setValue:@0.1 forKeyPath:@"wheels[0].radius"];
      * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehicle/1387906-wheels
     */

  }, {
    key: 'wheels',
    get: function get() {
      return this._wheels;
    }
  }, {
    key: 'speedInKilometersPerHour',
    get: function get() {
      return this._speedInKilometersPerHour;
    }
  }]);

  return SCNPhysicsVehicle;
}(_SCNPhysicsBehavior3.default);

exports.default = SCNPhysicsVehicle;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNNode from './SCNNode'
//import SCNVector3 from './SCNVector3'

/**
 * The appearance and physical characteristics of an individual wheel associated with an physics vehicle behavior.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel
 */
var SCNPhysicsVehicleWheel = function (_NSObject) {
  _inherits(SCNPhysicsVehicleWheel, _NSObject);

  // Creating a Wheel

  /**
   * Creates a wheel object.
   * @access public
   * @constructor
   * @param {SCNNode} node - The node whose contents provide the wheel’s visual representation.
   * @desc The node representing a wheel must be a child of the node whose physics body serves as the chassis of the SCNPhysicsVehicle behavior the wheel is attached to. Each wheel object must reference a unique node. To use the wheel, add it to the vehicle behavior using the addWheel: method.SceneKit uses the node’s bounding box to determine the wheel’s initial size, and it uses the node’s position to determine the where the wheel connects to the vehicle’s chassis. You can change attributes using the radius and connectionPosition properties.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387989-init
   */
  function SCNPhysicsVehicleWheel(node) {
    _classCallCheck(this, SCNPhysicsVehicleWheel);

    // Managing a Wheel’s Connection to a Vehicle

    /**
     * The position of the wheel’s connection to the vehicle’s chassis.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387959-connectionposition
     */
    var _this = _possibleConstructorReturn(this, (SCNPhysicsVehicleWheel.__proto__ || Object.getPrototypeOf(SCNPhysicsVehicleWheel)).call(this));

    _this.connectionPosition = null;

    /**
     * The direction of the axis that the wheel spins around to move the vehicle.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387969-axle
     */
    _this.axle = null;

    /**
     * The direction of the axis that the wheel pivots around to steer the vehicle.
     * @type {SCNVector3}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387882-steeringaxis
     */
    _this.steeringAxis = null;

    // Simulating Wheel Size

    /**
     * The radius of the wheel.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387991-radius
     */
    _this.radius = 0;

    // Simulating Traction

    /**
     * The traction between the wheel and any surface in contact with it.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387904-frictionslip
     */
    _this.frictionSlip = 0;

    // Simulating Suspension

    /**
     * The spring coefficient of the suspension between the vehicle and the wheel.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387983-suspensionstiffness
     */
    _this.suspensionStiffness = 0;

    /**
     * The coefficient that limits the speed of the suspension returning to its rest length when compressed.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387971-suspensioncompression
     */
    _this.suspensionCompression = 0;

    /**
     * The damping ratio that limits oscillation in the vehicle’s suspension.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387886-suspensiondamping
     */
    _this.suspensionDamping = 0;

    /**
     * The maximum distance that the wheel is allowed to move up or down relative to its connection point, in centimeters.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387928-maximumsuspensiontravel
     */
    _this.maximumSuspensionTravel = 0;

    /**
     * The maximum force of the suspension between the vehicle and the wheel, in newtons.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387934-maximumsuspensionforce
     */
    _this.maximumSuspensionForce = 0;

    /**
     * The resting length of the suspension, in meters.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387880-suspensionrestlength
     */
    _this.suspensionRestLength = 0;

    // Inspecting the Wheel Node

    _this._node = null;
    return _this;
  }

  // Inspecting the Wheel Node

  /**
   * The node providing the wheel’s visual representation.
   * @type {SCNNode}
   * @desc SceneKit automatically rotates and repositions this node in response to the physics simulation.
   * @see https://developer.apple.com/documentation/scenekit/scnphysicsvehiclewheel/1387892-node
   */


  _createClass(SCNPhysicsVehicleWheel, [{
    key: 'node',
    get: function get() {
      return this._node;
    }
  }]);

  return SCNPhysicsVehicleWheel;
}(_NSObject3.default);

exports.default = SCNPhysicsVehicleWheel;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNGeometry2 = __webpack_require__(9);

var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNGeometryElement = __webpack_require__(15);

var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A rectangular, one-sided plane geometry of specified width and height.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scnplane
 */
var SCNPlane = function (_SCNGeometry) {
  _inherits(SCNPlane, _SCNGeometry);

  _createClass(SCNPlane, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        width: 'float',
        height: 'float',
        widthSegmentCount: 'integer',
        heightSegmentCount: 'integer',
        cornerRadius: 'float',
        cornerSegmentCount: 'integer',
        materials: 'NSArray',
        tessellator: 'SCNGeometryTessellator',
        wantsAdaptiveSubdivision: 'boolean',

        name: 'string',
        primitiveType: ['integer', null],
        subdivisionLevel: 'integer',
        subdivisionSettings: ['bytes', null]
      };
    }

    // Creating a Plane

    /**
     * Creates a plane geometry with the specified width and height.
     * @access public
     * @constructor
     * @param {number} width - The width of the plane along the x-axis of its local coordinate space.
     * @param {number} height - The height of the plane along the y-axis of its local coordinate space.
     * @desc The plane is centered in its local coordinate system. For example, if you create a plane whose width and height are both 10.0, it extends from -5.0 to 5.0 along both the x- and y-axes, and the z-coordinate of all points in the plane is zero.
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1523631-init
     */

  }]);

  function SCNPlane() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;

    _classCallCheck(this, SCNPlane);

    // Adjusting a Plane’s Dimensions

    /**
     * The extent of the plane along its horizontal axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1523782-width
     */
    var _this = _possibleConstructorReturn(this, (SCNPlane.__proto__ || Object.getPrototypeOf(SCNPlane)).call(this, [], []));

    _this.width = width;

    /**
     * The extent of the plane along its vertical axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1522837-height
     */
    _this.height = height;

    // Adjusting Geometric Detail

    /**
     * The number of subdivisions in the plane’s surface along its horizontal axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1523991-widthsegmentcount
     */
    _this.widthSegmentCount = 1;

    /**
     * The number of subdivisions in the plane’s surface along its vertical axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1522889-heightsegmentcount
     */
    _this.heightSegmentCount = 1;

    // Adding Rounded Corners

    /**
     * The radius of curvature for the plane’s corners. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1523005-cornerradius
     */
    _this.cornerRadius = 0;

    /**
     * The number of line segments used to create each rounded corner of the plane. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnplane/1524234-cornersegmentcount
     */
    _this.cornerSegmentCount = 10;

    _this._createGeometry();
    _this.materials.push(new _SCNMaterial2.default());
    return _this;
  }

  _createClass(SCNPlane, [{
    key: '_createGeometry',
    value: function _createGeometry() {
      var sourceData = [];
      var indexData = [];

      // TODO: chamfer
      var wStep = 1.0 / this.widthSegmentCount;
      for (var i = 0; i <= this.heightSegmentCount; i++) {
        var ty = i / this.heightSegmentCount;
        var y = (-0.5 + ty) * this.height;
        for (var j = 0; j <= this.widthSegmentCount; j++) {
          var tx = j / this.widthSegmentCount;
          var x = (-0.5 + tx) * this.width;

          sourceData.push(x, y, 0.0 // position
          );sourceData.push(0.0, 0.0, 1.0 // normal
          );sourceData.push(tx, 1.0 - ty // texcoord
          );
        }
      }

      var numSegments = this.widthSegmentCount * this.heightSegmentCount;
      for (var _i = 0; _i < numSegments; _i++) {
        var index = _i * 4;
        indexData.push(index, index + 1, index + 3);
        indexData.push(index, index + 3, index + 2);
      }

      var vectorCount = (this.widthSegmentCount + 1) * (this.heightSegmentCount + 1);

      var vertexSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.vertex, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      32 // sride
      );

      var normalSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.normal, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      12, // offset
      32 // stride
      );

      var texcoordSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.texcoord, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      24, // offset
      32 // stride
      );

      var element = new _SCNGeometryElement2.default(indexData, _SCNGeometryPrimitiveType2.default.triangles);

      this._geometryElements = [element];
      this._geometrySources = [vertexSource, normalSource, texcoordSource];
      this.boundingBox = {
        min: new _SCNVector2.default(-0.5 * this.width, -0.5 * this.height, 0.0),
        max: new _SCNVector2.default(0.5 * this.width, 0.5 * this.height, 0.0)
      };
    }
  }]);

  return SCNPlane;
}(_SCNGeometry3.default);

exports.default = SCNPlane;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNProgram from './SCNProgram'
//import SCNRenderer from './SCNRenderer'

/**
 * The interface for tracking errors that occur when compiling shader source code.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnprogramdelegate
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNProgramDelegate = function () {
  function SCNProgramDelegate() {
    _classCallCheck(this, SCNProgramDelegate);
  }

  _createClass(SCNProgramDelegate, [{
    key: 'programHandleError',


    /**
     * constructor
     * @access public
     * @constructor
     */
    //constructor() {
    //}

    // Handling Shader Compilation Errors

    /**
     * Tells the delegate that an error occurred when compiling GLSL source code.
     * @access public
     * @param {SCNProgram} program - The program that generated the compilation error.
     * @param {Error} error - The compilation error that was raised.
     * @returns {void}
     * @desc Examine the error parameter for details of the compilation error provided by the GLSL compiler.
     * @see https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1523007-program
     */
    value: function programHandleError(program, error) {}

    // Finding Fragment Opaqueness

    /**
     * Asks the delegate whether fragments rendered by a program are opaque.
     * @deprecated
     * @access public
     * @param {SCNProgram} program - 
     * @returns {boolean} - 
     * @see https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1523068-programisopaque
     */

  }, {
    key: 'programIsOpaque',
    value: function programIsOpaque(program) {
      return false;
    }

    // Binding and Unbinding Values

    /**
     * Invoked on the delegate to let it bind program values and/or associated graphics resources (such as textures) for symbols.
     * @deprecated
     * @access public
     * @param {SCNProgram} program - The SCNProgram object to bind values for.
     * @param {string} symbol - The name of the symbol to bind a value for.
     * @param {number} location - The location of the symbol within the program object to be modified.
     * @param {number} programID - The underlying OpenGL program object in which the binding is made.
     * @param {SCNRenderer} renderer - The renderer that is currently rendering the scene.
     * @returns {boolean} - 
     * @desc If you use the handleBinding(ofSymbol:handler:) method to associate a handler block with a SceneKit object for a symbol, SceneKit will not call the delegate’s program(_:bindValueForSymbol:atLocation:programID:renderer:) method for that symbol when rendering that object.
     * @see https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1524155-program
     */

  }, {
    key: 'programBindValueForSymbolAtLocation',
    value: function programBindValueForSymbolAtLocation(program, symbol, location, programID, renderer) {
      return false;
    }

    /**
     * Invoked on the delegate to let it unbind program values and/or also unbind associated graphic resources (such as textures).
     * @deprecated
     * @access public
     * @param {SCNProgram} program - The SCNProgram object to unbind values for.
     * @param {string} symbol - The name of the symbol to unbind a value for.
     * @param {number} location - The location of the symbol within the program object to be modified.
     * @param {number} programID - The underlying OpenGL program object in which the unbinding is done.
     * @param {SCNRenderer} renderer - The renderer that is currently rendering the scene.
      * @returns {void}
     * @desc If you use the handleUnbinding(ofSymbol:handler:) method to associate a handler block with a SceneKit object for a symbol, SceneKit will not call the delegate’s program(_:unbindValueForSymbol:atLocation:programID:renderer:) method for that symbol when rendering that object.
     * @see https://developer.apple.com/documentation/scenekit/scnprogramdelegate/1523857-program
     */

  }, {
    key: 'programUnbindValueForSymbolAtLocation',
    value: function programUnbindValueForSymbolAtLocation(program, symbol, location, programID, renderer) {}
  }]);

  return SCNProgramDelegate;
}();

exports.default = SCNProgramDelegate;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNGeometry2 = __webpack_require__(9);

var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

var _SCNGeometryElement = __webpack_require__(15);

var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A right rectangular pyramid geometry.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scnpyramid
 */
var SCNPyramid = function (_SCNGeometry) {
  _inherits(SCNPyramid, _SCNGeometry);

  // Creating a Pyramid

  /**
   * Creates a pyramid geometry with the specified width, height, and length.
   * @access public
   * @constructor
   * @param {number} width - The width of the pyramid along the x-axis of its local coordinate space.
   * @param {number} height - The height of the pyramid along the y-axis of its local coordinate space.
   * @param {number} length - The length of the pyramid along the z-axis of its local coordinate space.
   * @desc The pyramid’s base is centered in its local coordinate system. For example, if you create a pyramid whose width, height and length are all 10.0, its apex is at the point {0, 10.0, 0}, and its base lies in the plane whose y-coordinate is 0.0, extending from -5.0 to 5.0 along both the x- and z-axes.
   * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1523254-init
   */
  function SCNPyramid() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
    var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;

    _classCallCheck(this, SCNPyramid);

    // Adjusting a Pyramid’s Dimensions

    /**
     * The extent of the pyramid along its x-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1522613-width
     */
    var _this = _possibleConstructorReturn(this, (SCNPyramid.__proto__ || Object.getPrototypeOf(SCNPyramid)).call(this, [], []));

    _this.width = 1.0;

    /**
     * The extent of the pyramid along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1522805-height
     */
    _this.height = height;

    /**
     * The extent of the pyramid along its z-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1524203-length
     */
    _this.length = length; // For the original SceneKit, the default value is 0.0, but it should be 1.0.


    // Adjusting Geometric Detail

    /**
     * The number of subdivisions in each face of the pyramid along its x-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1523083-widthsegmentcount
     */
    _this.widthSegmentCount = 1;

    /**
     * The number of subdivisions in each face of the pyramid along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1524059-heightsegmentcount
     */
    _this.heightSegmentCount = 1;

    /**
     * The number of subdivisions in each face of the pyramid along its z-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnpyramid/1524227-lengthsegmentcount
     */
    _this.lengthSegmentCount = 1;

    _this._createGeometry();
    _this.materials.push(new _SCNMaterial2.default());
    return _this;
  }

  _createClass(SCNPyramid, [{
    key: '_createGeometry',
    value: function _createGeometry() {
      var sourceData = [];

      // TODO: use segment count

      var right = this.width * 0.5;
      var left = -right;
      var front = this.length * 0.5;
      var back = -front;
      var top = this.height;
      var bottom = 0;

      /*
      const nfront = (new SCNVector3(0, front, top)).normalize()
      const nleft = (new SCNVector3(top, left, 0)).normalize()
      const nright = (new SCNVector3(top, right, 0)).normalize()
      const nback = (new SCNVector3(0, back, top)).normalize()
      const tex = [[0.0, 1.0], [0.0, 0.0], [1.0, 1.0], [1.0, 0.0]]
      */

      // front
      sourceData.push.apply(sourceData, _toConsumableArray(this._createSideFace(left, front, right, front)));

      // right
      sourceData.push.apply(sourceData, _toConsumableArray(this._createSideFace(right, front, right, back)));

      // back
      sourceData.push.apply(sourceData, _toConsumableArray(this._createSideFace(right, back, left, back)));

      // left
      sourceData.push.apply(sourceData, _toConsumableArray(this._createSideFace(left, back, left, front)));

      // bottom
      sourceData.push(left, 0, back);
      sourceData.push(0, -1, 0);
      sourceData.push(0.0, 1.0);

      sourceData.push(right, 0, back);
      sourceData.push(0, -1, 0);
      sourceData.push(1.0, 1.0);

      sourceData.push(left, 0, front);
      sourceData.push(0, -1, 0);
      sourceData.push(0.0, 0.0);

      sourceData.push(right, 0, front);
      sourceData.push(0, -1, 0);
      sourceData.push(1.0, 0.0);

      var vectorCount = 20; // TODO: use segmentCount

      var vertexSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.vertex, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      32 // sride
      );

      var normalSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.normal, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      12, // offset
      32 // stride
      );

      var texcoordSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.texcoord, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      24, // offset
      32 // stride
      );

      var elements = [];

      // TODO: use segmentCount
      var indexData = [[0, 2, 3], [4, 6, 7], [8, 10, 11], [12, 14, 15], [16, 17, 19, 16, 19, 18]];

      for (var i = 0; i < 5; i++) {
        elements.push(new _SCNGeometryElement2.default(indexData[i], _SCNGeometryPrimitiveType2.default.triangles));
      }

      this._geometryElements = elements;
      this._geometrySources = [vertexSource, normalSource, texcoordSource];
      this.boundingBox = {
        min: new _SCNVector2.default(left, bottom, back),
        max: new _SCNVector2.default(right, top, front)
      };
    }
  }, {
    key: '_createSideFace',
    value: function _createSideFace(x0, z0, x1, z1) {
      var top = this.height;

      var data = [];
      var normal = new _SCNVector2.default();

      if (x0 === x1) {
        normal.x = top;
        normal.y = x0;
        if (x0 < 0) {
          normal.x = -normal.x;
          normal.y = -normal.y;
        }
      } else if (z0 === z1) {
        normal.z = top;
        normal.y = z0;
        if (z0 < 0) {
          normal.z = -normal.z;
          normal.y = -normal.y;
        }
      } else {
        throw new Error('position inconsistent');
      }
      normal = normal.normalize

      // left bottom
      ();data.push(x0, 0, z0);
      data.push(normal.x, normal.y, normal.z);
      data.push(0.0, 1.0

      // top
      );data.push(0, this.height, 0);
      data.push(normal.x, normal.y, normal.z);
      data.push(0.0, 0.0

      // right bottom
      );data.push(x1, 0, z1);
      data.push(normal.x, normal.y, normal.z);
      data.push(1.0, 1.0

      // top again
      );data.push(0, this.height, 0);
      data.push(normal.x, normal.y, normal.z);
      data.push(1.0, 0.0);

      return data;
    }
  }]);

  return SCNPyramid;
}(_SCNGeometry3.default);

exports.default = SCNPyramid;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNNode2 = __webpack_require__(14);

var _SCNNode3 = _interopRequireDefault(_SCNNode2);

var _SCNReferenceLoadingPolicy = __webpack_require__(105);

var _SCNReferenceLoadingPolicy2 = _interopRequireDefault(_SCNReferenceLoadingPolicy);

var _SCNScene = __webpack_require__(106);

var _SCNScene2 = _interopRequireDefault(_SCNScene);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A scene graph node that serves as a placeholder for content to be loaded from a separate scene file. 
 * @access public
 * @extends {SCNNode}
 * @see https://developer.apple.com/documentation/scenekit/scnreferencenode
 */
var SCNReferenceNode = function (_SCNNode) {
  _inherits(SCNReferenceNode, _SCNNode);

  _createClass(SCNReferenceNode, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        paused: ['boolean', 'isPaused'],
        scale: ['SCNVector3', '_scale'],
        rotation: ['SCNVector4', '_rotation'],
        orientation: ['SCNVector4', function (obj, value) {
          obj.orientation = value;
        }],
        position: ['SCNVector3', '_position'],
        loadingPolicy: 'integer',
        referenceURL: ['NSURL', function (obj, value) {
          obj.referenceURL = value;
          obj.load();
        }],
        opacity: ['float', '_opacity'],
        castsShadow: 'boolean',
        categoryBitMask: 'integer',
        hidden: ['boolean', 'isHidden'],
        name: 'string',
        renderingOrder: 'integer',
        movabilityHint: 'integer',

        clientAttributes: ['NSMutableDictionary', null],
        overrides: ['NSObject', null] // what is this?
      };
    }

    // Creating a Reference Node

    /**
     * Initializes a node whose content is to be loaded from the referenced URL.
     * @access public
     * @constructor
     * @param {string} referenceURL - The URL to a scene file from which to load the node’s content.
     * @desc Using this initializer does not load the node’s content. To load content from the referenced URL, use the load() method.
     * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1523967-init
     */

  }]);

  function SCNReferenceNode(referenceURL) {
    _classCallCheck(this, SCNReferenceNode);

    /**
     * @access private
     * @type {boolean}
     */
    var _this = _possibleConstructorReturn(this, (SCNReferenceNode.__proto__ || Object.getPrototypeOf(SCNReferenceNode)).call(this));

    _this._isLoading = false;

    /**
     * @access private
     * @type {boolean}
     */
    _this._isLoaded = false;

    // Loading and Unloading a Reference Node’s Content

    /**
     * An option for whether to load the node’s content automatically.
     * @type {SCNReferenceLoadingPolicy}
     * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1522996-loadingpolicy
     */
    _this.loadingPolicy = null;

    /**
     * The URL to a scene file from which to load content for the reference node.
     * @type {string}
     * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1522733-referenceurl
     */
    _this._referenceURL = referenceURL;

    _this._scene = null;

    if (referenceURL) {
      _this.load();
    }

    /**
     * @access private
     * @type {Promise}
     */
    _this._loadedPromise = null;
    return _this;
  }

  // Loading and Unloading a Reference Node’s Content

  /**
   * Loads content into the node from its referenced external scene file.
   * @access public
   * @returns {void}
   * @desc When SceneKit loads the referenced scene file, all children of the scene file’s root node become children of the reference node.If the node has already been loaded (either automatically, according to the loadingPolicy property, or through a previous call to this method), calling this method has no effect.
   * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1523204-load
   */


  _createClass(SCNReferenceNode, [{
    key: 'load',
    value: function load() {
      var _this2 = this;

      if (this._isLoaded || this._isLoading) {
        return;
      }
      if (!this._referenceURL) {
        return;
      }
      this._isLoading = true;

      var promise = new Promise(function (resolve, reject) {
        var scene = new _SCNScene2.default(_this2._referenceURL, null);
        scene.didLoad.then(function () {
          scene.rootNode.name = 'referenceRoot';
          _get(SCNReferenceNode.prototype.__proto__ || Object.getPrototypeOf(SCNReferenceNode.prototype), 'addChildNode', _this2).call(_this2, scene.rootNode);
          _this2._scene = scene;

          _this2._isLoaded = true;
          _this2._isLoading = false;
          resolve();
        }).catch(function () {
          reject();
        });
      });
      this._loadedPromise = promise.then(function () {
        return _this2._scene.didLoad;
      });
    }

    /**
     * Removes the node’s children and marks the node as not loaded.
     * @access public
     * @returns {void}
     * @desc Calling this method does not necessarily unload any content associated with the node’s child nodes from memory—it merely removes them from the scene graph. The unlinked nodes and their content are then subject to normal object memory management rules. Under ARC, those objects are deallocated if and only if they are not referenced from elsewhere in your program.
     * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1523566-unload
     */

  }, {
    key: 'unload',
    value: function unload() {
      if (!this._isLoaded) {
        return;
      }
      this.childNodes.forEach(function (child) {
        child.removeFromParentNode();
      });
      this._isLoaded = false;
      this._loadedPromise = null;
    }

    /**
     * A Boolean value that indicates whether the reference node has already loaded its content.
     * @type {boolean}
     * @desc 
     * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1523906-isloaded
     */

  }, {
    key: 'initCoder',


    // Initializers

    /**
     * 
     * @access public
     * @param {NSCoder} aDecoder - 
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnreferencenode/1524061-init
     */
    value: function initCoder(aDecoder) {}
  }, {
    key: 'addChildNode',
    value: function addChildNode(child) {
      throw new Error('cannot add a child node to SCNReferenceNode');
    }
  }, {
    key: 'insertChildNodeAt',
    value: function insertChildNodeAt(child, index) {
      throw new Error('cannot add a child node to SCNReferenceNode');
    }
  }, {
    key: 'replaceChildNodeWith',
    value: function replaceChildNodeWith(oldChild, newChild) {
      throw new Error('cannot add a child node to SCNReferenceNode');
    }
  }, {
    key: '_getLoadedPromise',


    /**
     * @access private
     * @returns {Promise} -
     */
    value: function _getLoadedPromise() {
      if (this._loadedPromise) {
        return this._loadedPromise;
      }
      this.load();
      return this._loadedPromise;
    }

    /**
     * @access public
     * @type {Promise} -
     */

  }, {
    key: 'isLoaded',
    get: function get() {
      return this._isLoaded;
    }
  }, {
    key: 'referenceURL',
    get: function get() {
      return this._referenceURL;
    },
    set: function set(newValue) {
      this.unload();
      this._referenceURL = newValue;
      if (this.loadingPolicy === _SCNReferenceLoadingPolicy2.default.immediate) {
        this.load();
      }
    }
  }, {
    key: 'childNodes',
    get: function get() {
      // FIXME: needs synchronous loading
      if (!this._isLoaded) {
        this.load();
      }
      return this._childNodes.slice(0);
    }
  }, {
    key: 'didLoad',
    get: function get() {
      return this._getLoadedPromise();
    }
  }]);

  return SCNReferenceNode;
}(_SCNNode3.default);

exports.default = SCNReferenceNode;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Methods you can implement to participate in the process of exporting a scene to a file.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnsceneexportdelegate
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNSceneExportDelegate = function () {
  function SCNSceneExportDelegate() {
    _classCallCheck(this, SCNSceneExportDelegate);
  }

  _createClass(SCNSceneExportDelegate, [{
    key: 'writeWithSceneDocumentURL',


    /**
     * constructor
     * @access public
     * @constructor
     */
    //constructor() {
    //}

    // Writing Image Attachments

    /**
     * Tells the delegate to export an image attached to a scene.
     * @access public
     * @param {Image} image - An image attached to the scene being exported.
     * @param {string} documentURL - The URL the scene is being exported to.
     * @param {?string} originalImageURL - The URL the image was originally loaded from, or nil if the image was not previously loaded from a URL.
     * @returns {?string} - 
     * @desc If you implement this method, Scene Kit calls it for each image (for example, a texture) attached to the scene. Your app can then save the image data in a location and format of your choice, returning a URL for the exported image file.If you do not provide a delegate when exporting a scene, or if your delegate returns nil from this method, Scene Kit exports the image in a default format to a default location.
     * @see https://developer.apple.com/documentation/scenekit/scnsceneexportdelegate/1524221-write
     */
    value: function writeWithSceneDocumentURL(image, documentURL, originalImageURL) {
      return null;
    }
  }]);

  return SCNSceneExportDelegate;
}();

exports.default = SCNSceneExportDelegate;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The signature for the block that SceneKit calls during scene export.
 * @type {function(totalProgress: number, error: ?Error, stop: UnsafeMutablePointer<ObjCBool>): void}
 * @param {number} totalProgress - A number between 0.0 and 1.0 that indicates the progress of the export operation, with 0.0 indicating that the operation has just begun and 1.0 indicating the operation has completed.
 * @param {?Error} error - An error encountered during the export process, or nil if no errors have occurred.
 * @param {UnsafeMutablePointer<ObjCBool>} stop - Set *stop to true inside the block to cancel export.
 * @returns {void}
 * @desc stopSet *stop to true inside the block to cancel export.
 * @see https://developer.apple.com/documentation/scenekit/scnsceneexportprogresshandler
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNSceneExportProgressHandler = function SCNSceneExportProgressHandler(totalProgress, error, stop) {};

exports.default = SCNSceneExportProgressHandler;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNScene from './SCNScene'
//import SCNNode from './SCNNode'
//import SCNDebugOptions from './SCNDebugOptions'
//import SCNRenderingAPI from './SCNRenderingAPI'
//import SCNHitTestResult from './SCNHitTestResult'
//import CGPoint from '../CoreGraphics/CGPoint'
//import SCNHitTestOption from './SCNHitTestOption'
//import SCNVector3 from './SCNVector3'
//import SCNSceneRendererDelegate from './SCNSceneRendererDelegate'

/**
 * Methods and properties common to the SCNView, SCNLayer and SCNRenderer classes.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNSceneRenderer = function () {
  /**
   * constructor
   * @access public
   * @constructor
   */
  function SCNSceneRenderer() {
    _classCallCheck(this, SCNSceneRenderer);

    // Presenting a Scene

    /**
     * Required. The scene to be displayed.
     * @type {?SCNScene}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523956-scene
     */
    this.scene = null;

    // Managing Scene Display

    /**
     * Required. The node from which the scene’s contents are viewed for rendering.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523982-pointofview
     */
    this.pointOfView = null;

    /**
     * Required. A Boolean value that determines whether SceneKit automatically adds lights to a scene.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting
     */
    this.autoenablesDefaultLighting = false;

    /**
     * Required. A Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524026-isjitteringenabled
     */
    this.isJitteringEnabled = false;

    /**
     * Required. A Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522763-showsstatistics
     */
    this.showsStatistics = false;

    /**
     * Required. Options for drawing overlay content in a scene that can aid debugging.
     * @type {SCNDebugOptions}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523281-debugoptions
     */
    this.debugOptions = null;

    this._renderingAPI = null;

    // Managing Scene Animation Timing

    /**
     * Required. The current scene time.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522680-scenetime
     */
    this.sceneTime = 0;

    /**
     * Required. A Boolean value that determines whether the scene is playing.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523401-isplaying
     */
    this.isPlaying = false;

    /**
     * Required. A Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522878-loops
     */
    this.loops = false;

    // Participating in the Scene Rendering Process

    /**
     * Required. A delegate object that receives messages about SceneKit’s rendering process.
     * @type {?SCNSceneRendererDelegate}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522671-delegate
     */
    this.delegate = null;

    // Customizing Scene Rendering with Metal

    this._currentRenderCommandEncoder = null;
    this._device = null;
    this._commandQueue = null;
    this._colorPixelFormat = null;
    this._depthPixelFormat = null;
    this._stencilPixelFormat = null;

    // Customizing Scene Rendering with OpenGL

    this._context = null;

    // Rendering Sprite Kit Content over a Scene

    /**
     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
     * @type {?SKScene}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524051-overlayskscene
     */
    this.overlaySKScene = null;

    // Working With Positional Audio

    /**
     * Required. The node representing the listener’s position in the scene for use with positional audio effects.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523747-audiolistener
     */
    this.audioListener = null;

    this._audioEnvironmentNode = null;
    this._audioEngine = null;

    // Instance Properties

    /**
     * Required. 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522854-currenttime
     */
    this.currentTime = 0;
  }

  // Presenting a Scene

  /**
   * Required. Displays the specified scene with an animated transition.
   * @access public
   * @param {SCNScene} scene - The new scene to be displayed.
   * @param {SKTransition} transition - An object that specifies the duration and style of the animated transition.
   * @param {?SCNNode} pointOfView - The node to use as the pointOfView property when displaying the new scene.
   * @param {?function(): void} [completionHandler = null] - A block that SceneKit calls after the transition animation has completed.This block takes no parameters and has no return value.
   * @returns {void}
   * @desc Use this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.
   * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523028-present
   */


  _createClass(SCNSceneRenderer, [{
    key: 'presentWithIncomingPointOfView',
    value: function presentWithIncomingPointOfView(scene, transition, pointOfView) {
      var completionHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    }

    // Managing Scene Display
    /**
     * Required. The graphics technology SceneKit uses to render the scene.
     * @type {SCNRenderingAPI}
     * @desc You choose a graphics technology when initializing a scene renderer:When initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.To create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.The rendering technology used by a SCNLayer object is determined by Core Animation.After initializing a renderer, this property reflects the rendering technology in use.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522616-renderingapi
     */

  }, {
    key: 'prepareShouldAbortBlock',


    // Preloading Renderer Resources

    /**
     * Required. Prepares a SceneKit object for rendering.
     * @access public
     * @param {Object} object - An SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.
     * @param {?function(): boolean} [block = null] - A block that SceneKit calls periodically while preparing the object. The block takes no parameters.Your block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.Pass nil for this parameter if you do not need an opportunity to cancel preparing the object.
     * @returns {boolean} - 
     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously. SceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.You can observe the progress of this operation with the Progress class. For details, see Progress.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522798-prepare
     */
    value: function prepareShouldAbortBlock(object) {
      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      return false;
    }

    /**
     * Required. Prepares the specified SceneKit objects for rendering, using a background thread.
     * @access public
     * @param {Object[]} objects - An array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.
     * @param {?function(arg1: boolean): void} [completionHandler = null] - A block that SceneKit calls when object preparation fails or completes.The block takes the following parameter:successtrue if all content was successfully prepared for rendering; otherwise, false.
     * @returns {void}
     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.SceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can observe the progress of this operation with the Progress class. For details, see Progress.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523375-prepare
     */

  }, {
    key: 'prepare',
    value: function prepare(objects) {
      var completionHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    }

    // Working With Projected Scene Contents

    /**
     * Required. Searches the renderer’s scene for objects corresponding to a point in the rendered image.
     * @access public
     * @param {CGPoint} point - 
     * @param {?Map<SCNHitTestOption, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
     * @returns {SCNHitTestResult[]} - 
     * @desc A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522929-hittest
     */

  }, {
    key: 'hitTest',
    value: function hitTest(point) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      return null;
    }

    /**
     * Required. Returns a Boolean value indicating whether a node might be visible from a specified point of view.
     * @access public
     * @param {SCNNode} node - The node whose visibility is to be tested.
     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
     * @returns {boolean} - 
     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.Note that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522647-isnode
     */

  }, {
    key: 'isNodeInsideFrustumOf',
    value: function isNodeInsideFrustumOf(node, pointOfView) {
      return false;
    }

    /**
     * Required. Returns all nodes that might be visible from a specified point of view.
     * @access public
     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
     * @returns {SCNNode[]} - 
     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node).Note that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522942-nodesinsidefrustum
     */

  }, {
    key: 'nodesInsideFrustumOf',
    value: function nodesInsideFrustumOf(pointOfView) {
      return null;
    }

    /**
     * Required. Projects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.
     * @access public
     * @param {SCNVector3} point - A point in the world coordinate system of the renderer’s scene.
     * @returns {SCNVector3} - 
     * @desc The z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524089-projectpoint
     */

  }, {
    key: 'projectPoint',
    value: function projectPoint(point) {
      return null;
    }

    /**
     * Required. Unprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.
     * @access public
     * @param {SCNVector3} point - A point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.
     * @returns {SCNVector3} - 
     * @desc The z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this line—for example, to find the geometry corresponding to the location of a click event in a view—use the hitTest(_:options:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522631-unprojectpoint
     */

  }, {
    key: 'unprojectPoint',
    value: function unprojectPoint(point) {
      return null;
    }

    // Customizing Scene Rendering with Metal
    /**
     * Required. The Metal render command encoder in use for the current SceneKit rendering pass.
     * @type {?MTLRenderCommandEncoder}
     * @desc Use this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.This property is valid only during the SceneKit rendering loop—that is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522609-currentrendercommandencoder
     */

  }, {
    key: 'renderingAPI',
    get: function get() {
      return this._renderingAPI;
    }
  }, {
    key: 'currentRenderCommandEncoder',
    get: function get() {
      return this._currentRenderCommandEncoder;
    }

    /**
     * Required. The Metal device this renderer uses for rendering.
     * @type {?MTLDevice}
     * @desc Use this property to create or look up other Metal resources that use the same device as your SceneKit renderer.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523935-device
     */

  }, {
    key: 'device',
    get: function get() {
      return this._device;
    }

    /**
     * Required. The Metal command queue this renderer uses for rendering.
     * @type {?MTLCommandQueue}
     * @desc Use this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523974-commandqueue
     */

  }, {
    key: 'commandQueue',
    get: function get() {
      return this._commandQueue;
    }

    /**
     * Required. The Metal pixel format for the renderer’s color output.
     * @type {MTLPixelFormat}
     * @desc Use this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523701-colorpixelformat
     */

  }, {
    key: 'colorPixelFormat',
    get: function get() {
      return this._colorPixelFormat;
    }

    /**
     * Required. The Metal pixel format for the renderer’s depth buffer.
     * @type {MTLPixelFormat}
     * @desc Use this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523780-depthpixelformat
     */

  }, {
    key: 'depthPixelFormat',
    get: function get() {
      return this._depthPixelFormat;
    }

    /**
     * Required. The Metal pixel format for the renderer’s stencil buffer.
     * @type {MTLPixelFormat}
     * @desc Use this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523315-stencilpixelformat
     */

  }, {
    key: 'stencilPixelFormat',
    get: function get() {
      return this._stencilPixelFormat;
    }

    // Customizing Scene Rendering with OpenGL
    /**
     * Required. The OpenGL rendering context that SceneKit uses for rendering the scene.
     * @type {?Object}
     * @desc In macOS, the value of this property is a Core OpenGL cglContextObj object.In iOS, the value of this property is an EAGLContext object.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522840-context
     */

  }, {
    key: 'context',
    get: function get() {
      return this._context;
    }

    // Working With Positional Audio

    /**
     * Required. The 3D audio mixing node SceneKit uses for positional audio effects.
     * @type {AVAudioEnvironmentNode}
     * @desc SceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523582-audioenvironmentnode
     */

  }, {
    key: 'audioEnvironmentNode',
    get: function get() {
      return this._audioEnvironmentNode;
    }

    /**
     * Required. The audio engine SceneKit uses for playing scene sounds.
     * @type {AVAudioEngine}
     * @desc SceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522686-audioengine
     */

  }, {
    key: 'audioEngine',
    get: function get() {
      return this._audioEngine;
    }
  }]);

  return SCNSceneRenderer;
}();

exports.default = SCNSceneRenderer;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNSceneRenderer from './SCNSceneRenderer'
//import SCNScene from './SCNScene'

/**
 * Methods your app can implement to participate in SceneKit’s animation loop or perform additional rendering. 
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNSceneRendererDelegate = function () {
  function SCNSceneRendererDelegate() {
    _classCallCheck(this, SCNSceneRendererDelegate);
  }

  _createClass(SCNSceneRendererDelegate, [{
    key: 'rendererUpdateAtTime',


    /**
     * constructor
     * @access public
     * @constructor
     */
    //constructor() {
    //}

    // Adding Custom Logic to the Rendering Loop

    /**
     * Tells the delegate to perform any updates that need to occur before actions, animations, and physics are evaluated.
     * @access public
     * @param {SCNSceneRenderer} renderer - 
     * @param {number} time - The current system time, in seconds. Use this parameter for any time-based elements of your game logic.
     * @returns {void}
     * @desc SceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused. Implement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to “batch” your changes).
      * @see https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1522937-renderer
     */
    value: function rendererUpdateAtTime(renderer, time) {}

    /**
     * Tells the delegate to perform any updates that need to occur after actions and animations are evaluated.
     * @access public
     * @param {SCNSceneRenderer} renderer - 
     * @param {number} time - The current system time, in seconds. Use this parameter for any time-based elements of your game logic.
     * @returns {void}
     * @desc SceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused. Implement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to “batch” your changes).
      * @see https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1523038-renderer
     */

  }, {
    key: 'rendererDidApplyAnimationsAtTime',
    value: function rendererDidApplyAnimationsAtTime(renderer, time) {}

    /**
     * Tells the delegate to perform any updates that need to occur after physics simulations are performed.
     * @access public
     * @param {SCNSceneRenderer} renderer - 
     * @param {number} time - The current system time, in seconds. Use this parameter for any time-based elements of your game logic.
     * @returns {void}
     * @desc SceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused. Implement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to “batch” your changes).
    This method is the last opportunity SceneKit provides for you to change the scene graph before rendering.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1522738-renderer
     */

  }, {
    key: 'rendererDidSimulatePhysicsAtTime',
    value: function rendererDidSimulatePhysicsAtTime(renderer, time) {}

    // Rendering Custom Scene Content

    /**
     * Tells the delegate that the renderer has cleared the viewport and is about to render the scene.
     * @access public
     * @param {SCNSceneRenderer} renderer - 
     * @param {SCNScene} scene - The SCNScene object to be rendered.
     * @param {number} time - The current system time, in seconds. If your custom rendering involves animation, use this parameter to compute your own animation state.
     * @returns {void}
     * @desc Implement this method to perform custom drawing before SceneKit renders a scene—for example, to draw backdrop content underneath SceneKit content. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this method—the results of modifying SceneKit objects during this method are undefined.To render using Metal, use the renderer parameter to retrieve the scene renderer’s currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.To render using OpenGL, simply call the relevant OpenGL drawing commands—SceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.You must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use. 
     * @see https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1523483-renderer
     */

  }, {
    key: 'rendererWillRenderSceneAtTime',
    value: function rendererWillRenderSceneAtTime(renderer, scene, time) {}

    /**
     * Tells the delegate that the renderer has rendered the scene.
     * @access public
     * @param {SCNSceneRenderer} renderer - 
     * @param {SCNScene} scene - The scene object that was rendered.
     * @param {number} time - The current system time, in seconds. If your custom rendering involves animation, use this parameter to compute your own animation state.
     * @returns {void}
     * @desc Implement this method to perform custom drawing after SceneKit has rendered a scene—for example, to draw overlay content on top of SceneKit content. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this method—the results of modifying SceneKit objects in this method are undefined.To render using Metal, use the renderer parameter to retrieve the scene renderer’s currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.To render using OpenGL, simply call the relevant OpenGL drawing commands—SceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.You must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use. 
     * @see https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate/1524233-renderer
     */

  }, {
    key: 'rendererDidRenderSceneAtTime',
    value: function rendererDidRenderSceneAtTime(renderer, scene, time) {}
  }]);

  return SCNSceneRendererDelegate;
}();

exports.default = SCNSceneRendererDelegate;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Constants identifying phases of SceneKit’s scene loading process, used in a SCNSceneSourceStatusHandler block.
 * @typedef {Object} SCNSceneSourceStatus
 * @property {number} error - An error occurred when SceneKit attempted to load the scene.
 * @property {number} parsing - SceneKit has begun deserializing the source file.
 * @property {number} validating - SceneKit has begun validating the scene file’s format.
 * @property {number} processing - SceneKit has begun generating scene graph objects from the scene file’s contents.
 * @property {number} complete - SceneKit has successfully finished loading the scene file’s contents.
 * @see https://developer.apple.com/documentation/scenekit/scnscenesourcestatus
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNSceneSourceStatus = {
  error: -1,
  parsing: 4,
  validating: 8,
  processing: 12,
  complete: 16
};

exports.default = SCNSceneSourceStatus;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNSceneSourceStatus from './SCNSceneSourceStatus'

/**
 * The signature for the block that SceneKit calls periodically to report progress while loading a scene.
 * @type {function(totalProgress: number, status: SCNSceneSourceStatus, error: ?Error, stopLoading: UnsafeMutablePointer<ObjCBool>): void}
 * @param {number} totalProgress - A floating-point number between 0.0 and 1.0 indicating the overall progress of loading the scene. A value of 0.0 indicates that the loading process has just begun, and a value of 1.0 indicates that the process has completed.
 * @param {SCNSceneSourceStatus} status - A constant identifying one of the distinct phases of SceneKit’s loading procedure. See SCNSceneSourceStatus for possible values.
 * @param {?Error} error - An error object describing any error that has occurred during scene loading, or nil if no errors has been encountered.
 * @param {UnsafeMutablePointer<ObjCBool>} stopLoading - A reference to a Boolean value. Set *stop to true within the block to abort further processing of the scene source’s contents.
 * @returns {void}
 * @see https://developer.apple.com/documentation/scenekit/scnscenesourcestatushandler
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNSceneSourceStatusHandler = function SCNSceneSourceStatusHandler(totalProgress, status, error, stopLoading) {};

exports.default = SCNSceneSourceStatusHandler;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNProgram from './SCNProgram'
//import SCNShaderModifierEntryPoint from './SCNShaderModifierEntryPoint'
//import SCNBindingBlock from './SCNBindingBlock'


/**
 * Methods for customizing SceneKit's rendering of geometry and materials using Metal or OpenGL shader programs.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scnshadable
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNShadable = function () {
  function SCNShadable() {
    _classCallCheck(this, SCNShadable);
  }

  _createClass(SCNShadable, [{
    key: 'init',


    /**
     * constructor
     * @access public
     * @returns {void}
     */
    value: function init() {

      // Assigning a Custom Shader Program

      /**
       * A program used when rendering the object.
       * @type {?SCNProgram}
       * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523689-program
       */
      this.program = null;

      // Customizing SceneKit’s Shader Programs

      /**
       * A dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.
       * @type {?Map<SCNShaderModifierEntryPoint, string>}
       * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523348-shadermodifiers
       */
      this.shaderModifiers = null;
    }

    // Handling Parameters in Custom OpenGL Shader Programs

    /**
     * Specifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.
     * @access public
     * @param {string} symbol - A GLSL uniform variable or attribute name.
     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
     * @returns {void}
     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
      }];
    This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
      }];
      * @see https://developer.apple.com/documentation/scenekit/scnshadable/1523063-handlebinding
     */

  }, {
    key: 'handleBindingOfSymbolHandler',
    value: function handleBindingOfSymbolHandler(symbol) {
      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    }

    /**
     * Specifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.
     * @access public
     * @param {string} symbol - A GLSL uniform variable or attribute name.
     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
     * @returns {void}
     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnshadable/1522783-handleunbinding
     */

  }, {
    key: 'handleUnbindingOfSymbolHandler',
    value: function handleUnbindingOfSymbolHandler(symbol) {
      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    }
  }]);

  return SCNShadable;
}();

exports.default = SCNShadable;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SCNShadableHelper = function (_NSObject) {
  _inherits(SCNShadableHelper, _NSObject);

  _createClass(SCNShadableHelper, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        owner: ['SCNGeometry', '_owner'],
        shaderModifiers: ['NSDictionary', '_shaderModifiers']
      };
    }
  }]);

  function SCNShadableHelper() {
    _classCallCheck(this, SCNShadableHelper);

    var _this = _possibleConstructorReturn(this, (SCNShadableHelper.__proto__ || Object.getPrototypeOf(SCNShadableHelper)).call(this));

    _this._owner = null;
    _this._shaderModifiers = null;
    return _this;
  }

  return SCNShadableHelper;
}(_NSObject3.default);

exports.default = SCNShadableHelper;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 
 * @typedef {Object} SCNShaderModifierEntryPoint
 * @property {string} fragment - Use this entry point to change the color of a fragment after all other shading has been performed.
 * @property {string} geometry - Use this entry point to deform a geometry’s surface or alter its vertex attributes.
 * @property {string} lightingModel - Use this entry point to provide a custom lighting equation.
 * @property {string} surface - Use this entry point to modify the surface properties of a material before lighting is computed.
 * @see https://developer.apple.com/documentation/scenekit/scnshadermodifierentrypoint
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNShaderModifierEntryPoint = {
  fragment: 'SCNShaderModifierEntryPointFragment',
  geometry: 'SCNShaderModifierEntryPointGeometry',
  lightingModel: 'SCNShaderModifierEntryPointLightingModel',
  surface: 'SCNShaderModifierEntryPointSurface'
};

exports.default = SCNShaderModifierEntryPoint;

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Options for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.
 * @typedef {Object} SCNShadowMode
 * @property {number} forward - SceneKit renders shadows during lighting computations.
 * @property {number} deferred - SceneKit renders shadows in a postprocessing pass.
 * @property {number} modulated - SceneKit renders shadows by projecting the light’s gobo image. The light does not illuminate the scene.
 * @see https://developer.apple.com/documentation/scenekit/scnshadowmode
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNShadowMode = {
  forward: 0,
  deferred: 1,
  modulated: 2
};

exports.default = SCNShadowMode;

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNGeometry2 = __webpack_require__(9);

var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNChamferMode from './SCNChamferMode'

/**
 * A geometry based on a two-dimensional path, optionally extruded to create a three-dimensional object.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scnshape
 */
var SCNShape = function (_SCNGeometry) {
  _inherits(SCNShape, _SCNGeometry);

  // Creating a Shape

  /**
   * Creates a shape geometry with the specified path and extrusion depth.
   * @access public
   * @constructor
   * @param {?UIBezierPath} path - The two-dimensional path forming the basis of the shape.
   * @param {number} extrusionDepth - The thickness of the extruded shape along the z-axis.
   * @desc SceneKit determines the filled area of the path using the even-odd winding rule (see Winding Rules in Cocoa Drawing Guide) and extrudes this area to create a three-dimensional geometry. The result of extruding a self-intersecting path is undefined.The extruded shape is centered at the zero point of its z-axis. For example, an extrusion depth of 1.0 creates a shape that extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape.The path’s flatness (see flatness in NSBezierPath) determines the level of detail SceneKit uses in building a three-dimensional shape from the path. A larger flatness value results in fewer polygons to render, increasing performance, and a smaller flatness value increases the smoothness of curves at a cost to performance.
   * @see https://developer.apple.com/documentation/scenekit/scnshape/1523432-init
   */
  function SCNShape(path, extrusionDepth) {
    _classCallCheck(this, SCNShape);

    // Modifying a Shape

    /**
     * The thickness of the extruded shape along the z-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnshape/1523365-extrusiondepth
     */
    var _this = _possibleConstructorReturn(this, (SCNShape.__proto__ || Object.getPrototypeOf(SCNShape)).call(this));

    _this.extrusionDepth = 0;

    /**
     * The two-dimensional path forming the basis of the shape.
     * @type {?UIBezierPath}
     * @see https://developer.apple.com/documentation/scenekit/scnshape/1523434-path
     */
    _this.path = null;

    // Chamfering a Shape

    /**
     * A constant specifying which ends of the extruded shape’s profile are chamfered.
     * @type {SCNChamferMode}
     * @see https://developer.apple.com/documentation/scenekit/scnshape/1523989-chamfermode
     */
    _this.chamferMode = null;

    /**
     * A path that determines the cross-sectional contour of each chamfered edge.
     * @type {?UIBezierPath}
     * @see https://developer.apple.com/documentation/scenekit/scnshape/1522865-chamferprofile
     */
    _this.chamferProfile = null;

    /**
     * The width or depth of each chamfered edge. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnshape/1524145-chamferradius
     */
    _this.chamferRadius = 0;
    return _this;
  }

  return SCNShape;
}(_SCNGeometry3.default);

exports.default = SCNShape;

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNMatrix4MakeTranslation = __webpack_require__(18);

var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import SCNGeometry from './SCNGeometry'
//import SCNNode from './SCNNode'

//import SCNMatrix4 from './SCNMatrix4'


/**
 * An object that manages the relationship between skeletal animations and the nodes and geometries they animate.
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scnskinner
 */
var SCNSkinner = function (_NSObject) {
  _inherits(SCNSkinner, _NSObject);

  _createClass(SCNSkinner, null, [{
    key: '_propTypes',
    get: function get() {
      return {
        $constructor: function $constructor(propNames, propValues) {
          var invTransforms = [];
          var len = propValues.bones.length;
          for (var i = 0; i < len; i++) {
            var inv = propValues['baseGeometryBindTransform-' + i];
            //console.log(`inv ${i} ${inv.float32Array()}`)
            if (typeof inv === 'undefined') {
              throw new Error('boneInverseBindTransforms ' + i + ' does not exist');
            }
            invTransforms.push(inv);
          }

          var instance = new SCNSkinner(propValues.baseGeometry, propValues.bones, invTransforms, propValues.boneWeights, propValues.boneIndices);
          instance.skeleton = propValues.skeleton;
          instance.baseGeometryBindTransform = propValues.baseGeometryBindTransform;
          return instance;
        },
        $unknownKey: function $unknownKey(key) {
          //console.warn(`SCNSkinner unknownKey ${key}`)
          var pattern = new RegExp(/^baseGeometryBindTransform-(\d+)$/);
          var result = key.match(pattern);
          if (result !== null) {
            return ['SCNMatrix4', null];
          }
          return null;
        },
        baseGeometry: ['SCNGeometry', null],
        baseGeometryBindTransform: ['SCNMatrix4', null],
        skeleton: ['SCNNode', null],
        bones: ['NSArray', null],
        boneWeights: ['SCNGeometrySource', null],
        boneIndices: ['SCNGeometrySource', null]
      };
    }

    // Creating a Skinner Object

    /**
     * Creates a skinner object with the specified visible geometry and skeleton information.
     * @access public
     * @constructor
     * @param {?SCNGeometry} baseGeometry - The geometry whose surface the skinner’s animation skeleton deforms.
     * @param {SCNNode[]} bones - An array of SCNNode objects, each representing a bone or control point for the animation skeleton.
     * @param {?NSValue[]} boneInverseBindTransforms - An array of NSValue objects containing SCNMatrix4 transforms, each of which corresponds to a node in the bones array. Each value is the inverse matrix (see SCNMatrix4Invert(_:)) of that node’s transform property for the skeleton’s default pose.
     * @param {SCNGeometrySource} boneWeights - The geometry source defining the influence of each bone on the positions of vertices in the geometry. For details, see the boneWeights property.
     * @param {SCNGeometrySource} boneIndices - The geometry source defining the mapping from bone indices in skeleton data to the skinner’s bones array. For details, see the boneIndices property.
     * @desc To use the skinner object in a scene, assign it to the skinner property of a node. That node’s geometry property should reference the same SCNGeometry object as the skinner’s baseGeometry property.
     * @see https://developer.apple.com/documentation/scenekit/scnskinner/1523964-init
     */

  }]);

  function SCNSkinner(baseGeometry, bones, boneInverseBindTransforms, boneWeights, boneIndices) {
    _classCallCheck(this, SCNSkinner);

    // data length consistency check
    var _this = _possibleConstructorReturn(this, (SCNSkinner.__proto__ || Object.getPrototypeOf(SCNSkinner)).call(this));

    var boneLen = bones.length;
    //const vectorLen = baseGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex).vectorCount
    if (boneInverseBindTransforms.length !== boneLen) {
      throw new Error('SCNSkinner: bones.length (' + boneLen + ') !== boneInverseBindTransforms.length (' + boneInverseBindTransforms.length + ')');
    }
    //if(boneWeights.vectorCount !== vectorLen){
    //  throw new Error(`SCNSkinner: vertices.length (${vectorLen}) !== boneWeights.vectorCount (${boneWeights.vectorCount})`)
    //}
    //if(boneIndices.vectorCount !== vectorLen){
    //  throw new Error(`SCNSkinner: vertices.length (${vectorLen}) !== boneIndices.vectorCount (${boneIndices.vectorCount})`)
    //}
    if (boneWeights.componentsPerVector !== boneIndices.componentsPerVector) {
      throw new Error('SCNSkinner: boneWeights.componentsPerVector (' + boneWeights.componentsPerVector + ') !== boneIndices.componentsPerVector (' + boneWeights.componentsPerVector + ')');
    }

    // Working with a Skinned Geometry

    /**
     * The geometry whose surface the skinner’s animation skeleton deforms.
     * @type {?SCNGeometry}
     * @see https://developer.apple.com/documentation/scenekit/scnskinner/1522823-basegeometry
     */
    _this.baseGeometry = baseGeometry;

    /**
     * The coordinate transformation for the skinner’s geometry in its default state.
     * @type {SCNMatrix4}
     * @see https://developer.apple.com/documentation/scenekit/scnskinner/1523160-basegeometrybindtransform
     */
    _this.baseGeometryBindTransform = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0

    // Working with an Animation Skeleton

    /**
     * The root node of the skinner object’s animation skeleton.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnskinner/1523048-skeleton
     */
    );_this.skeleton = null;

    /**
     * @access private
     * @type {SCNNode[]}
     */
    _this._bones = bones;

    /**
     * @access private
     * @type {SCNMatrix4[]}
     */
    _this._boneInverseBindTransforms = boneInverseBindTransforms;

    /**
     * @access private
     * @type {SCNGeometrySource}
     */
    _this._boneWeights = boneWeights;

    /**
     * @access private
     * @type {SCNGeometrySource}
     */
    _this._boneIndices = boneIndices;

    _this._useGPU = true;

    _this._checkUseGPU();
    return _this;
  }

  _createClass(SCNSkinner, [{
    key: '_checkUseGPU',
    value: function _checkUseGPU() {
      this._useGPU = true;
      if (this._boneWeights && this._boneWeights.componentsPerVector > 4) {
        this._useGPU = false;
      }
      if (this._boneIndices && this._boneIndices.componentsPerVector > 4) {
        this._useGPU = false;
      }
    }

    // Working with an Animation Skeleton

    /**
     * The control nodes of the animation skeleton.
     * @type {SCNNode[]}
     * @desc An array of SCNNode objects, each of which represents a control point of the animation skeleton. Moving a node deforms the surface of the skinner’s geometry, based on the skeleton data from which the skinner object was created.
     * @see https://developer.apple.com/documentation/scenekit/scnskinner/1522732-bones
     */

  }, {
    key: 'float32Array',


    /**
     * returns Float32Array of 3x4 matrices
     * @access public
     * @returns {Float32Array} -
     */
    value: function float32Array() {
      var arr = [];
      var len = this._bones.length;
      for (var i = 0; i < len; i++) {
        var bone = this._bones[i];
        // TODO: implement appropriate matrix multiplication.
        //       it doesn't consider the rotation of initial pose so far.
        //const mat = this._boneInverseBindTransforms[i].mult(bone._presentation._worldTransform)
        //const mat = this.baseGeometryBindTransform.mult(this._boneInverseBindTransforms[i]).mult(bone._presentation._worldTransform)
        var mat = this.baseGeometryBindTransform.mult(this._boneInverseBindTransforms[i]).mult(bone.presentation._worldTransform
        //const mat = bone._presentation._worldTransform.mult(this._boneInverseBindTransforms[i])
        //mat = bone.presentation.transform.mult(mat)
        //if(bone._parent !== null){
        //  mat = mat.mult(bone._parent.presentation._worldTransform)
        //  //mat = bone._parent.presentation._worldTransform.mult(mat)
        //}
        //mat = bone.presentation.transform.mult(mat)
        //mat = mat.mult(bone.presentation.transform)
        );arr.push.apply(arr, _toConsumableArray(mat.floatArray3x4f()));

        /*
        if(!mat.isIdentity()){
          console.warn(`inverse: ${this._boneInverseBindTransforms[i].floatArray3x4f()}`)
          console.warn(`presentation.worldTransform: ${bone.presentation._worldTransform.floatArray3x4f()}`)
          console.warn(`parent.presentation.world: ${bone._parent.presentation._worldTransform.floatArray3x4f()}`)
          console.warn(`presentation.transform: ${bone.presentation.transform.floatArray3x4f()}`)
          console.warn(`worldTransform: ${bone._worldTransform.floatArray3x4f()}`)
          console.warn(`transfrom: ${bone.transform.floatArray3x4f()}`)
          console.warn(`presentation.position.y: ${bone.presentation.position.y}`)
          console.warn(`position.y: ${bone.position.y}`)
          console.warn(`mat: ${mat.floatArray3x4f()}`)
          throw new Error(`mat ${i} ${bone.name} is not identity`)
        }
        */
      }

      // DEBUG
      /*
      console.log('boneInverseBindTransforms')
      for(let i=0; i<4; i++){
        const mat = this._boneInverseBindTransforms[i]
        console.log(mat.floatArray3x4f())
      }
      console.log('bone._presentation._worldTransform')
      for(let i=0; i<4; i++){
        const mat = this._bones[i]._presentation._worldTransform
        console.log(mat.floatArray3x4f())
      }
      */

      return new Float32Array(arr);
    }

    /**
     * @access private
     * @param {SCNNode} node -
     * @returns {void}
     */

  }, {
    key: '_update',
    value: function _update(node) {
      if (this._useGPU) {
        return;
      }
      var p = node.presentation;
      if (node.geometry === null || p === null || p.geometry === null) {
        // data is not ready
        return;
      }
      // baseGeometryBindTransform
      this.baseGeometryBindTransform;
      this._boneInverseBindTransforms;
      var boneLen = this._bones.length;
      var transforms = [];
      for (var i = 0; i < boneLen; i++) {
        var bone = this._bones[i];
        //transforms.push(this.baseGeometryBindTransform.mult(this._boneInverseBindTransforms[i]).mult(bone._presentation._worldTransform))
        transforms.push(this.baseGeometryBindTransform.mult(this._boneInverseBindTransforms[i]).mult(bone.presentation._worldTransform));
      }

      var baseGeometry = this.baseGeometry;
      var baseVertex = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
      var baseNormal = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
      // TODO: tangent
      //const pg = baseGeometry.presentation
      var pg = p.geometry;
      var vertex = pg.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
      var normal = pg.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
      var weights = this._boneWeights;
      var indices = this._boneIndices;
      var len = weights.vectorCount;
      var vlen = weights.componentsPerVector;
      if (baseNormal) {
        for (var _i = 0; _i < len; _i++) {
          var bv = baseVertex._scnVectorAt(_i);
          var bn = baseNormal._scnVectorAt(_i);
          var w = weights._vectorAt(_i);
          var ind = indices._vectorAt(_i);
          var pos = new _SCNVector2.default(0, 0, 0);
          var nom = new _SCNVector2.default(0, 0, 0);
          for (var j = 0; j < vlen; j++) {
            if (ind[j] < 0) {
              continue;
            }
            if (w[j] === 0) {
              continue;
            }
            var jointMatrix = transforms[ind[j]];
            pos = pos.add(bv.transform(jointMatrix).mul(w[j]));
            nom = nom.add(bn.rotate(jointMatrix).mul(w[j]));
          }
          vertex._setVectorAt(pos, _i);
          normal._setVectorAt(nom, _i);
        }
      } else {
        // TODO: implement
      }
    }
  }, {
    key: 'bones',
    get: function get() {
      return this._bones.slice(0);
    }

    /**
     * The default transforms for the animation skeleton’s bone nodes.
     * @type {?SCNMatrix4[]}
     * @desc An array of NSValue objects containing SCNMatrix4 transforms, each of which corresponds to a node in the bones array. Each value is the inverse matrix (see SCNMatrix4Invert(_:)) of that node’s transform property for the skeleton’s default pose.
     * @see https://developer.apple.com/documentation/scenekit/scnskinner/1523802-boneinversebindtransforms
     */

  }, {
    key: 'boneInverseBindTransforms',
    get: function get() {
      return this._boneInverseBindTransforms.slice(0);
    }

    /**
     * The geometry source that defines the influence of each bone on the positions the geometry’s vertices.
     * @type {SCNGeometrySource}
     * @desc This geometry source’s semantic property must be boneWeights. Its data is an array of floating-point vectors, whose componentsPerVector count is the number of bones influencing each vertex. Each vector corresponds to a vertex in the geometry’s vertex geometry source, and each component in a vector specifies the influence of a bone on that vertex’s position. The boneIndices source determines which nodes in the bones array correspond to each component in the vector. A component value of 0.0 means that the bone has no influence on that vertex; positive or negative values scale the transformation of a bone node before SceneKit applies that transformation to the vertex.NoteSceneKit performs skeletal animation on the GPU only if the componentsPerVector count in this geometry source is 4 or less. Larger vectors result in CPU-based animation and drastically reduced rendering performance.
     * @see https://developer.apple.com/documentation/scenekit/scnskinner/1522986-boneweights
     */

  }, {
    key: 'boneWeights',
    get: function get() {
      return this._boneWeights;
    }
    //set boneWeights(newValue) {
    //  this._boneWeights = newValue
    //  this._checkUseGPU()
    //}

    /**
     * The geometry source defining the mapping from bone indices in skeleton data to the skinner’s bones array.
     * @type {SCNGeometrySource}
     * @desc This geometry source’s semantic property must be boneIndices. Its data is an array of integer vectors, each of which corresponds to a weight vector in the boneWeights geometry source. Each component in a vector specifies the index of the node in the bones array for the corresponding bone weight component.
     * @see https://developer.apple.com/documentation/scenekit/scnskinner/1524117-boneindices
     */

  }, {
    key: 'boneIndices',
    get: function get() {
      return this._boneIndices;
    }
    //set boneIndices(newValue) {
    //  this._boneIndices = newValue
    //  this._checkUseGPU()
    //}

    /**
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'numSkinningJoints',
    get: function get() {
      return this._boneWeights.componentsPerVector;
    }
  }]);

  return SCNSkinner;
}(_NSObject3.default);

exports.default = SCNSkinner;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SCNAnimatable from './SCNAnimatable'
//import SCNBindingBlock from './SCNBindingBlock'

/**
 * A specification for augmenting or postprocessing SceneKit's rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.
 * @access public
 * @extends {NSObject}
 * @implements {SCNAnimatable}
 * @see https://developer.apple.com/documentation/scenekit/scntechnique
 */
var SCNTechnique = function (_NSObject) {
  _inherits(SCNTechnique, _NSObject);

  // Creating a Technique

  /**
   * Creates a technique from a technique definition dictionary.,
   * @access public
   * @constructor
   * @param {Map<string, Object>} dictionary - A dictionary defining the series of rendering passes that comprise the technique.
   * @desc See the class overview for details of a technique definition dictionary.
   * @see https://developer.apple.com/documentation/scenekit/scntechnique/1520494-init
   */
  function SCNTechnique(dictionary) {
    _classCallCheck(this, SCNTechnique);

    // Retrieving a Technique’s Definition

    var _this = _possibleConstructorReturn(this, (SCNTechnique.__proto__ || Object.getPrototypeOf(SCNTechnique)).call(this));

    _this._dictionaryRepresentation = null;
    return _this;
  }

  // Combining Techniques

  /**
   * Creates a new rendering technique that combines a series of techniques.
   * @access public
   * @param {SCNTechnique[]} techniques - An array of SCNTechnique objects.
   * @returns {void}
   * @desc The new technique applies the effects of the techniques in the order specified in the techniques array. Each output of a technique in the array becomes an input to the next technique in the array.
   * @see https://developer.apple.com/documentation/scenekit/scntechnique/1520497-init
   */


  _createClass(SCNTechnique, [{
    key: 'initBySequencingTechniques',
    value: function initBySequencingTechniques(techniques) {

      // Retrieving a Technique’s Definition

      this._dictionaryRepresentation = null;
    }

    // Retrieving a Technique’s Definition
    /**
     * The dictionary defining the rendering technique.
     * @type {Map<string, Object>}
     * @desc Read this property when you want to save a property list file containing the definition of a technique.See the class overview for details of a technique definition dictionary.
     * @see https://developer.apple.com/documentation/scenekit/scntechnique/1520492-dictionaryrepresentation
     */

  }, {
    key: 'handleBindingOfSymbolUsing',


    // Handling Parameters for a Technique’s Shader Programs

    /**
     * Specifies a block to be called before rendering using programs with the specified GLSL uniform variable or attribute name.
     * @access public
     * @param {string} symbol - A GLSL uniform variable or attribute name used in one of the technique’s shader programs.
     * @param {?SCNBindingBlock} [block = null] - A block that SceneKit calls.
     * @returns {void}
     * @desc This method associates a block for handling setup of an attribute or uniform variable in the shader programs associated with the technique. SceneKit calls your block before any performing any rendering passes that use that symbol. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader.NoteYou must associate a handler block with a technique before assigning that technique to a SceneKit object. The result of calling this method on a technique currently in use is undefined.Use this method when you need to update a value in a shader program every time SceneKit renders a frame. To set a value infrequently, or only once, use the setObject(_:forKeyedSubscript:) or setValue(_:forKey:) method instead.If you associate a block with a symbol using this method, SceneKit ignores values set using the setObject(_:forKeyedSubscript:) method.
     * @see https://developer.apple.com/documentation/scenekit/scntechnique/1520490-handlebinding
     */
    value: function handleBindingOfSymbolUsing(symbol) {
      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    }

    /**
     * Sets a value for the specified shader  variable or attribute name, using subscript syntax.
     * @access public
     * @param {?Object} obj - An object containing a new value for the shader symbol.
     * @param {NSCopying} key - A shader variable or attribute name used in one of the technique’s shader programs.
     * @returns {void}
     * @desc The value parameter should be an object appropriate to the type of the shader symbol being set. For example, use an NSNumber object to set the value of a float uniform variable, or use an NSValue object containing an SCNVector3 structure to set the value of a GLSL vec3 uniform variable or a Metal float3 variable.Use this method when you need to set a value infrequently or only once. To update a shader value every time SceneKit renders a frame, use the handleBinding(ofSymbol:using:) method instead.If you use the handleBinding(ofSymbol:using:) method to associate a handler block for a symbol, SceneKit ignores values set for the symbol using the setObject(_:forKeyedSubscript:) method.
     * @see https://developer.apple.com/documentation/scenekit/scntechnique/1520495-setobject
     */

  }, {
    key: 'setObjectForKeyedSubscript',
    value: function setObjectForKeyedSubscript(obj, key) {}
  }, {
    key: 'dictionaryRepresentation',
    get: function get() {
      return this._dictionaryRepresentation;
    }
  }]);

  return SCNTechnique;
}(_NSObject3.default);

exports.default = SCNTechnique;

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNTechnique from './SCNTechnique'

/**
 * The common interface for SceneKit objects that support multipass rendering using SCNTechnique objects.
 * @interface
 * @see https://developer.apple.com/documentation/scenekit/scntechniquesupport
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SCNTechniqueSupport =

/**
 * constructor
 * @access public
 * @constructor
 */
function SCNTechniqueSupport() {
  _classCallCheck(this, SCNTechniqueSupport);

  // Specifying a Technique

  /**
   * Required. The technique SceneKit uses when rendering the object.
   * @type {?SCNTechnique}
   * @see https://developer.apple.com/documentation/scenekit/scntechniquesupport/1520496-technique
   */
  this.technique = null;
};

exports.default = SCNTechniqueSupport;

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNGeometry2 = __webpack_require__(9);

var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import CGRect from '../CoreGraphics/CGRect'
//import CGSize from '../CoreGraphics/CGSize'

/**
 * A geometry based on a string of text, optionally extruded to create a three-dimensional object. 
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scntext
 */
var SCNText = function (_SCNGeometry) {
  _inherits(SCNText, _SCNGeometry);

  // Creating a Text Geometry

  /**
   * Creates a text geometry from a specified string, extruded with a specified depth.
   * @access public
   * @constructor
   * @param {?Object} string - An NSString or NSAttributedString object containing text from which to create the geometry.
   * @param {number} extrusionDepth - The extent of the text geometry in the Z dimension of its local coordinate space. Specify a depth of 0.0 to create 2D text confined to a plane.
   * @desc In the local coordinate system of the text geometry, the origin corresponds to the lower left corner of the text’s layout rectangle, with the text extending in the x- and y-axis dimensions. (SceneKit computes a layout rectangle automatically, or you can specify one using the containerFrame property.) The geometry is centered along its z-axis. For example, if its extrusionDepth property is 1.0, the geometry extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape—the geometry is confined to the plane whose z-coordinate is 0.0, and viewable only from its front unless its material’s isDoubleSided property is true.
   * @see https://developer.apple.com/documentation/scenekit/scntext/1522734-init
   */
  function SCNText(string, extrusionDepth) {
    _classCallCheck(this, SCNText);

    // Managing the Geometry’s Text Content

    /**
     * The string object whose text the geometry represents.
     * @type {?Object}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523439-string
     */
    var _this = _possibleConstructorReturn(this, (SCNText.__proto__ || Object.getPrototypeOf(SCNText)).call(this));

    _this.string = null;

    /**
     * The font that SceneKit uses to create geometry from the text.
     * @type {!UIFont}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523273-font
     */
    _this.font = null;

    // Managing Text Layout

    /**
     * A rectangle specifying the area in which SceneKit should lay out the text.
     * @type {CGRect}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523654-containerframe
     */
    _this.containerFrame = null;

    /**
     * A Boolean value that specifies whether SceneKit wraps long lines of text.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523585-iswrapped
     */
    _this.isWrapped = false;

    /**
     * A constant that specifies how SceneKit horizontally aligns each line of text within its container.
     * @type {string}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523158-alignmentmode
     */
    _this.alignmentMode = '';

    /**
     * A constant that specifies how SceneKit truncates text that is too long to fit its container.
     * @type {string}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523414-truncationmode
     */
    _this.truncationMode = '';

    _this._textSize = null;

    // Managing the Text’s 3D Representation

    /**
     * A number that determines the accuracy or smoothness of the text geometry.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1524111-flatness
     */
    _this.flatness = 0;

    /**
     * The extent of the extruded text in the z-axis direction. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1522604-extrusiondepth
     */
    _this.extrusionDepth = 0;

    /**
     * The width or depth of each chamfered edge. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1522846-chamferradius
     */
    _this.chamferRadius = 0;

    /**
     * A path that determines the cross-sectional contour of each chamfered edge.
     * @type {?UIBezierPath}
     * @see https://developer.apple.com/documentation/scenekit/scntext/1523334-chamferprofile
     */
    _this.chamferProfile = null;
    return _this;
  }

  // Managing Text Layout

  /**
   * The two-dimensional extent of the text after layout.
   * @type {CGSize}
   * @desc This property reports the size of the smallest bounding rectangle containing the text. This size does not necessarily match that of the layout rectangle specified by the containerFrame property. A long body of text may overflow the layout rectangle, depending on the values of the isWrapped and truncationMode properties, and a short string of text may fit in an area smaller than the layout rectangle.
   * @see https://developer.apple.com/documentation/scenekit/scntext/1523680-textsize
   */


  _createClass(SCNText, [{
    key: 'textSize',
    get: function get() {
      return this._textSize;
    }
  }]);

  return SCNText;
}(_SCNGeometry3.default);

exports.default = SCNText;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NSObject2 = __webpack_require__(0);

var _NSObject3 = _interopRequireDefault(_NSObject2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import CAMediaTimingFunction from '../QuartzCore/CAMediaTimingFunction'
//import SCNActionTimingMode from './SCNActionTimingMode'

/**
 * 
 * @access public
 * @extends {NSObject}
 * @see https://developer.apple.com/documentation/scenekit/scntimingfunction
 */
var SCNTimingFunction = function (_NSObject) {
  _inherits(SCNTimingFunction, _NSObject);

  _createClass(SCNTimingFunction, [{
    key: 'initCaMediaTimingFunction',


    // Initializers

    /**
     * 
     * @access public
     * @param {CAMediaTimingFunction} caTimingFunction - 
     * @returns {SCNTimingFunction} -
     * @see https://developer.apple.com/documentation/scenekit/scntimingfunction/2866052-init
     */
    value: function initCaMediaTimingFunction(caTimingFunction) {}

    /**
     * 
     * @access public
     * @constructor
     * @param {SCNActionTimingMode} timingMode - 
     * @see https://developer.apple.com/documentation/scenekit/scntimingfunction/2866061-init
     */

  }]);

  function SCNTimingFunction(timingMode) {
    _classCallCheck(this, SCNTimingFunction);

    return _possibleConstructorReturn(this, (SCNTimingFunction.__proto__ || Object.getPrototypeOf(SCNTimingFunction)).call(this));
  }

  return SCNTimingFunction;
}(_NSObject3.default);

exports.default = SCNTimingFunction;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNGeometry2 = __webpack_require__(9);

var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

var _SCNGeometryElement = __webpack_require__(15);

var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A torus, or ring-shaped geometry.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scntorus
 */
var SCNTorus = function (_SCNGeometry) {
  _inherits(SCNTorus, _SCNGeometry);

  // Creating a Torus

  /**
   * Creates a torus geometry with the specified ring radius and pipe radius.
   * @access public
   * @constructor
   * @param {number} ringRadius - The major radius of the torus, defining its circular ring in the x- and z-axis dimensions of its local coordinate space.
   * @param {number} pipeRadius - The minor radius of the torus, defining the pipe that encircles the ring.
   * @desc The torus is centered in its local coordinate system. For example, if you create a torus whose ring radius is 5.0 and pipe radius is 1.0, it extends from -6.0 to 6.0 (with a hole through the center from -4.0 to 4.0) in the x- and z-axes and from -1.0 to 1.0 in the y-axis.
   * @see https://developer.apple.com/documentation/scenekit/scntorus/1523833-init
   */
  function SCNTorus() {
    var ringRadius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
    var pipeRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.25;

    _classCallCheck(this, SCNTorus);

    // Adjusting a Torus’ Dimensions

    /**
     * The major radius of the torus, defining a circle in the x- and z-axis dimensions. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntorus/1522906-ringradius
     */
    var _this = _possibleConstructorReturn(this, (SCNTorus.__proto__ || Object.getPrototypeOf(SCNTorus)).call(this, [], []));

    _this.ringRadius = ringRadius;

    /**
     * The minor radius of the torus, defining the pipe that encircles the torus ring. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntorus/1522623-piperadius
     */
    _this.pipeRadius = pipeRadius;

    // Configuring Torus Properties

    /**
     * The number of subdivisions around the torus ring. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntorus/1523598-ringsegmentcount
     */
    _this.ringSegmentCount = 48;

    /**
     * The number of subdivisions around the torus pipe. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntorus/1522807-pipesegmentcount
     */
    _this.pipeSegmentCount = 24;

    _this._createGeometry();
    _this.materials.push(new _SCNMaterial2.default());
    return _this;
  }

  _createClass(SCNTorus, [{
    key: '_createGeometry',
    value: function _createGeometry() {
      var sourceData = [];
      var indexData = [];
      var vectorCount = (this.ringSegmentCount + 1) * (this.pipeSegmentCount + 1);

      for (var ri = 0; ri <= this.ringSegmentCount; ri++) {
        var r = 2.0 * ri * Math.PI / this.ringSegmentCount;
        var sinr = Math.sin(r);
        var cosr = Math.cos(r);
        var cx = -sinr * this.ringRadius;
        var cz = -cosr * this.ringRadius;
        var tx = ri / this.ringSegmentCount;

        for (var pi = 0; pi <= this.pipeSegmentCount; pi++) {
          var pr = 2.0 * pi * Math.PI / this.pipeSegmentCount;
          var sinp = Math.sin(pr);
          var cosp = Math.cos(pr);
          var x = cx + this.pipeRadius * sinr * cosp;
          var y = -this.pipeRadius * sinp;
          var z = cz + this.pipeRadius * cosr * cosp;

          // vertex
          sourceData.push(x, y, z

          // normal
          );sourceData.push(sinr * cosp, -sinp, cosr * cosp

          // texcoord
          );var tz = 1.0 - pi / this.pipeSegmentCount;
          sourceData.push(tx, tz);
        }
      }

      var vertexSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.vertex, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      32 // sride
      );

      var normalSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.normal, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      12, // offset
      32 // stride
      );

      var texcoordSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.texcoord, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      24, // offset
      32 // stride
      );

      var indexLen = this.ringSegmentCount * this.pipeSegmentCount;
      var base = 0;
      for (var i = 0; i < indexLen; i++) {
        var i2 = base + this.pipeSegmentCount + 1;
        indexData.push(base, i2 + 1, base + 1);
        indexData.push(base, i2, i2 + 1);
        base += 1;
        if ((i + 1) % this.pipeSegmentCount === 0) {
          base += 1;
        }
      }

      var element = new _SCNGeometryElement2.default(indexData, _SCNGeometryPrimitiveType2.default.triangles);

      this._geometryElements = [element];
      this._geometrySources = [vertexSource, normalSource, texcoordSource];
      this.boundingBox = {
        min: new _SCNVector2.default(-this.radius, -this.radius, -this.radius),
        max: new _SCNVector2.default(this.radius, this.radius, this.radius)
      };
    }
  }]);

  return SCNTorus;
}(_SCNGeometry3.default);

exports.default = SCNTorus;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SCNConstraint2 = __webpack_require__(17);

var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

var _SCNNode = __webpack_require__(14);

var _SCNNode2 = _interopRequireDefault(_SCNNode);

var _SCNMatrix = __webpack_require__(7);

var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

var _SCNQuaternion = __webpack_require__(104);

var _SCNQuaternion2 = _interopRequireDefault(_SCNQuaternion);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A constraint that runs a specified closure to compute a new transform (position, rotation, and scale) for each node that the constraint affects.
 * @access public
 * @extends {SCNConstraint}
 * @see https://developer.apple.com/documentation/scenekit/scntransformconstraint
 */
var SCNTransformConstraint = function (_SCNConstraint) {
  _inherits(SCNTransformConstraint, _SCNConstraint);

  function SCNTransformConstraint() {
    _classCallCheck(this, SCNTransformConstraint);

    return _possibleConstructorReturn(this, (SCNTransformConstraint.__proto__ || Object.getPrototypeOf(SCNTransformConstraint)).apply(this, arguments));
  }

  _createClass(SCNTransformConstraint, null, [{
    key: 'constraintInWorldSpaceWith',


    /**
     * constructor
     * @access public
     * @constructor
     */
    //constructor() {
    //  super()
    //}

    // Creating a Transform Constraint

    /**
     * Creates a new transform constraint.
     * @access public
     * @param {boolean} world - true to evaluate the constraint in the scene’s world coordinate space, or false to evaluate it relative to the local coordinate space of each constrained node.
     * @param {function(arg1: SCNNode, arg2: SCNMatrix4): SCNMatrix4} block - A block to be called when Scene Kit evaluates the constraint.The block takes the following parameters:nodeThe constrained node.transformThe constrained node’s current presentation transformation—the value of the transform property of the constrained node’s presentation object. If the node is affected by an in-progress animation, this value reflects the currently visible state of the node during the animation (rather than its target state that will be visible when the animation completes).The block returns a transformation matrix, which Scene Kit then applies to the node. If you return the transform value passed to the block, your constraint has no effect on the node. 
     * @returns {SCNTransformConstraint}
     * @desc The world parameter determines the coordinate space of the transformations passed to and returned by the block parameter.
     * @see https://developer.apple.com/documentation/scenekit/scntransformconstraint/1468679-init
     */
    value: function constraintInWorldSpaceWith(world, block) {
      var constraint = new SCNTransformConstraint();
      // TODO: implement
      return constraint;
    }

    // Type Methods

    /**
     * 
     * @access public
     * @param {boolean} world - 
     * @param {function(arg1: SCNNode, arg2: SCNQuaternion): SCNQuaternion} block - 
     * @returns {SCNTransformConstraint} - 
     * @see https://developer.apple.com/documentation/scenekit/scntransformconstraint/2867503-orientationconstraint
     */

  }, {
    key: 'orientationConstraintInWorldSpaceWith',
    value: function orientationConstraintInWorldSpaceWith(world, block) {
      var constraint = new SCNTransformConstraint();
      // TODO: implement
      return constraint;
    }

    /**
     * 
     * @access public
     * @param {boolean} world - 
     * @param {function(arg1: SCNNode, arg2: SCNVector3): SCNVector3} block - 
     * @returns {SCNTransformConstraint} - 
     * @see https://developer.apple.com/documentation/scenekit/scntransformconstraint/2867461-positionconstraint
     */

  }, {
    key: 'positionConstraintInWorldSpaceWith',
    value: function positionConstraintInWorldSpaceWith(world, block) {
      var constraint = new SCNTransformConstraint();
      // TODO: implement
      return constraint;
    }
  }]);

  return SCNTransformConstraint;
}(_SCNConstraint3.default);

exports.default = SCNTransformConstraint;

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SCNGeometry2 = __webpack_require__(9);

var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

var _SCNGeometryElement = __webpack_require__(15);

var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

var _SCNGeometryPrimitiveType = __webpack_require__(13);

var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

var _SCNGeometrySource = __webpack_require__(6);

var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

var _SCNMaterial = __webpack_require__(12);

var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A tube or pipe geometry—a right circular cylinder with a circular hole along its central axis.
 * @access public
 * @extends {SCNGeometry}
 * @see https://developer.apple.com/documentation/scenekit/scntube
 */
var SCNTube = function (_SCNGeometry) {
  _inherits(SCNTube, _SCNGeometry);

  // Creating a Tube

  /**
   * Creates a tube geometry with the specified inner radius, outer radius, and height.
   * @access public
   * @constructor
   * @param {number} innerRadius - The radius of the tube’s circular central hole in the x- and z-axes of its local coordinate space.
   * @param {number} outerRadius - The radius of the tube’s circular cross section in the x- and z-axes of its local coordinate space.
   * @param {number} height - The height of the tube along the y-axis of its local coordinate space.
   * @desc The tube is centered in its local coordinate system. For example, if you create a tube whose outer radius is 5.0, inner radius is 1.0, and height is 10.0, its circular cross section extends from -5.0 to 5.0 along the x- and z-axes, the y-coordinates of its base and top are -5.0 and 5.0, and the hole through its center extends from -0.5 to 0.5 along the x- and z-axes.
   * @see https://developer.apple.com/documentation/scenekit/scntube/1522843-init
   */
  function SCNTube() {
    var innerRadius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.25;
    var outerRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;

    _classCallCheck(this, SCNTube);

    // Adjusting a Tube’s Dimensions

    /**
     * The radius of the tube’s outer circular cross section. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntube/1523270-outerradius
     */
    var _this = _possibleConstructorReturn(this, (SCNTube.__proto__ || Object.getPrototypeOf(SCNTube)).call(this));

    _this.outerRadius = outerRadius;

    /**
     * The radius of the circular hole through the tube. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntube/1524070-innerradius
     */
    _this.innerRadius = innerRadius;

    /**
     * The extent of the tube along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntube/1522640-height
     */
    _this.height = height;

    // Adjusting Geometric Detail

    /**
     * The number of subdivisions around the circumference of the tube. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntube/1523619-radialsegmentcount
     */
    _this.radialSegmentCount = 48;

    /**
     * The number of subdivisions in the inner and outer surfaces of the tube along its y-axis. Animatable.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scntube/1523080-heightsegmentcount
     */
    _this.heightSegmentCount = 1;

    _this._createGeometry();
    _this.materials.push(new _SCNMaterial2.default());
    return _this;
  }

  _createClass(SCNTube, [{
    key: '_createGeometry',
    value: function _createGeometry() {
      var sourceData = [];

      var top = this.height * 0.5;
      var bottom = -this.height * 0.5;

      var outerData = [];
      var innerData = [];
      var topData = [];
      var bottomData = [];

      var rStep = 2.0 * Math.PI / this.radialSegmentCount;
      var tStep = 1.0 / this.radialSegmentCount;
      for (var i = 0; i <= this.radialSegmentCount; i++) {
        var x = -Math.sin(rStep * i);
        var z = -Math.cos(rStep * i);
        var ovx = x * this.outerRadius;
        var ovz = z * this.outerRadius;
        var ivx = x * this.innerRadius;
        var ivz = z * this.innerRadius;

        // vertex
        outerData.push(ovx, bottom, ovz);
        innerData.push(ivx, top, ivz);
        topData.push(ovx, top, ovz);
        bottomData.push(-ovx, bottom, ovz

        // normal
        );outerData.push(x, 0, z);
        innerData.push(-x, 0, -z);
        topData.push(0, 1, 0);
        bottomData.push(0, -1, 0

        // texcoord
        );var tx = tStep * i;
        outerData.push(tx, 1.0);
        innerData.push(1.0 - tx, 0.0);

        var ttx = 0.5 + Math.cos(rStep * i) * 0.5;
        var tty = 0.5 + Math.sin(rStep * i) * 0.5;
        topData.push(ttx, tty);
        bottomData.push(ttx, tty

        // vertex
        );outerData.push(ovx, top, ovz);
        innerData.push(ivx, bottom, ivz);
        topData.push(ivx, top, ivz);
        bottomData.push(-ivx, bottom, ivz

        // normal
        );outerData.push(x, 0, z);
        innerData.push(-x, 0, -z);
        topData.push(0, 1, 0);
        bottomData.push(0, -1, 0

        // texcoord
        );outerData.push(tx, 0.0);
        innerData.push(1.0 - tx, 1.0);

        var ttx2 = 0.5 + Math.cos(rStep * i) * 0.25;
        var tty2 = 0.5 + Math.sin(rStep * i) * 0.25;
        topData.push(ttx2, tty2);
        bottomData.push(ttx2, tty2);
      }
      sourceData.push.apply(sourceData, outerData.concat(innerData, topData, bottomData));

      var vectorCount = (this.radialSegmentCount + 1) * 8;
      var vertexSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.vertex, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // offset
      32 // sride
      );

      var normalSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.normal, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      12, // offset
      32 // stride
      );

      var texcoordSource = new _SCNGeometrySource2.default(sourceData, // data
      _SCNGeometrySource2.default.Semantic.texcoord, // semantic
      vectorCount, // vectorCount
      true, // floatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      24, // offset
      32 // stride
      );

      var elements = [];
      for (var _i = 0; _i < 4; _i++) {
        var indexData = [];
        var offset = (this.radialSegmentCount + 1) * _i * 2;
        for (var j = 0; j < this.radialSegmentCount; j++) {
          var base = offset + j * 2;
          indexData.push(base, base + 3, base + 1);
          indexData.push(base, base + 2, base + 3);
        }
        elements.push(new _SCNGeometryElement2.default(indexData, _SCNGeometryPrimitiveType2.default.triangles));
      }

      this._geometryElements = elements;
      this._geometrySources = [vertexSource, normalSource, texcoordSource];
      this.boundingBox = {
        min: new _SCNVector2.default(-this.outerRadius, bottom, -this.outerRadius),
        max: new _SCNVector2.default(this.outerRadius, top, this.outerRadius)
      };
    }
  }, {
    key: '_updateBoundingBoxForSkinner',
    value: function _updateBoundingBoxForSkinner() {
      var skinner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (skinner === null) {
        return this.boundingBox;
      }
      return _get(SCNTube.prototype.__proto__ || Object.getPrototypeOf(SCNTube.prototype), '_updateBoundingBoxForSkinner', this).call(this, skinner);
    }
  }]);

  return SCNTube;
}(_SCNGeometry3.default);

exports.default = SCNTube;

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNVector3 from './SCNVector3'

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _epsilon = 0.00001;

/**
 * Returns a Boolean value that indicates whether the corresponding components of two vectors are equal.
 * @access public
 * @param {SCNVector3} a - The first vector.
 * @param {SCNVector3} b - The second vector.
 * @returns {boolean} - 
 * @desc This function performs a numeric (not bitwise) comparison of each pair of component values.
 * @see https://developer.apple.com/documentation/scenekit/1409643-scnvector3equaltovector3
 */
var SCNVector3EqualToVector3 = function SCNVector3EqualToVector3(a, b) {
  return Math.abs(a.x - b.x) < _epsilon && Math.abs(a.y - b.y) < _epsilon && Math.abs(a.z - b.z) < _epsilon;
};

exports.default = SCNVector3EqualToVector3;

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 
 * @access public
 * @param {number[]} v - 
 * @returns {SCNVector3} - 
 * @see https://developer.apple.com/documentation/scenekit/1524143-scnvector3fromfloat3
 */
var SCNVector3FromFloat3 = function SCNVector3FromFloat3(v) {
  return new _SCNVector2.default(v);
};

exports.default = SCNVector3FromFloat3;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNVector3 from './SCNVector3'
//import GLKVector3 from '../undefined/GLKVector3'

/**
 * Returns a three-element SceneKit vector structure corresponding to a GLKit vector structure.
 * @access public
 * @param {GLKVector3} vector - A three-element GLKit vector structure.
 * @returns {SCNVector3} - 
 * @see https://developer.apple.com/documentation/scenekit/1409692-scnvector3fromglkvector3
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNVector3FromGLKVector3 = function SCNVector3FromGLKVector3(vector) {
  return null;
};

exports.default = SCNVector3FromGLKVector3;

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a new three-component vector created from individual component values.
 * @access public
 * @param {number} x - The first component of the vector.
 * @param {number} y - The second component of the vector.
 * @param {number} z - The third component of the vector.
 * @returns {SCNVector3} - 
 * @see https://developer.apple.com/documentation/scenekit/1409705-scnvector3make
 */
var SCNVector3Make = function SCNVector3Make(x, y, z) {
  return new _SCNVector2.default(x, y, z);
};

exports.default = SCNVector3Make;

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNVector3 from './SCNVector3'

/**
 * 
 * @access public
 * @param {SCNVector3} v - 
 * @returns {number[]} - 
 * @see https://developer.apple.com/documentation/scenekit/1523448-scnvector3tofloat3
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNVector3ToFloat3 = function SCNVector3ToFloat3(v) {
  return [v.x, v.y, v.z];
};

exports.default = SCNVector3ToFloat3;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import GLKVector3 from '../undefined/GLKVector3'

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a three-element GLKit vector structure corresponding to a SceneKit vector structure.
 * @access public
 * @param {SCNVector3} vector - A three-element SceneKit vector structure.
 * @returns {GLKVector3} - 
 * @see https://developer.apple.com/documentation/scenekit/1409651-scnvector3toglkvector3
 */
var SCNVector3ToGLKVector3 = function SCNVector3ToGLKVector3(vector) {
  return null;
};exports.default = SCNVector3ToGLKVector3;

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNVector = __webpack_require__(1);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SCNVector3Zero = new _SCNVector2.default(0, 0, 0);

exports.default = SCNVector3Zero;

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNVector4 from './SCNVector4'

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _epsilon = 0.00001;

/**
 * Returns a Boolean value that indicates whether the corresponding components of two vectors are equal.
 * @access public
 * @param {SCNVector4} a - The first vector.
 * @param {SCNVector4} b - The second vector.
 * @returns {boolean} - 
 * @desc This function performs a numeric (not bitwise) comparison of each pair of component values.
 * @see https://developer.apple.com/documentation/scenekit/1409707-scnvector4equaltovector4
 */
var SCNVector4EqualToVector4 = function SCNVector4EqualToVector4(a, b) {
  return Math.abs(a.x - b.x) < _epsilon && Math.abs(a.y - b.y) < _epsilon && Math.abs(a.z - b.z) < _epsilon && Math.abs(a.w - b.w) < _epsilon;
};

exports.default = SCNVector4EqualToVector4;

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SCNVector = __webpack_require__(11);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 
 * @access public
 * @param {number[]} v - 
 * @returns {SCNVector4} - 
 * @see https://developer.apple.com/documentation/scenekit/1523606-scnvector4fromfloat4
 */
var SCNVector4FromFloat4 = function SCNVector4FromFloat4(v) {
  return new _SCNVector2.default(v);
};

exports.default = SCNVector4FromFloat4;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNVector4 from './SCNVector4'
//import GLKVector4 from '../undefined/GLKVector4'

/**
 * Returns a four-element SceneKit vector structure corresponding to a GLKit vector structure.
 * @access public
 * @param {GLKVector4} vector - A four-element GLKit vector structure.
 * @returns {SCNVector4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409729-scnvector4fromglkvector4
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNVector4FromGLKVector4 = function SCNVector4FromGLKVector4(vector) {
  return null;
};

exports.default = SCNVector4FromGLKVector4;

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNVector4 from './SCNVector4'

/**
 * Returns a new four-component vector created from individual component values.
 * @access public
 * @param {number} x - The first component of the vector.
 * @param {number} y - The second component of the vector.
 * @param {number} z - The third component of the vector.
 * @param {number} w - The fourth component of the vector.
 * @returns {SCNVector4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409677-scnvector4make
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNVector4Make = function SCNVector4Make(x, y, z, w) {
  return new SCNVector4Make(x, y, z, w);
};

exports.default = SCNVector4Make;

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import SCNVector4 from './SCNVector4'

/**
 * 
 * @access public
 * @param {SCNVector4} v - 
 * @returns {number[]} - 
 * @see https://developer.apple.com/documentation/scenekit/1523001-scnvector4tofloat4
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNVector4ToFloat4 = function SCNVector4ToFloat4(v) {
  return [v.x, v.y, v.z, v.w];
};

exports.default = SCNVector4ToFloat4;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import GLKVector4 from '../undefined/GLKVector4'
//import SCNVector4 from './SCNVector4'

/**
 * Returns a four-element GLKit vector structure corresponding to a SceneKit vector structure.
 * @access public
 * @param {SCNVector4} vector - A four-element SceneKit vector structure.
 * @returns {GLKVector4} - 
 * @see https://developer.apple.com/documentation/scenekit/1409663-scnvector4toglkvector4
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SCNVector4ToGLKVector4 = function SCNVector4ToGLKVector4(vector) {
  return null;
};

exports.default = SCNVector4ToGLKVector4;

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//import _HTMLCanvasElement from '../util/HTMLCanvasElement'

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
//import SCNTechniqueSupport from './SCNTechniqueSupport'
//import SCNScene from './SCNScene'

//import SCNNode from './SCNNode'
//import SCNCamera from './SCNCamera'
//import SCNMatrix4 from './SCNMatrix4'
//import SCNMatrix4MakeTranslation from './SCNMatrix4MakeTranslation'


var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _CGRect = __webpack_require__(16);

var _CGRect2 = _interopRequireDefault(_CGRect);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

var _GCController = __webpack_require__(29);

var _GCController2 = _interopRequireDefault(_GCController);

var _SCNRenderer = __webpack_require__(108);

var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

var _SCNRenderingAPI = __webpack_require__(111);

var _SCNRenderingAPI2 = _interopRequireDefault(_SCNRenderingAPI);

var _SCNAntialiasingMode = __webpack_require__(87);

var _SCNAntialiasingMode2 = _interopRequireDefault(_SCNAntialiasingMode);

var _SCNVector = __webpack_require__(11);

var _SCNVector2 = _interopRequireDefault(_SCNVector);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*global window*/

var _Option = {
  preferLowPowerDevice: 'SCNPreferLowPowerDeviceKey',
  preferredDevice: 'SCNPreferredDeviceKey',
  preferredRenderingAPI: 'SCNPreferredRenderingAPIKey'
};

var _KeyCode = new Map([['KeyA', 0x00], ['KeyS', 0x01], ['KeyD', 0x02], ['KeyF', 0x03], ['KeyH', 0x04], ['KeyG', 0x05], ['KeyZ', 0x06], ['KeyX', 0x07], ['KeyC', 0x08], ['KeyV', 0x09], ['IntlBackslash', 0x0A], ['KeyB', 0x0B], ['KeyQ', 0x0C], ['KeyW', 0x0D], ['KeyE', 0x0E], ['KeyR', 0x0F], ['KeyY', 0x10], ['KeyT', 0x11], ['Digit1', 0x12], ['Digit2', 0x13], ['Digit3', 0x14], ['Digit4', 0x15], ['Digit6', 0x16], ['Digit5', 0x17], ['Equal', 0x18], // '^' in JIS keyboard
['Digit9', 0x19], ['Digit7', 0x1A], ['Minus', 0x1B], ['Digit8', 0x1C], ['Digit0', 0x1D], ['BracketRight', 0x1E], // '[' in JIS keyboard
['KeyO', 0x1F], ['KeyU', 0x20], ['BracietLeft', 0x21], // '@' in JIS keyboard
['KeyI', 0x22], ['KeyP', 0x23], ['Enter', 0x24], ['KeyL', 0x25], ['KeyJ', 0x26], ['Quote', 0x27], // ':' in JIS keyboard
['KeyK', 0x28], ['Semicolon', 0x29], ['Backslash', 0x2A], // ']' in JIS keyboard
['Comma', 0x2B], ['Slash', 0x2C], ['KeyN', 0x2D], ['KeyM', 0x2E], ['Period', 0x2F], ['Tab', 0x30], ['Space', 0x31], ['Backquote', 0x32], ['Delete', 0x33], ['NumpadEnter', 0x34], ['Escape', 0x35], ['OSRight', 0x36], ['MetaRight', 0x36], ['OSLeft', 0x37], ['MetaLeft', 0x37], ['ShiftLeft', 0x38], ['CapsLock', 0x39], ['AltLeft', 0x3A], ['ControlLeft', 0x3B], ['ShiftRight', 0x3C], ['AltRight', 0x3D], ['ControlRight', 0x3E], ['Fn', 0x3F], // impossible to catch the key event for function key
['F17', 0x40], ['NumpadDecimal', 0x41],
// 0x42: unknown
['NumpadMultiply', 0x43],
// 0x44: unknown
['NumpadAdd', 0x45],
// 0x46: unknown
['NumLock', 0x47], ['AudioVolumeUp', 0x48], ['AudioVolumeDown', 0x49], ['AudioVolumeMute', 0x4A], ['NumpadDivide', 0x4B], ['NumpadEnter', 0x4C],
// 0x4D: unknown
['NumpadSubtract', 0x4E], ['F18', 0x4F], ['F19', 0x50], ['NumpadEqual', 0x51], ['Numpad0', 0x52], ['Numpad1', 0x53], ['Numpad2', 0x54], ['Numpad3', 0x55], ['Numpad4', 0x56], ['Numpad5', 0x57], ['Numpad6', 0x58], ['Numpad7', 0x59], ['F20', 0x5A], ['Numpad8', 0x5B], ['Numpad9', 0x5C], ['IntlYen', 0x5D], // JIS_Yen
['IntlRo', 0x5E], // JIS_Underscore
['NumpadComma', 0x5F], ['F5', 0x60], ['F6', 0x61], ['F7', 0x62], ['F3', 0x63], ['F8', 0x64], ['F9', 0x65], ['Lang2', 0x66], // JIS_Eisu. It could be ''
['F11', 0x67], ['Lang1', 0x68], // JIS_Kana. It could be 'KanaMode'
['F13', 0x69], ['F16', 0x6A], ['F14', 0x6B],
// 0x6C: unknown
['F10', 0x6D],
// 0x6E: unknown
['F12', 0x6F],
// 0x70: unknown
['F15', 0x71], ['Help', 0x72], ['Insert', 0x72], ['Home', 0x73], ['PageUp', 0x74], ['Delete', 0x75], ['F4', 0x76], ['End', 0x77], ['F2', 0x78], ['PageDown', 0x79], ['F1', 0x7A], ['ArrowLeft', 0x7B], ['ArrowRight', 0x7C], ['ArrowDown', 0x7D], ['ArrowUp', 0x7E]]);

/**
 * A view for displaying 3D SceneKit content.
 * @access public
 * @implements {SCNSceneRenderer}
 * @implements {SCNTechniqueSupport}
 * @see https://developer.apple.com/documentation/scenekit/scnview
 */

var SCNView = function () {

  // Initializing a SceneKit View

  /**
   * Initializes and returns a newly allocated SceneKit view object with the specified frame rectangle and options.
   * @access public
   * @constructor
   * @param {CGRect} frame - The frame rectangle for the view, measured in points and specified in the coordinate system of its superview.
   * @param {?Map<string, Object>} [options = null] - Rendering options for the view. See SCNView.
   * @returns {void}
   * @see https://developer.apple.com/documentation/scenekit/scnview/1524215-init
   */
  function SCNView(frame) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, SCNView);

    //super()

    // Specifying a Scene

    /**
     * The scene to be displayed in the view.
     * @access private
     * @type {?SCNScene}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1523904-scene
     */
    this._scene = null;

    // Configuring a View

    /**
     * The background color of the view.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1523088-backgroundcolor
     */
    this._backgroundColor = _SKColor2.default.white;

    /**
     * A Boolean value that determines whether the user can manipulate the current point of view that is used to render the scene. 
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1523171-allowscameracontrol
     */
    this.allowsCameraControl = false;

    /**
     * The antialiasing mode used for rendering the view’s scene.
     * @type {SCNAntialiasingMode}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1524085-antialiasingmode
     */
    this.antialiasingMode = _SCNAntialiasingMode2.default.multisampling4X;

    /**
     * The animation frame rate that the view uses to render its scene.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1621205-preferredframespersecond
     */
    this.preferredFramesPerSecond = 0;

    // Working with a View’s OpenGL ES Context

    /**
     * The OpenGL ES context that the view uses to render its contents.
     * @type {?EAGLContext}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1621072-eaglcontext
     */
    //this.eaglContext = null


    // Working with a View’s OpenGL Context

    /**
     * The OpenGL context that the view uses to render its contents.
     * @type {?NSOpenGLContext}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1522850-openglcontext
     */
    //this.openGLContext = null

    /**
     * @access private
     * @type {WebGL2RenderingContext}
     */
    this._context = null;

    /**
     * The view’s OpenGL pixel format.
     * @type {?NSOpenGLPixelFormat}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1523612-pixelformat
     */
    this.pixelFormat = null;

    ////////////////////////////////////////////////
    // SCNSceneRenderer
    ////////////////////////////////////////////////

    /**
     * Required. The graphics technology SceneKit uses to render the scene.
     * @access private
     * @type {SCNRenderingAPI}
     */
    this._renderingAPI = _SCNRenderingAPI2.default.webGL;

    // Participating in the Scene Rendering Process

    /**
     * Required. A delegate object that receives messages about SceneKit’s rendering process.
     * @access private
     * @type {?SCNSceneRendererDelegate}
     */
    this._delegate = null;

    // Customizing Scene Rendering with Metal

    //this._currentRenderCommandEncoder = null
    this._device = null; // MTLIGAccelDevice
    //this._commandQueue = null // MTLIGAccessCommandQueue
    //this._colorPixelFormat = null // MTLPixelFormat
    //this._depthPixelFormat = null // MTLPixelFormat
    //this._stencilPixelFormat = null // MTLPixelFormat

    // Rendering Sprite Kit Content over a Scene

    /**
     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
     * @type {?SKScene}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524051-overlayskscene
     */
    //this.overlaySKScene = null

    // Working With Positional Audio

    /**
     * Required. The node representing the listener’s position in the scene for use with positional audio effects.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523747-audiolistener
     */
    //this.audioListener = null

    //this._audioEnvironmentNode = null
    //this._audioEngine = null

    // Instance Properties

    /**
     * Required. 
     * @type {number}
     * @deprecated
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522854-currenttime
     */
    //this.currentTime = 0


    ////////////////////////////////////////////////
    // SCNTechniqueSupport
    ////////////////////////////////////////////////

    // Specifying a Technique

    /**
     * Required. The technique SceneKit uses when rendering the object.
     * @type {?SCNTechnique}
     * @see https://developer.apple.com/documentation/scenekit/scntechniquesupport/1520496-technique
     */
    this.technique = null;

    // for JavaScript

    /**
     * @access private
     * @type {CGRect}
     */
    this._frame = frame;

    /**
     * @access private
     * @type {HTMLCanvasElement}
     */
    this._canvas = document.createElement('canvas');
    this._canvas.tabIndex = 1; // to get keydown/up events, it needs to set tabIndex
    if (typeof frame === 'undefined') {
      frame = _CGRect2.default.rectWithXYWidthHeight(0, 0, 300, 300);
    }
    this._canvas.style.width = frame.width;
    this._canvas.style.height = frame.height;

    /**
     * @access private
     * @type {number}
     */
    this._canvasWidth = 0;

    /**
     * @access private
     * @type {number}
     */
    this._canvasHeight = 0;

    /**
     * @access private
     * @type {number}
     */
    this._currentSystemTime = 0;

    /**
     * @access private
     * @type {number}
     */
    this._elapsedTime = 0;

    /**
     * @access private
     * @type {number}
     */
    this._previousSystemTimeMs = 0;

    /**
     * @access private
     * @type {number}
     */
    this._sumElapsedTimeMs = 0;

    /**
     * @access private
     * @type {number}
     */
    this._sumFrames = 0;

    /**
     * @access private
     * @type {number}
     */
    this._lastFpsCalculationTimeMs = 0;

    /**
     * @access private
     * @type {number}
     */
    this._fpsCalculationSpanMs = 2000;

    /**
     * @access private
     * @type {number}
     */
    this._fps = 0;

    /**
     * @access private
     * @type {SCNSceneRenderer}
     */
    this._renderer = new _SCNRenderer2.default();
    //this._renderer.scene = this._scene
    //if(this._scene !== null){
    //  this._scene._physicsWorld._renderer = this._renderer
    //}

    /**
     * @access private
     * @type {function(function(timestamp: number))}
     */
    this._requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
      window.setTimeout(callback, 1000 / 60);
    };

    var preferLowPowerDevice = options ? options[SCNView.Option.preferLowPowerDevice] : null;
    var preferredDevice = options ? options[SCNView.Option.preferredDevice] : null;
    var preferredRenderingAPI = options ? options[SCNView.Option.preferredRenderingAPI] : null;
    var opt = {
      alpha: true,
      depth: true,
      stencil: true,
      antialias: true,
      premultipliedAlpha: true,
      preserveDrawingBuffer: false,
      preferLowPowerToHighPerformance: Boolean(preferLowPowerDevice),
      failIfMajorPerformanceCaveat: false

      //const contextNames = ['webgl2', 'webgl', 'webkit-3d', 'moz-webgl', 'experimental-webgl']
    };var contextNames = ['webgl2'];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = contextNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var name = _step.value;

        try {
          this._context = this._canvas.getContext(name, opt);
        } catch (e) {/* just ignore and try the next name */}
        if (this._context) {
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!this._context) {
      throw new Error('can\'t create WebGL context');
    }
    this._context.viewport(frame.minX, frame.minY, frame.width, frame.height);

    this._renderer._setContext(this._context);
    this._renderer._backgroundColor = this._backgroundColor;
    this._renderer._viewRect = frame;

    this._mouseIsDown = false;
    this._mouseDownX = 0;
    this._mouseDownY = 0;

    // add event listeners
    this._canvas.addEventListener('mousedown', function (e) {
      var ev = _this._createEvent(e);
      _this._mouseIsDown = true;
      _this._mouseDownX = e.clientX;
      _this._mouseDownY = e.clientY;
      if (_this.allowsCameraControl) {
        _this._baseCameraPosition = _this._renderer._getCameraPosition();
        _this._baseCameraOrientation = _this._renderer._getCameraOrientation();
        _this._baseCameraDistance = _this._renderer._getCameraDistance();
      }
      _this.mouseDownWith(ev);
    });
    this._canvas.addEventListener('mousemove', function (e) {
      var ev = _this._createEvent(e);
      _this.mouseMovedWith(ev);
      if (_this._mouseIsDown) {
        if (_this.allowsCameraControl) {
          var mx = e.clientX;
          var my = e.clientY;
          var dx = mx - _this._mouseDownX;
          var dy = my - _this._mouseDownY;
          var d = Math.sqrt(dx * dx + dy * dy);
          var rotScale = 0.01;
          if (d > 0) {
            var r = -d * 0.5 * rotScale;
            var sinr = Math.sin(r) / d;
            var q = new _SCNVector2.default(dy * sinr, dx * sinr, 0, Math.cos(r));
            var orientation = _this._baseCameraOrientation.cross(q);
            _this._renderer._setDefaultCameraOrientation(orientation);
          }
          _this._renderer._switchToDefaultCamera();
        }
        _this.mouseDraggedWith(ev);
      }
    });
    document.addEventListener('mouseup', function (e) {
      if (_this._mouseIsDown) {
        _this._mouseIsDown = false;
        var ev = _this._createEvent(e);
        _this.mouseUpWith(ev);
        _this._preventDefault(ev);
      }
    });
    this._canvas.addEventListener('mouseover', function (e) {
      var ev = _this._createEvent(e);
      _this._preventDefault(ev);
    });
    this._canvas.addEventListener('mouseout', function (e) {
      var ev = _this._createEvent(e);
      _this.mouseExitedWith(ev);
      _this._preventDefault(ev);
    });
    this._canvas.addEventListener('mousewheel', function (e) {
      var ev = _this._createEvent(e);
      _this.scrollWheelWith(ev);
      _this._preventDefault(ev);
    });

    this._canvas.addEventListener('keydown', function (e) {
      var ev = _this._createEvent(e);

      _this.keyDownWith(ev);
      _this._preventDefault(ev);
    });
    this._canvas.addEventListener('keyup', function (e) {
      var ev = _this._createEvent(e);

      _this.keyUpWith(ev);
      _this._preventDefault(ev);
    });
  }

  _createClass(SCNView, [{
    key: 'connectedCallback',
    value: function connectedCallback() {}
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {}
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback() {}

    /**
     * @access private
     * @returns {void}
     */

  }, {
    key: '_resizeCanvas',
    value: function _resizeCanvas() {
      var w = this._canvas.clientWidth;
      var h = this._canvas.clientHeight;
      if (this._frame && this._frame.width === w && this._frame.height === h) {
        return;
      }

      this._frame = _CGRect2.default.rectWithXYWidthHeight(0, 0, w, h);
      this._canvas.width = w;
      this._canvas.height = h;
      this._context.viewport(0, 0, w, h);
      this._renderer._viewRect = this._frame;

      this.setFrameSize(this._frame.size);
    }

    /**
     *
     * @access public
     * @param {HTMLElement} element - parent element to append this view
     * @returns {void}
     */

  }, {
    key: 'appendTo',
    value: function appendTo(element) {
      var _this2 = this;

      element.appendChild(this._canvas

      // update canvas size
      );if (typeof this._frame === 'undefined') {
        this._canvas.style.width = '100%';
        this._canvas.style.height = '100%';
        if (this._canvas.clientHeight <= 0) {
          this._canvas.style.height = 300;
        }
      }
      this._resizeCanvas();
      if (typeof window !== 'undefined') {
        window.addEventListener('resize', function () {
          _this2._resizeCanvas();
        });
      }
    }
  }, {
    key: 'pause',


    // Playing Action and Animation in a View’s Scene

    /**
     * Pauses playback of the view’s scene.
     * @access public
     * @param {?Object} sender - The object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.
     * @returns {void}
     * @desc This method has no effect if the scene is already paused.
     * @see https://developer.apple.com/documentation/scenekit/scnview/1522825-pause
     */
    value: function pause(sender) {
      if (!this._isPlaying) {
        return;
      }
      this._isPlaying = false;
    }

    /**
     * Resumes playback of the view’s scene.
     * @access public
     * @param {?Object} sender - The object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.
     * @returns {void}
     * @desc This method has no effect if the scene is not paused.
     * @see https://developer.apple.com/documentation/scenekit/scnview/1523699-play
     */

  }, {
    key: 'play',
    value: function play(sender) {
      if (this._isPlaying) {
        return;
      }
      this._isPlaying = true;

      this.__requestAnimationFrame();
    }

    /**
     * Stops playback of the view’s scene and resets the scene time to its start time.
     * @access public
     * @param {?Object} sender - The object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.
     * @returns {void}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1524132-stop
     */

  }, {
    key: 'stop',
    value: function stop(sender) {
      this._isPlaying = false;
    }

    // Capturing a View Snapshot

    /**
     * Renders the view’s scene into a new image object.
     * @access public
     * @returns {Image} - 
     * @desc This method is thread-safe and may be called at any time.
     * @see https://developer.apple.com/documentation/scenekit/scnview/1524031-snapshot
     */

  }, {
    key: 'snapshot',
    value: function snapshot() {
      return null;
    }

    // Structures
    /**
     * @type {Object} Option
     * @property {string} preferLowPowerDevice An option for whether to select low-power-usage devices for Metal rendering.
     * @property {string} preferredDevice The device to use for Metal rendering.
     * @property {string} preferredRenderingAPI The rendering API to use for rendering the view (for example, Metal or OpenGL).
     * @see https://developer.apple.com/documentation/scenekit/scnview.option
     */

  }, {
    key: 'presentWithIncomingPointOfView',


    ////////////////////////////////////////////////
    // SCNSceneRenderer
    ////////////////////////////////////////////////

    // Presenting a Scene

    /**
     * Required. Displays the specified scene with an animated transition.
     * @access public
     * @param {SCNScene} scene - The new scene to be displayed.
     * @param {SKTransition} transition - An object that specifies the duration and style of the animated transition.
     * @param {?SCNNode} pointOfView - The node to use as the pointOfView property when displaying the new scene.
     * @param {?function(): void} [completionHandler = null] - A block that SceneKit calls after the transition animation has completed.This block takes no parameters and has no return value.
     * @returns {void}
     * @desc Use this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523028-present
     */
    value: function presentWithIncomingPointOfView(scene, transition, pointOfView) {
      var completionHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    }

    // Managing Scene Display

    /**
     * Required. The node from which the scene’s contents are viewed for rendering.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523982-pointofview
     */

  }, {
    key: 'prepareShouldAbortBlock',


    // Preloading Renderer Resources

    /**
     * Required. Prepares a SceneKit object for rendering.
     * @access public
     * @param {Object} object - An SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.
     * @param {?function(): boolean} [block = null] - A block that SceneKit calls periodically while preparing the object. The block takes no parameters.Your block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.Pass nil for this parameter if you do not need an opportunity to cancel preparing the object.
     * @returns {boolean} - 
     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously. SceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.You can observe the progress of this operation with the Progress class. For details, see Progress.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522798-prepare
     */
    value: function prepareShouldAbortBlock(object) {
      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      return false;
    }

    /**
     * Required. Prepares the specified SceneKit objects for rendering, using a background thread.
     * @access public
     * @param {Object[]} objects - An array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.
     * @param {?function(arg1: boolean): void} [completionHandler = null] - A block that SceneKit calls when object preparation fails or completes.The block takes the following parameter:successtrue if all content was successfully prepared for rendering; otherwise, false.
     * @returns {void}
     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.SceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can observe the progress of this operation with the Progress class. For details, see Progress.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523375-prepare
     */

  }, {
    key: 'prepare',
    value: function prepare(objects) {
      var completionHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    }

    // Working With Projected Scene Contents

    /**
     * Required. Searches the renderer’s scene for objects corresponding to a point in the rendered image.
     * @access public
     * @param {CGPoint} point - 
     * @param {?Map<SCNHitTestOption, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
     * @returns {SCNHitTestResult[]} - 
     * @desc A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522929-hittest
     */

  }, {
    key: 'hitTest',
    value: function hitTest(point) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var x = (point.x - this._frame.minX) / this._frame.width * 2.0 - 1.0;
      var y = (point.y - this._frame.minY) / this._frame.height * 2.0 - 1.0;
      return this._renderer.hitTest(new _CGPoint2.default(x, -y), options);
    }

    /**
     * Required. Returns a Boolean value indicating whether a node might be visible from a specified point of view.
     * @access public
     * @param {SCNNode} node - The node whose visibility is to be tested.
     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
     * @returns {boolean} - 
     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.Note that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522647-isnode
     */

  }, {
    key: 'isNodeInsideFrustumOf',
    value: function isNodeInsideFrustumOf(node, pointOfView) {
      return false;
    }

    /**
     * Required. Returns all nodes that might be visible from a specified point of view.
     * @access public
     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
     * @returns {SCNNode[]} - 
     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node).Note that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522942-nodesinsidefrustum
     */

  }, {
    key: 'nodesInsideFrustumOf',
    value: function nodesInsideFrustumOf(pointOfView) {
      return null;
    }

    /**
     * Required. Projects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.
     * @access public
     * @param {SCNVector3} point - A point in the world coordinate system of the renderer’s scene.
     * @returns {SCNVector3} - 
     * @desc The z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524089-projectpoint
     */

  }, {
    key: 'projectPoint',
    value: function projectPoint(point) {
      return null;
    }

    /**
     * Required. Unprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.
     * @access public
     * @param {SCNVector3} point - A point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.
     * @returns {SCNVector3} - 
     * @desc The z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this line—for example, to find the geometry corresponding to the location of a click event in a view—use the hitTest(_:options:) method.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522631-unprojectpoint
     */

  }, {
    key: 'unprojectPoint',
    value: function unprojectPoint(point) {
      return null;
    }

    // Customizing Scene Rendering with Metal

    /**
     * Required. The Metal render command encoder in use for the current SceneKit rendering pass.
     * @type {?MTLRenderCommandEncoder}
     * @desc Use this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.This property is valid only during the SceneKit rendering loop—that is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522609-currentrendercommandencoder
     */

  }, {
    key: 'viewDidMoveToWindow',


    ////////////////////////////////////////////////
    // NSView/UIView
    ////////////////////////////////////////////////
    // TODO: implement NSView/UIView and extend it
    value: function viewDidMoveToWindow() {}
  }, {
    key: 'setFrameSize',
    value: function setFrameSize(newSize) {}

    /**
     * draw one frame
     * @access private
     * @param {number} time - current time
     * @param {WebGLRenderingContext} context - context to draw frame
     * @returns {void}
     */

  }, {
    key: '_drawAtTimeWithContext',
    value: function _drawAtTimeWithContext(time, context) {
      this._renderer._time = time;

      this._createPresentationNodes();
      this._createSKPresentationNodes();

      this._updateTransform();

      if (this._delegate && this._delegate.rendererUpdateAtTime) {
        this._delegate.rendererUpdateAtTime(this._renderer, time);
      }

      ///////////////////////////////
      // runs actions & animations //
      ///////////////////////////////
      this._copyTransformToPresentationNodes();
      this._copyTransformToPresentationSKNodes();
      this._updateTransform();

      this._runActions();
      this._runAnimations();
      this._runSKActions();

      this._updateTransform();

      if (this._delegate && this._delegate.rendererDidApplyAnimationsAtTime) {
        this._delegate.rendererDidApplyAnimationsAtTime(this._renderer, time);
      }

      this._updateTransform

      ///////////////////////
      // simulates physics //
      ///////////////////////
      ();if (this._scene && this._scene._physicsWorld !== null) {
        this._scene._physicsWorld._simulate(time);
      }

      if (this._delegate && this._delegate.rendererDidSimulatePhysicsAtTime) {
        this._delegate.rendererDidSimulatePhysicsAtTime(this._renderer, time);
      }

      ///////////////////////////
      // evaluates constraints //
      ///////////////////////////

      if (this._delegate && this._delegate.rendererWillRenderSceneAtTime) {
        this._delegate.rendererWillRenderSceneAtTime(this._renderer, this._scene, time);
      }

      ///////////////////////
      // renders the scene //
      ///////////////////////
      this._updateSkinner();
      this._updateMorph();
      this._updateParticles();

      this._updateSKTransform();
      this._renderer.render();

      if (this._delegate && this._delegate.rendererDidRenderSceneAtTime) {
        this._delegate.rendererDidRenderSceneAtTime(this._renderer, time);
      }
    }
  }, {
    key: '_createPresentationNodes',
    value: function _createPresentationNodes() {
      if (this._scene === null) {
        return;
      }

      var arr = [this._scene.rootNode];
      while (arr.length > 0) {
        var node = arr.shift();
        if (!node._presentation) {
          node._createPresentation();
        }
        arr.push.apply(arr, _toConsumableArray(node.childNodes));
      }
    }
  }, {
    key: '_copyTransformToPresentationNodes',
    value: function _copyTransformToPresentationNodes() {
      if (this._scene === null) {
        return;
      }

      var arr = [this._scene.rootNode, this._scene._skyBox, this._renderer._defaultCameraPosNode, this._renderer._defaultLightNode];
      while (arr.length > 0) {
        var node = arr.shift();
        node._copyTransformToPresentation();
        node._copyMaterialPropertiesToPresentation();
        arr.push.apply(arr, _toConsumableArray(node.childNodes));
      }
    }
  }, {
    key: '_createSKPresentationNodes',
    value: function _createSKPresentationNodes() {
      if (this.overlaySKScene === null) {
        return;
      }

      var arr = [this.overlaySKScene];
      while (arr.length > 0) {
        var node = arr.shift();
        var p = node.__presentation;
        if (p === null) {
          p = node.copy();
          p._isPresentationInstance = true;
          node.__presentation = p;
        }
        //node._copyTransformToPresentation()

        arr.push.apply(arr, _toConsumableArray(node.children));
      }
    }
  }, {
    key: '_copyTransformToPresentationSKNodes',
    value: function _copyTransformToPresentationSKNodes() {
      if (this.overlaySKScene === null) {
        return;
      }

      var arr = [this.overlaySKScene];
      while (arr.length > 0) {
        var node = arr.shift();
        node._copyTransformToPresentation();
        arr.push.apply(arr, _toConsumableArray(node.children));
      }
    }

    /**
     * request animation frame repeatedly as long as isPlaying is true
     * @access private
     * @returns {void}
     */

  }, {
    key: '__requestAnimationFrame',
    value: function __requestAnimationFrame() {
      var _this3 = this;

      // Reflect.apply(this._requestAnimationFrame, window, () => {
      this._requestAnimationFrame.call(window, function () {
        var time = Date.now();

        var elapsedTimeMs = 0;
        if (_this3._previousSystemTimeMs) {
          elapsedTimeMs = time - _this3._previousSystemTimeMs;
        }
        if (elapsedTimeMs) {
          if (!_this3._lastFpsCalculationTimeMs) {
            _this3._lastFpsCalculationTime = time;
          }
          _this3._sumElapsedTimeMs += elapsedTimeMs;
          _this3._sumFrames += 1;

          if (time - _this3._lastFpsCalculationTimeMs > _this3._fpsCalculationSpanMs) {
            _this3._fps = _this3._sumFrames / (_this3._sumElapsedTimeMs * 0.001);

            _this3._sumFrames = 0;
            _this3._sumElapsedTimeMs = 0;
            _this3._lastFpsCalculationTimeMs = time;

            console.error('fps: ' + _this3._fps);
          }
        }

        _this3._currentSystemTime = time * 0.001;
        _this3._elapsedTime = elapsedTimeMs * 0.001;
        _this3.currentTime = _this3._currentSystemTime;
        _GCController2.default._update();
        _this3._drawAtTimeWithContext(_this3.currentTime, _this3._context);

        if (_this3._isPlaying) {
          _this3.__requestAnimationFrame();
        }
        _this3._previousSystemTimeMs = time;
      });
    }
  }, {
    key: '_updateTransform',
    value: function _updateTransform(node, parentTransform) {
      if (this._scene === null) {
        return;
      }
      this._scene.rootNode._updateWorldTransform();
      this._scene.rootNode._updateBoundingBox();
    }
  }, {
    key: '_updateSkinner',
    value: function _updateSkinner(node) {
      var _this4 = this;

      if (typeof node === 'undefined') {
        if (this._scene) {
          this._updateSkinner(this._scene.rootNode);
        }
        return;
      }
      if (node.skinner !== null && !node.skinner._useGPU) {
        node.skinner._update(node);
      }
      node.childNodes.forEach(function (child) {
        _this4._updateSkinner(child);
      });
    }
  }, {
    key: '_updateMorph',
    value: function _updateMorph(node) {
      var _this5 = this;

      if (typeof node === 'undefined') {
        if (this._scene) {
          this._updateMorph(this._scene.rootNode);
        }
        return;
      }
      if (node.morpher !== null) {
        node.morpher._morph(node);
      }
      node.childNodes.forEach(function (child) {
        _this5._updateMorph(child);
      });
    }
  }, {
    key: '_updateSKTransform',
    value: function _updateSKTransform() {
      if (this.overlaySKScene === null) {
        return;
      }
      this.overlaySKScene._updateWorldTransform();
    }
  }, {
    key: '_runActions',
    value: function _runActions() {
      if (this._scene === null) {
        return;
      }
      this._runActionForNode(this._scene.rootNode);
    }
  }, {
    key: '_runActionForNode',
    value: function _runActionForNode(node) {
      var _this6 = this;

      this._runActionForObject(node);
      node.childNodes.forEach(function (child) {
        return _this6._runActionForNode(child);
      });
    }
  }, {
    key: '_runActionForObject',
    value: function _runActionForObject(obj) {
      var _this7 = this;

      var deleteKeys = [];
      obj._actions.forEach(function (action, key) {
        action._applyAction(obj, _this7.currentTime);
        if (action._finished) {
          if (action._completionHandler) {
            action._completionHandler();
          }
          deleteKeys.push(key);
        }
      });
      deleteKeys.forEach(function (key) {
        obj._actions.delete(key);
      });
    }
  }, {
    key: '_runSKActions',
    value: function _runSKActions() {
      if (this.overlaySKScene === null) {
        return;
      }
      this._runSKActionForNode(this.overlaySKScene);
    }
  }, {
    key: '_runSKActionForNode',
    value: function _runSKActionForNode(node) {
      var _this8 = this;

      this._runSKActionForObject(node);
      node.children.forEach(function (child) {
        return _this8._runSKActionForNode(child);
      });
    }
  }, {
    key: '_runSKActionForObject',
    value: function _runSKActionForObject(obj) {
      var _this9 = this;

      var deleteKeys = [];
      obj._actions.forEach(function (action, key) {
        action._applyAction(obj, _this9.currentTime);
        if (action._finished) {
          if (action._completionHandler) {
            action._completionHandler();
          }
          deleteKeys.push(key);
        }
      });
      deleteKeys.forEach(function (key) {
        obj._actions.delete(key);
      });
    }
  }, {
    key: '_runAnimations',
    value: function _runAnimations() {
      if (this._scene === null) {
        return;
      }
      this._runAnimationForNode(this._scene.rootNode);
    }
  }, {
    key: '_runAnimationForNode',
    value: function _runAnimationForNode(node) {
      var _this10 = this;

      node.childNodes.forEach(function (child) {
        return _this10._runAnimationForNode(child);
      });
      this._runAnimationForObject(node
      // TODO: implement animations for all animatable objects:
      //         SCNCamera, SCNConstraint, SCNGeometry, SCNLight, SCNMaterial, 
      //         SCNMaterialProperty, SCNMorpher, SCNParticleSystem, SCNTechnique
      );if (node.geometry) {
        this._runAnimationForObject(node.geometry);
        node.geometry.materials.forEach(function (material) {
          _this10._runAnimationForObject(material);
          var properties = [material._diffuse, material._ambient, material._specular, material._normal, material._reflective, material._emission, material._transparent, material._multiply, material._ambientOcclusion, material._selfIllumination, material._metalness, material._roughness];
          properties.forEach(function (prop) {
            _this10._runAnimationForObject(prop);
          });
        });
      }
      if (node._particleSystems) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = node._particleSystems[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var system = _step2.value;

            this._runAnimationForObject(system);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }
  }, {
    key: '_runAnimationForObject',
    value: function _runAnimationForObject(obj) {
      var _this11 = this;

      var deleteKeys = [];
      obj._animations.forEach(function (animation, key) {
        animation._applyAnimation(obj, _this11.currentTime);
        if (animation._isFinished && animation.isRemovedOnCompletion) {
          deleteKeys.push(key);
        }
      });
      deleteKeys.forEach(function (key) {
        obj._animations.delete(key);
      });
    }
  }, {
    key: '_updateParticles',
    value: function _updateParticles() {
      if (this._scene === null) {
        return;
      }
      this._updateParticlesForScene();
      this._updateParticlesForNode(this._scene.rootNode);
    }
  }, {
    key: '_updateParticlesForScene',
    value: function _updateParticlesForScene() {
      if (this._scene._particleSystems === null) {
        return;
      }
      var gravity = this._scene.physicsWorld ? this._scene.physicsWorld.gravity : null;
      var len = this._scene._particleSystems.length;
      for (var i = 0; i < len; i++) {
        var system = this._scene._particleSystems[i];
        var transform = this._scene._particleSystemsTransform[i];
        system._updateParticles(transform, gravity, this.currentTime);
      }
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this._scene._particleSystems[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _system = _step3.value;

          if (_system._finished) {
            this._scene.removeParticleSystem(_system);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: '_updateParticlesForNode',
    value: function _updateParticlesForNode(node) {
      var _this12 = this;

      this._updateParticlesForObject(node);
      node.childNodes.forEach(function (child) {
        return _this12._updateParticlesForNode(child);
      });
    }
  }, {
    key: '_updateParticlesForObject',
    value: function _updateParticlesForObject(obj) {
      if (obj.particleSystems === null) {
        return;
      }
      var gravity = this._scene.physicsWorld ? this._scene.physicsWorld.gravity : null;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = obj.particleSystems[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var system = _step4.value;

          system._updateParticles(obj.presentation.worldTransform, gravity, this.currentTime);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = obj.particleSystems[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _system2 = _step5.value;

          if (_system2._finished) {
            obj.removeParticleSystem(_system2);
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }

    // NSView

    /**
     * @access private
     * @param {Event} e -
     * @returns {NSEvent} -
     */

  }, {
    key: '_createEvent',
    value: function _createEvent(e) {
      // TODO: implement NSEvent
      var ev = {};

      ev.locationInWindow = new _CGPoint2.default(e.clientX, e.clientY);

      ev.modifierFlags = 0; // TODO: implement
      ev.timestamp = e.timeStamp;
      // ev.type

      if (typeof window !== 'undefined') {
        ev.window = window;
      }
      ev.windowNumber = 0;
      ev.eventRef = e;
      ev.cgEvent = null;
      ev.characters = null; // TODO: implement
      ev.charactersIgnoringModifiers = null; // TODO: implement

      ev.isARepeat = false;
      if (typeof e.repeat !== 'undefined') {
        ev.isARepeat = e.repeat;
      }

      if (e.code && _KeyCode.has(e.code)) {
        ev.keyCode = _KeyCode.get(e.code);
      } else {
        ev.keyCode = 0;
      }

      ev.buttonNumber = 0;
      ev.clickCount = 0;
      ev.associatedEventsMask = null;
      ev.eventNumber = 0;
      ev.trackingNumber = 0;
      ev.trackingArea = 0;
      ev.userData = null;

      ev.data1 = 0;
      ev.data2 = 0;
      ev.sutype = null;

      ev.deltaX = e.deltaX;
      ev.deltaY = e.deltaY;
      ev.deltaZ = e.deltaZ;

      ev._doDefaultAction = false;
      return ev;
    }
  }, {
    key: '_preventDefault',
    value: function _preventDefault(e) {
      if (!e._doDefaultAction) {
        e.eventRef.preventDefault();
      }
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'mouseDownWith',
    value: function mouseDownWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'mouseDraggedWith',
    value: function mouseDraggedWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'mouseUpWith',
    value: function mouseUpWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'mouseMovedWith',
    value: function mouseMovedWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'mouseEnteredWith',
    value: function mouseEnteredWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'mouseExitedWith',
    value: function mouseExitedWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'rightMouseDraggedWith',
    value: function rightMouseDraggedWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'rightMouseUpWith',
    value: function rightMouseUpWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'otherMouseDownWith',
    value: function otherMouseDownWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'otherMouseDraggedWith',
    value: function otherMouseDraggedWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'otherMouseUpWith',
    value: function otherMouseUpWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'scrollWheelWith',
    value: function scrollWheelWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'keyDownWith',
    value: function keyDownWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'keyUpWith',
    value: function keyUpWith(theEvent) {
      theEvent._doDefaultAction = true;
    }

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'flagsChangedWith',
    value: function flagsChangedWith(theEvent) {}

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'tablePointWith',
    value: function tablePointWith(theEvent) {}

    /**
     * @access public
     * @param {NSEvent} theEvent -
     * @returns {void}
     */

  }, {
    key: 'tableProximityWith',
    value: function tableProximityWith(theEvent) {}
  }, {
    key: 'convertFrom',
    value: function convertFrom(point, view) {
      var sx = 0;
      var sy = 0;
      if (view) {
        // FIXME: add accessor functions to get the element position
        sx = view._frame.origin.x;
        sy = view._frame.origin.y;
      }
      // FIXME: add accessor functions to get the element position
      var rect = this._canvas.getBoundingClientRect();
      var dx = rect.left;
      var dy = rect.top;

      return new _CGPoint2.default(point.x + sx - dx, point.y + sy - dy);
    }

    /**
     * @type {CGRect}
     */

  }, {
    key: 'backgroundColor',
    get: function get() {
      return this._backgroundColor;
    },
    set: function set(newValue) {
      this._backgroundColor = newValue;
      //this._context.clearColor(newValue.r, newValue.g, newValue.b, newValue.a)
      this._renderer._backgroundColor = newValue;
    }

    /**
     * Required. A Boolean value that determines whether the scene is playing.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523401-isplaying
     */

  }, {
    key: 'isPlaying',
    get: function get() {
      return this._renderer.isPlaying;
    }

    /**
     * Required. A Boolean value that determines whether the scene is playing.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523401-isplaying
     */
    ,
    set: function set(newValue) {
      if (newValue) {
        this.play();
      } else {
        this.pause();
      }
    }

    // Specifying a Scene

    /**
     * The scene to be displayed in the view.
     * @access private
     * @type {?SCNScene}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1523904-scene
     */

  }, {
    key: 'scene',
    get: function get() {
      return this._scene;
    }

    /**
     * The scene to be displayed in the view.
     * @access private
     * @type {?SCNScene}
     * @see https://developer.apple.com/documentation/scenekit/scnview/1523904-scene
     */
    ,
    set: function set(newValue) {
      // FIXME: it should not be changed while drawing
      this._scene = newValue;
      this._renderer.scene = this._scene;
      if (this._scene === null) {
        return;
      }
      this._scene._physicsWorld._renderer = this._renderer;
      this._updateTransform();
      this._scene.rootNode._resetPhysicsTransformRecursively();
    }
  }, {
    key: 'pointOfView',
    get: function get() {
      return this._renderer.pointOfView;
    },
    set: function set(newValue) {
      this._renderer.pointOfView = newValue;
    }

    /**
     * Required. A Boolean value that determines whether SceneKit automatically adds lights to a scene.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting
     */

  }, {
    key: 'autoenablesDefaultLighting',
    get: function get() {
      return this._renderer.autoenablesDefaultLighting;
    },
    set: function set(newValue) {
      this._renderer.autoenablesDefaultLighting = newValue;
    }

    /**
     * Required. A Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524026-isjitteringenabled
     */

  }, {
    key: 'isJitteringEnabled',
    get: function get() {
      return this._renderer.isJitteringEnabled;
    },
    set: function set(newValue) {
      this._renderer.isJitteringEnabled = newValue;
    }

    /**
     * Required. A Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522763-showsstatistics
     */

  }, {
    key: 'showsStatistics',
    get: function get() {
      return this._renderer.showsStatistics;
    },
    set: function set(newValue) {
      this._renderer.showsStatistics = newValue;
    }

    /**
     * Required. Options for drawing overlay content in a scene that can aid debugging.
     * @type {SCNDebugOptions}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523281-debugoptions
     */

  }, {
    key: 'debugOptions',
    get: function get() {
      return this._renderer.debugOptions;
    },
    set: function set(newValue) {
      this._renderer.debugOptions = newValue;
    }

    /**
     * Required. The current scene time.
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522680-scenetime
     */

  }, {
    key: 'sceneTime',
    get: function get() {
      return this._renderer.sceneTime;
    },
    set: function set(newValue) {
      this._renderer.sceneTime = newValue;
    }

    /**
     * Required. A Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522878-loops
     */

  }, {
    key: 'loops',
    get: function get() {
      return this._renderer.loops;
    },
    set: function set(newValue) {
      this._renderer.loops = newValue;
    }

    /**
     * Required. The graphics technology SceneKit uses to render the scene.
     * @type {SCNRenderingAPI}
     * @desc You choose a graphics technology when initializing a scene renderer:When initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.To create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.The rendering technology used by a SCNLayer object is determined by Core Animation.After initializing a renderer, this property reflects the rendering technology in use.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522616-renderingapi
     */

  }, {
    key: 'renderingAPI',
    get: function get() {
      return this._renderingAPI;
    }

    // Participating in the Scene Rendering Process

    /**
     * Required. A delegate object that receives messages about SceneKit’s rendering process.
     * @type {?SCNSceneRendererDelegate}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522671-delegate
     */

  }, {
    key: 'delegate',
    get: function get() {
      return this._delegate;
    }

    /**
     * Required. A delegate object that receives messages about SceneKit’s rendering process.
     * @type {?SCNSceneRendererDelegate}
     * @param {?SCNSceneRendererDelegate} newValue -
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522671-delegate
     */
    ,
    set: function set(newValue) {
      // FIXME: delegate should not be changed while drawing
      this._delegate = newValue;
    }
  }, {
    key: 'currentRenderCommandEncoder',
    get: function get() {
      return this._renderer.currentRenderCommandEncoder;
    }

    /**
     * Required. The Metal device this renderer uses for rendering.
     * @type {?MTLDevice}
     * @desc Use this property to create or look up other Metal resources that use the same device as your SceneKit renderer.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523935-device
     */

  }, {
    key: 'device',
    get: function get() {
      return this._device;
    }

    /**
     * Required. The Metal command queue this renderer uses for rendering.
     * @type {?MTLCommandQueue}
     * @desc Use this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523974-commandqueue
     */

  }, {
    key: 'commandQueue',
    get: function get() {
      return this._renderer.commandQueue;
    }

    /**
     * Required. The Metal pixel format for the renderer’s color output.
     * @type {MTLPixelFormat}
     * @desc Use this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523701-colorpixelformat
     */

  }, {
    key: 'colorPixelFormat',
    get: function get() {
      return this._renderer.colorPixelFormat;
    }

    /**
     * Required. The Metal pixel format for the renderer’s depth buffer.
     * @type {MTLPixelFormat}
     * @desc Use this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523780-depthpixelformat
     */

  }, {
    key: 'depthPixelFormat',
    get: function get() {
      return this._renderer.depthPixelFormat;
    }

    /**
     * Required. The Metal pixel format for the renderer’s stencil buffer.
     * @type {MTLPixelFormat}
     * @desc Use this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523315-stencilpixelformat
     */

  }, {
    key: 'stencilPixelFormat',
    get: function get() {
      return this._renderer._stencilPixelFormat;
    }

    // Customizing Scene Rendering with OpenGL

    /**
     * Required. The OpenGL rendering context that SceneKit uses for rendering the scene.
     * @type {?WebGLRenderingContext}
     * @desc In macOS, the value of this property is a Core OpenGL cglContextObj object.In iOS, the value of this property is an EAGLContext object.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522840-context
     */

  }, {
    key: 'context',
    get: function get() {
      return this._renderer.context;
    }

    // Rendering Sprite Kit Content over a Scene

    /**
     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
     * @type {?SKScene}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1524051-overlayskscene
     */

  }, {
    key: 'overlaySKScene',
    get: function get() {
      return this._renderer.overlaySKScene;
    },
    set: function set(newValue) {
      this._renderer.overlaySKScene = newValue;
    }

    // Working With Positional Audio

    /**
     * Required. The node representing the listener’s position in the scene for use with positional audio effects.
     * @type {?SCNNode}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523747-audiolistener
     */

  }, {
    key: 'audioListener',
    get: function get() {
      return this._renderer.audioListener;
    },
    set: function set(newValue) {
      this._renderer.audioListener = newValue;
    }

    /**
     * Required. The 3D audio mixing node SceneKit uses for positional audio effects.
     * @type {AVAudioEnvironmentNode}
     * @desc SceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1523582-audioenvironmentnode
     */

  }, {
    key: 'audioEnvironmentNode',
    get: function get() {
      return this._renderer.audioEnvironmentNode;
    }

    /**
     * Required. The audio engine SceneKit uses for playing scene sounds.
     * @type {AVAudioEngine}
     * @desc SceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522686-audioengine
     */

  }, {
    key: 'audioEngine',
    get: function get() {
      return this._renderer.audioEngine;
    }

    // Instance Properties

    /**
     * Required. 
     * @type {number}
     * @see https://developer.apple.com/documentation/scenekit/scnscenerenderer/1522854-currenttime
     */

  }, {
    key: 'currentTime',
    get: function get() {
      return this._renderer.currentTime;
    },
    set: function set(newValue) {
      this._renderer.currentTime = newValue;
    }
  }, {
    key: 'bounds',
    get: function get() {
      var rect = this._canvas.getBoundingClientRect();
      return new _CGRect2.default(new _CGPoint2.default(rect.left, rect.top), new _CGSize2.default(rect.width, rect.height));
    }
  }], [{
    key: 'Option',
    get: function get() {
      return _Option;
    }
  }]);

  return SCNView;
}();

// TODO: use extension of HTMLElement when it's supported.
//if(customElements){
//  customElements.define('scn-view', SCNView)
//}


exports.default = SCNView;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SKAction2 = __webpack_require__(20);

var _SKAction3 = _interopRequireDefault(_SKAction2);

var _SKActionTimingMode = __webpack_require__(23);

var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

var _SKNode = __webpack_require__(19);

var _SKNode2 = _interopRequireDefault(_SKNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SKFade = function (_SKAction) {
  _inherits(SKFade, _SKAction);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SKFade() {
    _classCallCheck(this, SKFade);

    var _this = _possibleConstructorReturn(this, (SKFade.__proto__ || Object.getPrototypeOf(SKFade)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SKActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;

    _this._toValue = null;
    _this._byValue = null;
    return _this;
  }

  /**
   * Creates an action that changes the alpha value of the node to 1.0.
   * @access public
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s alpha property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeOut(withDuration: sec)
  let action = SKAction.fadeOut(withDuration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417818-fadein
   */


  _createClass(SKFade, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SCNActionFade} -
     */
    value: function copy() {
      var action = _get(SKFade.prototype.__proto__ || Object.getPrototypeOf(SKFade.prototype), 'copy', this).call(this);

      action._toValue = this._toValue;
      action._byValue = this._byValue;
      action._duration = this._duration;

      return action;
    }

    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAction',
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var t = this._getTime(time, needTimeConversion);
      if (!(obj instanceof _SKNode2.default)) {
        throw new Error('unsupported class for SKFade: ' + obj.constructor.name);
      }

      var baseValue = obj.alpha;
      var toValue = 0;
      if (this._toValue !== null) {
        toValue = this._toValue;
      } else if (this._byValue !== null) {
        toValue = baseValue + this._byValue;
      } else {
        throw new Error('both toValue and byValue are null');
      }

      var value = this._lerp(baseValue, toValue, t);
      obj._presentation.alpha = value;

      if (this._finished) {
        obj.alpha = toValue;
      }
    }
  }], [{
    key: 'fadeInWithDuration',
    value: function fadeInWithDuration(sec) {
      var action = new SKFade();
      action._toValue = 1;
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that changes the alpha value of the node to 0.0.
     * @access public
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s alpha property animates from its current value to 0.0. This causes the node to disappear.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeIn(withDuration: sec)
    let action = SKAction.fadeIn(withDuration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417738-fadeout
     */

  }, {
    key: 'fadeOutWithDuration',
    value: function fadeOutWithDuration(sec) {
      var action = new SKFade();
      action._toValue = 0;
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that adjusts the alpha value of a node by a relative value.
     * @access public
     * @param {number} factor - The amount to add to the node’s alpha value.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s alpha property animates to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeAlpha(by: -factor, duration: sec)
    let action = SKAction.fadeAlpha(by: -factor, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417716-fadealpha
     */

  }, {
    key: 'fadeAlphaByDuration',
    value: function fadeAlphaByDuration(factor, sec) {
      var action = new SKFade();
      action._byValue = factor;
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that adjusts the alpha value of a node to a new value.
     * @access public
     * @param {number} alpha - The new value of the node’s alpha.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s alpha property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417673-fadealpha
     */

  }, {
    key: 'fadeAlphaToDuration',
    value: function fadeAlphaToDuration(alpha, sec) {
      var action = new SKFade();
      action._toValue = alpha;
      action._duration = sec;
      return action;
    }
  }]);

  return SKFade;
}(_SKAction3.default);

exports.default = SKFade;


_SKAction3.default.fadeInWithDuration = SKFade.fadeInWithDuration;
_SKAction3.default.fadeOutWithDuration = SKFade.fadeOutWithDuration;
_SKAction3.default.fadeAlphaByDuration = SKFade.fadeAlphaByDuration;
_SKAction3.default.fadeAlphaToDuration = SKFade.fadeAlphaToDuration;

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SKAction2 = __webpack_require__(20);

var _SKAction3 = _interopRequireDefault(_SKAction2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SKActionTimingMode from './SKActionTimingMode'
//import SKNode from './SKNode'

var SKGroup = function (_SKAction) {
  _inherits(SKGroup, _SKAction);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SKGroup() {
    _classCallCheck(this, SKGroup);

    var _this = _possibleConstructorReturn(this, (SKGroup.__proto__ || Object.getPrototypeOf(SKGroup)).call(this));

    _this._actions = [];
    return _this;
  }

  /**
   * Creates an action that runs a collection of actions in parallel.
   * @access public
   * @param {SKAction[]} actions - An array of SKAction objects.
   * @returns {SKAction} - 
   * @desc When the action executes, the actions that comprise the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the group’s duration, the action completes, then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417688-group
   */


  _createClass(SKGroup, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SCNActionFade} -
     */
    value: function copy() {
      var action = _get(SKGroup.prototype.__proto__ || Object.getPrototypeOf(SKGroup.prototype), 'copy', this).call(this);

      action._actions = [];
      this._actions.forEach(function (act) {
        action._actions.push(act.copy());
      });

      return action;
    }
  }, {
    key: '_applyAction',


    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var duration = this._activetimeFromTime(time);

      var finished = true;
      this._actions.forEach(function (action) {
        if (!action._finished) {
          action._applyAction(obj, duration, needTimeConversion);
          if (!action._finished) {
            finished = false;
          }
        }
      });
      this._finished = finished;
    }
  }, {
    key: '_resetFinished',
    value: function _resetFinished() {
      this._actions.forEach(function (action) {
        action._resetFinished();
      });
      this._finished = false;
    }
  }, {
    key: 'duration',
    get: function get() {
      var d = 0;
      this._actions.forEach(function (act) {
        if (d < act.duration) {
          d = act.duration;
        }
      });
      return d;
    }
  }], [{
    key: 'group',
    value: function group(actions) {
      var action = new SKGroup();
      action._actions = actions;
      return action;
    }
  }]);

  return SKGroup;
}(_SKAction3.default);

exports.default = SKGroup;


_SKAction3.default.group = SKGroup.group;

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _SKNode2 = __webpack_require__(19);

var _SKNode3 = _interopRequireDefault(_SKNode2);

var _SKLabelVerticalAlignmentMode = __webpack_require__(114);

var _SKLabelVerticalAlignmentMode2 = _interopRequireDefault(_SKLabelVerticalAlignmentMode);

var _SKLabelHorizontalAlignmentMode = __webpack_require__(113);

var _SKLabelHorizontalAlignmentMode2 = _interopRequireDefault(_SKLabelHorizontalAlignmentMode);

var _SKBlendMode = __webpack_require__(28);

var _SKBlendMode2 = _interopRequireDefault(_SKBlendMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @access private
 * @type {string}
 */
var _defaultVertexShader = '#version 300 es\n  precision mediump float;\n\n  in vec3 position;\n  in vec2 texcoord;\n\n  uniform float screenWidth;\n  uniform float screenHeight;\n\n  out vec2 v_texcoord;\n\n  void main() {\n    vec3 pos = position;\n    pos.x = (pos.x * 2.0 / screenWidth) - 1.0;\n    pos.y = (pos.y * 2.0 / screenHeight) - 1.0;\n    v_texcoord = texcoord;\n    gl_Position = vec4(pos, 1.0);\n  }\n';

/**
 * @access private
 * @type {string}
 */
var _defaultFragmentShader = '#version 300 es\n  precision mediump float;\n\n  uniform sampler2D spriteTexture;\n  uniform float alpha;\n  in vec2 v_texcoord;\n\n  out vec4 outColor;\n\n  void main() {\n    outColor = texture(spriteTexture, v_texcoord);\n    outColor.a *= alpha;\n  }\n';

/**
 * A node that displays a text label.
 * @access public
 * @extends {SKNode}
 * @see https://developer.apple.com/documentation/spritekit/sklabelnode
 */

var SKLabelNode = function (_SKNode) {
  _inherits(SKLabelNode, _SKNode);

  // Creating a New Label Node

  /**
   * Initializes a new label object with a text string.
   * @access public
   * @constructor
   * @param {?string} text - The text to use to initialize the label node.
   * @desc The label node’s font is set to Helvetica Neue Ultra Light, 32 point.
   * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519612-init
   */
  function SKLabelNode(text) {
    _classCallCheck(this, SKLabelNode);

    // Configuring the Label Message

    /**
     * The string that the label node displays.
     * @access private
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519788-text
     */
    var _this = _possibleConstructorReturn(this, (SKLabelNode.__proto__ || Object.getPrototypeOf(SKLabelNode)).call(this));

    _this._text = null;

    // Configuring the Label Font

    /**
     * The color of the label.
     * @access private
     * @type {?CGColor}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1520057-fontcolor
     */
    _this._fontColor = new _SKColor2.default(1.0, 1.0, 1.0, 1.0);

    /**
     * The font used for the text in the label.
     * @access private
     * @type {?string}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1520129-fontname
     */
    _this._fontName = 'HelveticaNeue-UltraLight';

    /**
     * The size of the font used in the label.
     * @access private
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1520208-fontsize
     */
    _this._fontSize = 32.0;

    // Configuring the Label’s Position

    /**
     * The vertical position of the text within the node.
     * @access private
     * @type {SKLabelVerticalAlignmentMode}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519933-verticalalignmentmode
     */
    _this._verticalAlignmentMode = _SKLabelVerticalAlignmentMode2.default.baseline;

    /**
     * The horizontal position of the text within the node.
     * @access private
     * @type {SKLabelHorizontalAlignmentMode}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519711-horizontalalignmentmode
     */
    _this._horizontalAlignmentMode = _SKLabelHorizontalAlignmentMode2.default.center;

    // Performing Color Blending

    /**
     * The label’s blend color.
     * @type {?CGColor}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519938-color
     */
    _this.color = new _SKColor2.default(1.0, 1.0, 1.0, 1.0);

    /**
     * A floating-point value that describes how the color is blended with the font color.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519724-colorblendfactor
     */
    _this.colorBlendFactor = 0.0;

    // Blending the Label into the Framebuffer

    /**
     * The blend mode used to draw the label into the parent’s framebuffer.
     * @type {SKBlendMode}
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519598-blendmode
     */
    _this.blendMode = _SKBlendMode2.default.alpha;

    _this._canvas = document.createElement('canvas');
    _this._context = _this._canvas.getContext('2d');
    _this._glContext = null;
    _this._texture = null;
    _this._textureUpToDate = false;

    /**
     * @access private
     * @type {WebGLProgram}
     */
    _this._program = null;

    _this._vertexArrayObject = null;
    _this._vertexBuffer = null;
    _this._indexBuffer = null;

    _this.text = text;
    return _this;
  }

  /**
   * Initializes a new label object with a specified font.
   * @access public
   * @param {?string} fontName - The name of the font used by the label.
   * @returns {SKLabelNode} -
   * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519917-init
   */


  _createClass(SKLabelNode, [{
    key: '_updateCanvas',
    value: function _updateCanvas() {
      this._context.font = this._fontSize + 'px ' + this._fontName;
      var metrics = this._context.measureText(this._text);
      this._canvas.width = metrics.width;
      this._canvas.height = this._fontSize * 3;

      this._context.font = this._fontSize + 'px ' + this._fontName;
      this._context.fillStyle = this._fontColor.hexColor;

      switch (this._verticalAlignmentMode) {
        case _SKLabelVerticalAlignmentMode2.default.baseline:
          this._context.textBaseline = 'alphabetic';
          break;
        case _SKLabelVerticalAlignmentMode2.default.center:
          this._context.textBaseline = 'middle';
          break;
        case _SKLabelVerticalAlignmentMode2.default.top:
          this._context.textBaseline = 'top';
          break;
        case _SKLabelVerticalAlignmentMode2.default.bottom:
          this._context.textBaseline = 'bottom';
          break;
        default:
          throw new Error('unknown vertical alignment mode: ' + this._verticalAlignmentMode);
      }

      //switch(this._horizontalAlignmentMode){
      //  case SKLabelHorizontalAlignmentMode.center:
      //    this._context.textAlign = 'center'
      //    break
      //  case SKLabelHorizontalAlignmentMode.left:
      //    this._context.textAlign = 'left'
      //    break
      //  case SKLabelHorizontalAlignmentMode.right:
      //    this._context.textAlign = 'right'
      //    break
      //  default:
      //    throw new Error(`unknown horizontal alignment mode: ${this._horizontalAlignmentMode}`)
      //}
      this._context.textAlign = 'left';

      this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
      this._context.fillText(this._text, 0, this._canvas.height * 0.5);
      this._textureUpToDate = false;
    }

    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @param {CGRect} viewRect -
     * @returns {void}
     */

  }, {
    key: '_render',
    value: function _render(gl, viewRect) {
      var p = this.__presentation;
      if (this._texture === null || this._glContext !== gl) {
        this._glContext = gl;
        this._texture = gl.createTexture();
        this._textureUpToDate = false;
      }
      if (!this._textureUpToDate) {
        gl.bindTexture(gl.TEXTURE_2D, this._texture
        // texImage2D(target, level, internalformat, width, height, border, format, type, source)
        );gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._canvas.width, this._canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this._canvas);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);

        this._textureUpToDate = true;
      }
      if (this._program === null) {
        this._program = this._createProgram(gl);
      }
      var program = this._program;
      gl.useProgram(program);

      if (this._vertexArrayObject === null) {
        this._createVertexArrayObject(gl, program);
      }
      gl.bindVertexArray(this._vertexArrayObject);

      gl.uniform1f(gl.getUniformLocation(program, 'screenWidth'), viewRect.size.width);
      gl.uniform1f(gl.getUniformLocation(program, 'screenHeight'), viewRect.size.height);
      gl.uniform1f(gl.getUniformLocation(program, 'alpha'), p.alpha);

      var data = this._createVertexData();
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform1i(gl.getUniformLocation(program, 'spriteTexture'), 0);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this._texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);
    }
  }, {
    key: '_createProgram',
    value: function _createProgram(gl) {
      var program = gl.createProgram();
      var vsText = _defaultVertexShader;
      var fsText = _defaultFragmentShader;

      // initialize vertex shader
      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vsText);
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(vertexShader);
        throw new Error('SKSpriteNode vertex shader compile error: ' + info);
      }

      // initialize fragment shader
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fsText);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        var _info = gl.getShaderInfoLog(fragmentShader);
        throw new Error('particle fragment shader compile error: ' + _info);
      }

      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader

      // link program object
      );gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var _info2 = gl.getProgramInfoLog(program);
        throw new Error('program link error: ' + _info2);
      }

      //gl.useProgram(program)

      return program;
    }

    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @param {WebGLProgram} program -
     * @returns {void}
     */

  }, {
    key: '_createVertexArrayObject',
    value: function _createVertexArrayObject(gl, program) {
      this._vertexArrayObject = gl.createVertexArray();
      gl.bindVertexArray(this._vertexArrayObject);

      this._vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);

      var positionLoc = gl.getAttribLocation(program, 'position');
      gl.bindAttribLocation(program, positionLoc, 'position');
      gl.enableVertexAttribArray(positionLoc
      // idx, size, type, norm, stride, offset
      );gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 20, 0);

      var texcoordLoc = gl.getAttribLocation(program, 'texcoord');
      gl.bindAttribLocation(program, texcoordLoc, 'texcoord');
      gl.enableVertexAttribArray(texcoordLoc
      // idx, size, type, norm, stride, offset
      );gl.vertexAttribPointer(texcoordLoc, 2, gl.FLOAT, false, 20, 12);

      this._indexBuffer = gl.createBuffer();
      var indexData = new Uint8Array([0, 3, 2, 0, 1, 3]);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
    }
  }, {
    key: '_createVertexData',
    value: function _createVertexData() {
      var p = this.__presentation._worldPosition;
      var w = this._canvas.width * this.__presentation.xScale;
      var h = this._canvas.height * this.__presentation.yScale;
      var left = p.x;
      var right = p.x;
      var top = p.y + h * 0.5;
      var bottom = p.y - h * 0.5;
      switch (this.__presentation._horizontalAlignmentMode) {
        case _SKLabelHorizontalAlignmentMode2.default.center:
          left -= w * 0.5;
          right += w * 0.5;
          break;
        case _SKLabelHorizontalAlignmentMode2.default.left:
          right += w;
          break;
        case _SKLabelHorizontalAlignmentMode2.default.right:
          left -= w;
          break;
        default:
          // unknown mode
          break;
      }

      var arr = [left, top, this.__presentation._worldZPosition, 0, 0, right, top, this.__presentation._worldZPosition, 1, 0, left, bottom, this.__presentation._worldZPosition, 0, 1, right, bottom, this.__presentation._worldZPosition, 1, 1];
      return new Float32Array(arr);
    }
  }, {
    key: 'copy',
    value: function copy() {
      var node = new SKLabelNode();
      node._copyValue(this);
      return node;
    }
  }, {
    key: '_copyValue',
    value: function _copyValue(src) {
      _get(SKLabelNode.prototype.__proto__ || Object.getPrototypeOf(SKLabelNode.prototype), '_copyValue', this).call(this, src);
      this._text = src._text;
      this._fontColor = src._fontColor._copy();
      this._fontName = src._fontName;
      this._fontSize = src._fontSize;
      this._verticalAlignmentMode = src._verticalAlignmentMode;
      this._horizontalAlignmentMode = src._horizontalAlignmentMode;
      this.color = src.color._copy();
      this.colorBlendFactor = src.colorBlendFactor;
      this.blendMode = src.blendMode;
      this._canvas = src._canvas;
      this._context = src._context;
      //this._glContext = src._glContext
      //this._texture = src._texture
      //this._program = src._program
      //this._vertexArrayObject = src._vertexArrayObject
      //this._vertexBuffer = src._vertexBuffer
      //this._indexBuffer = src._indexBuffer
    }
  }, {
    key: 'text',
    get: function get() {
      return this._text;
    },
    set: function set(newValue) {
      this._text = newValue;
      this._updateCanvas();
    }
  }, {
    key: 'fontColor',
    get: function get() {
      return this._fontColor;
    },
    set: function set(newValue) {
      this._fontColor = newValue;
      this._updateCanvas();
    }
  }, {
    key: 'fontName',
    get: function get() {
      return this._fontName;
    },
    set: function set(newValue) {
      this._fontName = newValue;
      this._updateCanvas();
    }
  }, {
    key: 'fontSize',
    get: function get() {
      return this._fontSize;
    },
    set: function set(newValue) {
      this._fontSize = newValue;
      this._updateCanvas();
    }
  }, {
    key: 'verticalAlignmentMode',
    get: function get() {
      return this._verticalAlignmentMode;
    },
    set: function set(newValue) {
      this._verticalAlignmentMode = newValue;
      this._updateCanvas();
    }
  }, {
    key: 'horizontalAlignmentMode',
    get: function get() {
      return this._horizontalAlignmentMode;
    },
    set: function set(newValue) {
      this._horizontalAlignmentMode = newValue;
      this._updateCanvas();
    }
  }], [{
    key: 'labelWithFontNamed',
    value: function labelWithFontNamed(fontName) {
      var label = new SKLabelNode();
      label.fontName = fontName;
      return label;
    }

    /**
     * Initializes a new label object with a text string.
     * @access public
     * @param {?string} text - The text to use to initialize the label node.
     * @returns {SKLabelNode} -
     * @desc The label node’s font is set to Helvetica Neue Ultra Light, 32 point.
     * @see https://developer.apple.com/documentation/spritekit/sklabelnode/1519612-init
     */

  }, {
    key: 'labelWithText',
    value: function labelWithText(text) {
      return new SKLabelNode(text);
    }
  }]);

  return SKLabelNode;
}(_SKNode3.default);

exports.default = SKLabelNode;

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SKAction2 = __webpack_require__(20);

var _SKAction3 = _interopRequireDefault(_SKAction2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SKActionTimingMode from './SKActionTimingMode'
//import SKNode from './SKNode'

var SKRepeat = function (_SKAction) {
  _inherits(SKRepeat, _SKAction);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SKRepeat() {
    _classCallCheck(this, SKRepeat);

    var _this = _possibleConstructorReturn(this, (SKRepeat.__proto__ || Object.getPrototypeOf(SKRepeat)).call(this));

    _this._timesToRepeat = 0;
    _this._repeatedAtion = null;
    _this._forever = false;
    _this._timesRepeated = 0;
    return _this;
  }

  /**
   * Creates an action that repeats another action a specified number of times.
   * @access public
   * @param {SKAction} action - The action to execute.
   * @param {number} count - The number of times to execute the action.
   * @returns {SKAction} - 
   * @desc When the action executes, the associated action runs to completion and then repeats, until the count is reached.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417750-repeat
   */


  _createClass(SKRepeat, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SCNActionFade} -
     */
    value: function copy() {
      var action = _get(SKRepeat.prototype.__proto__ || Object.getPrototypeOf(SKRepeat.prototype), 'copy', this).call(this);

      action._timesToRepeat = this._timesToRepeat;
      action._repeatedAction = this._repeatedAction;
      action._forever = this._forever;
      action._timesRepeated = this._timesRepeated;

      return action;
    }
  }, {
    key: '_getTime',
    value: function _getTime(time, needTimeConversion) {
      if (!needTimeConversion) {
        return time;
      }

      var baseTime = this._basetimeFromTime(time);
      if (this.timingFunction === null) {
        return baseTime;
      }

      var n = Math.floor(baseTime);
      var t = this.timingFunction._getValueAtTime(baseTime - n);
      return n + t;
    }

    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAction',
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var dt = this._getTime(time, needTimeConversion);
      var timesRepeated = Math.floor(dt);
      while (timesRepeated > this._timesRepeated) {
        this._timesRepeated += 1;
        this._repeatedAction._applyAction(obj, 1.0, false);
        if (!this._forever && this._timesRepeated >= this._timesToRepeat) {
          this._finished = true;
          return;
        }
        this._repeatedAction._resetFinished();
      }
      var t = dt - this._timesRepeated;
      this._repeatedAction._applyAction(obj, t, false);
      this._finished = false;
    }
  }, {
    key: '_resetFinished',
    value: function _resetFinished() {
      this._repeatedAction._resetFinished();
      this._timesRepeated = 0;
      this._finished = false;
    }
  }, {
    key: 'duration',
    get: function get() {
      if (this._forever) {
        return Infinity;
      }
      return this._repeatedAction.duration * this._timesToRepeat;
    }
  }], [{
    key: 'repeat',
    value: function repeat(action, count) {
      var _action = new SKRepeat();
      _action._repeatedAction = action;
      _action._duration = action.duration;
      _action._timesToRepeat = count;
      _action._forever = count === Infinity;
      return _action;
    }

    /**
     * Creates an action that repeats another action forever.
     * @access public
     * @param {SKAction} action - The action to execute.
     * @returns {SKAction} - 
     * @desc When the action executes, the associated action runs to completion and then repeats.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.NoteThe action to be repeated must have a non-instantaneous duration.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417676-repeatforever
     */

  }, {
    key: 'repeatForever',
    value: function repeatForever(action) {
      return this.repeat(action, Infinity);
    }
  }]);

  return SKRepeat;
}(_SKAction3.default);

exports.default = SKRepeat;


_SKAction3.default.repeat = SKRepeat.repeat;
_SKAction3.default.repeatForever = SKRepeat.repeatForever;

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SKAction2 = __webpack_require__(20);

var _SKAction3 = _interopRequireDefault(_SKAction2);

var _SKActionTimingMode = __webpack_require__(23);

var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

var _SKNode = __webpack_require__(19);

var _SKNode2 = _interopRequireDefault(_SKNode);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SKScale = function (_SKAction) {
  _inherits(SKScale, _SKAction);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SKScale() {
    _classCallCheck(this, SKScale);

    var _this = _possibleConstructorReturn(this, (SKScale.__proto__ || Object.getPrototypeOf(SKScale)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SKActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;

    _this._scaleXTo = null;
    _this._scaleXBy = null;
    _this._scaleWidthTo = null;
    _this._scaleYTo = null;
    _this._scaleYBy = null;
    _this._scaleHeightTo = null;
    return _this;
  }

  /**
   * Creates an action that changes the x and y scale values of a node by a relative value.
   * @access public
   * @param {number} scale - The amount to add to the node’s x and y scale values.
   * @param {number} sec - The duration of the animation.
   * @returns {SKAction} - 
   * @desc When the action executes, the node’s xScale and yScale properties are animated to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.scale(by: -scale, duration: sec)
  let action = SKAction.scale(by: -scale, duration: sec)
    * @see https://developer.apple.com/documentation/spritekit/skaction/1417741-scale
   */


  _createClass(SKScale, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SCNActionFade} -
     */
    value: function copy() {
      var action = _get(SKScale.prototype.__proto__ || Object.getPrototypeOf(SKScale.prototype), 'copy', this).call(this);

      action._scaleXTo = this._scaleXTo;
      action._scaleXBy = this._scaleXBy;
      action._scaleWidthTo = this._scaleWidthTo;
      action._scaleYTo = this._scaleYTo;
      action._scaleYBy = this._scaleYBy;
      action._scaleHeightTo = this._scaleHeightTo;

      return action;
    }

    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAction',
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var t = this._getTime(time, needTimeConversion);
      if (!(obj instanceof _SKNode2.default)) {
        throw new Error('unsupported class for SKSequence: ' + obj.constructor.name);
      }

      var baseXValue = obj.xScale;
      var toXValue = null;
      if (this._scaleXTo !== null) {
        toXValue = this._scaleXTo;
      } else if (this._scaleXBy !== null) {
        toXValue = baseXValue + this._scaleXBy;
      } else if (this._scaleWidthTo !== null) {
        toXValue = this._scaleWidthTo / this._frame.size.width;
      }

      var baseYValue = obj.yScale;
      var toYValue = null;
      if (this._scaleYTo !== null) {
        toYValue = this._scaleYTo;
      } else if (this._scaleYBy !== null) {
        toYValue = baseYValue + this._scaleYBy;
      } else if (this._scaleHeightTo !== null) {
        toYValue = this._scaleHeightTo / this._frame.size.height;
      }

      if (toXValue === null && toYValue === null) {
        throw new Error('both toXValue and toYValue are null');
      }

      if (toXValue !== null) {
        var xValue = this._lerp(baseXValue, toXValue, t);
        obj._presentation.xScale = xValue;
      }
      if (toYValue !== null) {
        var yValue = this._lerp(baseYValue, toYValue, t);
        obj._presentation.yScale = yValue;
      }

      if (this._finished) {
        if (toXValue !== null) {
          obj.xScale = toXValue;
        }
        if (toYValue !== null) {
          obj.yScale = toYValue;
        }
      }
    }
  }], [{
    key: 'scaleByDuration',
    value: function scaleByDuration(scale, sec) {
      var action = new SKScale();
      action._scaleXBy = scale;
      action._scaleYBy = scale;
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that changes the x and y scale values of a node to achieve 
     * @access public
     * @param {number|CGSize} size - The new size of the node.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s xScale and yScale properties are animated to achieve the specified size in its parent's coordinate space. This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1643619-scale
     */

  }, {
    key: 'scaleToDuration',
    value: function scaleToDuration(size, sec) {
      var action = new SKScale();
      if (size instanceof _CGSize2.default) {
        action._scaleWidthTo = size.width;
        action._scaleHeightTo = size.height;
      } else if (typeof size === 'number') {
        action._scaleXTo = size;
        action._scaleYTo = size;
      } else {
        throw new Error('unsupported format');
      }
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that adds relative values to the x and y scale values of a node.
     * @access public
     * @param {number} xScale - The amount to add to the node’s x scale value.
     * @param {number} yScale - The amount to add to the node’s y scale value.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s xScale and yScale properties are animated to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)
    let action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)
      * @see https://developer.apple.com/documentation/spritekit/skaction/1417796-scalex
     */

  }, {
    key: 'scaleXByYDuration',
    value: function scaleXByYDuration(xScale, yScale, sec) {
      var action = new SKScale();
      action._scaleXBy = xScale;
      action._scaleYBy = yScale;
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that changes the x and y scale values of a node.
     * @access public
     * @param {number} xScale - The new value for the node’s x scale value.
     * @param {number} yScale - The new value for the node’s y scale value.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s xScale and yScale properties are animated to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417728-scalex
     */

  }, {
    key: 'scaleXToYDuration',
    value: function scaleXToYDuration(xScale, yScale, sec) {
      var action = new SKScale();
      action._scaleXTo = xScale;
      action._scaleYTo = yScale;
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that changes the x scale value of a node to a new value.
     * @access public
     * @param {number} scale - The new value for the node’s x scale value.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s xScale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417699-scalex
     */

  }, {
    key: 'scaleXToDuration',
    value: function scaleXToDuration(scale, sec) {
      var action = new SKScale();
      action._scaleXTo = scale;
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that changes the y scale value of a node to a new value.
     * @access public
     * @param {number} scale - The new value for the node’s y scale value.
     * @param {number} sec - The duration of the animation.
     * @returns {SKAction} - 
     * @desc When the action executes, the node’s yScale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417708-scaley
     */

  }, {
    key: 'scaleYToDuration',
    value: function scaleYToDuration(scale, sec) {
      var action = new SKScale();
      action._scaleYTo = scale;
      action._duration = sec;
      return action;
    }
  }]);

  return SKScale;
}(_SKAction3.default);

exports.default = SKScale;


_SKAction3.default.scaleByDuration = SKScale.scaleByDuration;
_SKAction3.default.scaleToDuration = SKScale.scaleToDuration;
_SKAction3.default.scaleXByYDuration = SKScale.scaleXByYDuration;
_SKAction3.default.scaleXToYDuration = SKScale.scaleXToYDuration;
_SKAction3.default.scaleXToDuration = SKScale.scaleXToDuration;
_SKAction3.default.scaleYToDuration = SKScale.scaleYToDuration;

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CGPoint = __webpack_require__(10);

var _CGPoint2 = _interopRequireDefault(_CGPoint);

var _CGSize = __webpack_require__(8);

var _CGSize2 = _interopRequireDefault(_CGSize);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _SKEffectNode2 = __webpack_require__(112);

var _SKEffectNode3 = _interopRequireDefault(_SKEffectNode2);

var _SKSceneScaleMode = __webpack_require__(115);

var _SKSceneScaleMode2 = _interopRequireDefault(_SKSceneScaleMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SKCameraNode from './SKCameraNode'
//import SKView from './SKView'
//import SKSceneDelegate from './SKSceneDelegate'
//import SKPhysicsWorld from './SKPhysicsWorld'
//import SKNode from './SKNode'


/**
 * The root node for all Sprite Kit objects displayed in a view. 
 * @access public
 * @extends {SKEffectNode}
 * @see https://developer.apple.com/documentation/spritekit/skscene
 */
var SKScene = function (_SKEffectNode) {
  _inherits(SKScene, _SKEffectNode);

  // Initializing a Scene

  /**
   * Initializes a new scene object.
   * @access public
   * @constructor
   * @param {CGSize} size - The size of the scene in points.
   * @desc This is the class’s designated initializer method.
   * @see https://developer.apple.com/documentation/spritekit/skscene/1520435-init
   */
  function SKScene(size) {
    _classCallCheck(this, SKScene);

    // Determining What Portion of the Scene Is Visible in the View

    /**
     * The camera node in the scene that determines what part of the scene’s coordinate space is visible in the view.
     * @type {?SKCameraNode}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519696-camera
     */
    var _this = _possibleConstructorReturn(this, (SKScene.__proto__ || Object.getPrototypeOf(SKScene)).call(this));

    _this.camera = null;

    /**
     * The point in the view’s frame that corresponds to the scene’s origin.
     * @type {CGPoint}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519864-anchorpoint
     */
    _this.anchorPoint = new _CGPoint2.default(0, 0);

    /**
     * The dimensions of the scene in points.
     * @type {CGSize}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519831-size
     */
    _this.size = size ? size : new _CGSize2.default(1, 1);

    /**
     * Defines how the scene is mapped to the view that presents it.
     * @type {SKSceneScaleMode}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519562-scalemode
     */
    _this.scaleMode = _SKSceneScaleMode2.default.fill;

    // Setting the Background Color of a Scene

    /**
     * The background color of the scene.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1520278-backgroundcolor
     */
    _this.backgroundColor = new _SKColor2.default(0.15, 0.15, 0.15, 1.0);

    // Presenting a Scene

    _this._view = null;

    // Executing the Animation Loop

    /**
     * A delegate to be called during the animation loop. 
     * @type {?SKSceneDelegate}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1520213-delegate
     */
    _this.delegate = null;

    // Working with Physics in the Scene

    //this._physicsWorld = new SKPhysicsWorld()
    _this._physicsWorld = null;

    // Working with Audio in the Scene

    /**
     * A node used to determine the position of the listener for positional audio in the scene.
     * @type {?SKNode}
     * @see https://developer.apple.com/documentation/spritekit/skscene/1520363-listener
     */
    _this.listener = null;

    //this._audioEngine = null
    return _this;
  }

  _createClass(SKScene, [{
    key: '_copyValue',
    value: function _copyValue(src) {
      this.camera = src.camera;
      this.anchorPoint = src.anchorPoint.copy();
      this.size = src.size.copy();
      this.scaleMode = src.scaleMode;
      this.backgroundColor = src.backgroundColor._copy();
      this._view = src._view;
      this.delegate = src.delegate;
      this._physicsWorld = src._physicsWorld;
      this.listener = src.listener;
    }

    // Determining What Portion of the Scene Is Visible in the View

    /**
     * Called whenever the scene’s size changes.
     * @access public
     * @param {CGSize} oldSize - The old size of the scene, in points.
     * @returns {void}
     * @desc This method is intended to be overridden in a subclass. Typically, you use this method to adjust the positions of nodes in the scene.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519545-didchangesize
     */

  }, {
    key: 'didChangeSize',
    value: function didChangeSize(oldSize) {}

    // Converting Between View and Scene Coordinates

    /**
     * Converts a point from view coordinates to scene coordinates.
     * @access public
     * @param {CGPoint} point - A point in view coordinates.
     * @returns {CGPoint} - 
     * @desc The scene must be presented in a view before calling this method.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1520395-convertpoint
     */

  }, {
    key: 'convertPointFromView',
    value: function convertPointFromView(point) {
      return null;
    }

    /**
     * Converts a point from scene coordinates to view coordinates.
     * @access public
     * @param {CGPoint} point - A point in scene coordinates.
     * @returns {CGPoint} - 
     * @desc The scene must be presented in a view before calling this method.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1520082-convertpoint
     */

  }, {
    key: 'convertPointToView',
    value: function convertPointToView(point) {
      return null;
    }

    // Presenting a Scene

    /**
     * Called immediately after the scene has been initialized or decoded.
     * @access public
     * @returns {void}
     * @desc This method is intended to be overridden in a subclass. You can use this method to implement any custom behavior after it has been initialized or decoded.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1645216-scenedidload
     */

  }, {
    key: 'sceneDidLoad',
    value: function sceneDidLoad() {}

    /**
     * Called immediately before a scene is removed from a view.
     * @access public
     * @param {SKView} view - The view that is presenting the scene.
     * @returns {void}
     * @desc This method is intended to be overridden in a subclass. You can use this method to implement any custom behavior for your scene when it is about to be removed from the view.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519703-willmove
     */

  }, {
    key: 'willMoveFrom',
    value: function willMoveFrom(view) {}

    /**
     * Called immediately after a scene is presented by a view.
     * @access public
     * @param {SKView} view - The view that is presenting the scene.
     * @returns {void}
     * @desc This method is intended to be overridden in a subclass. You can use this method to implement any custom behavior for your scene when it is about to be presented by a view. For example, you might use this method to create the scene’s contents.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519607-didmove
     */

  }, {
    key: 'didMoveTo',
    value: function didMoveTo(view) {}
    /**
     * The view that is currently presenting the scene.
     * @type {?SKView}
     * @desc To present a scene, you call the presentScene(_:) method or presentScene(_:transition:) method on the SKView class. If the scene is not currently presented, this property holds nil.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519726-view
     */

  }, {
    key: 'update',


    // Executing the Animation Loop

    /**
     * Performs any scene-specific updates that need to occur before scene actions are evaluated.
     * @access public
     * @param {number} currentTime - The current system time.
     * @returns {void}
     * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519802-update
     */
    value: function update(currentTime) {}

    /**
     * Performs any scene-specific updates that need to occur after scene actions are evaluated.
     * @access public
     * @returns {void}
     * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519903-didevaluateactions
     */

  }, {
    key: 'didEvaluateActions',
    value: function didEvaluateActions() {}

    /**
     * Performs any scene-specific updates that need to occur after physics simulations are performed.
     * @access public
     * @returns {void}
     * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519965-didsimulatephysics
     */

  }, {
    key: 'didSimulatePhysics',
    value: function didSimulatePhysics() {}

    /**
     * Performs any scene-specific updates that need to occur after constraints are applied.
     * @access public
     * @returns {void}
     * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1520006-didapplyconstraints
     */

  }, {
    key: 'didApplyConstraints',
    value: function didApplyConstraints() {}

    /**
     * Called after the scene has finished all of the steps required to process animations.
     * @access public
     * @returns {void}
     * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene. This method is the last method to be called before the scene is rendered.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1520269-didfinishupdate
     */

  }, {
    key: 'didFinishUpdate',
    value: function didFinishUpdate() {}

    // Working with Physics in the Scene
    /**
     * The physics simulation associated with the scene.
     * @type {SKPhysicsWorld}
     * @desc Every scene automatically creates a physics world object to simulate physics on nodes in the scene. You use this property to access the scene’s global physics properties, such as gravity. To add physics to a particular node, see physicsBody.
     * @see https://developer.apple.com/documentation/spritekit/skscene/1519584-physicsworld
     */

  }, {
    key: 'view',
    get: function get() {
      return this._view;
    }
  }, {
    key: 'physicsWorld',
    get: function get() {
      return this._physicsWorld;
    }

    // Working with Audio in the Scene
    /**
     * The AV Foundation audio engine used to play audio from audio nodes contained in the scene.
     * @type {AVAudioEngine}
     * @desc An audio engine instance is automatically created for you when the scene is created. You can use methods and properties on a scene’s audio engine for overall control of all of its child audio nodes. The following code shows how a scene’s overall volume can be reduced from its default of 1.0 down to 0.2 and then paused:let scene = SKScene()
    scene.audioEngine.mainMixerNode.outputVolume = 0.2
    scene.audioEngine.pause()
    let scene = SKScene()
    scene.audioEngine.mainMixerNode.outputVolume = 0.2
    scene.audioEngine.pause()
      * @see https://developer.apple.com/documentation/spritekit/skscene/1519644-audioengine
     */
    //get audioEngine() {
    //  return this._audioEngine
    //}

  }]);

  return SKScene;
}(_SKEffectNode3.default);

exports.default = SKScene;

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SKAction2 = __webpack_require__(20);

var _SKAction3 = _interopRequireDefault(_SKAction2);

var _SKActionTimingMode = __webpack_require__(23);

var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SKNode from './SKNode'

var SKSequence = function (_SKAction) {
  _inherits(SKSequence, _SKAction);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SKSequence() {
    _classCallCheck(this, SKSequence);

    var _this = _possibleConstructorReturn(this, (SKSequence.__proto__ || Object.getPrototypeOf(SKSequence)).call(this));

    _this._actions = [];
    _this._animIndex = 0;

    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SKActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  /**
   * Creates an action that runs a collection of actions sequentially.
   * @access public
   * @param {SKAction[]} actions - An array of SKAction objects.
   * @returns {SKAction} - 
   * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, if an action sequence is {1,2,3}, the reversed sequence would be {3R,2R,1R}.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417817-sequence
   */


  _createClass(SKSequence, [{
    key: 'copy',


    /**
     * @access public
     * @returns {SCNActionFade} -
     */
    value: function copy() {
      var action = _get(SKSequence.prototype.__proto__ || Object.getPrototypeOf(SKSequence.prototype), 'copy', this).call(this);

      action._actions = this._actions.slice(0);
      action._animIndex = this._animIndex;

      return action;
    }

    /**
     * apply action to the given node.
     * @access private
     * @param {Object} obj - target object to apply this action.
     * @param {number} time - active time
     * @param {boolean} [needTimeConversion = true] -
     * @returns {void}
     */

  }, {
    key: '_applyAction',
    value: function _applyAction(obj, time) {
      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var total = this.duration;
      var duration = 0;
      if (total <= 0 || total === Infinity) {
        duration = this._activetimeFromTime(time);
      } else {
        duration = this._getTime(time, needTimeConversion) * total;
      }

      for (var i = 0; i < this._animIndex; i++) {
        duration -= this._actions[i].duration / this._actions[i].speed;
      }
      for (; this._animIndex < this._actions.length; this._animIndex++) {
        var action = this._actions[this._animIndex];
        action._applyAction(obj, duration, true);
        duration -= action.duration / action.speed;
        if (duration <= 0 || !action._finished) {
          break;
        }
      }
      if (this._animIndex >= this._actions.length) {
        this._finished = true;
      }
    }
  }, {
    key: '_resetFinished',
    value: function _resetFinished() {
      this._actions.forEach(function (action) {
        action._resetFinished();
      });
      this._finished = false;
      this._animIndex = 0;
    }
  }, {
    key: 'duration',
    get: function get() {
      var d = 0;
      this._actions.forEach(function (act) {
        if (act.speed > 0) {
          d += act.duration / act.speed;
        }
      });
      return d;
    }
  }], [{
    key: 'sequence',
    value: function sequence(actions) {
      var action = new SKSequence();
      action._actions = actions;
      action._duration = 0;
      return action;
    }
  }]);

  return SKSequence;
}(_SKAction3.default);

exports.default = SKSequence;


_SKAction3.default.sequence = SKSequence.sequence;

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CGLineCap = __webpack_require__(58);

var _CGLineCap2 = _interopRequireDefault(_CGLineCap);

var _CGLineJoin = __webpack_require__(59);

var _CGLineJoin2 = _interopRequireDefault(_CGLineJoin);

var _SKBlendMode = __webpack_require__(28);

var _SKBlendMode2 = _interopRequireDefault(_SKBlendMode);

var _SKColor = __webpack_require__(2);

var _SKColor2 = _interopRequireDefault(_SKColor);

var _SKNode2 = __webpack_require__(19);

var _SKNode3 = _interopRequireDefault(_SKNode2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import CGPath from '../CoreGraphics/CGPath'
//import CGRect from '../CoreGraphics/CGRect'
//import CGSize from '../CoreGraphics/CGSize'
//import SKTexture from './SKTexture'
//import SKShader from './SKShader'
//import SKAttributeValue from './SKAttributeValue'


/**
 * A node that renders a shape defined by a Core Graphics path.
 * @access public
 * @extends {SKNode}
 * @see https://developer.apple.com/documentation/spritekit/skshapenode
 */
var SKShapeNode = function (_SKNode) {
  _inherits(SKShapeNode, _SKNode);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SKShapeNode() {
    _classCallCheck(this, SKShapeNode);

    // Inspecting the Shape Node’s Path

    /**
     * The path that defines the shape.
     * @type {?CGPath}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519741-path
     */
    var _this = _possibleConstructorReturn(this, (SKShapeNode.__proto__ || Object.getPrototypeOf(SKShapeNode)).call(this));

    _this.path = null;

    // Setting the Fill Properties

    /**
     * The color used to fill the shape.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520154-fillcolor
     */
    _this.fillColor = new _SKColor2.default(0, 0, 0, 0);

    /**
     * The texture used to fill the shape.
     * @type {?SKTexture}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519956-filltexture
     */
    _this.fillTexture = null;

    /**
     * A custom shader used to determine the color of the filled portion of the shape node.
     * @type {?SKShader}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519629-fillshader
     */
    _this.fillShader = null;

    // Setting the Stroke Properties

    /**
     * The width used to stroke the path.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519885-linewidth
     */
    _this.lineWidth = 1.0;

    /**
     * The glow that extends outward from the stroked line.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520116-glowwidth
     */
    _this.glowWidth = 0;

    /**
     * A Boolean value that determines whether the stroked path is smoothed when drawn.
     * @type {boolean}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519719-isantialiased
     */
    _this.isAntialiased = true;

    /**
     * The color used to stroke the shape.
     * @type {SKColor}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519748-strokecolor
     */
    _this.strokeColor = new _SKColor2.default(1.0, 1.0, 1.0, 1.0);

    /**
     * The texture used to stroke the shape.
     * @type {?SKTexture}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519824-stroketexture
     */
    _this.strokeTexture = null;

    /**
     * A custom shader used to determine the color of the stroked portion of the shape node.
     * @type {?SKShader}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519784-strokeshader
     */
    _this.strokeShader = null;

    /**
     * The style used to render the endpoints of the stroked portion of the shape node.
     * @type {CGLineCap}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520360-linecap
     */
    _this.lineCap = _CGLineCap2.default.butt;

    /**
     * The junction type used when the stroked portion of the shape node is rendered.
     * @type {CGLineJoin}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520358-linejoin
     */
    _this.lineJoin = _CGLineJoin2.default.bevel;

    /**
     * The miter limit to use when the line is stroked using a miter join style.
     * @type {number}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520240-miterlimit
     */
    _this.miterLimit = 0.5;

    // Blending the Shape with the Framebuffer

    /**
     * The blend mode used to blend the shape into the parent’s framebuffer.
     * @type {SKBlendMode}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520045-blendmode
     */
    _this.blendMode = _SKBlendMode2.default.alpha;

    // Reading the Shape Node’s Properties

    //this._lineLength = 0

    // Working with Custom Shaders

    /**
     * The values of each attribute associated with the node's attached shader.
     * @type {Map<string, SKAttributeValue>}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/2715841-attributevalues
     */
    _this.attributeValues = new Map();

    // Instance Properties

    _this._customPlaygroundQuickLook = null;
    return _this;
  }

  // Creating a Shape Path

  /**
   * Creates a shape node from a Core Graphics path.
   * @access public
   * @param {CGPath} path - The Core Graphics path to use. The path is relative to the node’s origin.
   * @returns {void}
   * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520022-init
   */


  _createClass(SKShapeNode, [{
    key: 'setValueForAttribute',


    // Working with Custom Shaders

    /**
     * Sets an attribute value for an attached shader.
     * @access public
     * @param {SKAttributeValue} value - An attribute value object containing the scalar or vector value to set in the attached shader.
     * @param {string} key - The attribute name.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/2715855-setvalue
     */
    value: function setValueForAttribute(value, key) {}

    /**
     * The value of a shader attribute.
     * @access public
     * @param {string} key - The attribute name.
     * @returns {?SKAttributeValue} - 
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/2715843-value
     */

  }, {
    key: 'valueForAttributeNamed',
    value: function valueForAttributeNamed(key) {
      return null;
    }

    // Instance Properties
    /**
     * A custom playground quick look for this instance.
     * @type {PlaygroundQuickLook}
     * @desc 
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1645784-customplaygroundquicklook
     */

  }, {
    key: '_render',


    /**
     * @access private
     * @param {WebGLRenderingContext} gl -
     * @returns {void}
     */
    value: function _render(gl) {}
  }, {
    key: 'lineLength',


    // Reading the Shape Node’s Properties
    /**
     * The length of the line defined by the shape node.
     * @type {number}
     * @desc 
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520398-linelength
     */
    get: function get() {
      //return this._lineLength
      // TODO: implement
      return 0;
    }
  }, {
    key: 'customPlaygroundQuickLook',
    get: function get() {
      return this._customPlaygroundQuickLook;
    }
  }], [{
    key: 'node',
    value: function node(path) {}

    /**
     * Creates a shape node with a rectangular path centered on the node’s origin.
     * @access public
     * @param {CGSize} size - The size of the rectangle.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520147-init
     */

  }, {
    key: 'nodeWithRectOf',
    value: function nodeWithRectOf(size) {}

    /**
     * Creates a shape node with a circular path centered on the node’s origin.
     * @access public
     * @param {number} radius - The radius of the circle.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519570-init
     */

  }, {
    key: 'nodeWithCircleOfRadius',
    value: function nodeWithCircleOfRadius(radius) {
      var node = new SKShapeNode();
      // TODO: implement
      return node;
    }

    /**
     * Creates a shape node with an elliptical path centered on the node’s origin.
     * @access public
     * @param {CGSize} size - The height and width of the ellipse.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1519980-init
     */

  }, {
    key: 'nodeWithEllipseOf',
    value: function nodeWithEllipseOf(size) {}

    /**
     * Creates a shape node with an elliptical path that fills the specified rectangle.
     * @access public
     * @param {CGRect} rect - A rectangle, relative to the node’s origin.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520412-init
     */

  }, {
    key: 'nodeWithEllipseIn',
    value: function nodeWithEllipseIn(rect) {}

    /**
     * Creates a shape node from a series of points.
     * @access public
     * @param {UnsafeMutablePointer<CGPoint>} points - An array of Core Graphics points. The points are relative to the node’s origin.
     * @param {number} numPoints - The number of points in the array.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520120-init
     */

  }, {
    key: 'nodeWithPointsCount',
    value: function nodeWithPointsCount(points, numPoints) {}

    /**
     * Creates a shape node from a series of spline points.
     * @access public
     * @param {UnsafeMutablePointer<CGPoint>} points - An array of Core Graphics points.
     * @param {number} numPoints - The number of points in the array.
     * @returns {void}
     * @see https://developer.apple.com/documentation/spritekit/skshapenode/1520140-init
     */

  }, {
    key: 'nodeWithSplinePointsCount',
    value: function nodeWithSplinePointsCount(points, numPoints) {}
  }]);

  return SKShapeNode;
}(_SKNode3.default);

exports.default = SKShapeNode;

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SKAction2 = __webpack_require__(20);

var _SKAction3 = _interopRequireDefault(_SKAction2);

var _SKActionTimingMode = __webpack_require__(23);

var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import SKNode from './SKNode'

var SKWait = function (_SKAction) {
  _inherits(SKWait, _SKAction);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function SKWait() {
    _classCallCheck(this, SKWait);

    var _this = _possibleConstructorReturn(this, (SKWait.__proto__ || Object.getPrototypeOf(SKWait)).call(this));

    _this._actions = [];
    _this._finished = false;
    _this._duration = 0;
    _this._timingMode = _SKActionTimingMode2.default.linear;
    _this._beginTime = 0;
    _this._isRunning = false;
    _this._pausedTime = 0;
    return _this;
  }

  /**
   * Creates an action that idles for a specified period of time.
   * @access public
   * @param {number} sec - The amount of time to wait.
   * @returns {SKAction} - 
   * @desc When the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
   * @see https://developer.apple.com/documentation/spritekit/skaction/1417788-wait
   */


  _createClass(SKWait, null, [{
    key: 'waitForDuration',
    value: function waitForDuration(sec) {
      var action = new SKWait();
      action._duration = sec;
      return action;
    }

    /**
     * Creates an action that idles for a randomized period of time.
     * @access public
     * @param {number} sec - The average amount of time to wait.
     * @param {number} durationRange - The range of possible values for the duration.
     * @returns {SKAction} - 
     * @desc When the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
     * @see https://developer.apple.com/documentation/spritekit/skaction/1417760-wait
     */

  }, {
    key: 'waitForDurationWithRange',
    value: function waitForDurationWithRange(sec, durationRange) {
      var duration = Math.max(0, sec + (Math.random() - 0.5) * durationRange);
      var action = new SKWait();
      action._duration = duration;
      return action;
    }
  }]);

  return SKWait;
}(_SKAction3.default);

exports.default = SKWait;


_SKAction3.default.waitForDuration = SKWait.waitForDuration;
_SKAction3.default.waitForDurationWithRange = SKWait.waitForDurationWithRange;

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BinaryParser = __webpack_require__(272);

var _BinaryParser2 = _interopRequireDefault(_BinaryParser);

var _ecl = __webpack_require__(70);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _supportedEncoding = ['ascii', 'utf8', 'utf16le', 'ucs2', 'base64', 'latin1', 'binary', 'hex'];

/*global Buffer*/
var _Buffer = null;
if (typeof Buffer !== 'undefined') {
  _Buffer = Buffer;
} else {
  var allowException = true;
  var _beParser = new _BinaryParser2.default(true, allowException);
  var _leParser = new _BinaryParser2.default(false, allowException);

  var _Buffer2 = function () {
    function _Buffer2() {
      _classCallCheck(this, _Buffer2);

      this._data = null;
    }

    _createClass(_Buffer2, [{
      key: 'readIntBE',
      value: function readIntBE(offset, byteLength) {
        var noAssert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        switch (byteLength) {
          case 1:
            return this.readInt8(offset, noAssert);
          case 2:
            return this.readInt16BE(offset, noAssert);
          case 4:
            return this.readInt32BE(offset, noAssert);
        }
        var data = this.slice(offset, offset + byteLength)._data;
        return _beParser.decodeInt(data, byteLength * 8, true);
      }
    }, {
      key: 'readIntLE',
      value: function readIntLE(offset, byteLength) {
        var noAssert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        switch (byteLength) {
          case 1:
            return this.readInt8(offset, noAssert);
          case 2:
            return this.readInt16LE(offset, noAssert);
          case 4:
            return this.readInt32LE(offset, noAssert);
        }
        var data = this.slice(offset, offset + byteLength)._data;
        return _leParser.decodeInt(data, byteLength * 8, true);
      }
    }, {
      key: 'readInt8',
      value: function readInt8(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getInt8(offset);
      }
    }, {
      key: 'readInt16BE',
      value: function readInt16BE(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getInt16(offset, false);
      }
    }, {
      key: 'readInt16LE',
      value: function readInt16LE(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getInt16(offset, true);
      }
    }, {
      key: 'readInt32BE',
      value: function readInt32BE(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getInt32(offset, false);
      }
    }, {
      key: 'readInt32LE',
      value: function readInt32LE(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getInt32(offset, true);
      }
    }, {
      key: 'readUIntBE',
      value: function readUIntBE(offset, byteLength) {
        var noAssert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        switch (byteLength) {
          case 1:
            return this.readUInt8(offset, noAssert);
          case 2:
            return this.readUInt16BE(offset, noAssert);
          case 4:
            return this.readUInt32BE(offset, noAssert);
        }
        var data = this.slice(offset, offset + byteLength)._data;
        return _beParser.decodeInt(data, byteLength * 8, false);
      }
    }, {
      key: 'readUIntLE',
      value: function readUIntLE(offset, byteLength) {
        var noAssert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        switch (byteLength) {
          case 1:
            return this.readUInt8(offset, noAssert);
          case 2:
            return this.readUInt16LE(offset, noAssert);
          case 4:
            return this.readUInt32LE(offset, noAssert);
        }
        var data = this.slice(offset, offset + byteLength)._data;
        return _leParser.decodeInt(data, byteLength * 8, false);
      }
    }, {
      key: 'readUInt8',
      value: function readUInt8(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getUint8(offset);
      }
    }, {
      key: 'readUInt16BE',
      value: function readUInt16BE(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getUint16(offset, false);
      }
    }, {
      key: 'readUInt16LE',
      value: function readUInt16LE(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getUint16(offset, true);
      }
    }, {
      key: 'readUInt32BE',
      value: function readUInt32BE(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getUint32(offset, false);
      }
    }, {
      key: 'readUInt32LE',
      value: function readUInt32LE(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getUint32(offset, true);
      }
    }, {
      key: 'readFloatBE',
      value: function readFloatBE(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getFloat32(offset, false);
      }
    }, {
      key: 'readFloatLE',
      value: function readFloatLE(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getFloat32(offset, true);
      }
    }, {
      key: 'readDoubleBE',
      value: function readDoubleBE(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getFloat64(offset, false);
      }
    }, {
      key: 'readDoubleLE',
      value: function readDoubleLE(offset) {
        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        return this._data.getFloat64(offset, true);
      }
    }, {
      key: 'slice',
      value: function slice(start, end) {
        return new _Buffer2(this._data.buffer.slice(start, end));
      }
    }, {
      key: 'toString',
      value: function toString(encoding, start, end) {
        if (!_Buffer2.isEncoding(encoding)) {
          throw new Error('unsupported encoding: ' + encoding);
        }
        var data = new Uint8Array(this._data.buffer);
        if (encoding === 'binary') {
          return String.fromCharCode.apply('', data);
        } else if (encoding === 'ascii' || encoding === 'latin1') {
          var len = data.indexOf(0);
          var _data = data.slice(0, len);
          return String.fromCharCode.apply('', _data);
        } else if (encoding === 'hex') {
          return this._hex(data, false);
        } else if (encoding === 'base64') {
          var _str = String.fromCharCode.apply('', data);
          if (typeof atob === 'function') {
            return atob(_str);
          }
          throw new Error('needs atob() function to convert to base64');
        }

        var str = this._hex(data, true);
        if (encoding === 'utf8') {
          return (0, _ecl.UnescapeUTF8)(str);
        } else if (encoding === 'utf16le' || encoding === 'ucs2') {
          return (0, _ecl.UnescapeUTF16LE)(str);
        }
        throw new Error('unsupported encoding: ' + encoding);
      }
    }, {
      key: '_hex',
      value: function _hex(data, usePercent) {
        var hexArray = data.map(function (num) {
          if (num < 16) {
            return '0' + num.toString(16);
          }
          return num.toString(16);
        });
        var pad = '';
        if (usePercent) {
          pad = '%';
        }
        return hexArray.join(pad);
      }
    }, {
      key: 'length',
      get: function get() {
        return this._data.byteLength;
      }
    }], [{
      key: 'from',
      value: function from(array) {
        var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var buf = new _Buffer2();
        if (Array.isArray(array)) {
          var ab = new ArrayBuffer(array);
          buf._data = new DataView(ab.buffer, byteOffset, length);
        } else if (array instanceof ArrayBuffer) {
          buf._data = new DataView(array, byteOffset, length);
        } else if (array.buffer instanceof ArrayBuffer) {
          buf._data = new DataView(array.buffer, byteOffset, length);
        }

        if (buf._data === null) {
          throw new Error('Buffer.from: unsupported data type: ' + array);
        }

        return buf;
      }
    }, {
      key: 'isEncoding',
      value: function isEncoding(encoding) {
        return _supportedEncoding.indexOf(encoding) >= 0;
      }
    }]);

    return _Buffer2;
  }();

  _Buffer = _Buffer2;
}

exports.default = _Buffer;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21).Buffer))

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
//+ Jonas Raoni Soares Silva
//@ http://jsfromhell.com/classes/binary-parser [rev. #1]

var BinaryParser = function BinaryParser(bigEndian, allowExceptions) {
	this.bigEndian = bigEndian, this.allowExceptions = allowExceptions;
};
exports.default = BinaryParser;


var p = BinaryParser.prototype;

p.encodeFloat = function (number, precisionBits, exponentBits) {
	var bias = Math.pow(2, exponentBits - 1) - 1,
	    minExp = -bias + 1,
	    maxExp = bias,
	    minUnnormExp = minExp - precisionBits,
	    status = isNaN(n = parseFloat(number)) || n == -Infinity || n == +Infinity ? n : 0,
	    exp = 0,
	    len = 2 * bias + 1 + precisionBits + 3,
	    bin = new Array(len),
	    signal = (n = status !== 0 ? 0 : n) < 0,
	    n = Math.abs(n),
	    intPart = Math.floor(n),
	    floatPart = n - intPart,
	    i,
	    lastBit,
	    rounded,
	    j,
	    result;
	for (i = len; i; bin[--i] = 0) {}
	for (i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2)) {}
	for (i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2) >= 1) - 0) && --floatPart) {}
	for (i = -1; ++i < len && !bin[i];) {}
	if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1]) {
		if (!(rounded = bin[lastBit])) for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]) {}
		for (j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0) && (rounded = 0)) {}
	}
	for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];) {}

	(exp = bias + 1 - i) >= minExp && exp <= maxExp ? ++i : exp < minExp && (exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow"), i = bias + 1 - (exp = minExp - 1));
	(intPart || status !== 0) && (this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status), exp = maxExp + 1, i = bias + 2, status == -Infinity ? signal = 1 : isNaN(status) && (bin[i] = 1));
	for (n = Math.abs(exp + bias), j = exponentBits + 1, result = ""; --j; result = n % 2 + result, n = n >>= 1) {}
	for (n = 0, j = 0, i = (result = (signal ? "1" : "0") + result + bin.slice(i, i + precisionBits).join("")).length, r = []; i; n += (1 << j) * result.charAt(--i), j == 7 && (r[r.length] = String.fromCharCode(n), n = 0), j = (j + 1) % 8) {}
	r[r.length] = n ? String.fromCharCode(n) : "";
	return (this.bigEndian ? r.reverse() : r).join("");
};
p.encodeInt = function (number, bits, signed) {
	var max = Math.pow(2, bits),
	    r = [];
	(number >= max || number < -(max >> 1)) && this.warn("encodeInt::overflow") && (number = 0);
	number < 0 && (number += max);
	for (; number; r[r.length] = String.fromCharCode(number % 256), number = Math.floor(number / 256)) {}
	for (bits = -(-bits >> 3) - r.length; bits--; r[r.length] = "\0") {}
	return (this.bigEndian ? r.reverse() : r).join("");
};
p.decodeFloat = function (data, precisionBits, exponentBits) {
	var b = ((b = new this.Buffer(this.bigEndian, data)).checkBuffer(precisionBits + exponentBits + 1), b),
	    bias = Math.pow(2, exponentBits - 1) - 1,
	    signal = b.readBits(precisionBits + exponentBits, 1),
	    exponent = b.readBits(precisionBits, exponentBits),
	    significand = 0,
	    divisor = 2,
	    curByte = b.buffer.length + (-precisionBits >> 3) - 1,
	    byteValue,
	    startBit,
	    mask;
	do {
		for (byteValue = b.buffer[++curByte], startBit = precisionBits % 8 || 8, mask = 1 << startBit; mask >>= 1; byteValue & mask && (significand += 1 / divisor), divisor *= 2) {}
	} while (precisionBits -= startBit);
	return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0);
};
p.decodeInt = function (data, bits, signed) {
	var b = new this.Buffer(this.bigEndian, data),
	    x = b.readBits(0, bits),
	    max = Math.pow(2, bits);
	return signed && x >= max / 2 ? x - max : x;
};

var p2 = (p.Buffer = function (bigEndian, buffer) {
	this.bigEndian = bigEndian || 0, this.buffer = [], this.setBuffer(buffer);
}).prototype;

p2.readBits = function (start, length) {
	//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)
	function shl(a, b) {
		for (++b; --b; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1) {}
		return a;
	}
	if (start < 0 || length <= 0) return 0;
	this.checkBuffer(start + length);
	for (var offsetLeft, offsetRight = start % 8, curByte = this.buffer.length - (start >> 3) - 1, lastByte = this.buffer.length + (-(start + length) >> 3), diff = curByte - lastByte, sum = (this.buffer[curByte] >> offsetRight & (1 << (diff ? 8 - offsetRight : length)) - 1) + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & (1 << offsetLeft) - 1) << (diff-- << 3) - offsetRight : 0); diff; sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight)) {}
	return sum;
};
p2.setBuffer = function (data) {
	if (data) {
		for (var l, i = l = data.length, b = this.buffer = new Array(l); i; b[l - i] = data.charCodeAt(--i)) {}
		this.bigEndian && b.reverse();
	}
};
p2.hasNeededBits = function (neededBits) {
	return this.buffer.length >= -(-neededBits >> 3);
};
p2.checkBuffer = function (neededBits) {
	if (!this.hasNeededBits(neededBits)) throw new Error("checkBuffer::missing bytes");
};

p.warn = function (msg) {
	if (this.allowExceptions) throw new Error(msg);
	return 1;
};
p.toSmall = function (data) {
	return this.decodeInt(data, 8, true);
};
p.fromSmall = function (number) {
	return this.encodeInt(number, 8, true);
};
p.toByte = function (data) {
	return this.decodeInt(data, 8, false);
};
p.fromByte = function (number) {
	return this.encodeInt(number, 8, false);
};
p.toShort = function (data) {
	return this.decodeInt(data, 16, true);
};
p.fromShort = function (number) {
	return this.encodeInt(number, 16, true);
};
p.toWord = function (data) {
	return this.decodeInt(data, 16, false);
};
p.fromWord = function (number) {
	return this.encodeInt(number, 16, false);
};
p.toInt = function (data) {
	return this.decodeInt(data, 32, true);
};
p.fromInt = function (number) {
	return this.encodeInt(number, 32, true);
};
p.toDWord = function (data) {
	return this.decodeInt(data, 32, false);
};
p.fromDWord = function (number) {
	return this.encodeInt(number, 32, false);
};
p.toFloat = function (data) {
	return this.decodeFloat(data, 23, 8);
};
p.fromFloat = function (number) {
	return this.encodeFloat(number, 23, 8);
};
p.toDouble = function (data) {
	return this.decodeFloat(data, 52, 11);
};
p.fromDouble = function (number) {
	return this.encodeFloat(number, 52, 11);
};

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*global HTMLCanvasElement*/

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _HTMLCanvasElement = null;
if (typeof HTMLCanvasElement !== 'undefined') {
  _HTMLCanvasElement = HTMLCanvasElement;
} else {
  var _HTMLCanvasElement2 = function () {
    function _HTMLCanvasElement2() {
      _classCallCheck(this, _HTMLCanvasElement2);
    }

    _createClass(_HTMLCanvasElement2, [{
      key: 'getContext',
      value: function getContext(name, opt) {
        throw new Error('getContext is not implemented');
      }
    }]);

    return _HTMLCanvasElement2;
  }();

  _HTMLCanvasElement = _HTMLCanvasElement2;
}
exports.default = _HTMLCanvasElement;

/***/ })
/******/ ]);

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jscenekit = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _MMDNodeType = {
  rotate: Symbol(),
  rotateTranslate: Symbol(),
  ik: Symbol(),
  unknown: Symbol(),
  ikChild: Symbol(),
  rotateChild: Symbol(),
  ikTarget: Symbol(),
  hidden: Symbol(),
  twist: Symbol(),
  roll: Symbol()
};

var _MMDAnimationCompletionBlockKey = 'MMDAnimationCompletionBlockKey';
var _faceWeightsPattern = /faceWeights\[(\d+)\]/;

var DummyNode = function (_NSObject) {
  _inherits(DummyNode, _NSObject);

  function DummyNode() {
    _classCallCheck(this, DummyNode);

    return _possibleConstructorReturn(this, (DummyNode.__proto__ || Object.getPrototypeOf(DummyNode)).apply(this, arguments));
  }

  _createClass(DummyNode, [{
    key: 'valueForUndefinedKey',
    value: function valueForUndefinedKey(key) {
      return this;
    }
  }]);

  return DummyNode;
}(_jscenekit.NSObject);

var _dummyNode = new DummyNode();

/**
 *
 * @access public
 * @extends {SCNNode}
 * @implements {CAAnimationDelegate}
 */

var MMDNode = function (_SCNNode) {
  _inherits(MMDNode, _SCNNode);

  /**
   *
   * @access public
   * @param {MMDNode} mmdNode -
   * @constructor
   */
  function MMDNode() {
    var mmdNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, MMDNode);

    /**
     *
     * @type {SCNPhysicsBehaviors[]}
     */
    var _this2 = _possibleConstructorReturn(this, (MMDNode.__proto__ || Object.getPrototypeOf(MMDNode)).call(this));

    _this2.physicsBehaviors = [];

    /**
     *
     * @type {Symbol}
     */
    _this2.type = MMDNode.Type.unknown;

    /**
     *
     * @type {boolean}
     */
    _this2.isKnee = false;

    /**
     *
     * @type {MMDIKConstraint}
     */
    _this2.ikConstraint = null;

    /**
     *
     * @type {MMDIKConstraint[]}
     */
    _this2.ikArray = null;

    /**
     *
     * @type {SCNPhysicsBehavior[]}
     */
    _this2.joints = null;

    /**
     *
     * @type {number}
     */
    _this2.vertexCount = 0;

    /**
     *
     * @type {number[]}
     */
    _this2.vertexArray = null;

    /**
     *
     * @type {number[]}
     */
    _this2.normalArray = null;

    /**
     *
     * @type {number[]}
     */
    _this2.texcoordArray = null;

    /**
     *
     * @type {number[]}
     */
    _this2.boneIndicesArray = null;

    /**
     *
     * @type {number[]}
     */
    _this2.boneWeightsArray = null;

    /**
     *
     * @type {number}
     */
    _this2.indexCount = 0;

    /**
     *
     * @type {number[]}
     */
    _this2.indexArray = null;

    /**
     *
     * @type {number}
     */
    _this2.materialCount = 0;

    /**
     *
     * @type {SCNMaterial[]}
     */
    _this2.materialArray = null;

    /**
     *
     * @type {number[]}
     */
    _this2.materialIndexCountArray = null;

    /**
     *
     * @type {?SCNGeometryElement[]}
     */
    _this2.elementArray = null;

    /**
     *
     * @type {MMDNode[]}
     */
    _this2.boneArray = null;

    /**
     *
     * @type {SCNMatrix4[]}
     */
    _this2.boneInverseMatrixArray = null;

    /**
     *
     * @type {MMDNode}
     */
    _this2.rootBone = null;

    /**
     *
     * @type {?MMDNode}
     */
    _this2.rotateEffector = null;

    /**
     *
     * @type {number}
     */
    _this2.rotateEffectRate = 0;

    /**
     *
     * @type {?MMDNode}
     */
    _this2.translateEffector = null;

    /**
     *
     * @type {number}
     */
    _this2.translateEffectRate = 0;

    /**
     *
     * @type {?number[]}
     */
    _this2.faceIndexArray = null;

    /**
     *
     * @type {?number[][]}
     */
    _this2.faceDataArray = null;

    /**
     *
     * @type {number[]}
     */
    _this2.faceWeights = null;

    /**
     *
     * @type {SCNMorpher}
     */
    _this2.geometryMorpher = null;

    /**
     *
     * @type {?Map}
     */
    _this2.preparedAnimation = null;

    if (mmdNode !== null) {
      _this2.copySCNNodeValues(mmdNode);
      _this2.copyValues(mmdNode);
    }
    return _this2;
  }

  /**
   *
   * @access public
   * @returns {MMDNode} -
   */


  _createClass(MMDNode, [{
    key: 'clone',
    value: function clone() {
      //console.log('MMDNode.clone() ' + this.name)
      var newNode = _get(MMDNode.prototype.__proto__ || Object.getPrototypeOf(MMDNode.prototype), 'clone', this).call(this);
      // TODO: copy values of SCNNode
      this.copyValuesRecursive(this, newNode);

      return newNode;
    }

    /*
    copy() {
      return this.clone()
    }
    */

    /**
     *
     * @access public
     * @param {SCNNode} node -
     * @returns {void}
     */

  }, {
    key: 'copySCNNodeValues',
    value: function copySCNNodeValues(node) {
      this.name = node.name;
      this.light = node.light;
      this.camera = node.camera;
      this.geometry = node.geometry;
      this.morpher = node.morpher;
      this.skinner = node.skinner;
      this.categoryBitMask = node.categoryBitMask;
      this.isPaused = node.isPaused;
      this.transform = node.transform;
      this.constraints = node.constraints ? node.constraints.slice() : null;
      this.isHidden = node.isHidden;
      this.opacity = node.opacity;
      this.renderingOrder = node.renderingOrder;
      this.castsShadow = node.castsShadow;
      this.movabilityHint = node.movabilityHint;
      this.filters = node.filters ? node.filters.slice() : null;
      this.rendererDelegate = node.rendererDelegate;

      if (node.physicsBody) {
        var body = node.physicsBody;
        var newBody = null;
        switch (body.type) {
          case _jscenekit.SCNPhysicsBody.Type.static:
            newBody = _jscenekit.SCNPhysicsBody.static();
            break;
          case _jscenekit.SCNPhysicsBody.Type.dynamic:
            newBody = _jscenekit.SCNPhysicsBody.dynamic();
            break;
          case _jscenekit.SCNPhysicsBody.Type.kinematic:
            newBody = _jscenekit.SCNPhysicsBody.kinematic();
            break;
          default:
            throw new Error('unknown physics body type: ' + body.type);
        }
        newBody.physicsShape = body.physicsShape;
        newBody.velocityFactor = body.velocityFactor;
        newBody.angularVelocityFactor = body.angularVelocityFactor;
        newBody.isAffectedByGravity = body.isAffectedByGravity;
        newBody.mass = body.mass;
        newBody.charge = body.charge;
        newBody.friction = body.friction;
        newBody.rollingFriction = body.rollingFriction;
        newBody.restitution = body.restitution;
        newBody.damping = body.damping;
        newBody.angularDamping = body.angularDamping;
        newBody.momentOfInertia = body.momentOfInertia;
        newBody.usesDefaultMomentOfInertia = body.usesDefaultMomentOfInertia;
        newBody.cateogryBitMask = body.categoryBitMask;
        newBody.contactTestBitMask = body.contactTestBitMask;
        newBody.collisionBitMask = body.collisionBitMask;
        newBody.velocity = body.velocity;
        newBody.angularVelocity = body.angularVelocity;
        newBody.allowsResting = body.allowsResting;

        this.physicsBody = newBody;
      }

      this.physicsField = node.physicsField;
    }

    /**
     *
     * @access public
     * @param {MMDNode} node -
     * @returns {void}
     */

  }, {
    key: 'copyValues',
    value: function copyValues(node) {
      this.physicsBehaviors = node.physicsBehaviors; // [SCNPhysicsBehavior]
      this.type = node.type;
      this.isKnee = node.isKnee;
      this.ikConstraint = node.ikConstraint; // MMDIKConstraint
      this.ikArray = node.ikArray; // [MMDIKConstraint]
      this.joints = node.joints; // [SCNPhysicsBehavior]
      this.vertexCount = node.vertexCount;
      this.vertexArray = node.vertexArray;
      this.normalArray = node.normalArray;
      this.texcoordArray = node.texcoordArray;
      this.boneIndicesArray = node.boneIndicesArray;
      this.boneWeightsArray = node.boneWeightsArray;
      this.indexCount = node.indexCount;
      this.indexArray = node.indexArray;
      this.materialCount = node.materialCount;
      this.materialArray = node.materialArray; // [SCNMaterial]
      this.materialIndexCountArray = node.materialIndexCountArray;
      this.elementArray = node.elementArray; // [SCNGeometryElement]
      this.boneArray = node.boneArray; // [MMDNode]
      this.boneInverseMatrixArray = node.boneInverseMatrixArray;
      this.rootBone = node.rootBone; // MMDNode

      this.rotateEffector = node.rotateEffector; // MMDNode
      this.rotateEffectRate = node.rotateEffectRate;
      this.translateEffector = node.translateEffector; // MMDNode
      this.translateEffectRate = node.translateEffectRate;

      this.faceIndexArray = node.faceIndexArray;
      this.faceDataArray = node.faceDataArray;
      this.faceWeights = node.faceWeights;
      this.geometryMorpher = node.geometryMorpher; // SCNMorpher

      this.preparedAnimation = node.preparedAnimation;
    }

    /**
     *
     * @access public
     * @param {SCNNode} src -
     * @param {SCNNode} dst -
     * @returns {void}
     */

  }, {
    key: 'copyValuesRecursive',
    value: function copyValuesRecursive(src, dst) {
      if (src instanceof MMDNode) {
        if (dst instanceof MMDNode) {
          dst.copyValues(src);
        }
      }

      for (var i = 0; i < src.childNodes.length; i++) {
        this.copyValuesRecursive(src.childNodes[i], dst.childNodes[i]);
      }
    }
  }, {
    key: 'valueForUndefinedKey',
    value: function valueForUndefinedKey(key) {
      //console.log('MMDNode.valueForUndefinedKey: ' + key)
      if (key.startsWith('/')) {
        var searchKey = key.substring(1);
        var node = this.childNodeWithNameRecursively(searchKey, true);
        if (node) {
          return node;
        }

        //console.warn(`valueForUndefinedKey ${key} not found.`)
        return _dummyNode;
      }

      var result = key.match(_faceWeightsPattern);
      if (result) {
        var index = result[1];
        var value = this.faceWeights[index];
        return value;
      }

      if (key === 'kPivotKey') {
        return null;
      }

      return _get(MMDNode.prototype.__proto__ || Object.getPrototypeOf(MMDNode.prototype), 'valueForUndefinedKey', this).call(this, key);
    }

    /*
    setValueForUndefinedKey(value, key) {
      console.log('MMDNode.setValueForUndefinedKey: ' + key)
    }
     setValueForKeyPath(value, keyPath) {
      console.log('MMDNode.setValueForKeyPath: ' + keyPath)
      super.setValueForKeyPath(value, keyPath)
    }
    */

    /**
     *
     * @access public
     * @param {CAAnimation} animation -
     * @param {string} key -
     * @returns {void}
     */

  }, {
    key: 'prepareAnimationForKey',
    value: function prepareAnimationForKey(animation, key) {
      if (this.preparedAnimation === null) {
        this.preparedAnimation = new Map();
      }
      if (animation instanceof _jscenekit.CAAnimationGroup) {
        var convertedAnimation = this._convertAnimation(animation);
        convertedAnimation.delegate = this;
        this.preparedAnimation.set(key, convertedAnimation);
      } else {
        animation.delegate = this;
        this.preparedAnimation.set(key, animation);
      }
    }

    /**
     *
     * @access public
     * @param {string} key -
     * @returns {void}
     */

  }, {
    key: 'stopPreparedAnimationForKey',
    value: function stopPreparedAnimationForKey(key) {
      if (this.preparedAnimation === null) {
        return;
      }
      _get(MMDNode.prototype.__proto__ || Object.getPrototypeOf(MMDNode.prototype), 'removeAnimationForKey', this).call(this, key);
      //this.preparedAnimation.delete(key)
    }

    /**
     *
     * @access public
     * @param {string} key -
     * @returns {void}
     */

  }, {
    key: 'playPreparedAnimationForKey',
    value: function playPreparedAnimationForKey(key) {
      if (this.preparedAnimation === null) {
        return;
      }
      var anim = this.preparedAnimation.get(key);
      if (anim) {
        _get(MMDNode.prototype.__proto__ || Object.getPrototypeOf(MMDNode.prototype), 'addAnimationForKey', this).call(this, anim, key);
      }
    }

    /**
     *
     * @access private
     * @param {CAAnimationGroup} animation -
     * @returns {CAAnimationGroup} -
     */

  }, {
    key: '_convertAnimation',
    value: function _convertAnimation(animation) {
      var _this3 = this;

      console.log('_convertAnimation start');
      var geometryNode = this.childNodeWithNameRecursively('Geometry', true);
      var newGroup = animation.copy();
      newGroup.animations = [];

      var animations = animation.animations;
      console.log('animations');
      if (animations) {
        console.log('if(animations): true');
        animations.forEach(function (anim) {
          console.log('anim: ' + anim.keyPath);
          var hasEffector = false;
          var newAnim = anim.copy();

          if (newAnim instanceof _jscenekit.CAKeyframeAnimation) {
            console.log('newAnim: ' + newAnim.keyPath);
            var boneNameKey = newAnim.keyPath.split('.')[0];
            var boneName = boneNameKey.substring(1);
            var bone = _this3.childNodeWithNameRecursively(boneName, true);
            console.log('boneName: ' + boneName + ', bone: ' + bone);

            if (boneNameKey === 'morpher') {
              if (newAnim.keyPath.startsWith('morpher.weights.')) {
                var faceName = newAnim.keyPath.substring(16);
                var faceIndex = -1;

                // search face name from geometry node
                for (var i = 0; i < geometryNode.morpher.targets.length; i++) {
                  if (geometryNode.morpher.targets[i].name === faceName) {
                    faceIndex = i;
                    break;
                  }
                }

                if (faceIndex >= 0) {
                  newAnim.keyPath = '/Geometry.morpher.weights[' + faceIndex + ']';
                } else {
                  newAnim.keyPath = '//';
                }
              }
            } else if (bone !== null) {
              if (newAnim.keyPath.endsWith('.translation.x')) {
                for (var _i = 0; _i < newAnim.values.length; _i++) {
                  var origValue = newAnim.values[_i];
                  var newValue = origValue + bone.position.x;
                  newAnim.values[_i] = newValue;

                  //console.log(`convert ${newAnim.keyPath}: ${origValue} => ${newValue}`)
                }
              } else if (newAnim.keyPath.endsWith('.translation.y')) {
                for (var _i2 = 0; _i2 < newAnim.values.length; _i2++) {
                  var _origValue = newAnim.values[_i2];
                  var _newValue = _origValue + bone.position.y;
                  newAnim.values[_i2] = _newValue;

                  //console.log(`convert ${newAnim.keyPath}: ${origValue} => ${newValue}`)
                }
              } else if (newAnim.keyPath.endsWith('.translation.z')) {
                for (var _i3 = 0; _i3 < newAnim.values.length; _i3++) {
                  var _origValue2 = newAnim.values[_i3];
                  var _newValue2 = _origValue2 + bone.position.z;
                  newAnim.values[_i3] = _newValue2;

                  //console.log(`convert ${newAnim.keyPath}: ${origValue} => ${newValue}`)
                }
              }

              if (newAnim.values.length === 1) {
                // remove the meanless animation
                var value = newAnim.values[0];
                if (value instanceof _jscenekit.SCNVector3) {
                  if (value.x === 0 && value.y === 0 && value.z === 0) {
                    hasEffector = true;
                  }
                } else if (value instanceof _jscenekit.SCNVector4) {
                  if (value.x === 0 && value.y === 0 && value.z === 0) {
                    hasEffector = true;
                  }
                }
              } // newAnim.values.length === 1
            } // bone !== null
          } // newAnim instanceof CAKeyframeAnimation

          if (!hasEffector) {
            newGroup.animations.push(newAnim);
          }
        }); // animations.forEach
      } // animations
      console.log('_convertAnimation end');
      return newGroup;
    }

    /**
     *
     * @access public
     * @param {CAAnimation} animation -
     * @param {string} key -
     * @returns {void}
     */

  }, {
    key: 'addAnimationForKey',
    value: function addAnimationForKey(animation, key) {
      if (animation instanceof _jscenekit.CAAnimationGroup) {
        var convertedAnimation = this._convertAnimation(animation);
        _get(MMDNode.prototype.__proto__ || Object.getPrototypeOf(MMDNode.prototype), 'addAnimationForKey', this).call(this, convertedAnimation, key);
      } else {
        animation.delegate = this;
        _get(MMDNode.prototype.__proto__ || Object.getPrototypeOf(MMDNode.prototype), 'addAnimationForKey', this).call(this, animation, key);
      }
    }

    /**
     *
     * @access public
     * @returns {void}
     */

  }, {
    key: 'updateIK',
    value: function updateIK() {
      var _this4 = this;

      if (this.ikArray !== null) {
        var zeroThreshold = 0.0000001;
        this.ikArray.forEach(function (ik) {
          var ikBone = ik.ikBone;
          var targetBone = ik.targetBone;

          for (var i = 0; i < ik.iteration; i++) {
            for (var index = 0; index < ik.boneArray.length; index++) {
              var bone = ik.boneArray[index];

              var bonePosition = _this4._getWorldPosition(bone.presentation);
              var targetPosition = _this4._getWorldPosition(targetBone.presentation);
              var ikPosition = _this4._getWorldPosition(ikBone.presentation);
              //console.log(`IK it ${i} bone ${bone.name} target ${targetPosition.float32Array()} ik ${ikPosition.float32Array()}`)

              var v1 = bonePosition.sub(targetPosition);
              var v2 = bonePosition.sub(ikPosition);

              v1 = v1.normalize();
              v2 = v2.normalize();

              var diff = v1.sub(v2);
              var x2 = diff.x * diff.x;
              var y2 = diff.y * diff.y;
              var z2 = diff.z * diff.z;
              if (x2 + y2 + z2 < zeroThreshold) {
                break;
              }

              var v = v1.cross(v2);
              v = _this4._inverseCross(v, bone.parent.presentation.worldTransform);
              v = v.normalize();

              if (bone.isKnee) {
                if (v.x > 0) {
                  v.x = 1.0;
                } else {
                  v.x = -1.0;
                }
                v.y = 0;
                v.z = 0;
              }

              var innerProduct = v1.dot(v2);
              if (innerProduct > 1) {
                innerProduct = 1;
              } else if (innerProduct < -1) {
                innerProduct = -1;
              }

              var ikRot = 0.5 * Math.acos(innerProduct);
              var maxRot = ik.weight * (index + 1) * 2;
              if (ikRot > maxRot) {
                ikRot = maxRot;
              }

              var ikSin = Math.sin(ikRot);
              var ikCos = Math.cos(ikRot);
              var quat = new _jscenekit.SCNVector4();

              // create quaternion
              quat.x = v.x * ikSin;
              quat.y = v.y * ikSin;
              quat.z = v.z * ikSin;
              quat.w = ikCos;

              var orgQuat = _this4._rotationToQuat(bone.presentation.rotation);
              //console.log(`${this.name} rot ${bone.presentation.rotation.float32Array()}`)
              //console.log(`${this.name} orgQuat ${orgQuat.float32Array()}`)
              quat = quat.cross(orgQuat);

              // FIXME: don't use presentation node
              //bone.presentation.rotation = this._quatToRotation(quat)
              bone.rotation = _this4._quatToRotation(quat);

              if (bone.isKnee) {
                // FIXME: don't use presentation node
                //if(bone.presentation.eulerAngles.x < 0){
                if (bone.eulerAngles.x < 0) {
                  quat.x = -quat.x;
                  // FIXME: don't use presentation node
                  //bone.presentation.rotation = rot
                  bone.rotation = _this4._quatToRotation(quat);
                  //console.log(`${bone.name} quatToRotation ${bone.rotation.float32Array()}`)
                }
              }
              //console.log(`after ${this.name} rot ${bone.presentation.rotation.float32Array()}`)
            } // boneArray
          } // iteration
        }); // ikArray
      }
      this.updateEffector();
    }

    /**
     *
     * @access public
     * @returns {void}
     */

  }, {
    key: 'updateEffector',
    value: function updateEffector() {
      if (this.rotateEffector !== null) {
        var rot = this.rotateEffector.presentation.rotation;
        if (this.rotateEffectRate === 1.0) {
          // FIXME: don't use presentation node
          //this.presentation.rotation = rot
          this.rotation = rot;
        } else {
          var quat = this._rotationToQuat(rot);
          //console.log(`${this.name} quat ${quat.float32Array()}`)
          var orgQuat = this._rotationToQuat(this.presentation.rotation);
          //console.log(`${this.name} orgQuat ${orgQuat.float32Array()}`)
          //const newQuat = this.slerp(orgQuat, quat, this.rotateEffectRate)
          var newQuat = orgQuat.slerp(quat, this.rotateEffectRate);
          var newRot = this._quatToRotation(newQuat);
          // FIXME: don't use presentation
          //this.presentation.rotation = newRot
          this.rotation = newRot;
          //console.log(`${this.name} newQuat.quatToRotation ${this.rotation.float32Array()}`)
        }
      }
      if (this.translateEffector !== null) {
        var pos = this.translateEffector.presentation.position;
        if (this.translateEffectRate === 1.0) {
          // FIXME: don't use presentation node
          //this.presentation.position = pos
          this.position = pos;
        } else {
          // FIXME: don't use presentation node
          //this.presentation.position = pos.mul(this.translateEffectRate)
          this.position = pos.mul(this.translateEffectRate);
        }
      }
    }

    /**
     * 
     * @access public
     * @param {SCNScene} scene -
     * @returns {void}
     */

  }, {
    key: 'addPhysicsBehavior',
    value: function addPhysicsBehavior(scene) {
      if (this.joints === null) {
        return;
      }

      this.joints.forEach(function (joint) {
        scene.physicsWorld.addBehavior(joint);
      });
    }

    /**
     *
     * @access public
     * @param {SCNScene} scene -
     * @returns {void}
     */

  }, {
    key: 'removePhysicsBehavior',
    value: function removePhysicsBehavior(scene) {
      if (this.joints === null) {
        return;
      }

      this.joints.forEach(function (joint) {
        scene.physicsWorld.removeBehavior(joint);
      });
    }

    /**
     *
     * @access public
     * @returns {SCNNode} -
     */

  }, {
    key: 'getRootNode',
    value: function getRootNode() {
      var node = this;
      var parentNode = node.parent;
      while (parentNode !== null) {
        node = parentNode;
        parentNode = node.parent;
      }
      return node;
    }

    /**
     *
     * @access public
     * @param {string} key -
     * @param {string} boneName -
     * @returns {object} -
     */

  }, {
    key: 'getFirstFramePoseForKeyBoneName',
    value: function getFirstFramePoseForKeyBoneName(key, boneName) {}
    // TODO: implement


    /**
     *
     * @access public
     * @param {string} key -
     * @param {string} boneName -
     * @returns {object} -
     */

  }, {
    key: 'getLastFramePoseForKeyBoneName',
    value: function getLastFramePoseForKeyBoneName(key, boneName) {}
    // TODO: implement


    /////////////////////////
    // CAAnimationDelegate //
    /////////////////////////

    /**
     * @access public
     * @param {CAAnimation} anim -
     * @param {boolean} finished -
     * @returns {void}
     */

  }, {
    key: 'animationDidStop',
    value: function animationDidStop(anim, finished) {
      if (finished) {
        var block = anim.valueForKey(_MMDAnimationCompletionBlockKey);
        if (block) {
          block();
        }
      }
    }

    /**
     * @access public
     * @param {function} block -
     * @param {string} key -
     * @returns {void}
     */

  }, {
    key: 'setCompletionHandler',
    value: function setCompletionHandler(block, key) {
      var anim = this.preparedAnimation.get(key);
      if (anim) {
        anim.setValueForKey(block, _MMDAnimationCompletionBlockKey);
      }
    }
  }, {
    key: '_getWorldPosition',


    /**
     *
     * @access private
     * @param {SCNNode} node -
     * @returns {SCNVector3} -
     */
    value: function _getWorldPosition() {
      var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var m = null;
      if (node === null) {
        m = this.worldTransform;
      } else {
        m = node.worldTransform;
      }
      return new _jscenekit.SCNVector3(m.m41, m.m42, m.m43);
    }

    /**
     * @access private
     * @param {SCNVector3} v1 -
     * @param {SCNMatrix4} mat -
     * @param {boolean} [includeTranslation = false] -
     * @returns {SCNVector3} -
     */

  }, {
    key: '_inverseCross',
    value: function _inverseCross(v1, mat) {
      var includeTranslation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var v = new _jscenekit.SCNVector3();

      v.x = v1.x * mat.m11 + v1.y * mat.m12 + v1.z * mat.m13;
      v.y = v1.x * mat.m21 + v1.y * mat.m22 + v1.z * mat.m23;
      v.z = v1.x * mat.m31 + v1.y * mat.m32 + v1.z * mat.m33;

      if (includeTranslation) {
        v.x += mat.m14;
        v.y += mat.m24;
        v.z += mat.m34;
      }

      return v;
    }
  }, {
    key: '_rotationToQuat',
    value: function _rotationToQuat(rot) {
      var quat = new _jscenekit.SCNVector4();
      if (rot.x === 0 && rot.y === 0 && rot.z === 0) {
        quat.x = 0;
        quat.y = 0;
        quat.z = 0;
        quat.w = 1.0;
      } else {
        var r = 1.0 / Math.sqrt(rot.x * rot.x + rot.y * rot.y + rot.z * rot.z);
        var cosW = Math.cos(rot.w);
        var sinW = Math.sin(rot.w) * r;
        quat.x = rot.x * sinW;
        quat.y = rot.y * sinW;
        quat.z = rot.z * sinW;
        quat.w = cosW;
      }
      return quat;
    }
  }, {
    key: '_quatToRotation',
    value: function _quatToRotation(quat) {
      var rot = new _jscenekit.SCNVector4();

      if (quat.x === 0 && quat.y === 0 && quat.z === 0) {
        rot.x = 0;
        rot.y = 0;
        rot.z = 0;
        rot.w = 0;
      } else {
        rot.x = quat.x;
        rot.y = quat.y;
        rot.z = quat.z;

        var qw = quat.w;
        if (quat.w > 1) {
          qw = 1;
        } else if (quat.w < -1) {
          qw = -1;
        }
        var w = Math.acos(qw);

        if (isNaN(w)) {
          rot.w = 0;
        } else {
          rot.w = w;
        }
      }

      return rot;
    }
  }], [{
    key: 'Type',
    get: function get() {
      return _MMDNodeType;
    }
  }]);

  return MMDNode;
}(_jscenekit.SCNNode);

exports.default = MMDNode;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jscenekit = __webpack_require__(0);

var _TGAImage = __webpack_require__(20);

var _TGAImage2 = _interopRequireDefault(_TGAImage);

var _TextReader2 = __webpack_require__(10);

var _TextReader3 = _interopRequireDefault(_TextReader2);

var _ToonImages2 = __webpack_require__(7);

var _ToonImages3 = _interopRequireDefault(_ToonImages2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * @access public
 */
var MMDReader = function () {
  /**
   *
   * @access public
   * @constructor
   * @param {Buffer} data -
   * @param {string} directoryPath -
   * @param {boolean} [isBinary = true] -
   * @param {boolean} [isBigEndian = false] -
   * @param {string} [encoding = ''] -
   */
  function MMDReader(data, directoryPath) {
    var isBinary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var isBigEndian = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var encoding = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';

    _classCallCheck(this, MMDReader);

    /**
     *
     * @type {string}
     */
    this.directoryPath = directoryPath;

    /**
     *
     * @type {}
     */
    this.binaryData = data;

    /**
     *
     * @type {number}
     */
    //this.length = data.byteLength
    this.length = data.length;

    this._reader = null;

    if (isBinary) {
      this._reader = new _jscenekit._BinaryReader(data, isBigEndian, encoding);
    } else {
      this._reader = new _TextReader3.default(data, encoding);
    }
  }

  _createClass(MMDReader, [{
    key: 'skip',
    value: function skip(length) {
      var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this._reader.skip(length, noAssert);
    }
  }, {
    key: 'readString',
    value: function readString(length, encoding) {
      return this._reader.readString(length, encoding);
    }
  }, {
    key: 'readInteger',
    value: function readInteger(length, signed) {
      return this._reader.readInteger(length, signed);
    }
  }, {
    key: 'readUnsignedByte',
    value: function readUnsignedByte() {
      return this._reader.readUnsignedByte();
    }
  }, {
    key: 'readUnsignedShort',
    value: function readUnsignedShort() {
      return this._reader.readUnsignedShort();
    }
  }, {
    key: 'readUnsignedInt',
    value: function readUnsignedInt() {
      return this._reader.readUnsignedInt();
    }
  }, {
    key: 'readInt',
    value: function readInt() {
      return this._reader.readInt();
    }
  }, {
    key: 'readFloat',
    value: function readFloat() {
      return this._reader.readFloat();
    }
  }, {
    key: 'readDouble',
    value: function readDouble() {
      return this._reader.readDouble();
    }
  }, {
    key: 'getAvailableDataLength',
    value: function getAvailableDataLength() {
      return this._reader.getAvailableDataLength();
    }
  }, {
    key: 'loadTexture',
    value: function loadTexture(filePath) {
      var _this = this;

      var promise = new Promise(function (resolve, reject) {
        var fileName = _this.directoryPath + filePath;
        if (fileName.endsWith('tga')) {
          var tga = _TGAImage2.default.imageWithURL(fileName);
          tga.didLoad.then(function () {
            resolve(tga.image);
          });
        } else {
          var image = new Image();
          image.onload = function () {
            resolve(image);
          };
          image.onerror = function () {
            reject(new Error('image ' + fileName + ' load error'));
          };
          image.src = fileName;
        }
      });
      return promise;
    }
  }, {
    key: 'pos',
    get: function get() {
      return this._reader._pos;
    }
  }], [{
    key: 'toonTextures',
    get: function get() {
      return _ToonImages3.default;
    }
  }]);

  return MMDReader;
}();

exports.default = MMDReader;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _jscenekit = __webpack_require__(0);

var _MMDNode = __webpack_require__(1);

var _MMDNode2 = _interopRequireDefault(_MMDNode);

var _MMDPMDReader = __webpack_require__(9);

var _MMDPMDReader2 = _interopRequireDefault(_MMDPMDReader);

var _MMDPMMReader = __webpack_require__(12);

var _MMDPMMReader2 = _interopRequireDefault(_MMDPMMReader);

var _MMDPMXReader = __webpack_require__(13);

var _MMDPMXReader2 = _interopRequireDefault(_MMDPMXReader);

var _MMDVACReader = __webpack_require__(14);

var _MMDVACReader2 = _interopRequireDefault(_MMDVACReader);

var _MMDVMDReader = __webpack_require__(15);

var _MMDVMDReader2 = _interopRequireDefault(_MMDVMDReader);

var _MMDVPDReader = __webpack_require__(16);

var _MMDVPDReader2 = _interopRequireDefault(_MMDVPDReader);

var _MMDXReader = __webpack_require__(17);

var _MMDXReader2 = _interopRequireDefault(_MMDXReader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _MMDFileType = {
  pmm: 'pmm',
  pmd: 'pmd',
  vmd: 'vmd',
  vpd: 'vpd',
  x: 'x',
  vac: 'vac',
  pmx: 'pmx',
  obj: 'obj',
  dae: 'dae',
  abc: 'abc',
  scn: 'scn',
  unknown: 'unknown'
};

var _LoadingOption = {
  animationImportPolicy: 'kSceneSourceAnimationLoadingMode',
  assetDirectoryURLs: 'kSceneSourceAssetDirectoryURLs',
  checkConsistency: 'kSceneSourceCheckConsistency',
  convertToYUp: 'kSceneSourceConvertToYUpIfNeeded',
  convertUnitsToMeters: 'kSceneSourceConvertToUnit',
  createNormalsIfAbsent: 'kSceneSourceCreateNormalsIfAbsent',
  flattenScene: 'kSceneSourceFlattenScene',
  overrideAssetURLs: 'kSceneSourceOverrideAssetURLs',
  preserveOriginalTopology: 'kSceneSourcePreserveOriginalTopology',
  strictConformance: 'kSceneSourceStrictConformanceKey',
  useSafeMode: 'kSceneSourceUseSafeMode'

  // for node
  //import fs from 'fs'

  /**
   *
   * @access public
   * @extends {SCNSceneSource}
   */
};
var MMDSceneSource = function (_SCNSceneSource) {
  _inherits(MMDSceneSource, _SCNSceneSource);

  // Creating a Scene Source

  /**
   * Initializes a scene source for reading the scene graph from a specified file.
   * @access public
   * @constructor
   * @param {string|Buffer|ArrayBuffer} data -
   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.
   * @param {string} directoryPath -
   * @param {MMDNode[]} models -
   * @param {CAAnimation[]} motions -
   * @desc If you have the contents of a scene file but not the file itself (for example, if your app downloads scene files from the network), use the init(data:options:) method instead.
   * @see https://developer.apple.com/reference/scenekit/scnscenesource/1522629-init
   */
  function MMDSceneSource(data, options, directoryPath, models, motions) {
    _classCallCheck(this, MMDSceneSource);

    var _this = _possibleConstructorReturn(this, (MMDSceneSource.__proto__ || Object.getPrototypeOf(MMDSceneSource)).call(this, data, options));

    _this._fileType = _MMDFileType.unknown;
    _this._directoryPath = directoryPath;
    _this._workingScene = null;
    _this._workingNode = null;
    _this._workingAnimationGroup = null;

    //if(typeof data === 'undefined'){
    //  return
    //}
    //this._loadData(data, options)
    return _this;
  }

  _createClass(MMDSceneSource, [{
    key: '_loadData',


    /**
     *
     * @access private
     * @param {Buffer} data -
     * @param {Map<SCNSceneSource.LoadingOption, object>} options -
     * @param {?MMDNode[]} [models = null] -
     * @param {?CAAnimation[]} [motions = null] -
     * @returns {void}
     */
    value: function _loadData(data, options) {
      var _this2 = this;

      var models = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var motions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      console.warn('MMDSceneSource _loadData');
      //this._workingScene = new MMDScene()
      this._workingScene = new _jscenekit.SCNScene();
      this._checkFileTypeFromData(data);

      if (this._fileType === _MMDFileType.pmd) {
        var pmdNode = _MMDPMDReader2.default.getNode(data, this._directoryPath);
        if (pmdNode) {
          this._workingNode = pmdNode;
        }
      } else if (this._fileType === _MMDFileType.vmd) {
        var vmdMotion = _MMDVMDReader2.default.getMotion(data);
        if (vmdMotion) {
          this._workingAnimationGroup = vmdMotion;
        }
      } else if (this._fileType === _MMDFileType.x) {
        var xNode = _MMDXReader2.default.getNode(data, this._directoryPath);
        if (xNode) {
          this._workingNode = xNode;
        }
      } else if (this._fileType === _MMDFileType.pmx) {
        var pmxNode = _MMDPMXReader2.default.getNode(data, this._directoryPath);
        if (pmxNode) {
          this._workingNode = pmxNode;
          pmxNode.didLoad.then(function () {
            console.error('pmxNode.didLoad');
          });
        }
      } else if (this._fileType === _MMDFileType.vpd) {
        var vpdAnimation = _MMDVPDReader2.default.getAnimation(data);
        if (vpdAnimation) {
          this.workingAnimationGroup = vpdAnimation;
        }
      } else if (this._fileType === _MMDFileType.pmm) {
        var pmmScene = _MMDPMMReader2.default.getScene(data, this._directoryPath, models, motions);
        if (pmmScene) {
          pmmScene.rootNode.childNodes.forEach(function (node) {
            _this2._workingScene.rootNode.addChildNode(node);
          });
        }
      } else if (this._fileType === _MMDFileType.vac) {
        var vacNode = _MMDVACReader2.default.getNode(data, this._directoryPath);
        if (vacNode) {
          this._workingNode = vacNode;
        }
      } else if (this._fileType === _MMDFileType.obj || this._fileType === _MMDFileType.dae || this._fileType === _MMDFileType.scn) {
        var sceneSource = new _jscenekit.SCNSceneSource(data, options);
        if (sceneSource) {
          var scene = sceneSource.scene(options);
          var mmdNode = new _MMDNode2.default();
          scene.rootNode.childNodes.forEach(function (child) {
            mmdNode.addChildNode(child);
          });
          this._workingNode = mmdNode;
        }
      } else if (this._fileType === _MMDFileType.abc) {
        // ?
      } else {
        // try SCNSceneSource to load the data
        this._data = data;
        this._workingScene = _get(MMDSceneSource.prototype.__proto__ || Object.getPrototypeOf(MMDSceneSource.prototype), 'scene', this).call(this, options);
      }

      if (this._workingNode) {
        this._workingScene.rootNode.addChildNode(this._workingNode);
      }
      if (this._workingAnimationGroup) {
        this._workingScene.rootNode.addAnimationForKey(this._workingAnimationGroup, null);
      }
    }
  }, {
    key: 'scene',
    value: function scene() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var statusHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var _options = options;
      if (!_options) {
        if (this._options) {
          _options = this._options;
        } else {
          _options = new Map();
        }
      }

      var url = this._url;
      var assetDirectoryURLs = _options.get(_LoadingOption.assetDirectoryURLs);
      if (assetDirectoryURLs) {
        var dir = assetDirectoryURLs;
        if (Array.isArray(dir)) {
          dir = dir[0];
        }
        url = dir + '/';
        if (this._url) {
          url += this._url.split('/').pop();
        }
      }
      if (!this._directoryPath) {
        var paths = url.split('/');
        paths.pop();
        this._directoryPath = paths.join('/') + '/';
      }

      this._loadData(this._data, _options);

      return this.getScene();
    }
  }, {
    key: 'modelNodes',
    value: function modelNodes() {
      var nodeArray = [];
      if (this._fileType === _MMDFileType.pmd || this._fileType === _MMDFileType.pmx || this._fileType === _MMDFileType.x || this._fileType === _MMDFileType.vac) {
        nodeArray.push(this._workingNode);
      } else if (this._fileType === _MMDFileType.pmm) {
        this._workingScene.rootNode.childNodes.forEach(function (node) {
          if (node instanceof _MMDNode2.default) {
            nodeArray.push(node); // FIXME: clone node
          }
        });
      }
      return nodeArray;
    }
  }, {
    key: 'getScene',
    value: function getScene() {
      return this._workingScene;
    }
  }, {
    key: 'getModel',
    value: function getModel() {
      if (this._workingScene === null) {
        this.scene();
      }

      if (this._fileType === _MMDFileType.pmd || this._fileType === _MMDFileType.pmx || this._fileType === _MMDFileType.x || this._fileType === _MMDFileType.vac) {
        this._workingNode.didLoad.then(function () {
          console.error('workingNode.didLoad');
        });
        return this._workingNode;
      } else if (this._fileType === _MMDFileType.pmm) {
        return this._workingScene.rootNode.childNodes.find(function (node) {
          return node instanceof _MMDNode2.default;
        });
      }
      throw new Error('getModel not implemented for the file type');
    }
  }, {
    key: 'getMotion',
    value: function getMotion() {
      if (this._workingScene === null) {
        this.scene();
      }

      return this._workingAnimationGroup;
    }

    /**
     *
     * @access public
     * @returns {Map<string, CAAnimation>} -
     */

  }, {
    key: 'animations',
    value: function animations() {
      var animationHash = new Map();
      animationHash.set('animation', this._workingAnimationGroup); // FIXME
      return animationHash;
    }

    /**
     * 
     * @access private
     * @param {Buffer} data -
     * @returns {Symbol} -
     */

  }, {
    key: '_checkFileTypeFromData',
    value: function _checkFileTypeFromData(data) {
      var str = data.toString('ascii', 0, 25);
      if (str.startsWith('Pmd')) {
        this._fileType = _MMDFileType.pmd;
      } else if (str.startsWith('xof ')) {
        this._fileType = _MMDFileType.x;
      } else if (str.startsWith('PMX ')) {
        this._fileType = _MMDFileType.pmx;
      } else if (str.startsWith('Vocaloid Pose Data File')) {
        this._fileType = _MMDFileType.vpd;
      } else if (str.startsWith('Polygon Movie maker 0001') || str.startsWith('Polygon Movie maker 0002')) {
        this._fileType = _MMDFileType.pmm;
      } else if (str.startsWith('Vocaloid Motion Data 0002')) {
        this._fileType = _MMDFileType.vmd;
      }

      return this._fileType;
    }
  }, {
    key: 'cameraNodes',
    get: function get() {
      var cameraArray = [];
      // TODO: implement
      return cameraArray;
    }
  }, {
    key: 'lightNodes',
    get: function get() {
      var lightArray = [];
      // TODO: implement
      return lightArray;
    }
  }], [{
    key: 'sceneSourceWithDataOptions',
    value: function sceneSourceWithDataOptions(data, options, directoryPath) {
      var models = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var motions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

      return new MMDSceneSource(data, options, directoryPath, models, motions);
    }
  }, {
    key: 'sceneSourceWithURLOptions',
    value: function sceneSourceWithURLOptions(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var models = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var motions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var _options = options;
      if (_options === null) {
        _options = new Map();
      }
      if (typeof _options.get(_LoadingOption.assetDirectoryURLs) === 'undefined') {
        var paths = url.split('/');
        var name = paths.pop();
        var directory = paths.join('/');

        _options.set(_LoadingOption.assetDirectoryURLs, directory);
      }

      var source = new MMDSceneSource();
      source._url = url;
      _jscenekit._BinaryRequest.get(url).then(function (data) {
        source._data = data;
        source._options = _options;
        source._resolveFunction();
      });

      // check file type from the file extension
      if (url.endsWith('.vac')) {
        source._fileType = _MMDFileType.vac;
      } else if (url.endsWith('.obj')) {
        source._fileType = _MMDFileType.obj;
      } else if (url.endsWith('.dae')) {
        source._fileType = _MMDFileType.dae;
      } else if (url.endsWith('.abc')) {
        source._fileType = _MMDFileType.abc;
      } else if (url.endsWith('.scn')) {
        source._fileType = _MMDFileType.scn;
      }

      return source;
    }
  }, {
    key: 'sceneSourceWithPathOptions',
    value: function sceneSourceWithPathOptions(path, options) {
      var models = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var motions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var paths = path.split('/');
      var fileName = paths.pop();
      var directoryPath = paths.join('/') + '/';

      // for node
      /*
      const promise = new Promise((resolve, reject) => {
        fs.readFile(path, null, (err, data) => {
          if(err){
            reject(err)
            return
          }
           const source = new MMDSceneSource(data, options, directoryPath, models, motions)
          resolve(source)
        })
      })
      */

      // for browser
      /*
      const promise = BinaryRequest.get(path)
        .then((data) => {
          const source = new MMDSceneSource(data, options, models, motions)
          Promise.reject(error)
          Promise.resolve(source)
        })
      */

      var promise = new Promise(function (resolve, reject) {
        var file = new _jscenekit._File([], path);
        var reader = new _jscenekit._FileReader();
        reader.onloadend = function () {
          var data = reader.result;
          var source = new MMDSceneSource(data, options, directoryPath, models, motions);
          resolve(source);
        };
        reader.onerror = function () {
          reject(reader.error);
        };
        reader.readAsBinaryString(file);
      });

      return promise;
    }
  }, {
    key: 'sceneSource',
    value: function sceneSource() {
      return new MMDSceneSource();
    }
  }, {
    key: 'FileType',
    get: function get() {
      return _MMDFileType;
    }
  }]);

  return MMDSceneSource;
}(_jscenekit.SCNSceneSource);

exports.default = MMDSceneSource;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * @access public
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MMDIKConstraint = function MMDIKConstraint() {
  _classCallCheck(this, MMDIKConstraint);
};

exports.default = MMDIKConstraint;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _jscenekit = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @access private
 * @type {string}
 */
var _vertexShader = '#version 300 es\n  precision mediump float;\n\n  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__\n  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__\n  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__\n  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__\n  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__\n  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__\n  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__\n\n  #define NUM_SHADOW_LIGHTS (NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS)\n  #define NUM_LIGHTS (NUM_AMBIENT_LIGHTS + NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS + NUM_IES_LIGHTS + NUM_PROBE_LIGHTS)\n\n  #define USE_SHADER_MODIFIER_GEOMETRY __USE_SHADER_MODIFIER_GEOMETRY__\n\n  layout (std140) uniform cameraUniform {\n    vec4 position;\n    mat4 viewTransform;\n    mat4 viewProjectionTransform;\n  } camera;\n\n  layout (std140) uniform materialUniform {\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    float shininess;\n    float fresnelExponent;\n  } material;\n\n  struct AmbientLight {\n    vec4 color;\n  };\n\n  struct DirectionalLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct DirectionalShadowLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n    vec4 shadowColor;\n    mat4 viewProjectionTransform;\n    mat4 shadowProjectionTransform;\n  };\n\n  struct OmniLight {\n    vec4 color;\n    vec4 position; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct SpotLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct IESLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct ProbeLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  layout (std140) uniform lightUniform {\n    #if NUM_AMBIENT_LIGHTS > 0\n      AmbientLight ambient[NUM_AMBIENT_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n      DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    #endif\n    #if NUM_OMNI_LIGHTS > 0\n      OmniLight omni[NUM_OMNI_LIGHTS];\n    #endif\n    #if NUM_SPOT_LIGHTS > 0\n      SpotLight spot[NUM_SPOT_LIGHTS];\n    #endif\n    #if NUM_IES_LIGHTS > 0\n      IESLight ies[NUM_IES_LIGHTS];\n    #endif\n    #if NUM_PROBE_LIGHTS > 0\n      ProbeLight probe[NUM_PROBE_LIGHTS];\n    #endif\n    #if NUM_LIGHTS == 0\n      vec4 dummy;\n    #endif\n  } light;\n  #if NUM_SHADOW_LIGHTS > 0\n    out vec3 v_light[NUM_SHADOW_LIGHTS];\n  #endif\n  #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n    out vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    out vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n  #endif\n  out vec2 v_sptex;\n\n  layout (std140) uniform fogUniform {\n    vec4 color;\n    float startDistance;\n    float endDistance;\n    float densityExponent;\n  } fog;\n\n  #define kSCNTexcoordCount 2\n  struct SCNShaderGeometry {\n    vec3 position;\n    vec3 normal;\n    vec4 tangent;\n    vec4 color;\n    vec2 texcoords[kSCNTexcoordCount];\n  };\n\n  uniform float u_time;\n  //uniform mat3x4[255] skinningJoints;\n  uniform vec4[765] skinningJoints;\n  uniform int numSkinningJoints;\n  uniform mat4 modelTransform;\n\n  in vec3 position;\n  in vec3 normal;\n  in vec3 tangent;\n  in vec4 color;\n  in vec2 texcoord0;\n  in vec2 texcoord1;\n  in vec4 boneIndices;\n  in vec4 boneWeights;\n\n  out vec3 v_position;\n  out vec3 v_normal;\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n  out vec2 v_texcoord0;\n  out vec2 v_texcoord1;\n  out vec4 v_color;\n  out vec3 v_eye;\n  out float v_fogFactor;\n\n  __USER_CUSTOM_UNIFORM__\n\n  #if USE_SHADER_MODIFIER_GEOMETRY\n  void shaderModifierGeometry(inout SCNShaderGeometry _geometry) {\n    __SHADER_MODIFIER_GEOMETRY__\n  }\n  #endif\n\n  void main() {\n    SCNShaderGeometry _geometry;\n    _geometry.position = position;\n    _geometry.normal = normal;\n    _geometry.tangent = vec4(tangent, 1.0);\n    _geometry.color = color;\n    _geometry.texcoords[0] = texcoord0;\n    _geometry.texcoords[1] = texcoord1;\n    \n    #if USE_SHADER_MODIFIER_GEOMETRY\n      shaderModifierGeometry(_geometry);\n    #endif\n\n    vec3 pos = vec3(0, 0, 0);\n    vec3 nom = vec3(0, 0, 0);\n    vec3 tng = vec3(0, 0, 0);\n    vec4 col = _geometry.color;\n\n    if(numSkinningJoints > 0){\n      for(int i=0; i<numSkinningJoints; i++){\n        float weight = boneWeights[i];\n        if(int(boneIndices[i]) < 0){\n          continue;\n        }\n        int idx = int(boneIndices[i]) * 3;\n        mat4 jointMatrix = transpose(mat4(skinningJoints[idx],\n                                          skinningJoints[idx+1],\n                                          skinningJoints[idx+2],\n                                          vec4(0, 0, 0, 1)));\n        pos += (jointMatrix * vec4(_geometry.position, 1.0)).xyz * weight;\n        nom += (mat3(jointMatrix) * _geometry.normal) * weight;\n        tng += (mat3(jointMatrix) * _geometry.tangent.xyz) * weight;\n      }\n    }else{\n      mat4 jointMatrix = transpose(mat4(skinningJoints[0],\n                                        skinningJoints[1],\n                                        skinningJoints[2],\n                                        vec4(0, 0, 0, 1)));\n      pos = (jointMatrix * vec4(_geometry.position, 1.0)).xyz;\n      nom = mat3(jointMatrix) * _geometry.normal;\n      tng = mat3(jointMatrix) * _geometry.tangent.xyz;\n    }\n    v_position = pos;\n    v_normal = normalize(nom);\n    v_tangent = normalize(tng);\n    v_bitangent = cross(v_tangent, v_normal);\n\n    vec3 viewVec = camera.position.xyz - pos;\n    v_eye = viewVec;\n\n    v_color = material.emission;\n\n    // Lighting\n    int numLights = 0;\n\n    v_color.rgb = material.emission.rgb;\n\n    #if NUM_AMBIENT_LIGHTS > 0\n      for(int i=0; i<NUM_AMBIENT_LIGHTS; i++){\n        v_color.rgb += light.ambient[i].color.rgb * material.ambient.rgb;\n      }\n    #endif\n\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      if(!useToon){\n        for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){\n          v_light[numLights + i] = -light.directional[i].direction.xyz;\n\n          vec4 diffuseColor = material.diffuse * vec4(light.directional[i].color.rgb, 1.0);\n          vec3 lightVec = normalize(v_light[numLights + i]);\n          float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n          v_color.rgb += diffuse * diffuseColor.rgb;\n          //v_color.a = diffuseColor.a;\n          v_color = clamp(v_color, 0.0f, 1.0f);\n        }\n      }\n      v_color.a = material.diffuse.a;\n\n      numLights += NUM_DIRECTIONAL_LIGHTS;\n    #endif\n\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n      if(!useToon){\n        for(int i=0; i<NUM_DIRECTIONAL_SHADOW_LIGHTS; i++){\n          v_light[numLights + i] = -light.directionalShadow[i].direction.xyz;\n          v_directionalShadowDepth[i] = light.directionalShadow[i].viewProjectionTransform * vec4(pos, 1.0);\n          v_directionalShadowTexcoord[i] = light.directionalShadow[i].shadowProjectionTransform * vec4(pos, 1.0);\n\n          vec4 diffuseColor = material.diffuse * vec4(light.directionalShadow[i].color.rgb, 1.0);\n          vec3 lightVec = normalize(v_light[numLights + i]);\n          float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n          v_color.rgb += diffuse * diffuseColor.rgb;\n          v_color.a = diffuseColor.a;\n          v_color = clamp(v_color, 0.0f, 1.0f);\n        }\n      }\n      v_color.a = material.diffuse.a;\n\n      numLights += NUM_DIRECTIONAL_SHADOW_LIGHTS;\n    #endif\n\n    if(useSphereMap){\n      if(useSubTexture){\n        v_sptex = \n      }else{\n        vec2 normalWV = vec2(camera.viewTransform * vec4(v_normal, 1.0));\n        v_sptex.x = normalWV.x * 0.5 + 0.5;\n        v_sptex.y = normalWV.y * (-0.5) + 0.5;\n      }\n    }\n\n    #if NUM_OMNI_LIGHTS > 0\n      for(int i=0; i<NUM_OMNI_LIGHTS; i++){\n        v_light[numLights + i] = light.omni[i].position.xyz - pos;\n      }\n      numLights += NUM_OMNI_LIGHTS;\n    #endif\n\n    #if NUM_SPOT_LIGHTS > 0\n      for(int i=0; i<NUM_SPOT_LIGHTS; i++){\n        v_light[numLights + i] = light.spot[i].position.xyz - pos;\n      }\n      numLights += NUM_SPOT_LIGHTS;\n    #endif\n\n    #if NUM_IES_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_PROBE_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    float distance = length(viewVec);\n    v_fogFactor = clamp((distance - fog.startDistance) / (fog.endDistance - fog.startDistance), 0.0, 1.0);\n\n    v_texcoord0 = _geometry.texcoords[0];\n    v_texcoord1 = _geometry.texcoords[1];\n    gl_Position = camera.viewProjectionTransform * vec4(pos, 1.0);\n  }\n';

/**
 * @access private
 * @type {string}
 */
var _fragmentShader = '#version 300 es\n  precision mediump float;\n  precision highp sampler2DShadow;\n\n  uniform bool[8] textureFlags;\n  #define TEXTURE_EMISSION_INDEX 0\n  #define TEXTURE_AMBIENT_INDEX 1\n  #define TEXTURE_DIFFUSE_INDEX 2\n  #define TEXTURE_SPECULAR_INDEX 3\n  #define TEXTURE_REFLECTIVE_INDEX 4\n  #define TEXTURE_TRANSPARENT_INDEX 5\n  #define TEXTURE_MULTIPLY_INDEX 6\n  #define TEXTURE_NORMAL_INDEX 7\n\n  uniform bool selfIllumination;\n\n  uniform sampler2D u_emissionTexture;\n  uniform sampler2D u_ambientTexture;\n  uniform sampler2D u_diffuseTexture;\n  uniform sampler2D u_specularTexture;\n  uniform samplerCube u_reflectiveTexture;\n  uniform sampler2D u_transparentTexture;\n  uniform sampler2D u_multiplyTexture;\n  uniform sampler2D u_normalTexture;\n\n  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__\n  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__\n  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__\n  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__\n  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__\n  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__\n  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__\n\n  #define NUM_SHADOW_LIGHTS (NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS)\n  #define NUM_LIGHTS (NUM_AMBIENT_LIGHTS + NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS + NUM_IES_LIGHTS + NUM_PROBE_LIGHTS)\n\n  #define USE_SHADER_MODIFIER_SURFACE __USE_SHADER_MODIFIER_SURFACE__\n  #define USE_SHADER_MODIFIER_FRAGMENT __USE_SHADER_MODIFIER_FRAGMENT__\n\n  layout (std140) uniform materialUniform {\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    float shininess;\n    float fresnelExponent;\n  } material;\n\n  struct AmbientLight {\n    vec4 color;\n  };\n\n  struct DirectionalLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct DirectionalShadowLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n    vec4 shadowColor;\n    mat4 viewProjectionTransform;\n    mat4 shadowProjectionTransform;\n  };\n\n  struct OmniLight {\n    vec4 color;\n    vec4 position; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct ProbeLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct SpotLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  layout (std140) uniform lightUniform {\n    #if NUM_AMBIENT_LIGHTS > 0\n      AmbientLight ambient[NUM_AMBIENT_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS];\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n      DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    #endif\n    #if NUM_OMNI_LIGHTS > 0\n      OmniLight omni[NUM_OMNI_LIGHTS];\n    #endif\n    #if NUM_SPOT_LIGHTS > 0\n      SpotLight spot[NUM_SPOT_LIGHTS];\n    #endif\n    #if NUM_IES_LIGHTS > 0\n      IESLight ies[NUM_IES_LIGHTS];\n    #endif\n    #if NUM_PROBE_LIGHTS > 0\n      ProbeLight probe[NUM_PROBE_LIGHTS];\n    #endif\n    #if NUM_LIGHTS == 0\n      vec4 dummy;\n    #endif\n  } light;\n  #if NUM_SHADOW_LIGHTS > 0\n    in vec3 v_light[NUM_SHADOW_LIGHTS];\n  #endif\n  #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n    in vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    in vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS];\n    uniform sampler2D u_shadowMapTexture0;\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 1\n      uniform sampler2D u_shadowMapTexture1;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 2\n      uniform sampler2D u_shadowMapTexture2;\n    #endif\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 3\n      uniform sampler2D u_shadowMapTexture3;\n    #endif\n  #endif\n\n  layout (std140) uniform fogUniform {\n    vec4 color;\n    float startDistance;\n    float endDistance;\n    float densityExponent;\n  } fog;\n\n  struct SCNShaderSurface {\n    vec3 view;\n    vec3 position;\n    vec3 normal;\n    vec2 normalTexcoord;\n    vec3 geometryNormal;\n    vec3 tangent;\n    vec3 bitangent;\n    vec4 ambient;\n    vec2 ambientTexcoord;\n    vec4 diffuse;\n    vec2 diffuseTexcoord;\n    vec4 specular;\n    vec2 specularTexcoord;\n    vec4 emission;\n    vec2 emissionTexcoord;\n    vec4 multiply;\n    vec2 multiplyTexcoord;\n    vec4 transparent;\n    vec2 transparentTexcoord;\n    vec4 reflective;\n    float ambientOcclusion;\n    float shininess;\n    float fresnel;\n    __USER_CUSTOM_SURFACE__\n  } _surface;\n\n  struct SCNShaderOutput {\n    vec4 color;\n  } _output;\n\n  vec2 poissonDisk[4] = vec2[](\n    vec2( -0.94201624, -0.39906216 ),\n    vec2( 0.94558609, -0.76890725 ),\n    vec2( -0.094184101, -0.92938870 ),\n    vec2( 0.34495938, 0.29387760 )\n  );\n\n  uniform float u_time;\n\n  in vec3 v_position;\n  in vec3 v_normal;\n  in vec2 v_texcoord0;\n  in vec2 v_texcoord1;\n  in vec4 v_color;\n  in vec3 v_eye;\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  in float v_fogFactor;\n\n  out vec4 outColor;\n\n  __USER_CUSTOM_UNIFORM__\n\n  float saturate(float value) {\n    return clamp(value, 0.0, 1.0);\n  }\n\n  float convDepth(vec4 color) {\n    const float rMask = 1.0;\n    const float gMask = 1.0 / 255.0;\n    const float bMask = 1.0 / (255.0 * 255.0);\n    const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n    float depth = dot(color, vec4(rMask, gMask, bMask, aMask));\n    return depth * 2.0 - 1.0;\n  }\n\n  #if USE_SHADER_MODIFIER_SURFACE\n  void shaderModifierSurface() {\n    __SHADER_MODIFIER_SURFACE__\n  }\n  #endif\n\n  #if USE_SHADER_MODIFIER_FRAGMENT\n  void shaderModifierFragment() {\n    __SHADER_MODIFIER_FRAGMENT__\n  }\n  #endif\n\n    \n  void main() {\n    bool spadd = true;\n\n    _output.color = v_color;\n\n    //vec3 viewVec = normalize(v_eye);\n    //vec3 nom = normalize(v_normal);\n    _surface.view = normalize(v_eye);\n    _surface.position = v_position;\n    _surface.normal = normalize(v_normal);\n    _surface.tangent = normalize(v_tangent);\n    _surface.bitangent = normalize(v_bitangent);\n\n    // normal texture\n    //if(textureFlags[TEXTURE_NORMAL_INDEX]){\n    //  mat3 tsInv = mat3(_surface.tangent, _surface.bitangent, _surface.normal);\n    //  vec3 color = normalize(texture(u_normalTexture, v_texcoord0).rgb * 2.0 - 1.0); // FIXME: check mappingChannel to decide which texture you use.\n    //  _surface.normal = normalize(tsInv * color);\n    //}\n\n    #if USE_SHADER_MODIFIER_SURFACE\n      shaderModifierSurface();\n    #endif\n\n    // emission texture\n    //if(textureFlags[TEXTURE_EMISSION_INDEX]){\n    //  if(selfIllumination){\n    //    vec4 color = texture(u_emissionTexture, v_texcoord1); // FIXME: check mappingChannel to decide which texture you use.\n    //    _output.color += color;\n    //  }else{\n    //    vec4 color = texture(u_emissionTexture, v_texcoord0);\n    //    _output.color = color * _output.color;\n    //  }\n    //}\n\n    vec4 specularColor;\n    if(textureFlags[TEXTURE_SPECULAR_INDEX]){\n      vec4 color = texture(u_specularTexture, v_texcoord0);\n      specularColor = color;\n    }else{\n      specularColor = material.specular;\n    }\n      \n    //_output.color.a = material.diffuse.a;\n    vec4 shadowColor = vec4(clamp(material.ambient.rgb, 0.0f, 1.0f), v_color.a);\n    if(textureFlags[TEXTURE_DIFFUSE_INDEX]){\n      vec4 texColor = texture(u_diffuseTexture, v_texcoord0);\n      vec4 textureMulValue = vec4(1);\n      vec4 textureAddValue = vec4(0);\n\n      if(textureFlags[TEXTURE_EMISSION_INDEX]){\n        textureAddValue = texture(u_emissionTexture, v_texcoord0);\n      }\n      if(textureFlags[TEXTURE_MULTIPLY_INDEX]){\n        textureMulValue = texture(u_multiplyTexture, v_texcoord0);\n      }\n      texColor.rgb = mix(vec3(1), texColor.rgb * textureMulValue.rgb + textureAddValue.rgb, textureMulValue.a + textureAddValue.a);\n      _output.color *= texColor;\n      shadowColor *= texColor;\n\n    }\n    if(textureFlags[TEXTURE_REFLECTIVE_INDEX]){\n      vec4 sphereMulValue = vec4(1);\n      vec4 sphereAddValue = vec4(0);\n\n      vec3 r = reflect(_surface.view, _surface.normal);\n      vec4 texColor = texture(u_reflectiveTexture, r);\n      texColor.rgb = mix(spadd ? vec3(0) : vec3(1), texColor.rgb * sphereMulValue.rgb + sphereAddValue.rgb, sphereMulValue.a + sphereAddValue.a);\n      if(spadd){\n        _output.color.rgb += texColor.rgb;\n        shadowColor.rgb += texColor.rgb;\n      }else{\n        _output.color.rgb *= texColor.rgb;\n        shadowColor.rgb *= texColor.rgb;\n      }\n      _output.color.a *= texColor.a;\n      shadowColor.a *= texColor.a;\n    }\n    _output.color.rgb += specularColor.rgb;\n\n    // Lighting\n    int numLights = 0;\n\n    #if NUM_AMBIENT_LIGHTS > 0\n      // nothing to do for ambient lights\n    #endif\n\n    vec4 outSpecular = vec4(0, 0, 0, 1);\n    #if NUM_DIRECTIONAL_LIGHTS > 0\n      //for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){\n      //  // diffuse\n      //  vec3 lightVec = normalize(v_light[numLights + i]);\n      //  float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n      //  _output.color.rgb += light.directional[i].color.rgb * material.diffuse.rgb * diffuse;\n      //  _output.color.a = material.diffuse.a;\n\n      //  // specular\n      //  if(diffuse > 0.0f){\n      //    vec3 halfVec = normalize(lightVec + _surface.view);\n      //    float specular = pow(dot(halfVec, _surface.normal), material.shininess);\n      //    _output.color.rgb += specularColor.rgb * specular;\n      //  }\n      //}\n      for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        vec3 halfVector = normalize(lightVec + _surface.view);\n        float specular = pow(max(0, dot(halfVec, _surface.normal)), material.shininess);\n        outSpecular = specular * specularColor;\n      }\n      numLights += NUM_DIRECTIONAL_LIGHTS;\n    #endif\n\n    #if NUM_DIRECTIONAL_SHADOW_LIGHTS > 0\n      for(int i=0; i<NUM_DIRECTIONAL_SHADOW_LIGHTS; i++){\n        vec3 lightVec = normalize(v_light[numLights + i]);\n        vec3 halfVector = normalize(lightVec + _surface.view);\n        float specular = pow(max(0, dot(halfVec, _surface.normal)), material.shininess);\n        outSpecular = specular * specularColor;\n      }\n    #endif\n\n    #if NUM_OMNI_LIGHTS > 0\n      //for(int i=0; i<NUM_OMNI_LIGHTS; i++){\n      //  // diffuse\n      //  vec3 lightVec = normalize(v_light[numLights + i]);\n      //  float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n      //  _output.color.rgb += light.omni[i].color.rgb * material.diffuse.rgb * diffuse;\n\n      //  // specular\n      //  if(diffuse > 0.0f){\n      //    vec3 halfVec = normalize(lightVec + _surface.view);\n      //    float specular = pow(dot(halfVec, _surface.normal), material.shininess);\n      //    //outColor.rgb += material.specular.rgb * specular; // TODO: get the light color of specular\n      //    _output.color.rgb += specularColor.rgb * specular;\n      //  }\n      //}\n      numLights += NUM_OMNI_LIGHTS;\n    #endif\n\n    #if NUM_SPOT_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_IES_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n    #if NUM_PROBE_LIGHTS > 0\n      // TODO: implement\n    #endif\n\n\n    // diffuse texture\n    //if(textureFlags[TEXTURE_DIFFUSE_INDEX]){\n    //  vec4 color = texture(u_diffuseTexture, v_texcoord0);\n    //  _output.color = color * _output.color;\n    //}\n\n    // fresnel reflection\n    //if(textureFlags[TEXTURE_REFLECTIVE_INDEX]){\n    //  vec3 r = reflect(_surface.view, _surface.normal);\n    //  //float f0 = 0.0; // TODO: calculate f0\n    //  //float fresnel = f0 + (1.0 - f0) * pow(1.0 - clamp(dot(viewVec, nom), 0.0, 1.0), material.fresnelExponent);\n    //  float fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent);\n    //  _output.color.rgb += texture(u_reflectiveTexture, r).rgb * fresnel;\n    //}\n\n    //float fogFactor = pow(v_fogFactor, fog.densityExponent);\n    //_output.color = mix(_output.color, fog.color, fogFactor);\n\n    #if USE_SHADER_MODIFIER_FRAGMENT\n      shaderModifierFragment();\n    #endif\n\n    // DEBUG\n    //_output.color.a = material.diffuse.a;\n\n    outColor = _output.color;\n  }\n';

/**
 *
 * @access public
 * @extends {SCNProgram}
 */

var MMDProgram = function (_SCNProgram) {
  _inherits(MMDProgram, _SCNProgram);

  /**
   *
   * @access public
   * @constructor
   */
  function MMDProgram() {
    _classCallCheck(this, MMDProgram);

    var _this = _possibleConstructorReturn(this, (MMDProgram.__proto__ || Object.getPrototypeOf(MMDProgram)).call(this));

    _this.vertexShader = _vertexShader;
    _this.fragmentShader = _fragmentShader;
    return _this;
  }

  return MMDProgram;
}(_jscenekit.SCNProgram);

exports.default = MMDProgram;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var _MMDFragmentShader = '\n  uniform float useTexture;\n  uniform float useToon;\n  uniform float useSphereMap;\n  uniform float useSubtexture;\n\n  uniform float spadd;\n\n  uniform sampler2D sphereTexture;\n\n  #pragma transparent\n  #pragma body\n\n  // linear to sRGB\n  //vec4 materialDiffuse = pow(_surface.diffuse, vec4(1.0/2.2));\n  //vec4 materialSpecular = pow(_surface.specular, vec4(1.0/2.2));\n  //vec4 materialEmission = pow(_surface.emission, vec4(1.0/2.2));\n  //vec3 lightAmbient = pow(_lightingContribution.ambient, vec3(1.0/2.2));\n  //vec3 lightSpecular = pow(_lightingContribution.specular, vec3(1.0/2.2));\n  vec4 materialDiffuse = _surface.diffuse;\n  vec4 materialSpecular = _surface.specular;\n  vec4 materialEmission = _surface.emission;\n  vec3 lightAmbient = _lightingContribution.ambient;\n  vec3 lightSpecular = _lightingContribution.specular;\n\n  vec3 lightDirection = -scn_lights.direction0.xyz;\n\n  // light direction in view space\n  vec3 lightDir = normalize((u_viewTransform * vec4(lightDirection, 0.0)).xyz);\n\n  //vec4 diffuseColor = materialDiffuse * vec4(lightDiffuse, 1.0);\n  vec4 diffuseColor = vec4(0, 0, 0, 1);\n  // This is not typo; use materialDiffuse for ambientColor.\n  vec3 ambientColor = materialDiffuse.rgb * lightAmbient.rgb + materialEmission.rgb;\n  vec3 specularColor = materialSpecular.rgb * lightSpecular.rgb;\n\n  vec3 n = normalize(_surface.normal);\n\n  #define SKII1 1500\n  #define SKII2 8000\n  #define Toon 3\n\n  _output.color.rgb = ambientColor.rgb;\n  if(useToon <= 0.0){\n    _output.color.rgb += diffuseColor.rgb;\n  }\n  _output.color.a = diffuseColor.a;\n  _output.color = clamp(_output.color, vec4(0), vec4(1));\n\n  vec2 spTex;\n  if(useSphereMap > 0.0){\n    if(useSubtexture > 0.0){\n      spTex = _surface.specularTexcoord;\n    }else{\n      spTex.x = n.x * 0.5 + 0.5;\n      spTex.y = -n.y * 0.5 + 0.5;\n    }\n  }\n\n  //vec3 halfVector = normalize(normalize(_surface.view) - normalize(lightDir));\n  //vec3 specular = pow(max(0.0, dot(halfVector, n)), _surface.shininess) * specularColor;\n\n\n\n  if(useTexture > 0.0){\n    _output.color *= texture(u_multiplyTexture, _surface.multiplyTexcoord);\n  }\nvec4 debugColor = _output.color;\n\n  if(useSphereMap > 0.0){\n    vec4 texColor = texture(sphereTexture, spTex);\n    if(spadd > 0.0){\n      _output.color.rgb += texColor.rgb;\n    }else{\n      _output.color.rgb *= texColor.rgb;\n    }\n    _output.color.a *= texColor.a;\n  }\n\n  if(useToon > 0.0){\n    float lightNormal = dot(n, -lightDir);\n    _output.color *= texture(u_transparentTexture, vec2(0, 0.5 + lightNormal * 0.5));\n  }\n  _output.color.rgb += specularColor.rgb;\n\n  _output.color.rgb *= _output.color.a;\n\n  // sRGB to linear\n  //_output.color = pow(_output.color, vec4(2.2));\n\n\n\n\n\n  // DEBUG\n\n  //if(useTexture > 0.0){\n  //  _output.color = texture(u_multiplyTexture, _surface.multiplyTexcoord);\n  //}\n\n  //_output.color.rgb = ambientColor;\n  //_output.color.a = 1.0;\n\n  //_output.color.rgb = _lightingContribution.specular;\n  //_output.color.a = 1.0;\n\n  //if(useToon > 0.0){\n  //  float lightNormal = dot(n, -lightDir);\n  //  _output.color = texture(u_transparentTexture, vec2(0, 0.5 + lightNormal * 0.5));\n  //}\n\n  //_output.color = debugColor;\n';

exports.default = _MMDFragmentShader;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var _dataUrls = ['data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAD1JREFUWAnt1UENACAMA0Ag+JdWS0Aw0c/VQJfrY/O8jGJWsftXO4AAAQIECBDYSaof2QQECBAgQIBAXeAC0JEGqCKc/58AAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAD5JREFUWAnt1bENACAMAzBA/H9kj2CliCeyOA+kcobO+zKCWcHuX+0AAgQIECBAYJ+q6Ec2AQECBAgQIBAXaFUyBvgWZ9yCAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAD1JREFUWAnt1UENACAMA0Ag+DdQsUAw0c/VQJfrY/O8jGJWsftXO4AAAQIECBDYSaof2QQECBAgQIBAXeAC/+gGD8FBA34AAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAD9JREFUWAnt1bENACAMAzBA/H8pAytTQTyRxXkglTO010sLZgS7f7UDCBAgQIAAgXn2in5kExAgQIAAAQJxgQsutAcTsTp79gAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAXVJREFUWAntVtFuAyEMg4r//96p63qNTQzhjtOp26S+gLQmxI4dWHu6vNlKH1y3D3rTeg2wbmDdwLqBdQPrBtYNrBsohxcSvSDlnJLySLJy0juUOKgl56P2xio02Z695WBqbtGwM3vWTON0BnNAj2JDv/FTKulxrxCN3UmGJBusoZqgq2l/06ktNvGYg489gn1I35I6gMwByBQ9rKMLS10uhG0zQw6OuOD4H8uoY+8cRSuUdP9CtS6aG0pjFScxGk/gYTDiMKdrjxwIAzy+XcKOBBIPqtPu1V2klXkN1rKZXMWYy8xgKWXWKr+1W62kHxuARFEbzASyQmIulkYSB3XlwmZ9tR8DPPEL6CeowPgpIVR73m0yLTsSu1VVjBh87TkgIcWRcr1Tn+J1R2QcH0QR/Y/8bC6/kj7AGfHPQ0AYbjsDbvEd0Jr/k4Rex53+2HAG8jsg5zPSKHW6k0wk+CkPpw+cssXf5y9nmHnTgwBEnTF5wL0ALDJrOqmNWLMAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAl5JREFUWAntlb9qVEEUxr+ZvbtZTRAUUVHsFCwiCKJYWmjpI1jY2fkGPoC+h62FIiJ2FrYRAxY2ioQgGI0b3ST7Z8bfmbl33cgaI6IX4c7u3Dlz5sz5vvnm7lkX125E1dh8jdgJuiHQKPCfK+CKX/+InJNc96dxhdw+Fq0UhLJj29S1eACQQFiLgzy3ONeWWselzkVp8xFzhIxDRgMqy4rljX1SnKafkrafM/+cfQG/EVNbLvbvR/kF7PM58fYzaeuJtHBTGq8CdJLNT6W5Kxk0fGAjzQiFNXzHmEDK9vmj2CQevSbfGfrZnGP4Supeznb/HjEQ9gfxXYNA6EW5/STkBFsP6Y/ZuAiBWzmxBWssDV5kgpsPwIOEPyzNX5eGy3TW7ACdC3nNCJidSL6H0BviD5Uq9KQDt8mFwuErBHp3INABYwUH0oiTuXlGu98RG49w+ktIDbmwjs+ayWeDXZMRRIEUb/KzJzJ2INS9Km3cxWfxFoPfzaHaCUywwHN7+i8woFgmIM2emr07pqSpY4RmteFSoj1raacvcgW/2yJKDJZ23zVaTvrtHvQ3V4vFmgm0z9VMAHXtFa61NQQaBYoYxvn/i2pln/y18fvcnLNqWVmQKa/ZclZyk5ms5N/hK+Oqt97WivVPqwoh0McKVLyY7AB+1afJZBr2nAbPIDwByN0zWnfyvpVs70tfOVbz4t3bl4nANGBMtZtTVzU8qWG8jUzFf2r84dS2kogkRYxUJjMZIeHNB7niy8ZHwsuTpWEWwhTYH5n5iibq2RWY9P+ucbj8nUA2P8NGgdoV+AaTnOoWJjozfwAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAADJJREFUWAnt0EENAAAIAzHAv2cgmODTGbil2bt4XD22L+0AAQIECBAgQIAAAQIECBAgME2IBDzy317fAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAADJJREFUWAnt0EENAAAIAzHAv2cgmODTGbil2bt4XD22L+0AAQIECBAgQIAAAQIECBAgME2IBDzy317fAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAADJJREFUWAnt0EENAAAIAzHAv2cgmODTGbil2bt4XD22L+0AAQIECBAgQIAAAQIECBAgME2IBDzy317fAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAADJJREFUWAnt0EENAAAIAzHAv2cgmODTGbil2bt4XD22L+0AAQIECBAgQIAAAQIECBAgME2IBDzy317fAAAAAElFTkSuQmCC'];

var _ToonImages = [];
var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  for (var _iterator = _dataUrls[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    var data = _step.value;

    var image = new Image();
    image.src = data;
    _ToonImages.push(image);
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator.return) {
      _iterator.return();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}

exports.default = _ToonImages;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MMD_CAMERA_ROTZ_NODE_NAME = exports.MMD_CAMERA_ROTY_NODE_NAME = exports.MMD_CAMERA_ROTX_NODE_NAME = exports.MMD_CAMERA_NODE_NAME = exports.MMD_CAMERA_ROOT_NODE_NAME = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jscenekit = __webpack_require__(0);

var _MMDNode2 = __webpack_require__(1);

var _MMDNode3 = _interopRequireDefault(_MMDNode2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MMD_CAMERA_ROOT_NODE_NAME = exports.MMD_CAMERA_ROOT_NODE_NAME = 'MMDCameraRoot';
var MMD_CAMERA_NODE_NAME = exports.MMD_CAMERA_NODE_NAME = 'MMDCamera';
var MMD_CAMERA_ROTX_NODE_NAME = exports.MMD_CAMERA_ROTX_NODE_NAME = 'MMDCameraRotX';
var MMD_CAMERA_ROTY_NODE_NAME = exports.MMD_CAMERA_ROTY_NODE_NAME = 'MMDCameraRotY';
var MMD_CAMERA_ROTZ_NODE_NAME = exports.MMD_CAMERA_ROTZ_NODE_NAME = 'MMDCameraRotZ';

/**
 *
 * @access public
 * @extends {MMDNode}
 */

var MMDCameraNode = function (_MMDNode) {
  _inherits(MMDCameraNode, _MMDNode);

  /**
   *
   * @access public
   * @param {string} [name = MMD_CAMERA_ROOT_NODE_NAME] -
   * @constructor
   */
  function MMDCameraNode() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MMD_CAMERA_ROOT_NODE_NAME;

    _classCallCheck(this, MMDCameraNode);

    var _this = _possibleConstructorReturn(this, (MMDCameraNode.__proto__ || Object.getPrototypeOf(MMDCameraNode)).call(this));

    _this.name = name;

    /** @type {MMDNode} */
    _this.cameraNode = new _MMDNode3.default();

    var camera = new _jscenekit.SCNCamera();
    _this.cameraNode.name = MMD_CAMERA_NODE_NAME;
    _this.cameraNode.camera = camera;

    // TODO: set default values of MikuMikuDance: ex) fov
    camera.yFov = 30.0;
    camera.automaticallyAdjustsZRange = true;

    /** @type {MMDNode} */
    _this.rotYNode = new _MMDNode3.default();

    _this.rotYNode.name = MMD_CAMERA_ROTY_NODE_NAME;
    _this.addChildNode(_this.rotYNode);

    /** @type {MMDNode} */
    _this.rotXNode = new _MMDNode3.default();

    _this.rotXNode.name = MMD_CAMERA_ROTX_NODE_NAME;
    _this.rotYNode.addChildNode(_this.rotXNode);

    /** @type {MMDNode} */
    _this.rotZNode = new _MMDNode3.default();

    _this.rotZNode.name = MMD_CAMERA_ROTZ_NODE_NAME;
    _this.rotXNode.addChildNode(_this.rotZNode);

    _this.rotZNode.addChildNode(_this.cameraNode);
    return _this;
  }

  _createClass(MMDCameraNode, [{
    key: 'getCameraNode',


    /**
     * @access public
     * @returns {SCNNode} -
     */
    value: function getCameraNode() {
      return this.cameraNode;
    }

    /**
     * @access public
     * @returns {SCNCamera} -
     */

  }, {
    key: 'getCamera',
    value: function getCamera() {
      return this.cameraNode.camera;
    }
  }, {
    key: 'rotX',
    get: function get() {
      //return this.rotXNode.eulerAngles.x
      var value = this.rotXNode.rotation.w;
      if (this.rotXNode.rotation.x < 0) {
        return -value;
      }
      return value;
    },
    set: function set(newValue) {
      //const euler = this.rotXNode.eulerAngles
      //euler.x = newValue
      //this.rotXNode.eulerAngles = euler
      this.rotXNode.rotation = new _jscenekit.SCNVector4(1, 0, 0, newValue);
    }
  }, {
    key: 'rotY',
    get: function get() {
      //return this.rotYNode.eulerAngles.y
      var value = this.rotYNode.rotation.w;
      if (this.rotYNode.rotation.y < 0) {
        return -value;
      }
      return value;
    },
    set: function set(newValue) {
      //const euler = this.rotYNode.eulerAngles
      //euler.y = newValue
      //this.rotYNode.eulerAngles = euler
      this.rotYNode.rotation = new _jscenekit.SCNVector4(0, 1, 0, newValue);
    }
  }, {
    key: 'rotZ',
    get: function get() {
      //return this.rotZNode.eulerAngles.z
      var value = this.rotZNode.rotation.w;
      if (this.rotZNode.rotation.z < 0) {
        return -value;
      }
      return value;
    },
    set: function set(newValue) {
      //const euler = this.rotZNode.eulerAngles
      //euler.z = newValue
      //this.rotZNode.eulerAngles = euler
      this.rotZNode.rotation = new _jscenekit.SCNVector4(0, 0, 1, newValue);
    }
  }, {
    key: 'distance',
    get: function get() {
      return this.cameraNode.position.z;
    },
    set: function set(newValue) {
      this.cameraNode.position.z = newValue;
    }
  }, {
    key: 'angle',
    get: function get() {
      return this.cameraNode.camera.yFov;
    },
    set: function set(newValue) {
      this.cameraNode.camera.yFov = newValue;
    }
  }]);

  return MMDCameraNode;
}(_MMDNode3.default);

exports.default = MMDCameraNode;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MMDNode = __webpack_require__(1);

var _MMDNode2 = _interopRequireDefault(_MMDNode);

var _MMDProgram = __webpack_require__(5);

var _MMDProgram2 = _interopRequireDefault(_MMDProgram);

var _MMDReader2 = __webpack_require__(2);

var _MMDReader3 = _interopRequireDefault(_MMDReader2);

var _MMDIKConstraint = __webpack_require__(4);

var _MMDIKConstraint2 = _interopRequireDefault(_MMDIKConstraint);

var _jscenekit = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _BoneNodeTypes = [_MMDNode2.default.Type.rotate, _MMDNode2.default.Type.rotateTranslate, _MMDNode2.default.Type.ik, _MMDNode2.default.Type.unknown, _MMDNode2.default.Type.ikChild, _MMDNode2.default.Type.rotateChild, _MMDNode2.default.Type.hidden, _MMDNode2.default.Type.twist, _MMDNode2.default.Type.roll];

/**
 *
 * @access public
 * @extends {MMDReader}
 */

var MMDPMDReader = function (_MMDReader) {
  _inherits(MMDPMDReader, _MMDReader);

  /**
   *
   * @access public
   * @constructor
   * @param {Buffer} data -
   * @param {string} directoryPath -
   */
  function MMDPMDReader(data, directoryPath) {
    _classCallCheck(this, MMDPMDReader);

    var isBinary = true;
    var isBigEndian = false;
    var encoding = 'sjis';

    /** @type {MMDNode} */
    var _this = _possibleConstructorReturn(this, (MMDPMDReader.__proto__ || Object.getPrototypeOf(MMDPMDReader)).call(this, data, directoryPath, isBinary, isBigEndian, encoding));

    _this._workingNode = null;

    // header
    _this._pmdMagic = '';
    _this._version = 0.0;
    _this._modelName = '';
    _this._comment = '';

    // vertex data
    _this._vertexCount = 0;
    _this._vertexArray = [];
    _this._normalArray = [];
    _this._texcoordArray = [];
    _this._boneIndicesArray = [];
    _this._boneWeightsArray = [];

    // index data
    _this._indexCount = 0;
    _this._indexArray = [];

    // material data
    _this._materialCount = 0;
    _this._materialIndexCountArray = [];
    _this._materialArray = [];

    // bone data
    _this._rootBone = new _MMDNode2.default();
    _this._boneCount = 0;
    _this._boneArray = [];
    _this._boneHash = new Map();
    _this._boneInverseMatrixArray = [];

    // ik data
    _this._ikCount = 0;

    // face data
    _this._faceCount = 0;
    _this._faceNameArray = [];
    _this._faceVertexArray = [];
    _this._faceIndexArray = [];

    // display info
    _this._faceDisplayCount = 0;
    _this._boneDisplayNameCount = 0;
    //this._boneDisplayCount

    // toon texture info
    //this._textureFileNames

    // physics
    _this._physicsBodyCount = 0;
    _this._physicsBodyArray = [];

    // geometry
    _this._vertexSource = null;
    _this._normalSource = null;
    _this._texcoordSource = null;
    _this._boneIndicesSource = null;
    _this._boneWeightsSource = null;
    _this._elementArray = [];
    return _this;
  }

  _createClass(MMDPMDReader, [{
    key: '_loadPMDFile',


    /**
     * @access private
     * @returns {MMDNode} -
     */
    value: function _loadPMDFile() {
      this._workingNode = new _MMDNode2.default();

      this._readPMDHeader();
      if (this._pmdMagic !== 'Pmd') {
        throw new Error('incorrect PMD format');
      }

      // read basic data
      this._readVertex();
      this._readIndex();
      this._readMaterial();
      this._readBone();
      this._readIK();
      this._readFace();
      this._readDisplayInfo();

      // create geometry for shader
      this._createGeometry();
      this._createFaceMorph();

      // read additional data
      if (this.pos >= this.length) {
        return this._workingNode;
      }

      this._readEnglishInfo();
      if (this.pos >= this.length) {
        return this._workingNode;
      }

      this._readToonTexture();

      if (this.pos >= this.length) {
        return this._workingNode;
      }

      this._readPhysicsBody();
      this._readConstraint();

      return this._workingNode;
    }
  }, {
    key: '_readPMDHeader',
    value: function _readPMDHeader() {
      this._pmdMagic = this.readString(3);
      this._version = this.readFloat();
      this._modelName = this.readString(20);
      this._comment = this.readString(256);
    }
  }, {
    key: '_readVertex',
    value: function _readVertex() {
      var vertexCount = this.readUnsignedInt();
      this._vertexCount = vertexCount;

      var edgeArray = [];

      for (var i = 0; i < vertexCount; i++) {
        this._vertexArray.push(this.readFloat());
        this._vertexArray.push(this.readFloat());
        this._vertexArray.push(-this.readFloat());

        this._normalArray.push(this.readFloat());
        this._normalArray.push(this.readFloat());
        this._normalArray.push(-this.readFloat());

        this._texcoordArray.push(this.readFloat());
        this._texcoordArray.push(this.readFloat());

        var boneNo1 = this.readUnsignedShort();
        var boneNo2 = this.readUnsignedShort();

        var weightByte = this.readUnsignedByte();
        var weight1 = weightByte / 100.0;
        var weight2 = 1.0 - weight1;

        if (weight1 === 0.0) {
          this._boneIndicesArray.push(boneNo2);
          this._boneIndicesArray.push(boneNo1);

          this._boneWeightsArray.push(weight2);
          this._boneWeightsArray.push(weight1);
        } else {
          this._boneIndicesArray.push(boneNo1);
          this._boneIndicesArray.push(boneNo2);

          this._boneWeightsArray.push(weight1);
          this._boneWeightsArray.push(weight2);
        }

        // FIXME: use edge data for rendering
        edgeArray.push(this.readUnsignedByte());
      }
    }
  }, {
    key: '_readIndex',
    value: function _readIndex() {
      this._indexCount = this.readUnsignedInt();
      var triangles = this._indexCount / 3;

      for (var i = 0; i < triangles; i++) {
        var index1 = this.readUnsignedShort();
        var index2 = this.readUnsignedShort();
        var index3 = this.readUnsignedShort();

        // change the index order because of the coordination difference
        this._indexArray.push(index1);
        this._indexArray.push(index3);
        this._indexArray.push(index2);
      }
    }
  }, {
    key: '_readMaterial',
    value: function _readMaterial() {
      var _this2 = this;

      this._materialCount = this.readUnsignedInt();

      var _loop = function _loop(i) {
        var material = new _jscenekit.SCNMaterial();
        material.diffuse.contents = new _jscenekit.SKColor(_this2.readFloat(), _this2.readFloat(), _this2.readFloat(), _this2.readFloat());
        material.shininess = _this2.readFloat();
        material.specular.contents = new _jscenekit.SKColor(_this2.readFloat(), _this2.readFloat(), _this2.readFloat(), 1.0);
        material.emission.contents = new _jscenekit.SKColor(_this2.readFloat(), _this2.readFloat(), _this2.readFloat(), 1.0);
        material.ambient.contents = new _jscenekit.SKColor(0.0, 0.0, 0.0, 0.0);

        var toonIndex = _this2.readUnsignedByte();
        var edge = _this2.readUnsignedByte();
        var indexCount = _this2.readUnsignedInt();
        var textureFile = _this2.readString(20);
        var sphereFile = '';
        if (textureFile.indexOf('*') >= 0) {
          var files = textureFile.split('*');
          textureFile = files[0];
          sphereFile = files[1];
        }
        if (textureFile.endsWith('spa') || textureFile.endsWith('sph')) {
          sphereFile = textureFile;
          textureFile = '';
        }

        if (textureFile !== '') {
          _this2.loadTexture(textureFile).then(function (texture) {
            material.multiply.contents = texture;
            material.multiply.wrapS = _jscenekit.SCNWrapMode.repeat;
            material.multiply.wrapT = _jscenekit.SCNWrapMode.repeat;
          });
        }
        if (sphereFile !== '') {
          _this2.loadTexture(sphereFile).then(function (texture) {
            material.reflective.contents = texture;
          });
        }
        material.isDoubleSided = true;

        _this2._materialIndexCountArray.push(indexCount);
        _this2._materialArray.push(material);
      };

      for (var i = 0; i < this._materialCount; i++) {
        _loop(i);
      }
    }
  }, {
    key: '_readBone',
    value: function _readBone() {
      var boneCount = this.readUnsignedShort();
      this._boneCount = boneCount;

      var parentNoArray = [];
      var bonePositionArray = [];

      this._rootBone.position = new _jscenekit.SCNVector3(0, 0, 0);
      this._rootBone.name = 'rootBone';

      for (var i = 0; i < boneCount; i++) {
        var boneNode = new _MMDNode2.default();
        boneNode.name = this.readString(20);

        if (boneNode.name !== null) {
          var kneeName = boneNode.name.substring(0, 3);
          if (kneeName === '右ひざ' || kneeName === '左ひざ') {
            boneNode.isKnee = true;
          }
        }

        var parentNo = this.readUnsignedShort();
        parentNoArray.push(parentNo);

        var childNo = this.readUnsignedShort();
        var type = this.readUnsignedByte();
        var ikTarget = this.readUnsignedShort();

        boneNode.type = _BoneNodeTypes[type] || _MMDNode2.default.Type.unknown;

        var position = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), this.readFloat());
        bonePositionArray.push(position);
        this._boneArray.push(boneNode);
        this._boneHash.set(boneNode.name, boneNode);

        //console.log(`${i} ${boneNode.name}: ${position.x}, ${position.y}, ${position.z}`)
      }

      // set parent node
      for (var _i = 0; _i < boneCount; _i++) {
        var bone = this._boneArray[_i];
        var _parentNo = parentNoArray[_i];
        var bonePos = bonePositionArray[_i];

        if (_parentNo !== 0xFFFF) {
          this._boneArray[_parentNo].addChildNode(bone);
          var parentPos = bonePositionArray[_parentNo];
          bone.position = bonePos.sub(parentPos);

          //console.log(`parent ${this._boneArray[parentNo].name} ${parentPos.y}, bone ${bone.name} ${bonePos.y}: pos: ${bone.position.y}`)
        } else {
          this._rootBone.addChildNode(bone);
          bone.position = bonePos;
        }
      }

      // calc initial matrix
      for (var _i2 = 0; _i2 < boneCount; _i2++) {
        var _bonePos = bonePositionArray[_i2];
        //const boneName = this._boneArray[i].name
        //console.log(`inverseMatrix ${i} ${boneName}: ${-bonePos.x}, ${-bonePos.y}, ${-bonePos.z}`)
        var matrix = _jscenekit.SCNMatrix4.matrixWithTranslation(-_bonePos.x, -_bonePos.y, -_bonePos.z);
        this._boneInverseMatrixArray.push(matrix);
      }

      this._boneArray.push(this._rootBone);
      this._boneInverseMatrixArray.push(new _jscenekit.SCNMatrix4());

      this._workingNode.addChildNode(this._rootBone);
    }
  }, {
    key: '_readIK',
    value: function _readIK() {
      var ikCount = this.readUnsignedShort();
      this._ikCount = ikCount;

      this._workingNode.ikArray = [];

      for (var i = 0; i < ikCount; i++) {
        var ik = new _MMDIKConstraint2.default();

        var ikBoneNo = this.readUnsignedShort();
        var targetBoneNo = this.readUnsignedShort();
        var numLink = this.readUnsignedByte();
        var iteration = this.readUnsignedShort();
        var weight = this.readFloat();

        ik.ikBone = this._boneArray[ikBoneNo];
        ik.targetBone = this._boneArray[targetBoneNo];
        ik.iteration = iteration;
        ik.weight = weight;
        ik.boneArray = [];

        //console.log(`targetBoneNo: ${targetBoneNo} ${ik.targetBone.name}, ikBoneNo: ${ikBoneNo} ${ik.ikBone.name}`)
        for (var j = 0; j < numLink; j++) {
          var linkNo = this.readUnsignedShort();
          var bone = this._boneArray[linkNo];

          //console.log(`linkNo: ${linkNo}, ${bone.name}`)
          ik.boneArray.push(bone);
        }
        this._workingNode.ikArray.push(ik);

        // FIXME: use SceneKit IK
        //const constraint = SCNIKConstraint.inverseKinematicsConstraint(ik.boneArray[ik.boneArray.length - 1])
      }
    }

    //_calcKneeConstraint(mat) {
    //}

  }, {
    key: '_readFace',
    value: function _readFace() {
      this._faceCount = this.readUnsignedShort();
      var zeroArray = [];
      zeroArray.length = this._vertexArray.length;
      zeroArray.fill(0);

      // read base face
      if (this._faceCount > 0) {
        var baseName = this.readString(20); // must be 'base'
        var baseFaceVertex = zeroArray.slice();

        var baseNumVertices = this.readUnsignedInt();
        var baseType = this.readUnsignedByte();

        for (var i = 0; i < baseNumVertices; i++) {
          var index = this.readUnsignedInt();
          this._faceIndexArray.push(index);

          var vertexIndex = index * 3;
          var x = this.readFloat();
          var y = this.readFloat();
          var z = -this.readFloat();

          baseFaceVertex[vertexIndex + 0] = x;
          baseFaceVertex[vertexIndex + 1] = y;
          baseFaceVertex[vertexIndex + 2] = z;
        }
        this._faceNameArray.push(baseName);
        this._faceVertexArray.push(baseFaceVertex);

        for (var _i3 = 1; _i3 < this._faceCount; _i3++) {
          var name = this.readString(20);
          var faceVertex = zeroArray.slice();
          //console.log(`faceName: ${name}`)

          var numVertices = this.readUnsignedInt();

          // 0: base, 1: eyebrows, 2: eyes, 3: lips, 4: etc
          var type = this.readUnsignedByte();

          for (var j = 0; j < numVertices; j++) {
            var _index = this._faceIndexArray[this.readUnsignedInt()];
            var _vertexIndex = _index * 3;
            var _x = this.readFloat();
            var _y = this.readFloat();
            var _z = -this.readFloat();

            faceVertex[_vertexIndex + 0] = _x;
            faceVertex[_vertexIndex + 1] = _y;
            faceVertex[_vertexIndex + 2] = _z;
          }

          this._faceNameArray.push(name);
          this._faceVertexArray.push(faceVertex);
        }
      }
    }
  }, {
    key: '_createFaceMorph',
    value: function _createFaceMorph() {
      var morpher = new _jscenekit.SCNMorpher();
      morpher.calculationMode = _jscenekit.SCNMorpherCalculationMode.additive;

      for (var i = 0; i < this._faceCount; i++) {
        var faceVertexData = this._faceVertexArray[i];
        var faceVertexSource = new _jscenekit.SCNGeometrySource(faceVertexData, // data
        _jscenekit.SCNGeometrySource.Semantic.vertex, // semantic
        this._vertexCount, // vectorCount
        true, // usesFloatComponents
        3, // componentsPerVector
        4, // bytesPerComponent
        0, // dataOffset
        12 // dataStride
        );

        var faceGeometry = new _jscenekit.SCNGeometry([faceVertexSource], []);
        faceGeometry.name = this._faceNameArray[i];

        morpher.targets.push(faceGeometry);
        morpher._weights.push(0);
      }
      var geometryNode = this._workingNode.childNodeWithName('Geometry', true);

      if (this._faceCount > 0) {
        geometryNode.morpher = morpher;
      }

      this._workingNode.geometryMorpher = morpher;
    }
  }, {
    key: '_readDisplayInfo',
    value: function _readDisplayInfo() {
      // read face display info
      var faceDisplayCount = this.readUnsignedByte();
      this._faceDisplayCount = faceDisplayCount;
      for (var i = 0; i < faceDisplayCount; i++) {
        var index = this.readUnsignedShort();
        // just ignore data
      }

      // read bone display name
      var boneDisplayNameCount = this.readUnsignedByte();
      this._boneDisplayNameCount = boneDisplayNameCount;
      for (var _i4 = 0; _i4 < boneDisplayNameCount; _i4++) {
        var name = this.readString(50);
        // just ignore data
      }

      // read bone display info
      var boneDisplayCount = this.readUnsignedInt();
      //this._boneDisplayCount = boneDisplayCount
      for (var _i5 = 0; _i5 < boneDisplayCount; _i5++) {
        var _index2 = this.readUnsignedShort();
        var frameIndex = this.readUnsignedByte();
      }
    }
  }, {
    key: '_readEnglishInfo',
    value: function _readEnglishInfo() {
      // read english
      var englishCompatibility = this.readUnsignedByte();

      // read english header
      var englishHeaderName = this.readString(20);
      var englishComment = this.readString(256);

      // read english bone name
      for (var i = 0; i < this._boneCount; i++) {
        var englishBoneName = this.readString(20);
      }

      // read english face name
      for (var _i6 = 0; _i6 < this._faceDisplayCount; _i6++) {
        var englishFaceName = this.readString(20);
      }

      // read english bone name
      for (var _i7 = 0; _i7 < this._boneDisplayNameCount; _i7++) {
        var englishBoneDisplayName = this.readString(50);
      }
    }
  }, {
    key: '_readToonTexture',
    value: function _readToonTexture() {
      for (var i = 0; i < 10; i++) {
        var textureFileName = this.readString(100);
      }
    }
  }, {
    key: '_readPhysicsBody',
    value: function _readPhysicsBody() {
      var physicsBodyCount = this.readUnsignedInt();
      this._physicsBodyCount = physicsBodyCount;
      var gravity = new _jscenekit.SCNPhysicsField();

      for (var i = 0; i < physicsBodyCount; i++) {
        var name = this.readString(20);
        var boneIndex = this.readUnsignedShort();
        var groupIndex = this.readUnsignedByte();
        var groupTarget = this.readUnsignedShort();
        var shapeType = this.readUnsignedByte();
        var dx = this.readFloat();
        var dy = this.readFloat();
        var dz = this.readFloat();
        var posX = this.readFloat();
        var posY = this.readFloat();
        var posZ = -this.readFloat();
        var rotX = this.readFloat();
        var rotY = this.readFloat();
        var rotZ = -this.readFloat();
        var weight = this.readFloat();
        var positionDim = this.readFloat();
        var rotateDim = this.readFloat();
        var recoil = this.readFloat();
        var friction = this.readFloat();
        var type = this.readUnsignedByte();

        var bodyType = null;
        if (type === 0) {
          bodyType = _jscenekit.SCNPhysicsBodyType.kinematic;
        } else if (type === 1) {
          bodyType = _jscenekit.SCNPhysicsBodyType.dynamic;
        } else if (type === 2) {
          bodyType = _jscenekit.SCNPhysicsBodyType.dynamic;
        }
        bodyType = _jscenekit.SCNPhysicsBodyType.kinematic; // for debug

        var shape = null;
        if (shapeType === 0) {
          shape = new _jscenekit.SCNSphere(dx);
        } else if (shapeType === 1) {
          shape = new _jscenekit.SCNBox(dx, dy, dz, 0);
        } else if (shapeType === 2) {
          shape = new _jscenekit.SCNCapsule(dx, dy);
        } else {
          throw new Error('unknown physics body shape: ' + shapeType);
        }

        var body = new _jscenekit.SCNPhysicsBody(bodyType, new _jscenekit.SCNPhysicsShape(shape, null));
        body.isAffectedByGravity = true;
        body.mass = weight;
        body.friction = friction;
        body.rollingFriction = rotateDim;
        body.collisionBitMask = groupTarget;
        body.restitution = recoil;
        body.usesDefaultMomentOfInertia = true;

        if (boneIndex !== 0xFFFF) {
          var bone = this._boneArray[boneIndex];
          bone.physicsBody = body;
        } else {
          // do nothing
        }
        this._physicsBodyArray.push(body);
      }
    }
  }, {
    key: '_readConstraint',
    value: function _readConstraint() {
      var constraintCount = this.readUnsignedInt();

      for (var i = 0; i < constraintCount; i++) {
        var name = this.readString(20);
        var bodyANo = this.readUnsignedInt();
        var bodyBNo = this.readUnsignedInt();

        var bodyA = this._physicsBodyArray[bodyANo];
        var bodyB = this._physicsBodyArray[bodyBNo];

        var pos = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());
        var rot = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());

        var pos1 = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());
        var pos2 = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());

        var rot1 = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());
        var rot2 = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());

        var spring_pos = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());
        var spring_rot = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());

        // TODO: create 6dof constraint
        //constraint = ...

        //this._workingNode.physicsBehaviors.push(constraint)
      }
    }
  }, {
    key: '_createGeometry',
    value: function _createGeometry() {
      var vertexData = this._vertexArray;
      var normalData = this._normalArray;
      var texcoordData = this._texcoordArray;
      var boneIndicesData = this._boneIndicesArray;
      var boneWeightsData = this._boneWeightsArray;
      var indexData = this._indexArray;

      this._vertexSource = new _jscenekit.SCNGeometrySource(vertexData, // data
      _jscenekit.SCNGeometrySource.Semantic.vertex, // semantic
      this._vertexCount, // vectorCount
      true, // usesFloatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // dataOffset
      12 // dataStride
      );

      this._normalSource = new _jscenekit.SCNGeometrySource(normalData, // data
      _jscenekit.SCNGeometrySource.Semantic.normal, // semantic
      this._vertexCount, // vectorCount
      true, // usesFloatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // dataOffset
      12 // dataStride
      );

      this._texcoordSource = new _jscenekit.SCNGeometrySource(texcoordData, // data
      _jscenekit.SCNGeometrySource.Semantic.texcoord, // semantic
      this._vertexCount, // vectorCount
      true, // usesFloatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      0, // dataOffset
      8 // dataStride
      );

      this._boneIndicesSource = new _jscenekit.SCNGeometrySource(boneIndicesData, // data
      _jscenekit.SCNGeometrySource.Semantic.boneIndices, // semantic
      this._vertexCount, // vectorCount
      false, // usesFloatComponents
      2, // componentsPerVector
      2, // bytesPerComponent
      0, // dataOffset
      4 // dataStride
      );

      this._boneWeightsSource = new _jscenekit.SCNGeometrySource(boneWeightsData, // data
      _jscenekit.SCNGeometrySource.Semantic.boneWeights, // semantic
      this._vertexCount, // vectorCount
      true, // usesFloatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      0, // dataOffset
      8 // dataStride
      );

      var indexPos = 0;
      for (var i = 0; i < this._materialCount; i++) {
        var count = this._materialIndexCountArray[i];
        var triangles = count / 3;
        //const length = count * 2
        var data = indexData.slice(indexPos, indexPos + count);
        var element = new _jscenekit.SCNGeometryElement(data, // data
        _jscenekit.SCNGeometryPrimitiveType.triangles, // primitiveType
        triangles, // primitiveCount
        2 // bytesPerIndex
        );
        this._elementArray.push(element);
        indexPos += count;
      }

      //const program = new MMDProgram()
      var geometry = new _jscenekit.SCNGeometry([this._vertexSource, this._normalSource, this._texcoordSource], this._elementArray);
      geometry.materials = this._materialArray;
      geometry.name = 'Geometry';

      var geometryNode = new _jscenekit.SCNNode(geometry);
      geometryNode.name = 'Geometry';

      if (this._vertexCount > 0 && this._indexCount > 0) {
        var skinner = new _jscenekit.SCNSkinner(geometry, // baseGeometry
        this._boneArray, // bones
        this._boneInverseMatrixArray, // boneInverseBindTransforms
        this._boneWeightsSource, // boneWeights
        this._boneIndicesSource // boneIndices
        );
        geometryNode.skinner = skinner;
        geometryNode.skinner.skeleton = this._rootBone;
      }
      geometryNode.castsShadow = true;

      this._workingNode.name = this._modelName;
      this._workingNode.castsShadow = true;
      this._workingNode.addChildNode(geometryNode);

      // FIXME: delete code below
      this._workingNode.boneArray = this._boneArray;
      this._workingNode.boneInverseMatrixArray = this._boneInverseMatrixArray;
      this._workingNode.vertexCount = this._vertexCount;
      this._workingNode.vertexArray = this._vertexArray;
      this._workingNode.normalArray = this._normalArray;
      this._workingNode.texcoordArray = this._texcoordArray;
      this._workingNode.boneIndicesArray = this._boneIndicesArray;
      this._workingNode.boneWeightsArray = this._boneWeightsArray;
      this._workingNode.indexCount = this._indexCount;
      this._workingNode.indexArray = this._indexArray;
      this._workingNode.materialCount = this._materialCount;
      this._workingNode.materialArray = this._materialArray;
      this._workingNode.materialIndexCountArray = this._materialIndexCountArray;
      this._workingNode.rootBone = this._rootBone;
    }
  }], [{
    key: 'getNode',
    value: function getNode(data, directoryPath) {
      var reader = new MMDPMDReader(data, directoryPath);
      return reader._loadPMDFile();
    }
  }]);

  return MMDPMDReader;
}(_MMDReader3.default);

exports.default = MMDPMDReader;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

// import {_Buffer} from 'jscenekit'

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ecl = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*global Buffer*/

var _integerPattern = new RegExp(/^(-|\+)?\d+;?/);
var _floatPattern = new RegExp(/^(-|\+)?(\d)*\.(\d)*;?/);
var _wordPattern = new RegExp(/^\w+/);

/**
 * TextReader class
 * @access public
 */

var TextReader = function () {
  /**
   * constructor
   * @access public
   * @constructor
   * @param {Buffer|ArrayBuffer} data -
   * @param {string} encoding -
   */
  function TextReader(data) {
    var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf-8';

    _classCallCheck(this, TextReader);

    /**
     * @access private
     * @type {number}
     */
    this._pos = 0;

    this._partialText = '';
    this._partialOffset = 0;
    this._partialStep = 200;
    this._partialMinLength = 100;

    /**
     * @access private
     * @type {boolean}
     */
    this._eof = true;

    /**
     *
     * @access public
     * @type {Buffer}
     */
    this.buffer = null;

    if (data instanceof Buffer) {
      this.buffer = data;
    } else {
      this.buffer = Buffer.from(data);
    }

    /**
     *
     * @access public
     * @type {boolean}
     */
    //this.bigEndian = bigEndian

    /**
     *
     * @access public
     * @type {string}
     */
    this.encoding = encoding;

    // prepare buffered text
    this._addPartialText();
  }

  /**
   * @access public
   * @param {number} length - length of data to skip
   * @param {boolean} noAssert -
   * @returns {void}
   */


  _createClass(TextReader, [{
    key: 'skip',
    value: function skip(length) {
      var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this._moveIndex(length);
      if (!noAssert) {
        this._check();
      }
    }

    /**
     *
     * @access public
     * @param {number} length - length of data to read
     * @param {?string} [encoding = null] -
     * @returns {string} -
     */

  }, {
    key: 'readString',
    value: function readString(length) {
      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var str = this._partialText.substring(0, length);

      this._moveIndex(str.length);
    }

    /**
     *
     * @access public
     * @param {number} length - 
     * @param {boolean} signed -
     * @returns {number} -
     */

  }, {
    key: 'readInteger',
    value: function readInteger(length, signed) {
      var str = this._getString(_integerPattern);
      var val = parseInt(str[0], 10);
      return val;
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readUnsignedByte',
    value: function readUnsignedByte() {
      return this.readInteger(1, false);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readUnsignedShort',
    value: function readUnsignedShort() {
      return this.readInteger(2, false);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readUnsignedInt',
    value: function readUnsignedInt() {
      return this.readInteger(4, false);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readInt',
    value: function readInt() {
      return this.readInteger(4, true);
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readFloat',
    value: function readFloat() {
      var str = this._getString(_floatPattern);
      var val = parseFloat(str[0]);
      return val;
    }

    /**
     *
     * @access public
     * @returns {number} -
     */

  }, {
    key: 'readDouble',
    value: function readDouble() {
      return this.readFloat();
    }

    /**
     *
     * @access public
     * @param {number} length -
     * @returns {Buffer} -
     */

  }, {
    key: 'readData',
    value: function readData(length) {
      var start = this._pos;
      this._pos += length;
      return this.buffer.slice(start, this._pos);
    }
  }, {
    key: 'readWord',
    value: function readWord() {
      var str = this._getString(_wordPattern);
      return str !== null ? str[0] : null;
    }
  }, {
    key: 'readPattern',
    value: function readPattern(pattern) {
      return this._getString(pattern);
    }

    /**
     *
     * @access private
     * @returns {void}
     */

  }, {
    key: '_check',
    value: function _check() {}

    /**
     *
     * @access private
     * @param {number[]} data - length of data to convert
     * @param {?string} [encoding = null] -
     * @returns {string} -
     */

  }, {
    key: '_convert',
    value: function _convert(data, encoding) {
      var length = data.length;
      var escapeString = '';
      for (var i = 0; i < length; i++) {
        var charCode = data.charCodeAt(i);
        if (charCode === 0) {
          break;
        } else if (charCode < 16) {
          escapeString += '%0' + charCode.toString(16);
        } else {
          escapeString += '%' + charCode.toString(16);
        }
      }

      if (encoding === 'sjis') {
        return (0, _ecl.UnescapeSJIS)(escapeString);
      } else if (encoding === 'euc-jp') {
        return (0, _ecl.UnescapeEUCJP)(escapeString);
      } else if (encoding === 'jis-7') {
        return (0, _ecl.UnescapeJIS7)(escapeString);
      } else if (encoding === 'jis-8') {
        return (0, _ecl.UnescapeJIS8)(escapeString);
      } else if (encoding === 'unicode') {
        return (0, _ecl.UnescapeUnicode)(escapeString);
      } else if (encoding === 'utf7') {
        return (0, _ecl.UnescapeUTF7)(escapeString);
      } else if (encoding === 'utf-8') {
        return (0, _ecl.UnescapeUTF8)(escapeString);
      } else if (encoding === 'utf-16') {
        return (0, _ecl.UnescapeUTF16LE)(escapeString);
      }

      throw new Error('unsupported encoding: ' + encoding);
    }
  }, {
    key: 'getAvailableDataLength',
    value: function getAvailableDataLength() {
      return this.buffer.length - this._pos;
    }

    /**
     *
     * @access private
     * @param {number} len -
     * @returns {void}
     */

  }, {
    key: '_moveIndex',
    value: function _moveIndex(len) {
      this._partialText = this._partialText.substring(len);
      if (this._partialText.length < this._partialMinLength) {
        this._addPartialText();
      }
    }
  }, {
    key: '_skipSpace',
    value: function _skipSpace() {
      var i = 0;
      var code = this._partialText.charCodeAt(i);

      //  9: Horizontal Tab
      // 10: Line Feed
      // 11: Vertical Tab
      // 12: New Page
      // 13: Carriage Return
      // 32: Space
      while (code === 32 || 9 <= code && code <= 13) {
        i++;
        code = this._partialText.charCodeAt(i);

        if (i >= this._partialText.length) {
          this._addPartialText();
        }
      }
      if (i > 0) {
        this._moveIndex(i);
      }
    }
  }, {
    key: '_addPartialText',
    value: function _addPartialText() {
      if (this._partialOffset >= this.buffer.length) {
        return;
      }

      var newOffset = this._partialOffset + this._partialStep;
      if (newOffset > this.buffer.length) {
        newOffset = this.buffer.length;
      }

      if (Buffer.isEncoding(this.encoding)) {
        this._partialText += this.buffer.toString(this.encoding, this._partialOffset, newOffset);
      } else {
        var data = this.buffer.toString('binary', this._partialOffset, newOffset);
        this._partialText += this._convert(data, this.encoding);
      }
      this._partialOffset = newOffset;
    }
  }, {
    key: '_getString',
    value: function _getString(pattern) {
      this._skipSpace();

      var str = this._partialText.match(pattern);
      if (str === null) {
        return null;
      }

      this._moveIndex(str[0].length);

      return str;
    }
  }]);

  return TextReader;
}();

exports.default = TextReader;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21).Buffer))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
//
// Escape Codec Library: ecl.js (Ver.041208)
//
// Copyright (C) http://nurucom-archives.hp.infoseek.co.jp/digital/
//

var EscapeSJIS = function EscapeSJIS(str) {
	return str.replace(/[^*+.-9A-Z_a-z-]/g, function (s) {
		var c = s.charCodeAt(0),
		    m;
		return c < 128 ? (c < 16 ? "%0" : "%") + c.toString(16).toUpperCase() : 65376 < c && c < 65440 ? "%" + (c - 65216).toString(16).toUpperCase() : (c = JCT11280.indexOf(s)) < 0 ? "%81E" : "%" + ((m = ((c < 8272 ? c : c = JCT11280.lastIndexOf(s)) - (c %= 188)) / 188) < 31 ? m + 129 : m + 193).toString(16).toUpperCase() + (64 < (c += c < 63 ? 64 : 65) && c < 91 || 95 == c || 96 < c && c < 123 ? String.fromCharCode(c) : "%" + c.toString(16).toUpperCase());
	});
};

var UnescapeSJIS = function UnescapeSJIS(str) {
	return str.replace(/%(8[1-9A-F]|[9E][0-9A-F]|F[0-9A-C])(%[4-689A-F][0-9A-F]|%7[0-9A-E]|[@-~])|%([0-7][0-9A-F]|A[1-9A-F]|[B-D][0-9A-F])/ig, function (s) {
		var c = parseInt(s.substring(1, 3), 16),
		    l = s.length;
		return 3 == l ? String.fromCharCode(c < 160 ? c : c + 65216) : JCT11280.charAt((c < 160 ? c - 129 : c - 193) * 188 + (4 == l ? s.charCodeAt(3) - 64 : (c = parseInt(s.substring(4), 16)) < 127 ? c - 64 : c - 65));
	});
};

var EscapeEUCJP = function EscapeEUCJP(str) {
	return str.replace(/[^*+.-9A-Z_a-z-]/g, function (s) {
		var c = s.charCodeAt(0);
		return (c < 128 ? (c < 16 ? "%0" : "%") + c.toString(16) : 65376 < c && c < 65440 ? "%8E%" + (c - 65216).toString(16) : (c = JCT8836.indexOf(s)) < 0 ? "%A1%A6" : "%" + ((c - (c %= 94)) / 94 + 161).toString(16) + "%" + (c + 161).toString(16)).toUpperCase();
	});
};

var UnescapeEUCJP = function UnescapeEUCJP(str) {
	return str.replace(/(%A[1-9A-F]|%[B-E][0-9A-F]|%F[0-9A-E]){2}|%8E%(A[1-9A-F]|[B-D][0-9A-F])|%[0-7][0-9A-F]/ig, function (s) {
		var c = parseInt(s.substring(1), 16);
		return c < 161 ? String.fromCharCode(c < 128 ? c : parseInt(s.substring(4), 16) + 65216) : JCT8836.charAt((c - 161) * 94 + parseInt(s.substring(4), 16) - 161);
	});
};

var EscapeJIS7 = function EscapeJIS7(str) {
	var u = String.fromCharCode,
	    ri = u(92, 120, 48, 48, 45, 92, 120, 55, 70),
	    rj = u(65377, 45, 65439, 93, 43),
	    H = function H(c) {
		return 41 < c && c < 58 && 44 != c || 64 < c && c < 91 || 95 == c || 96 < c && c < 123 ? u(c) : "%" + c.toString(16).toUpperCase();
	},
	    I = function I(s) {
		var c = s.charCodeAt(0);
		return (c < 16 ? "%0" : "%") + c.toString(16).toUpperCase();
	},
	    rI = new RegExp();rI.compile("[^*+.-9A-Z_a-z-]", "g");
	return ("g" + str + "g").replace(RegExp("[" + ri + "]+", "g"), function (s) {
		return "%1B%28B" + s.replace(rI, I);
	}).replace(RegExp("[" + rj, "g"), function (s) {
		var c,
		    i = 0,
		    t = "%1B%28I";while (c = s.charCodeAt(i++)) {
			t += H(c - 65344);
		}return t;
	}).replace(RegExp("[^" + ri + rj, "g"), function (s) {
		var a,
		    c,
		    i = 0,
		    t = "%1B%24B";while (a = s.charAt(i++)) {
			t += (c = JCT8836.indexOf(a)) < 0 ? "%21%26" : H((c - (c %= 94)) / 94 + 33) + H(c + 33);
		}return t;
	}).slice(8, -1);
};

var UnescapeJIS7 = function UnescapeJIS7(str) {
	var i = 0,
	    p,
	    q,
	    s = "",
	    u = String.fromCharCode,
	    P = ("%28B" + str.replace(/%49/g, "I").replace(/%1B%24%4[02]|%1B%24@/ig, "%1B%24B")).split(/%1B/i),
	    I = function I(s) {
		return u(parseInt(s.substring(1), 16));
	},
	    J = function J(s) {
		return u((3 == s.length ? parseInt(s.substring(1), 16) : s.charCodeAt(0)) + 65344);
	},
	    K = function K(s) {
		var l = s.length;
		return JCT8836.charAt(4 < l ? (parseInt(s.substring(1), 16) - 33) * 94 + parseInt(s.substring(4), 16) - 33 : 2 < l ? (37 == (l = s.charCodeAt(0)) ? (parseInt(s.substring(1, 3), 16) - 33) * 94 + s.charCodeAt(3) : (l - 33) * 94 + parseInt(s.substring(2), 16)) - 33 : (s.charCodeAt(0) - 33) * 94 + s.charCodeAt(1) - 33);
	},
	    rI = new RegExp(),
	    rJ = new RegExp(),
	    rK = new RegExp();
	rI.compile("%[0-7][0-9A-F]", "ig");rJ.compile("(%2[1-9A-F]|%[3-5][0-9A-F])|[!-_]", "ig");
	rK.compile("(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E]){2}|(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])[!-~]|[!-~](%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])|[!-~]{2}", "ig");
	while (p = P[i++]) {
		s += "%24B" == (q = p.substring(0, 4)) ? p.substring(4).replace(rK, K) : "%28I" == q ? p.substring(4).replace(rJ, J) : p.replace(rI, I).substring(2);
	}return s;
};

var EscapeJIS8 = function EscapeJIS8(str) {
	var u = String.fromCharCode,
	    r = u(92, 120, 48, 48, 45, 92, 120, 55, 70, 65377, 45, 65439, 93, 43),
	    H = function H(c) {
		return 41 < c && c < 58 && 44 != c || 64 < c && c < 91 || 95 == c || 96 < c && c < 123 ? u(c) : "%" + c.toString(16).toUpperCase();
	},
	    I = function I(s) {
		var c = s.charCodeAt(0);
		return (c < 16 ? "%0" : "%") + (c < 128 ? c : c - 65216).toString(16).toUpperCase();
	},
	    rI = new RegExp();rI.compile("[^*+.-9A-Z_a-z-]", "g");
	return ("g" + str + "g").replace(RegExp("[" + r, "g"), function (s) {
		return "%1B%28B" + s.replace(rI, I);
	}).replace(RegExp("[^" + r, "g"), function (s) {
		var a,
		    c,
		    i = 0,
		    t = "%1B%24B";while (a = s.charAt(i++)) {
			t += (c = JCT8836.indexOf(a)) < 0 ? "%21%26" : H((c - (c %= 94)) / 94 + 33) + H(c + 33);
		}return t;
	}).slice(8, -1);
};

var UnescapeJIS8 = function UnescapeJIS8(str) {
	var i = 0,
	    p,
	    s = "",
	    P = ("%28B" + str.replace(/%1B%24%4[02]|%1B%24@/ig, "%1B%24B")).split(/%1B/i),
	    I = function I(s) {
		var c = parseInt(s.substring(1), 16);
		return String.fromCharCode(c < 128 ? c : c + 65216);
	},
	    K = function K(s) {
		var l = s.length;
		return JCT8836.charAt(4 < l ? (parseInt(s.substring(1), 16) - 33) * 94 + parseInt(s.substring(4), 16) - 33 : 2 < l ? (37 == (l = s.charCodeAt(0)) ? (parseInt(s.substring(1, 3), 16) - 33) * 94 + s.charCodeAt(3) : (l - 33) * 94 + parseInt(s.substring(2), 16)) - 33 : (s.charCodeAt(0) - 33) * 94 + s.charCodeAt(1) - 33);
	},
	    rI = new RegExp(),
	    rK = new RegExp();
	rI.compile("%([0-7][0-9A-F]|A[1-9A-F]|[B-D][0-9A-F])", "ig");
	rK.compile("(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E]){2}|(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])[!-~]|[!-~](%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])|[!-~]{2}", "ig");
	while (p = P[i++]) {
		s += "%24B" == p.substring(0, 4) ? p.substring(4).replace(rK, K) : p.replace(rI, I).substring(2);
	}return s;
};

var EscapeUnicode = function EscapeUnicode(str) {
	return str.replace(/[^*+.-9A-Z_a-z-]/g, function (s) {
		var c = s.charCodeAt(0);
		return (c < 16 ? "%0" : c < 256 ? "%" : c < 4096 ? "%u0" : "%u") + c.toString(16).toUpperCase();
	});
};

var UnescapeUnicode = function UnescapeUnicode(str) {
	return str.replace(/%u[0-9A-F]{4}|%[0-9A-F]{2}/ig, function (s) {
		return String.fromCharCode("0x" + s.substring(s.length / 3));
	});
};

var EscapeUTF7 = function EscapeUTF7(str) {
	var B = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),
	    E = function E(s) {
		var c = s.charCodeAt(0);
		return B[c >> 10] + B[c >> 4 & 63] + B[(c & 15) << 2 | (c = s.charCodeAt(1)) >> 14] + (0 <= c ? B[c >> 8 & 63] + B[c >> 2 & 63] + B[(c & 3) << 4 | (c = s.charCodeAt(2)) >> 12] + (0 <= c ? B[c >> 6 & 63] + B[c & 63] : "") : "");
	},
	    re = new RegExp();re.compile("[^+]{1,3}", "g");
	return (str + "g").replace(/[^*+.-9A-Z_a-z-]+[*+.-9A-Z_a-z-]|[+]/g, function (s) {
		if ("+" == s) return "+-";
		var l = s.length - 1,
		    w = s.charAt(l);
		return "+" + s.substring(0, l).replace(re, E) + ("+" == w ? "-+-" : "*" == w || "." == w || "_" == w ? w : "-" + w);
	}).slice(0, -1);
};

var UnescapeUTF7 = function UnescapeUTF7(str) {
	var i = 0,
	    B = {};
	while (i < 64) {
		B["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(i)] = i++;
	}return str.replace(RegExp("[+][+/-9A-Za-z]*-?", "g"), function (s) {
		if ("+-" == s) return "+";
		var b = B[s.charAt(1)],
		    c,
		    i = 1,
		    t = "";
		while (0 <= b) {
			if ((c = i & 7) < 6) c = c < 3 ? b << 10 | B[s.charAt(++i)] << 4 | (b = B[s.charAt(++i)]) >> 2 : (b & 3) << 14 | B[s.charAt(++i)] << 8 | B[s.charAt(++i)] << 2 | (b = B[s.charAt(++i)]) >> 4;else {
				c = (b & 15) << 12 | B[s.charAt(++i)] << 6 | B[s.charAt(++i)];b = B[s.charAt(++i)];
			}
			if (c) t += String.fromCharCode(c);
		}
		return t;
	});
};

var EscapeUTF8 = function EscapeUTF8(str) {
	return str.replace(/[^*+.-9A-Z_a-z-]/g, function (s) {
		var c = s.charCodeAt(0);
		return (c < 16 ? "%0" + c.toString(16) : c < 128 ? "%" + c.toString(16) : c < 2048 ? "%" + (c >> 6 | 192).toString(16) + "%" + (c & 63 | 128).toString(16) : "%" + (c >> 12 | 224).toString(16) + "%" + (c >> 6 & 63 | 128).toString(16) + "%" + (c & 63 | 128).toString(16)).toUpperCase();
	});
};

var UnescapeUTF8 = function UnescapeUTF8(str) {
	return str.replace(/%(E(0%[AB]|[1-CEF]%[89AB]|D%[89])[0-9A-F]|C[2-9A-F]|D[0-9A-F])%[89AB][0-9A-F]|%[0-7][0-9A-F]/ig, function (s) {
		var c = parseInt(s.substring(1), 16);
		return String.fromCharCode(c < 128 ? c : c < 224 ? (c & 31) << 6 | parseInt(s.substring(4), 16) & 63 : ((c & 15) << 6 | parseInt(s.substring(4), 16) & 63) << 6 | parseInt(s.substring(7), 16) & 63);
	});
};

var EscapeUTF16LE = function EscapeUTF16LE(str) {
	var H = function H(c) {
		return 41 < c && c < 58 && 44 != c || 64 < c && c < 91 || 95 == c || 96 < c && c < 123 ? String.fromCharCode(c) : (c < 16 ? "%0" : "%") + c.toString(16).toUpperCase();
	};
	return str.replace(/[^ ]| /g, function (s) {
		var c = s.charCodeAt(0);return H(c & 255) + H(c >> 8);
	});
};

var UnescapeUTF16LE = function UnescapeUTF16LE(str) {
	var u = String.fromCharCode,
	    b = u(92, 120, 48, 48, 45, 92, 120, 70, 70);
	return str.replace(/^%FF%FE/i, "").replace(RegExp("%[0-9A-F]{2}%[0-9A-F]{2}|%[0-9A-F]{2}[" + b + "]|[" + b + "]%[0-9A-F]{2}|[" + b + "]{2}", "ig"), function (s) {
		var l = s.length;
		return u(4 < l ? "0x" + s.substring(4, 6) + s.substring(1, 3) : 2 < l ? 37 == (l = s.charCodeAt(0)) ? parseInt(s.substring(1, 3), 16) | s.charCodeAt(3) << 8 : l | parseInt(s.substring(2), 16) << 8 : s.charCodeAt(0) | s.charCodeAt(1) << 8);
	});
};

var GetEscapeCodeType = function GetEscapeCodeType(str) {
	if (/%u[0-9A-F]{4}/i.test(str)) return "Unicode";
	if (/%([0-9A-DF][0-9A-F]%[8A]0%|E0%80|[0-7][0-9A-F]|C[01])%[8A]0|%00|%[7F]F/i.test(str)) return "UTF16LE";
	if (/%E[0-9A-F]%[8A]0%[8A]0|%[CD][0-9A-F]%[8A]0/i.test(str)) return "UTF8";
	if (/%F[DE]/i.test(str)) return (/%8[0-9A-D]|%9[0-9A-F]|%A0/i.test(str) ? "UTF16LE" : "EUCJP"
	);
	if (/%1B/i.test(str)) return (/%[A-D][0-9A-F]/i.test(str) ? "JIS8" : "JIS7"
	);
	var S = str.substring(0, 6143).replace(/%[0-9A-F]{2}|[^ ]| /ig, function (s) {
		return s.length < 3 ? "40" : s.substring(1);
	}),
	    c,
	    C,
	    i = 0,
	    T;
	while (0 <= (c = parseInt(S.substring(i, i += 2), 16)) && i < 4092) {
		if (128 <= c) {
			if ((C = parseInt(S.substring(i, i + 2), 16)) < 128) i += 2;else if (194 <= c && c < 240 && C < 192) {
				if (c < 224) {
					T = "UTF8";i += 2;continue;
				}
				if (2 == parseInt(S.charAt(i + 2), 16) >> 2) {
					T = "UTF8";i += 4;continue;
				}
			}
			if (142 == c && 161 <= C && C < 224) {
				if (!T) T = "EUCJP";if ("EUCJP" == T) continue;
			}
			if (c < 161) return "SJIS";
			if (c < 224 && !T) {
				if ((164 == c && C < 244 || 165 == c && C < 247) && 161 <= C) i += 2;else T = 224 <= C ? "EUCJP" : "SJIS";
			} else T = "EUCJP";
		}
	}return T ? T : "EUCJP";
};

var JCT11280 = Function('var a="zKV33~jZ4zN=~ji36XazM93y!{~k2y!o~k0ZlW6zN?3Wz3W?{EKzK[33[`y|;-~j^YOTz$!~kNy|L1$353~jV3zKk3~k-4P4zK_2+~jY4y!xYHR~jlz$_~jk4z$e3X5He<0y!wy|X3[:~l|VU[F3VZ056Hy!nz/m1XD61+1XY1E1=1y|bzKiz!H034zKj~mEz#c5ZA3-3X$1~mBz$$3~lyz#,4YN5~mEz#{ZKZ3V%7Y}!J3X-YEX_J(3~mAz =V;kE0/y|F3y!}~m>z/U~mI~j_2+~mA~jp2;~m@~k32;~m>V}2u~mEX#2x~mBy+x2242(~mBy,;2242(~may->2&XkG2;~mIy-_2&NXd2;~mGz,{4<6:.:B*B:XC4>6:.>B*BBXSA+A:X]E&E<~r#z+625z s2+zN=`HXI@YMXIAXZYUM8X4K/:Q!Z&33 3YWX[~mB`{zKt4z (zV/z 3zRw2%Wd39]S11z$PAXH5Xb;ZQWU1ZgWP%3~o@{Dgl#gd}T){Uo{y5_d{e@}C(} WU9|cB{w}bzvV|)[} H|zT}d||0~{]Q|(l{|x{iv{dw}(5}[Z|kuZ }cq{{y|ij}.I{idbof%cu^d}Rj^y|-M{ESYGYfYsZslS`?ZdYO__gLYRZ&fvb4oKfhSf^d<Yeasc1f&a=hnYG{QY{D`Bsa|u,}Dl|_Q{C%xK|Aq}C>|c#ryW=}eY{L+`)][YF_Ub^h4}[X|?r|u_ex}TL@YR]j{SrXgo*|Gv|rK}B#mu{R1}hs|dP{C7|^Qt3|@P{YVV |8&}#D}ef{e/{Rl|>Hni}R1{Z#{D[}CQlQ||E}[s{SG_+i8eplY[=[|ec[$YXn#`hcm}YR|{Ci(_[ql|?8p3]-}^t{wy}4la&pc|3e{Rp{LqiJ],] `kc(]@chYnrM`O^,ZLYhZB]ywyfGY~aex!_Qww{a!|)*lHrM{N+n&YYj~Z b c#e_[hZSon|rOt`}hBXa^i{lh|<0||r{KJ{kni)|x,|0auY{D!^Sce{w;|@S|cA}Xn{C1h${E]Z-XgZ*XPbp]^_qbH^e[`YM|a||+=]!Lc}]vdBc=j-YSZD]YmyYLYKZ9Z>Xcczc2{Yh}9Fc#Z.l{}(D{G{{mRhC|L3b#|xK[Bepj#ut`H[,{E9Yr}1b{[e]{ZFk7[ZYbZ0XL]}Ye[(`d}c!|*y`Dg=b;gR]Hm=hJho}R-[n}9;{N![7k_{UbmN]rf#pTe[x8}!Qcs_rs[m`|>N}^V})7{^r|/E}),}HH{OYe2{Skx)e<_.cj.cjoMhc^d}0uYZd!^J_@g,[[[?{i@][|3S}Yl3|!1|eZ|5IYw|1D}e7|Cv{OHbnx-`wvb[6[4} =g+k:{C:}ed{S]|2M]-}WZ|/q{LF|dYu^}Gs^c{Z=}h>|/i|{W]:|ip{N:|zt|S<{DH[p_tvD{N<[8Axo{X4a.^o^X>Yfa59`#ZBYgY~_t^9`jZHZn`>G[oajZ;X,i)Z.^~YJe ZiZF^{][[#Zt^|]Fjx]&_5dddW]P0C[-]}]d|y {C_jUql] |OpaA[Z{lp|rz}:Mu#]_Yf6{Ep?f5`$[6^D][^u[$[6^.Z8]]ePc2U/=]K^_+^M{q*|9tYuZ,s(dS{i=|bNbB{uG}0jZOa:[-]dYtu3]:]<{DJ_SZIqr_`l=Yt`gkTnXb3d@kiq0a`Z{|!B|}e}Ww{Sp,^Z|0>_Z}36|]A|-t}lt{R6pi|v8hPu#{C>YOZHYmg/Z4nicK[}hF_Bg|YRZ7c|crkzYZY}_iXcZ.|)U|L5{R~qi^Uga@Y[xb}&qdbd6h5|Btw[}c<{Ds53[Y7]?Z<|e0{L[ZK]mXKZ#Z2^tavf0`PE[OSOaP`4gi`qjdYMgys/?[nc,}EEb,eL]g[n{E_b/vcvgb.{kcwi`~v%|0:|iK{Jh_vf5lb}KL|(oi=LrzhhY_^@`zgf[~g)[J_0fk_V{T)}I_{D&_/d9W/|MU[)f$xW}?$xr4<{Lb{y4}&u{XJ|cm{Iu{jQ}CMkD{CX|7A}G~{kt)nB|d5|<-}WJ}@||d@|Iy}Ts|iL|/^|no|0;}L6{Pm]7}$zf:|r2}?C_k{R(}-w|`G{Gy[g]bVje=_0|PT{^Y^yjtT[[[l!Ye_`ZN]@[n_)j3nEgMa]YtYpZy].d-Y_cjb~Y~[nc~sCi3|zg}B0}do{O^{|$`_|D{}U&|0+{J3|8*]iayx{a{xJ_9|,c{Ee]QXlYb]$[%YMc*]w[aafe]aVYi[fZEii[xq2YQZHg]Y~h#|Y:thre^@^|_F^CbTbG_1^qf7{L-`VFx Zr|@EZ;gkZ@slgko`[e}T:{Cu^pddZ_`yav^Ea+[#ZBbSbO`elQfLui}.F|txYcbQ`XehcGe~fc^RlV{D_0ZAej[l&jShxG[ipB_=u:eU}3e8[=j|{D(}dO{Do[BYUZ0/]AYE]ALYhZcYlYP/^-^{Yt_1_-;YT`P4BZG=IOZ&]H[e]YYd[9^F[1YdZxZ?Z{Z<]Ba2[5Yb[0Z4l?]d_;_)a?YGEYiYv`_XmZs4ZjY^Zb]6gqGaX^9Y}dXZr[g|]Y}K aFZp^k^F]M`^{O1Ys]ZCgCv4|E>}8eb7}l`{L5[Z_faQ|c2}Fj}hw^#|Ng|B||w2|Sh{v+[G}aB|MY}A{|8o}X~{E8paZ:]i^Njq]new)`-Z>haounWhN}c#{DfZ|fK]KqGZ=:u|fqoqcv}2ssm}.r{]{nIfV{JW)[K|,Z{Uxc|]l_KdCb%]cfobya3`p}G^|LZiSC]U|(X|kBlVg[kNo({O:g:|-N|qT}9?{MBiL}Sq{`P|3a|u.{Uaq:{_o|^S}jX{Fob0`;|#y_@[V[K|cw[<_ }KU|0F}d3|et{Q7{LuZttsmf^kYZ`Af`}$x}U`|Ww}d]| >}K,r&|XI|*e{C/a-bmr1fId4[;b>tQ_:]hk{b-pMge]gfpo.|(w[jgV{EC1Z,YhaY^q,_G[c_g[J0YX]`[h^hYK^_Yib,` {i6vf@YM^hdOKZZn(jgZ>bzSDc^Z%[[o9[2=/YHZ(_/Gu_`*|8z{DUZxYt^vuvZjhi^lc&gUd4|<UiA`z]$b/Z?l}YI^jaHxe|;F}l${sQ}5g}hA|e4}?o{ih}Uz{C)jPe4]H^J[Eg[|AMZMlc}:,{iz}#*|gc{Iq|/:|zK{l&}#u|myd{{M&v~nV};L|(g|I]ogddb0xsd7^V})$uQ{HzazsgxtsO^l}F>ZB]r|{7{j@cU^{{CbiYoHlng]f+nQ[bkTn/}<-d9q {KXadZYo+n|l[|lc}V2{[a{S4Zam~Za^`{HH{xx_SvF|ak=c^[v^7_rYT`ld@]:_ub%[$[m](Shu}G2{E.ZU_L_R{tz`vj(f?^}hswz}GdZ}{S:h`aD|?W|`dgG|if{a8|J1{N,}-Ao3{H#{mfsP|[ bzn+}_Q{MT{u4kHcj_q`eZj[8o0jy{p7}C|[}l){MuYY{|Ff!Ykn3{rT|m,^R|,R}$~Ykgx{P!]>iXh6[l[/}Jgcg{JYZ.^qYfYIZl[gZ#Xj[Pc7YyZD^+Yt;4;`e8YyZVbQ7YzZxXja.7SYl[s]2^/Ha$[6ZGYrb%XiYdf2]H]kZkZ*ZQ[ZYS^HZXcCc%Z|[(bVZ]]:OJQ_DZCg<[,]%Zaa [g{C00HY[c%[ChyZ,Z_`PbXa+eh`^&jPi0a[ggvhlekL]w{Yp^v}[e{~;k%a&k^|nR_z_Qng}[E}*Wq:{k^{FJZpXRhmh3^p>de^=_7`|ZbaAZtdhZ?n4ZL]u`9ZNc3g%[6b=e.ZVfC[ZZ^^^hD{E(9c(kyZ=bb|Sq{k`|vmr>izlH[u|e`}49}Y%}FT{[z{Rk}Bz{TCc/lMiAqkf(m$hDc;qooi[}^o:c^|Qm}a_{mrZ(pA`,}<2sY| adf_%|}`}Y5U;}/4|D>|$X{jw{C<|F.hK|*A{MRZ8Zsm?imZm_?brYWZrYx`yVZc3a@f?aK^ojEd {bN}/3ZH]/$YZhm^&j 9|(S|b]mF}UI{q&aM]LcrZ5^.|[j`T_V_Gak}9J[ ZCZD|^h{N9{~&[6Zd{}B}2O|cv]K}3s}Uy|l,fihW{EG`j_QOp~Z$F^zexS`dcISfhZBXP|.vn|_HYQ|)9|cr]<`&Z6]m_(ZhPcSg>`Z]5`~1`0Xcb4k1{O!bz|CN_T{LR|a/gFcD|j<{Z._[f)mPc:1`WtIaT1cgYkZOaVZOYFrEe[}T$}Ch}mk{K-^@]fH{Hdi`c*Z&|Kt{if[C{Q;{xYB`dYIX:ZB[}]*[{{p9|4GYRh2ao{DS|V+[zd$`F[ZXKadb*A] Ys]Maif~a/Z2bmclb8{Jro_rz|x9cHojbZ{GzZx_)]:{wAayeDlx}<=`g{H1{l#}9i|)=|lP{Qq}.({La|!Y{i2EZfp=c*}Cc{EDvVB|;g}2t{W4av^Bn=]ri,|y?|3+}T*ckZ*{Ffr5e%|sB{lx^0]eZb]9[SgAjS_D|uHZx]dive[c.YPkcq/}db{EQh&hQ|eg}G!ljil|BO]X{Qr_GkGl~YiYWu=c3eb}29v3|D|}4i||.{Mv})V{SP1{FX}CZW6{cm|vO{pS|e#}A~|1i}81|Mw}es|5[}3w{C`h9aL]o{}p[G`>i%a1Z@`Ln2bD[$_h`}ZOjhdTrH{[j_:k~kv[Sdu]CtL}41{I |[[{]Zp$]XjxjHt_eThoa#h>sSt8|gK|TVi[Y{t=}Bs|b7Zpr%{gt|Yo{CS[/{iteva|cf^hgn}($_c^wmb^Wm+|55jrbF|{9^ q6{C&c+ZKdJkq_xOYqZYSYXYl`8]-cxZAq/b%b*_Vsa[/Ybjac/OaGZ4fza|a)gY{P?| I|Y |,pi1n7}9bm9ad|=d{aV|2@[(}B`d&|Uz}B}{`q|/H|!JkM{FU|CB|.{}Az}#P|lk}K{|2rk7{^8^?`/|k>|Ka{Sq}Gz}io{DxZh[yK_#}9<{TRdgc]`~Z>JYmYJ]|`!ZKZ]gUcx|^E[rZCd`f9oQ[NcD_$ZlZ;Zr}mX|=!|$6ZPZYtIo%fj}CpcN|B,{VDw~gb}@hZg`Q{LcmA[(bo`<|@$|o1|Ss}9Z_}tC|G`{F/|9nd}i=}V-{L8aaeST]daRbujh^xlpq8|}zs4bj[S`J|]?G{P#{rD{]I`OlH{Hm]VYuSYUbRc*6[j`8]pZ[bt_/^Jc*[<Z?YE|Xb|?_Z^Vcas]h{t9|Uwd)_(=0^6Zb{Nc} E[qZAeX[a]P^|_J>e8`W^j_Y}R{{Jp__]Ee#e:iWb9q_wKbujrbR}CY`,{mJ}gz{Q^{t~N|? gSga`V_||:#mi}3t|/I`X{N*|ct|2g{km}gi|{={jC}F;|E}{ZZjYf*frmu}8Tdroi{T[|+~}HG{cJ}DM{Lp{Ctd&}$hi3|FZ| m}Kr|38}^c|m_|Tr{Qv|36}?Up>|;S{DV{k_as}BK{P}}9p|t`jR{sAm4{D=b4pWa[}Xi{EjwEkI}3S|E?u=X0{jf} S|NM|JC{qo^3cm]-|JUx/{Cj{s>{Crt[UXuv|D~|j|d{YXZR}Aq}0r}(_{pJfi_z}0b|-vi)Z mFe,{f4|q`b{}^Z{HM{rbeHZ|^x_o|XM|L%|uFXm}@C_{{Hhp%a7|0p[Xp+^K}9U{bP}: tT}B|}+$|b2|[^|~h{FAby[`{}xgygrt~h1[li`c4vz|,7p~b(|mviN}^pg[{N/|g3|^0c,gE|f%|7N{q[|tc|TKA{LU}I@|AZp(}G-sz{F |qZ{}F|f-}RGn6{Z]_5})B}UJ{FFb2]4ZI@v=k,]t_Dg5Bj]Z-]L]vrpdvdGlk|gF}G]|IW}Y0[G| /bo|Te^,_B}#n^^{QHYI[?hxg{[`]D^IYRYTb&kJ[cri[g_9]Ud~^_]<p@_e_XdNm-^/|5)|h_{J;{kacVopf!q;asqd}n)|.m|bf{QW|U)}b+{tL|w``N|to{t ZO|T]jF}CB|0Q{e5Zw|k |We}5:{HO{tPwf_uajjBfX}-V_C_{{r~gg|Ude;s+}KNXH}! `K}eW{Upwbk%ogaW}9EYN}YY|&v|SL{C3[5s.]Y]I]u{M6{pYZ`^,`ZbCYR[1mNg>rsk0Ym[jrE]RYiZTr*YJ{Ge|%-lf|y(`=[t}E6{k!|3)}Zk} ][G{E~cF{u3U.rJ|a9p#o#ZE|?|{sYc#vv{E=|LC}cu{N8`/`3`9rt[4|He{cq|iSYxY`}V |(Q|t4{C?]k_Vlvk)BZ^r<{CL}#h}R+[<|i=}X|{KAo]|W<`K{NW|Zx}#;|fe{IMr<|K~tJ_x}AyLZ?{GvbLnRgN}X&{H7|x~}Jm{]-| GpNu0}.ok>|c4{PYisrDZ|fwh9|hfo@{H~XSbO]Odv]%`N]b1Y]]|eIZ}_-ZA]aj,>eFn+j[aQ_+]h[J_m_g]%_wf.`%k1e#Z?{CvYu_B^|gk`Xfh^M3`afGZ-Z|[m{L}|k3cp[it ^>YUi~d>{T*}YJ{Q5{Jxa$hg|%4`}|LAgvb }G}{P=|<;Ux{_skR{cV|-*|s-{Mp|XP|$G|_J}c6cM{_=_D|*9^$ec{V;|4S{qO|w_|.7}d0|/D}e}|0G{Dq]Kdp{}dfDi>}B%{Gd|nl}lf{C-{y}|ANZr}#={T~|-(}c&{pI|ft{lsVP}){|@u}!W|bcmB{d?|iW|:dxj{PSkO|Hl]Li:}VYk@|2={fnWt{M3`cZ6|)}|Xj}BYa?vo{e4|L7|B7{L7|1W|lvYO}W8nJ|$Vih|{T{d*_1|:-n2dblk``fT{Ky|-%}m!|Xy|-a{Pz}[l{kFjz|iH}9N{WE{x,|jz}R {P|{D)c=nX|Kq|si}Ge{sh|[X{RF{t`|jsr*fYf,rK|/9}$}}Nf{y!1|<Std}4Wez{W${Fd_/^O[ooqaw_z[L`Nbv[;l7V[ii3_PeM}.h^viqYjZ*j1}+3{bt{DR[;UG}3Og,rS{JO{qw{d<_zbAh<R[1_r`iZTbv^^a}c{iEgQZ<exZFg.^Rb+`Uj{a+{z<[~r!]`[[|rZYR|?F|qppp]L|-d|}K}YZUM|=Y|ktm*}F]{D;g{uI|7kg^}%?Z%ca{N[_<q4xC]i|PqZC]n}.bDrnh0Wq{tr|OMn6tM|!6|T`{O`|>!]ji+]_bTeU}Tq|ds}n|{Gm{z,f)}&s{DPYJ`%{CGd5v4tvb*hUh~bf]z`jajiFqAii]bfy^U{Or|m+{I)cS|.9k:e3`^|xN}@Dnlis`B|Qo{`W|>||kA}Y}{ERYuYx`%[exd`]|OyiHtb}HofUYbFo![5|+]gD{NIZR|Go}.T{rh^4]S|C9_}xO^i`vfQ}C)bK{TL}cQ|79iu}9a];sj{P.o!f[Y]pM``Jda^Wc9ZarteBZClxtM{LW}l9|a.mU}KX}4@{I+f1}37|8u}9c|v${xGlz}jP{Dd1}e:}31}%3X$|22i<v+r@~mf{sN{C67G97855F4YL5}8f{DT|xy{sO{DXB334@55J1)4.G9A#JDYtXTYM4, YQD9;XbXm9SX]IB^4UN=Xn<5(;(F3YW@XkH-X_VM[DYM:5XP!T&Y`6|,^{IS-*D.H>:LXjYQ0I3XhAF:9:(==.F*3F1189K/7163D,:@|e2{LS36D4hq{Lw/84443@4.933:0307::6D7}&l{Mx657;89;,K5678H&93D(H<&<>0B90X^I;}Ag1{P%3A+>><975}[S{PZE453?4|T2{Q+5187;>447:81{C=hL6{Me^:=7ii{R=.=F<81;48?|h8}Uh{SE|,VxL{ST,7?9Y_5Xk3A#:$%YSYdXeKXOD8+TXh7(@>(YdXYHXl9J6X_5IXaL0N?3YK7Xh!1?XgYz9YEXhXaYPXhC3X`-YLY_XfVf[EGXZ5L8BXL9YHX]SYTXjLXdJ: YcXbQXg1PX]Yx4|Jr{Ys4.8YU+XIY`0N,<H%-H;:0@,74/:8546I=9177154870UC]d<C3HXl7ALYzXFXWP<<?E!88E5@03YYXJ?YJ@6YxX-YdXhYG|9o{`iXjY_>YVXe>AYFX[/(I@0841?):-B=14337:8=|14{c&93788|di{cW-0>0<097/A;N{FqYpugAFT%X/Yo3Yn,#=XlCYHYNX[Xk3YN:YRT4?)-YH%A5XlYF3C1=NWyY}>:74-C673<69545v {iT85YED=64=.F4..9878/D4378?48B3:7:7/1VX[f4{D,{l<5E75{dAbRB-8-@+;DBF/$ZfW8S<4YhXA.(5@*11YV8./S95C/0R-A4AXQYI7?68167B95HA1*<M3?1/@;/=54XbYP36}lc{qzSS38:19?,/39193574/66878Yw1X-87E6=;964X`T734:>86>1/=0;(I-1::7ALYGXhF+Xk[@W%TYbX7)KXdYEXi,H-XhYMRXfYK?XgXj.9HX_SX]YL1XmYJ>Y}WwIXiI-3-GXcYyXUYJ$X`Vs[7;XnYEZ;XF! 3;%8;PXX(N3Y[)Xi1YE&/ :;74YQ6X`33C;-(>Xm0(TYF/!YGXg8 9L5P01YPXO-5%C|qd{{/K/E6,=0144:361:955;6443@?B7*7:F89&F35YaX-CYf,XiFYRXE_e{}sF 0*7XRYPYfXa5YXXY8Xf8Y~XmA[9VjYj*#YMXIYOXk,HHX40YxYMXU8OXe;YFXLYuPXP?EB[QV0CXfY{:9XV[FWE0D6X^YVP*$4%OXiYQ(|xp|%c3{}V`1>Y`XH00:8/M6XhQ1:;3414|TE|&o@1*=81G8<3}6<|(f6>>>5-5:8;093B^3U*+*^*UT30XgYU&7*O1953)5@E78--F7YF*B&0:%P68W9Zn5974J9::3}Vk|-,C)=)1AJ4+<3YGXfY[XQXmT1M-XcYTYZXCYZXEYXXMYN,17>XIG*SaS|/eYJXbI?XdNZ+WRYP<F:R PXf;0Xg`$|1GX9YdXjLYxWX!ZIXGYaXNYm6X9YMX?9EXmZ&XZ#XQ>YeXRXfAY[4 ;0X!Zz0XdN$XhYL XIY^XGNXUYS/1YFXhYk.TXn4DXjB{jg|4DEX]:XcZMW=A.+QYL<LKXc[vV$+&PX*Z3XMYIXUQ:ZvW< YSXFZ,XBYeXMM)?Xa XiZ4/EXcP3%}&-|6~:1(-+YT$@XIYRBC<}&,|7aJ6}bp|8)K1|Xg|8C}[T|8Q.89;-964I38361<=/;883651467<7:>?1:.}le|:Z=39;1Y^)?:J=?XfLXbXi=Q0YVYOXaXiLXmJXO5?.SFXiCYW}-;|=u&D-X`N0X^,YzYRXO(QX_YW9`I|>hZ:N&X)DQXP@YH#XmNXi$YWX^=!G6YbYdX>XjY|XlX^XdYkX>YnXUXPYF)FXT[EVTMYmYJXmYSXmNXi#GXmT3X8HOX[ZiXN]IU2>8YdX1YbX<YfWuZ8XSXcZU%0;1XnXkZ_WTG,XZYX5YSX Yp 05G?XcYW(IXg6K/XlYP4XnI @XnO1W4Zp-9C@%QDYX+OYeX9>--YSXkD.YR%Q/Yo YUX].Xi<HYEZ2WdCE6YMXa7F)=,D>-@9/8@5=?7164;35387?N<618=6>7D+C50<6B03J0{Hj|N9$D,9I-,.KB3}m |NzE0::/81YqXjMXl7YG; [.W=Z0X4XQY]:MXiR,XgM?9$9>:?E;YE77VS[Y564760391?14941:0=:8B:;/1DXjFA-564=0B3XlH1+D85:0Q!B#:-6&N/:9<-R3/7Xn<*3J4.H:+334B.=>30H.;3833/76464665755:/83H6633:=;.>5645}&E|Y)?1/YG-,93&N3AE@5 <L1-G/8A0D858/30>8<549=@B8] V0[uVQYlXeD(P#ID&7T&7;Xi0;7T-$YE)E=1:E1GR):--0YI7=E<}n9|aT6783A>D7&4YG7=391W;Zx<5+>F#J39}o/|cc;6=A050EQXg8A1-}D-|d^5548083563695D?-.YOXd37I$@LYLWeYlX<Yd+YR A$;3-4YQ-9XmA0!9/XLY_YT(=5XdDI>YJ5XP1ZAW{9>X_6R(XhYO65&J%DA)C-!B:97#A9;@?F;&;(9=11/=657/H,<8}bz|j^5446>.L+&Y^8Xb6?(CYOXb*YF(8X`FYR(XPYVXmPQ%&DD(XmZXW??YOXZXfCYJ79,O)XnYF7K0!QXmXi4IYFRXS,6<%-:YO(+:-3Q!1E1:W,Zo}Am|n~;3580534*?3Zc4=9334361693:30C<6/717:<1/;>59&:4}6!|rS36=1?75<8}[B|s809983579I.A.>84758=108564741H*9E{L{|u%YQ<%6XfH.YUXe4YL@,>N}Tv|ve*G0X)Z;/)3@A74(4P&A1X:YVH97;,754*A66:1 D739E3553545558E4?-?K17/770843XAYf838A7K%N!YW4.$T19Z`WJ*0XdYJXTYOXNZ 1XaN1A+I&Xi.Xk3Z3GB&5%WhZ1+5#Y[X<4YMXhQYoQXVXbYQ8XSYUX4YXBXWDMG0WxZA[8V+Z8X;D],Va$%YeX?FXfX[XeYf<X:Z[WsYz8X_Y]%XmQ(!7BXIZFX]&YE3F$(1XgYgYE& +[+W!<YMYFXc;+PXCYI9YrWxGXY9DY[!GXiI7::)OC;*$.>N*HA@{C|}&k=:<TB83X`3YL+G4XiK]i}(fYK<=5$.FYE%4*5*H*6XkCYL=*6Xi6!Yi1KXR4YHXbC8Xj,B9ZbWx/XbYON#5B}Ue}+QKXnF1&YV5XmYQ0!*3IXBYb71?1B75XmF;0B976;H/RXU:YZX;BG-NXj;XjI>A#D3B636N;,*%<D:0;YRXY973H5)-4FXOYf0:0;/7759774;7;:/855:543L43<?6=E,.A4:C=L)%4YV!1(YE/4YF+ F3%;S;&JC:%/?YEXJ4GXf/YS-EXEYW,9;E}X$}547EXiK=51-?71C%?57;5>463553Zg90;6447?<>4:9.7538XgN{|!}9K/E&3-:D+YE1)YE/3;37/:05}n<}:UX8Yj4Yt864@JYK..G=.(A Q3%6K>3(P3#AYE$-6H/456*C=.XHY[#S.<780191;057C)=6HXj?955B:K1 E>-B/9,;5.!L?:0>/.@//:;7833YZ56<4:YE=/:7Z_WGC%3I6>XkC*&NA16X=Yz2$X:Y^&J48<99k8}CyB-61<18K946YO4{|N}E)YIB9K0L>4=46<1K0+R;6-=1883:478;4,S+3YJX`GJXh.Yp+Xm6MXcYpX(>7Yo,/:X=Z;Xi0YTYHXjYmXiXj;*;I-8S6N#XgY}.3XfYGO3C/$XjL$*NYX,1 6;YH&<XkK9C#I74.>}Hd`A748X[T450[n75<4439:18A107>|ET}Rf<1;14876/Yb983E<5.YNXd4149>,S=/4E/<306443G/06}0&}UkYSXFYF=44=-5095=88;63844,9E6644{PL}WA8:>)7+>763>>0/B3A545CCnT}Xm|dv}Xq1L/YNXk/H8;;.R63351YY747@15YE4J8;46;.38.>4A369.=-83,;Ye3?:3@YE.4-+N353;/;@(X[YYD>@/05-I*@.:551741Yf5>6A443<3535;.58/86=D4753442$635D1>0359NQ @73:3:>><Xn?;43C14 ?Y|X611YG1&<+,4<*,YLXl<1/AIXjF*N89A4Z576K1XbJ5YF.ZOWN.YGXO/YQ01:4G38Xl1;KI0YFXB=R<7;D/,/4>;$I,YGXm94@O35Yz66695385.>:6A#5}W7n^4336:4157597434433<3|XA}m`>=D>:4A.337370?-6Q96{`E|4A}C`|Qs{Mk|J+~r>|o,wHv>Vw}!c{H!|Gb|*Ca5}J||,U{t+{CN[!M65YXOY_*B,Y[Z9XaX[QYJYLXPYuZ%XcZ8LY[SYPYKZM<LMYG9OYqSQYM~[e{UJXmQYyZM_)>YjN1~[f3{aXFY|Yk:48YdH^NZ0|T){jVFYTZNFY^YTYN~[h{nPYMYn3I]`EYUYsYIZEYJ7Yw)YnXPQYH+Z.ZAZY]^Z1Y`YSZFZyGYHXLYG 8Yd#4~[i|+)YH9D?Y^F~Y7|-eYxZ^WHYdYfZQ~[j|3>~[k|3oYmYqY^XYYO=Z*4[]Z/OYLXhZ1YLZIXgYIHYEYK,<Y`YEXIGZI[3YOYcB4SZ!YHZ*&Y{Xi3~[l|JSY`Zz?Z,~[m|O=Yi>??XnYWXmYS617YVYIHZ(Z4[~L4/=~[n|Yu{P)|];YOHHZ}~[o33|a>~[r|aE]DH~[s|e$Zz~[t|kZFY~XhYXZB[`Y}~[u|{SZ&OYkYQYuZ2Zf8D~[v}% ~[w3},Q[X]+YGYeYPIS~[y}4aZ!YN^!6PZ*~[z}?E~[{3}CnZ=~[}}EdDZz/9A3(3S<,YR8.D=*XgYPYcXN3Z5 4)~[~}JW=$Yu.XX~] }KDX`PXdZ4XfYpTJLY[F5]X~[2Yp}U+DZJ::<446[m@~]#3}]1~]%}^LZwZQ5Z`/OT<Yh^ -~]&}jx[ ~m<z!%2+~ly4VY-~o>}p62yz!%2+Xf2+~ly4VY-zQ`z (=] 2z~o2",C={" ":0,"!":1},c=34,i=2,p,s="",u=String.fromCharCode,t=u(12539);while(++c<127)C[u(c)]=c^39&&c^92?i++:0;i=0;while(0<=(c=C[a.charAt(i++)]))if(16==c)if((c=C[a.charAt(i++)])<87){if(86==c)c=1879;while(c--)s+=u(++p)}else s+=s.substr(8272,360);else if(c<86)s+=u(p+=c<51?c-16:(c-55)*92+C[a.charAt(i++)]);else if((c=((c-86)*92+C[a.charAt(i++)])*92+C[a.charAt(i++)])<49152)s+=u(p=c<40960?c:c|57344);else{c&=511;while(c--)s+=t;p=12539}return s')();

var JCT8836 = JCT11280.substring(0, 8836);

exports.EscapeSJIS = EscapeSJIS;
exports.UnescapeSJIS = UnescapeSJIS;
exports.EscapeEUCJP = EscapeEUCJP;
exports.UnescapeEUCJP = UnescapeEUCJP;
exports.EscapeJIS7 = EscapeJIS7;
exports.UnescapeJIS7 = UnescapeJIS7;
exports.EscapeJIS8 = EscapeJIS8;
exports.UnescapeJIS8 = UnescapeJIS8;
exports.EscapeUnicode = EscapeUnicode;
exports.UnescapeUnicode = UnescapeUnicode;
exports.EscapeUTF7 = EscapeUTF7;
exports.UnescapeUTF7 = UnescapeUTF7;
exports.EscapeUTF8 = EscapeUTF8;
exports.UnescapeUTF8 = UnescapeUTF8;
exports.EscapeUTF16LE = EscapeUTF16LE;
exports.UnescapeUTF16LE = UnescapeUTF16LE;
exports.GetEscapeCodeType = GetEscapeCodeType;
exports.JCT11280 = JCT11280;
exports.JCT8836 = JCT8836;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MMDNode = __webpack_require__(1);

var _MMDNode2 = _interopRequireDefault(_MMDNode);

var _MMDReader2 = __webpack_require__(2);

var _MMDReader3 = _interopRequireDefault(_MMDReader2);

var _MMDSceneSource = __webpack_require__(3);

var _MMDSceneSource2 = _interopRequireDefault(_MMDSceneSource);

var _MMDCameraNode = __webpack_require__(8);

var _MMDCameraNode2 = _interopRequireDefault(_MMDCameraNode);

var _jscenekit = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @access private
 */
var MMDVMDInfo =
/**
 * @access public
 * @constructor
 * @param {MMDPMMReader} reader -
 */
function MMDVMDInfo(reader) {
  _classCallCheck(this, MMDVMDInfo);

  this.frameNo = reader.readUnsignedInt();
  this.prev = reader.readUnsignedInt();
  this.next = reader.readUnsignedInt();

  var interpolation = [];
  for (var i = 0; i < 16; i++) {
    interpolation.push(reader.readUnsignedByte() / 127.0);
  }

  this.posX = reader.readFloat();
  this.posY = reader.readFloat();
  this.posZ = -reader.readFloat();
  var quat = new _jscenekit.SCNVector4(-reader.readFloat(), -reader.readFloat(), reader.readFloat(), reader.readFloat());
  this.rotate = quat.normalize();

  this.timingX = _jscenekit.CAMediaTimingFunction.functionWithControlPoints(interpolation[0], interpolation[1], interpolation[2], interpolation[3]);
  this.timingY = _jscenekit.CAMediaTimingFunction.functionWithControlPoints(interpolation[4], interpolation[5], interpolation[6], interpolation[7]);
  this.timingZ = _jscenekit.CAMediaTimingFunction.functionWithControlPoints(interpolation[8], interpolation[9], interpolation[10], interpolation[11]);
  this.timingRot = _jscenekit.CAMediaTimingFunction.functionWithControlPoints(interpolation[12], interpolation[13], interpolation[14], interpolation[15]);

  if (reader.version > 1) {
    reader.skip(1); // unknown
  }

  var isSelected = reader.readUnsignedByte();
};

/**
 * @access private
 */


var MMDVMDFaceInfo =
/**
 * @access public
 * @constructor
 * @param {MMDPMMReader} reader -
 */
function MMDVMDFaceInfo(reader) {
  _classCallCheck(this, MMDVMDFaceInfo);

  this.frameNo = reader.readUnsignedInt();
  this.prev = reader.readUnsignedInt();
  this.next = reader.readUnsignedInt();

  this.weight = reader.readFloat();

  var selected = reader.readUnsignedByte();
};

/**
 * @access private
 */


var MMDVMDCameraInfo =
/**
 * @access public
 * @constructor
 * @param {MMDPMMReader} reader -
 */
function MMDVMDCameraInfo(reader) {
  _classCallCheck(this, MMDVMDCameraInfo);

  this.frameNo = reader.readUnsignedInt();
  this.prev = reader.readUnsignedInt();
  this.next = reader.readUnsignedInt();

  this.distance = -reader.readFloat();
  this.posX = reader.readFloat();
  this.posY = reader.readFloat();
  this.posZ = reader.readFloat();
  this.rotX = reader.readFloat();
  this.rotY = reader.readFloat();
  this.rotZ = reader.readFloat();

  var followModelIndex = -1;
  var followBoneIndex = 0;

  if (reader.version > 1) {
    followModelIndex = reader.readInt();
    followBoneIndex = reader.readUnsignedInt();
  }

  if (followModelIndex >= 0) {
    //const model = reader.models[followModelIndex]
  }

  var interpolation = [];
  for (var i = 0; i < 24; i++) {
    interpolation.push(reader.readUnsignedByte() / 127.0);
  }

  this.timingX = _jscenekit.CAMediaTimingFunction.functionWithControlPoints(interpolation[0], interpolation[1], interpolation[2], interpolation[3]);
  this.timingY = _jscenekit.CAMediaTimingFunction.functionWithControlPoints(interpolation[4], interpolation[5], interpolation[6], interpolation[7]);
  this.timingZ = _jscenekit.CAMediaTimingFunction.functionWithControlPoints(interpolation[8], interpolation[9], interpolation[10], interpolation[11]);
  this.timingRot = _jscenekit.CAMediaTimingFunction.functionWithControlPoints(interpolation[12], interpolation[13], interpolation[14], interpolation[15]);
  this.timingDistance = _jscenekit.CAMediaTimingFunction.functionWithControlPoints(interpolation[16], interpolation[17], interpolation[18], interpolation[19]);
  this.timingAngle = _jscenekit.CAMediaTimingFunction.functionWithControlPoints(interpolation[20], interpolation[21], interpolation[22], interpolation[23]);

  var perspective = reader.readUnsignedByte();
  this.useOrtho = perspective !== 0;
  this.angle = reader.readInt();

  var isSelected = reader.readUnsignedByte();
};

/**
 * @access private
 */


var MMDVMDLightInfo =
/**
 * @access public
 * @constructor
 * @param {MMDPMMReader} reader -
 */
function MMDVMDLightInfo(reader) {
  _classCallCheck(this, MMDVMDLightInfo);

  this.frameNo = reader.readUnsignedInt();
  this.prev = reader.readUnsignedInt();
  this.next = reader.readUnsignedInt();

  var color = new _jscenekit.SKColor(reader.readFloat(), reader.readFloat(), reader.readFloat(), 1.0);
  this.color = color;

  var rotX = -reader.readFloat();
  var rotY = -reader.readFloat();
  var rotZ = reader.readFloat();

  var cosX = Math.cos(rotX / 2);
  var cosY = Math.cos(rotY / 2);
  var cosZ = Math.cos(rotZ / 2);
  var sinX = Math.sin(rotX / 2);
  var sinY = Math.sin(rotY / 2);
  var sinZ = Math.sin(rotZ / 2);

  var quat = new _jscenekit.SCNVector4();
  quat.x = sinX * cosY * cosZ + cosX * sinY * sinZ;
  quat.y = cosX * sinY * cosZ - cosX * cosY * sinZ;
  quat.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
  quat.w = cosX * cosY * cosZ + sinX * sinY * sinZ;

  this.direction = quat.normalize();

  var isSelected = reader.readUnsignedByte();
};

/**
 * @access private
 */


var MMDVMDAccessoryInfo =
/**
 * @access public
 * @constructor
 * @param {MMDPMMReader} reader -
 */
function MMDVMDAccessoryInfo(reader) {
  _classCallCheck(this, MMDVMDAccessoryInfo);

  this.frameNo = reader.readUnsignedInt();
  this.prev = reader.readUnsignedInt();
  this.next = reader.readUnsignedInt();

  var visibility = reader.readUnsignedByte();
  var isVisible = visibility & 0x01;
  var opacity = (100 - (visibility >> 1)) * 0.01;

  this.isHidden = isVisible === 0;
  this.opacity = opacity;

  var modelIndex = reader.readUnsignedInt();
  if (modelIndex === 0xFFFFFFFF) {
    modelIndex = -1;
  }
  var boneIndex = reader.readUnsignedInt();

  var parentNode = null;
  if (modelIndex >= 0 && modelIndex < reader.models.length) {
    var parentModel = reader.models[modelIndex];

    if (boneIndex < parentModel.boneArray.length) {
      var boneName = parentModel.boneArray[boneIndex].name;
      if (boneName === null) {
        throw new Error('bone.name === null');
      }
      parentNode = parentModel.childNodeWithNameRecursively(boneName, true);
      if (parentNode === null) {
        throw new Error('parentNode === null');
      }
    }
  }
  this.parent = parentNode;

  var pos = new _jscenekit.SCNVector3(reader.readFloat(), reader.readFloat(), reader.readFloat());
  this.position = pos;

  var rotX = -reader.readFloat();
  var rotY = -reader.readFloat();
  var rotZ = reader.readFloat();

  var cosX = Math.cos(rotX / 2);
  var cosY = Math.cos(rotY / 2);
  var cosZ = Math.cos(rotZ / 2);
  var sinX = Math.sin(rotX / 2);
  var sinY = Math.sin(rotY / 2);
  var sinZ = Math.sin(rotZ / 2);

  var quat = new _jscenekit.SCNVector4();
  quat.x = sinX * cosY * cosZ + cosX * sinY * sinZ;
  quat.y = cosX * sinY * cosZ - cosX * cosY * sinZ;
  quat.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
  quat.w = cosX * cosY * cosZ + sinX * sinY * sinZ;

  this.rotation = quat.normalize();
  var scale = reader.readFloat() * 10.0;
  this.scale = new _jscenekit.SCNVector3(scale, scale, scale);

  var flag = reader.readUnsignedByte();
  if ((flag & 0x01) === 0) {
    this.additive = _jscenekit.SCNBlendMode.add;
  } else {
    this.additive = _jscenekit.SCNBlendMode.alpha;
  }
  var isSelected = reader.readUnsignedByte();

  console.log('=====');
  console.log('frameNo: ' + this.frameNo);
  console.log('prev: ' + this.prev);
  console.log('next: ' + this.next);
  console.log('visibility: ' + visibility);
  console.log('modelIndex: ' + modelIndex);
  console.log('boneIndex: ' + boneIndex);
};

var _userFilePathPattern = new RegExp(/\\UserFile\\(.*)$/);

/**
 *
 * @access public
 * @extends {MMDReader}
 */

var MMDPMMReader = function (_MMDReader) {
  _inherits(MMDPMMReader, _MMDReader);

  /**
   *
   * @access public
   * @constructor
   * @param {Buffer} data -
   * @param {string} directoryPath -
   */
  function MMDPMMReader(data, directoryPath) {
    _classCallCheck(this, MMDPMMReader);

    var isBinary = true;
    var isBigEndian = false;
    var encoding = 'sjis';

    /** @type {MMDScene} */
    var _this = _possibleConstructorReturn(this, (MMDPMMReader.__proto__ || Object.getPrototypeOf(MMDPMMReader)).call(this, data, directoryPath, isBinary, isBigEndian, encoding));

    _this._workingNode = null;

    // header
    _this._pmmMagic = '';
    _this.version = 0.0;

    _this.fps = 30.0;

    _this._boneCount = 0;
    _this._boneNameArray = null;

    _this._faceCount = 0;
    _this._faceNameArray = null;

    _this._ikCount = 0;
    _this._ikIndexArray = null;

    _this._parentCount = 0;

    _this._accessoryCount = 0;
    _this._accessoryNameCount = null;
    _this._accessories = [];

    _this._modelCount = 0;
    _this.models = [];
    _this._workingModel = null;
    _this._motions = [];

    _this._substituteModels = null;

    // for animation
    _this._frameLength = 0;
    _this._workingAnimationGroup = null;
    _this._animationHash = null;
    _this._faceAnimationHash = null;

    _this._initialBoneFrame = null;
    _this._boneFrameHash = null;
    _this._initialFaceFrame = null;
    _this._faceFrameHash = null;

    // for accessory animation
    _this._initialAccessoryFrame = null;
    _this._accessoryFrameHash = null;
    _this._accessoryMotions = [];

    // for camera animation
    _this._workingCameraAnimationGroup = null;
    _this._initialCameraFrame = null;
    _this._cameraFrameHash = null;

    // for light animation
    _this._workingLightAnimationGroup = null;
    _this._initialLightFrame = null;
    _this._lightFrameHash = null;
    return _this;
  }

  /**
   * @access public
   * @param {Buffer} data -
   * @param {string} directoryPath -
   * @param {MMDNode[]} [models = null] -
   * @param {CAAnimation[]} [motions = null] -
   * @returns {SCNScene} -
   */


  _createClass(MMDPMMReader, [{
    key: 'loadPMMFile',


    /**
     * @access private
     * @param {MMDNode[]} [models = null] -
     * @param {CAAnimation[]} [motions = null] -
     * @returns {?SCNScene} -
     */
    value: function loadPMMFile() {
      var _this2 = this;

      var models = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var motions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      // initialize working variables
      this._workingScene = new _jscenekit.SCNScene();
      this._workingScene._dataLoadedPromise = new Promise(function (resolve, reject) {
        _this2._resolveFunction = resolve;
        _this2._rejectFunction = reject;
      });

      this._pmmMagic = '';
      this.version = 0;

      this._substituteModels = models;
      if (this._substituteModels === null) {
        this._substituteModels = [];
      }

      // read contents of the file
      this._readPMMHeader();
      if (this.version !== 1 && this.version !== 2) {
        // unknown file format
        console.error('unknown file format: ' + this._pmmMagic);
        return null;
      }

      this._readModels().then(function () {
        _this2._readCameras();
        _this2._readLights();
        return _this2._readAccessories();
      }).then(function () {
        _this2._readSettings();

        _this2._setupScene();

        _this2._resolveFunction();
      });

      return this._workingScene;
    }

    /**
     * read PMD header data
     * @access private
     */

  }, {
    key: '_readPMMHeader',
    value: function _readPMMHeader() {
      this._pmmMagic = this.readString(30);

      if (this._pmmMagic === 'Polygon Movie maker 0001') {
        this.version = 1;
      } else if (this._pmmMagic === 'Polygon Movie maker 0002') {
        this.version = 2;
      }

      var movieWidth = this.readInt();
      var movieHeight = this.readInt();
      var frameWindowWidth = this.readInt();
      var viewAngle = this.readFloat();
      var isCameraMode = this.readUnsignedByte();

      this.skip(6); // skip unknown bytes

      if (this.version === 2) {
        this.skip(1); // unknown data
      }
    }

    /**
     * @access private
     */

  }, {
    key: '_readModels',
    value: function _readModels() {
      var _this3 = this;

      this._modelCount = this.readUnsignedByte();

      if (this.version === 1) {
        for (var i = 0; i < this._modelCount; i++) {
          var modelName = this.readString(20);
          console.log('modelName: ' + modelName);
        }
      }

      if (this._modelCount > this._substituteModels.length) {
        for (var _i = 0; _i < this._modelCount - this._substituteModels.length; _i++) {
          this._substituteModels.push(null);
        }
      }

      var prevPromise = Promise.resolve();

      var _loop = function _loop(modelNo) {
        prevPromise = prevPromise.then(function () {
          if (_this3._substituteModels[modelNo]) {
            var model = _this3._substituteModels[modelNo];

            // just skip data
            _this3.skip(1);
            if (_this3.version === 1) {
              _this3.skip(20);
            } else {
              var a = _this3._readPascalString();
              var b = _this3._readPascalString();
            }
            _this3.skip(257);
            return model;
          }

          var no = _this3.readUnsignedByte();
          if (_this3.version === 1) {
            var _modelName = _this3.readString(20);
          } else {
            var _modelName2 = _this3._readPascalString();
            var englishName = _this3._readPascalString();
          }

          var filePath = _this3.readString(256);
          _this3.skip(1); // unknown flag

          var paths = filePath.match(_userFilePathPattern);
          if (paths) {
            var replaced = paths[1].replace(/\\/g, '/');
            filePath = _this3.directoryPath + '/' + replaced;
          } else {
            filePath = filePath.replace(/\\/g, '/');
          }

          var modelSceneSource = _MMDSceneSource2.default.sceneSourceWithURLOptions(filePath);
          return modelSceneSource.didLoad.then(function () {
            var newModel = modelSceneSource.getModel();
            return newModel.didLoad.then(function () {
              return newModel;
            }).catch(function (error) {
              console.error('cannot get model data: ' + filePath + ': ' + error);
              return Promise.reject(error);
            });
          }).catch(function (error) {
            console.error('cannot read file: ' + filePath + ': ' + error);
            return Promise.reject(error);
          });
        }).then(function (model) {
          _this3._workingModel = model;

          if (_this3.version === 1) {
            _this3._boneCount = model.boneArray.length - 1;
            _this3._boneNameArray = [];

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = model.boneArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var bone = _step.value;

                _this3._boneNameArray.push(bone.name);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            _this3._faceCount = model.geometryMorpher.targets.length;
            _this3._faceNameArray = [];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = model.geometryMorpher.targets[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var face = _step2.value;

                _this3._faceNameArray.push(face.name);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            _this3._ikCount = model.ikArray.length;
            _this3._ikIndexArray = [];
            // TODO: set ikIndexArray

            _this3._parentCount = 0;
          } else {
            _this3._readBone();
            _this3._readFace();
            _this3._readIK();
            _this3._readParent();

            _this3.skip(1); // unknown flag
          }

          var visible = _this3.readUnsignedByte();
          var selectedBone = _this3.readUnsignedInt();
          var morph_eyebrows = _this3.readUnsignedInt();
          var morph_eyes = _this3.readUnsignedInt();
          var morph_lips = _this3.readUnsignedInt();
          var morph_etc = _this3.readUnsignedInt();

          var frameCount = _this3.readUnsignedByte();
          for (var _i2 = 0; _i2 < frameCount; _i2++) {
            _this3.readUnsignedByte();
          }

          _this3.skip(4); // unknown data

          // read motions
          var lastFrame = _this3.readUnsignedInt();

          _this3._workingAnimationGroup = new _jscenekit.CAAnimationGroup();
          _this3._workingAnimationGroup.animations = [];

          _this3._animationHash = {};
          _this3._faceAnimationHash = {};

          _this3._frameLength = 0;

          _this3._readBoneFrames();
          _this3._readFaceFrames();
          _this3._readIKFrames();

          _this3._createAnimations();

          _this3._readBoneStatus();
          _this3._readFaceStatus();
          _this3._readIKStatus();
          _this3._readParentStatus();

          if (_this3.version > 1) {
            _this3.skip(7); // unknown data
          }

          _this3.models.push(model);
        });
      };

      for (var modelNo = 0; modelNo < this._modelCount; modelNo++) {
        _loop(modelNo);
      }
      return prevPromise;
    }
  }, {
    key: '_readBone',
    value: function _readBone() {
      this._boneCount = this.readUnsignedInt();

      this._boneNameArray = [];
      for (var i = 0; i < this._boneCount; i++) {
        this._boneNameArray.push(this._readPascalString());
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this._boneNameArray[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var boneName = _step3.value;

          console.log('    bone: ' + boneName);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: '_readFace',
    value: function _readFace() {
      this._faceCount = this.readUnsignedInt();
      this._faceNameArray = [];
      for (var i = 0; i < this._faceCount; i++) {
        this._faceNameArray.push(this._readPascalString());
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._faceNameArray[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var faceName = _step4.value;

          console.log('    face: ' + faceName);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }, {
    key: '_readIK',
    value: function _readIK() {
      this._ikCount = this.readUnsignedInt();
      this._ikIndexArray = [];
      for (var i = 0; i < this._ikCount; i++) {
        this._ikIndexArray.push(this.readUnsignedInt());
      }
    }
  }, {
    key: '_readParent',
    value: function _readParent() {
      this._parentCount = this.readUnsignedInt();
      for (var i = 0; i < this._parentCount; i++) {
        this.readUnsignedInt();
      }
    }

    // MARK: - Bone Frame

  }, {
    key: '_readBoneFrames',
    value: function _readBoneFrames() {
      this._initialBoneFrame = [];
      this._boneFrameHash = {};

      for (var i = 0; i < this._boneCount; i++) {
        this._readOneBoneFrame(false);
      }

      var boneFrameCount = this.readUnsignedInt();
      for (var _i3 = 0; _i3 < boneFrameCount; _i3++) {
        this._readOneBoneFrame();
      }

      // create animation data
      for (var index = 0; index < this._boneCount; index++) {
        var boneName = this._boneNameArray[index];

        console.log('===== bone animation: ' + boneName + ' =====');

        var posXMotion = new _jscenekit.CAKeyframeAnimation('/' + boneName + '.transform.translation.x');
        var posYMotion = new _jscenekit.CAKeyframeAnimation('/' + boneName + '.transform.translation.y');
        var posZMotion = new _jscenekit.CAKeyframeAnimation('/' + boneName + '.transform.translation.z');
        var rotMotion = new _jscenekit.CAKeyframeAnimation('/' + boneName + '.transform.quaternion');

        posXMotion.values = [];
        posYMotion.values = [];
        posZMotion.values = [];
        rotMotion.values = [];

        posXMotion.keyTimes = [];
        posYMotion.keyTimes = [];
        posZMotion.keyTimes = [];
        rotMotion.keyTimes = [];

        posXMotion.timingFunctions = [];
        posYMotion.timingFunctions = [];
        posZMotion.timingFunctions = [];
        rotMotion.timingFunctions = [];

        this._animationHash['posX:' + boneName] = posXMotion;
        this._animationHash['posY:' + boneName] = posYMotion;
        this._animationHash['posZ:' + boneName] = posZMotion;
        this._animationHash['rot:' + boneName] = rotMotion;

        this._addMotionRecursive(this._initialBoneFrame[index], posXMotion, posYMotion, posZMotion, rotMotion);
      }
    }

    /**
     * @access private
     * @param {MMDVMDInfo} info -
     * @param {CAKeyframeAnimation} posXMotion -
     * @param {CAKeyframeAnimation} posYMotion -
     * @param {CAKeyframeAnimation} posZMotion -
     * @param {CAKeyframeAnimation} rotMotion -
     * @returns {void}
     */

  }, {
    key: '_addMotionRecursive',
    value: function _addMotionRecursive(info, posXMotion, posYMotion, posZMotion, rotMotion) {
      var motion = info;
      while (motion) {
        var frameIndex = posXMotion.keyTimes.length - 1;

        // the frame number mihgt not be sorted
        while (frameIndex >= 0) {
          var k = posXMotion.keyTimes[frameIndex];
          if (k < motion.frameNo) {
            break;
          }

          frameIndex -= 1;
        }
        frameIndex += 1;

        if (motion.frameNo > this._frameLength) {
          this._frameLength = motion.frameNo;
        }

        posXMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        posYMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        posZMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        rotMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);

        posXMotion.timingFunctions.splice(frameIndex, 0, motion.timingX);
        posYMotion.timingFunctions.splice(frameIndex, 0, motion.timingY);
        posZMotion.timingFunctions.splice(frameIndex, 0, motion.timingZ);
        rotMotion.timingFunctions.splice(frameIndex, 0, motion.timingRot);

        posXMotion.values.splice(frameIndex, 0, motion.posX);
        posYMotion.values.splice(frameIndex, 0, motion.posY);
        posZMotion.values.splice(frameIndex, 0, motion.posZ);
        rotMotion.values.splice(frameIndex, 0, motion.rotate);

        console.log('frameNo: ' + motion.frameNo);
        console.log('pos: ' + motion.posX + ', ' + motion.posY + ', ' + motion.posZ);
        console.log('rot: ' + motion.rotate);

        if (motion.next <= 0) {
          break;
        }

        var _motion = this._boneFrameHash[motion.next];
        if (!_motion) {
          console.error('error: the frame index(' + motion.next + ') does not exist');
        }
        motion = _motion;
      }
    }

    /**
     * @access private
     * @param {boolean} [hasIndex = true] -
     * @returns {void}
     */

  }, {
    key: '_readOneBoneFrame',
    value: function _readOneBoneFrame() {
      var hasIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var index = 0;
      if (hasIndex) {
        index = this.readUnsignedInt();
      }

      var vmdInfo = new MMDVMDInfo(this);
      if (hasIndex) {
        this._boneFrameHash[index] = vmdInfo;
      } else {
        this._initialBoneFrame.push(vmdInfo);
      }
    }

    // MARK: - Face Frame

  }, {
    key: '_readFaceFrames',
    value: function _readFaceFrames() {
      this._initialFaceFrame = [];
      this._faceFrameHash = {};

      console.log('faceCount: ' + this._faceCount);
      for (var i = 0; i < this._faceCount; i++) {
        this._readOneFaceFrame(false);
      }
      var faceFrameCount = this.readUnsignedInt();
      console.log('faceFrameCount: ' + faceFrameCount);
      for (var _i4 = 0; _i4 < faceFrameCount; _i4++) {
        this._readOneFaceFrame();
      }

      // create animation data
      for (var index = 0; index < this._faceCount; index++) {
        var faceName = this._faceNameArray[index];

        var faceMotion = new _jscenekit.CAKeyframeAnimation('morpher.weights.' + faceName);
        faceMotion.values = [];
        faceMotion.keyTimes = [];
        faceMotion.timingFunctions = [];

        this._faceAnimationHash[faceName] = faceMotion;

        this._addFaceMotionRecursive(this._initialFaceFrame[index], faceMotion);
      }
    }

    /**
     * @access private
     * @param {boolean} [hasIndex = true] -
     * @returns {void}
     */

  }, {
    key: '_readOneFaceFrame',
    value: function _readOneFaceFrame() {
      var hasIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var index = 0;
      if (hasIndex) {
        index = this.readUnsignedInt();
      }
      var faceInfo = new MMDVMDFaceInfo(this);
      if (hasIndex) {
        this._faceFrameHash[index] = faceInfo;
      } else {
        this._initialFaceFrame.push(faceInfo);
      }
    }

    /**
     * @access private
     * @param {MMDVMDFaceInfo} info -
     * @param {CAKeyframeAnimation} faceMotion -
     * @returns {void}
     */

  }, {
    key: '_addFaceMotionRecursive',
    value: function _addFaceMotionRecursive(info, faceMotion) {
      var motion = info;
      while (motion) {
        var frameIndex = faceMotion.keyTimes.length - 1;

        // the frame number might not be sorted.
        while (frameIndex >= 0) {
          var k = faceMotion.keyTimes[frameIndex];
          if (k < motion.frameNo) {
            break;
          }
          frameIndex -= 1;
        }
        frameIndex += 1;

        if (motion.frameNo > this._frameLength) {
          this._frameLength = motion.frameNo;
        }
        var timingFunc = _jscenekit.CAMediaTimingFunction.functionWithName(_jscenekit.kCAMediaTimingFunctionLinear);

        faceMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        faceMotion.timingFunctions.splice(frameIndex, 0, timingFunc);
        faceMotion.values.splice(frameIndex, 0, motion.weight);

        if (motion.next <= 0) {
          break;
        }

        var _motion = this._faceFrameHash[motion.next];
        if (!_motion) {
          console.error('error: the face frame index(' + motion.next + ') does not exist.');
        }
        motion = _motion;
      }
    }

    // MARK: - IK Frame

  }, {
    key: '_readIKFrames',
    value: function _readIKFrames() {
      this._readOneIKFrame(false);

      var boneIKCount = this.readUnsignedInt();
      for (var i = 0; i < boneIKCount; i++) {
        this._readOneIKFrame();
      }
    }

    /**
     * @access private
     * @param {boolean} [hasIndex = true] -
     * @returns {void}
     */

  }, {
    key: '_readOneIKFrame',
    value: function _readOneIKFrame() {
      var hasIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var index = 0;
      if (hasIndex) {
        index = this.readUnsignedInt();
      }
      var frameNo = this.readUnsignedInt();
      var prev = this.readUnsignedInt();
      var next = this.readUnsignedInt();

      var isVisible = this.readUnsignedByte();
      for (var i = 0; i < this._ikCount; i++) {
        var isEnable = this.readUnsignedByte();
      }

      // If the version is 1.0, parentCount is 0.
      for (var _i5 = 0; _i5 < this._parentCount; _i5++) {
        var modelIndex = this.readUnsignedInt();
        var boneIndex = this.readUnsignedInt();
      }

      var isSelected = this.readUnsignedByte();
    }

    // MARK: - Create Animation

  }, {
    key: '_createAnimations',
    value: function _createAnimations() {
      var duration = this._frameLength / this.fps;

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = Object.keys(this._animationHash)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var name = _step5.value;

          var motion = this._animationHash[name];
          var motionLength = motion.keyTimes[motion.keyTimes.length - 1];

          for (var num = 0; num < motion.keyTimes.length; num++) {
            var keyTime = motion.keyTimes[num] / motionLength;
            motion.keyTimes[num] = keyTime;
          }

          motion.duration = motionLength / this.fps;
          motion.usesSceneTimeBase = false;
          motion.isRemovedOnCompletion = false;
          motion.fillMode = _jscenekit.kCAFillModeForwards;

          if (motion.keyTimes.length === 1) {
            motion.repeatCount = Infinity;
          }

          this._workingAnimationGroup.animations.push(motion);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = Object.keys(this._faceAnimationHash)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _name = _step6.value;

          var _motion2 = this._faceAnimationHash[_name];
          var _motionLength = _motion2.keyTimes[_motion2.keyTimes.length - 1];

          for (var _num = 0; _num < _motion2.keyTimes.length; _num++) {
            var _keyTime = _motion2.keyTimes[_num] / _motionLength;
            _motion2.keyTimes[_num] = _keyTime;
          }

          _motion2.duration = _motionLength / this.fps;
          _motion2.usesSceneTimeBase = false;
          _motion2.isRemovedOnCompletion = false;
          _motion2.fillMode = _jscenekit.kCAFillModeForwards;

          this._workingAnimationGroup.animations.push(_motion2);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      this._workingAnimationGroup.duration = duration;
      this._workingAnimationGroup.usesSceneTimeBase = false;
      this._workingAnimationGroup.isRemovedOnCompletion = false;
      this._workingAnimationGroup.fillMode = _jscenekit.kCAFillModeForwards;

      this._motions.push(this._workingAnimationGroup);
    }
  }, {
    key: '_readBoneStatus',
    value: function _readBoneStatus() {
      // float3 translation
      // float4 rotation
      // bool isMoving?
      // bool enabledPhysics?
      // bool isSelected

      // just ignore data
      if (this.version === 1) {
        this.skip(34 * this._boneCount);
      } else {
        this.skip(31 * this._boneCount);
      }
    }
  }, {
    key: '_readFaceStatus',
    value: function _readFaceStatus() {
      // float skinValue

      // just ignore data
      this.skip(4 * this._faceCount);
    }
  }, {
    key: '_readIKStatus',
    value: function _readIKStatus() {
      // bool isIsEnable
      this.skip(this._ikCount);
    }
  }, {
    key: '_readParentStatus',
    value: function _readParentStatus() {
      // int4 parentStatus
      this.skip(16 * this._parentCount);
    }

    // MARK: - Camera Frame

  }, {
    key: '_readCameras',
    value: function _readCameras() {
      this._workingCameraAnimationGroup = new _jscenekit.CAAnimationGroup();
      this._workingCameraAnimationGroup.animations = [];
      this._cameraFrameHash = {};

      this._frameLength = 0;

      this._readOneCameraFrame(false);

      var cameraFrameCount = this.readUnsignedInt();
      for (var i = 0; i < cameraFrameCount; i++) {
        this._readOneCameraFrame();
      }

      this._createCameraAnimation();

      this._readCameraStatus();
    }

    /**
     * @access private
     * @param {boolean} [hasIndex = true] -
     * @returns {void}
     */

  }, {
    key: '_readOneCameraFrame',
    value: function _readOneCameraFrame() {
      var hasIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var index = -1;
      if (hasIndex) {
        index = this.readUnsignedInt();
      }
      var cameraInfo = new MMDVMDCameraInfo(this);
      if (hasIndex) {
        this._cameraFrameHash[index] = cameraInfo;
      } else {
        this._initialCameraFrame = cameraInfo;
      }
    }

    /**
     * @access private
     * @param {MMDVMDCameraInfo} info -
     * @param {CAKeyframeAnimation} distanceMotion -
     * @param {CAKeyframeAnimation} posXMotion -
     * @param {CAKeyframeAnimation} posYMotion -
     * @param {CAKeyframeAnimation} posZMotion -
     * @param {CAKeyframeAnimation} rotXMotion -
     * @param {CAKeyframeAnimation} rotYMotion -
     * @param {CAKeyframeAnimation} rotZMotion -
     * @param {CAKeyframeAnimation} angleMotion -
     * @param {CAKeyframeAnimation} persMotion -
     * @returns {void}
     */

  }, {
    key: '_addCameraMotionRecursive',
    value: function _addCameraMotionRecursive(info, distanceMotion, posXMotion, posYMotion, posZMotion, rotXMotion, rotYMotion, rotZMotion, angleMotion, persMotion) {

      var motion = info;
      while (motion) {
        var frameIndex = distanceMotion.keyTimes.length - 1;

        // the frame number might not be sorted.
        while (frameIndex >= 0) {
          var k = distanceMotion.keyTimes[frameIndex];
          if (k < motion.frameNo) {
            break;
          }

          frameIndex -= 1;
        }
        frameIndex += 1;

        if (motion.frameNo > this.frameLength) {
          this._frameLength = motion.frameNo;
        }
        console.log('camera frameNo: ' + motion.frameNo);

        distanceMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        posXMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        posYMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        posZMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        rotXMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        rotYMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        rotZMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        angleMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        persMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);

        distanceMotion.timingFunctions.splice(frameIndex, 0, motion.timingDistance);
        posXMotion.timingFunctions.splice(frameIndex, 0, motion.timingX);
        posYMotion.timingFunctions.splice(frameIndex, 0, motion.timingY);
        posZMotion.timingFunctions.splice(frameIndex, 0, motion.timingZ);
        rotXMotion.timingFunctions.splice(frameIndex, 0, motion.timingRot);
        rotYMotion.timingFunctions.splice(frameIndex, 0, motion.timingRot);
        rotZMotion.timingFunctions.splice(frameIndex, 0, motion.timingRot);
        angleMotion.timingFunctions.splice(frameIndex, 0, motion.timingAngle);

        distanceMotion.values.splice(frameIndex, 0, motion.distance);
        posXMotion.values.splice(frameIndex, 0, motion.posX);
        posYMotion.values.splice(frameIndex, 0, motion.posY);
        posZMotion.values.splice(frameIndex, 0, motion.posZ);
        rotXMotion.values.splice(frameIndex, 0, motion.rotX);
        rotYMotion.values.splice(frameIndex, 0, motion.rotY);
        rotZMotion.values.splice(frameIndex, 0, motion.rotZ);
        angleMotion.values.splice(frameIndex, 0, motion.angle);
        persMotion.values.splice(frameIndex, 0, motion.useOrtho);

        if (motion.next <= 0) {
          break;
        }

        var _motion = this._cameraFrameHash[motion.next];
        if (!_motion) {
          console.error('error: the camera frame index(' + motion.next + ') does not exist.');
        }
        motion = _motion;
      }
    }
  }, {
    key: '_createCameraAnimation',
    value: function _createCameraAnimation() {
      var distanceMotion = new _jscenekit.CAKeyframeAnimation('/' + _MMDCameraNode.MMD_CAMERA_NODE_NAME + '.translation.z');
      var posXMotion = new _jscenekit.CAKeyframeAnimation('transform.translation.x');
      var posYMotion = new _jscenekit.CAKeyframeAnimation('transform.translation.y');
      var posZMotion = new _jscenekit.CAKeyframeAnimation('transform.translation.z');
      var rotZMotion = new _jscenekit.CAKeyframeAnimation('/' + _MMDCameraNode.MMD_CAMERA_ROTZ_NODE_NAME + '.eulerAngles.z');
      var rotXMotion = new _jscenekit.CAKeyframeAnimation('/' + _MMDCameraNode.MMD_CAMERA_ROTX_NODE_NAME + '.eulerAngles.x');
      var rotYMotion = new _jscenekit.CAKeyframeAnimation('eulerAngles.y');
      var angleMotion = new _jscenekit.CAKeyframeAnimation('/' + _MMDCameraNode.MMD_CAMERA_NODE_NAME + '.camera.yFov');
      var persMotion = new _jscenekit.CAKeyframeAnimation('/' + _MMDCameraNode.MMD_CAMERA_NODE_NAME + '.camera.usesOrthographicProjection');

      distanceMotion.values = [];
      posXMotion.values = [];
      posYMotion.values = [];
      posZMotion.values = [];
      rotXMotion.values = [];
      rotYMotion.values = [];
      rotZMotion.values = [];
      angleMotion.values = [];
      persMotion.values = [];

      distanceMotion.keyTimes = [];
      posXMotion.keyTimes = [];
      posYMotion.keyTimes = [];
      posZMotion.keyTimes = [];
      rotXMotion.keyTimes = [];
      rotYMotion.keyTimes = [];
      rotZMotion.keyTimes = [];
      angleMotion.keyTimes = [];
      persMotion.keyTimes = [];

      distanceMotion.timingFunctions = [];
      posXMotion.timingFunctions = [];
      posYMotion.timingFunctions = [];
      posZMotion.timingFunctions = [];
      rotXMotion.timingFunctions = [];
      rotYMotion.timingFunctions = [];
      rotZMotion.timingFunctions = [];
      angleMotion.timingFunctions = [];
      //persMotion.timingFunctions = []

      this._frameLength = 0;
      this._addCameraMotionRecursive(this._initialCameraFrame, distanceMotion, posXMotion, posYMotion, posZMotion, rotXMotion, rotYMotion, rotZMotion, angleMotion, persMotion);

      var duration = this._frameLength / this.fps;

      var _arr = [distanceMotion, posXMotion, posYMotion, posZMotion, rotXMotion, rotYMotion, rotZMotion, angleMotion, persMotion];
      for (var _i6 = 0; _i6 < _arr.length; _i6++) {
        var motion = _arr[_i6];
        var motionLength = motion.keyTimes[motion.keyTimes.length - 1];
        motion.duration = motionLength / this.fps;
        motion.usesSceneTimeBase = false;
        motion.isRemovedOnCompletion = false;
        motion.fillMode = _jscenekit.kCAFillModeForwards;

        for (var num = 0; num < motion.keyTimes.length; num++) {
          var keyTime = motion.keyTimes[num] / motionLength;
          motion.keyTimes[num] = keyTime;
        }

        this._workingCameraAnimationGroup.animations.push(motion);
        this._workingCameraAnimationGroup.duration = duration;
        this._workingCameraAnimationGroup.usesSceneTimeBase = false;
        this._workingCameraAnimationGroup.isRemovedOnCompletion = false;
        this._workingCameraAnimationGroup.fillMode = _jscenekit.kCAFillModeForwards;
      }
    }
  }, {
    key: '_readCameraStatus',
    value: function _readCameraStatus() {
      // float3 pos
      // float3 lookat?
      // float3 rot
      // usesParse

      // just ignore data
      this.skip(37);
    }

    // MARK: - Light Frame

  }, {
    key: '_readLights',
    value: function _readLights() {
      this._workingLightAnimationGroup = new _jscenekit.CAAnimationGroup();
      this._workingLightAnimationGroup.animations = [];
      this._lightFrameHash = {};

      this._readOneLightFrame(false);

      var lightFrameCount = this.readUnsignedInt();
      for (var i = 0; i < lightFrameCount; i++) {
        this._readOneLightFrame();
      }

      this._createLightAnimation();

      this._readLightStatus();
    }

    /**
     * @access private
     * @param {boolean} [hasIndex = true] -
     * @returns {void}
     */

  }, {
    key: '_readOneLightFrame',
    value: function _readOneLightFrame() {
      var hasIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var index = -1;
      if (hasIndex) {
        index = this.readUnsignedInt();
      }

      var info = new MMDVMDLightInfo(this);
      if (hasIndex) {
        this._lightFrameHash[index] = info;
      } else {
        this._initialLightFrame = info;
      }
    }
  }, {
    key: '_createLightAnimation',
    value: function _createLightAnimation() {
      var colorMotion = new _jscenekit.CAKeyframeAnimation('light.color');
      var directionMotion = new _jscenekit.CAKeyframeAnimation('transform.quaternion');

      colorMotion.values = [];
      directionMotion.values = [];

      colorMotion.keyTimes = [];
      directionMotion.keyTimes = [];

      this._frameLength = 0;
      this._addLightMotionRecursive(this._initialLightFrame, colorMotion, directionMotion);

      var duration = this._frameLength / this.fps;

      var _arr2 = [colorMotion, directionMotion];
      for (var _i7 = 0; _i7 < _arr2.length; _i7++) {
        var motion = _arr2[_i7];
        motion.duration = duration;
        motion.usesSceneTimeBase = false;
        motion.isRemovedOnCompletion = false;
        motion.fillMode = _jscenekit.kCAFillModeForwards;

        for (var num = 0; num < motion.keyTimes.length; num++) {
          var keyTime = motion.keyTimes[num] / this._frameLength;
          motion.keyTimes[num] = keyTime;
        }

        this._workingLightAnimationGroup.animations.push(motion);
      }

      this._workingLightAnimationGroup.duration = duration;
      this._workingLightAnimationGroup.usesSceneTimeBase = false;
      this._workingLightAnimationGroup.isRemovedOnCompletion = false;
      this._workingLightAnimationGroup.fillMode = _jscenekit.kCAFillModeForwards;
    }

    /**
     * @access private
     * @param {MMDVMDLightInfo} info -
     * @param {CAKeyframeAnimation} colorMotion -
     * @param {CAKeyframeAnimation} directionMotion -
     * @returns {void}
     */

  }, {
    key: '_addLightMotionRecursive',
    value: function _addLightMotionRecursive(info, colorMotion, directionMotion) {
      var motion = info;
      while (motion) {
        var frameIndex = colorMotion.keyTimes.length - 1;

        // the frame number might not be sorted.
        while (frameIndex >= 0) {
          var k = colorMotion.keyTimes[frameIndex];
          if (k < motion.frameNo) {
            break;
          }

          frameIndex -= 1;
        }
        frameIndex += 1;

        if (motion.frameNo > this._frameLength) {
          this._frameLength = motion.frameNo;
        }

        colorMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        directionMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);

        colorMotion.values.splice(frameIndex, 0, motion.color);
        directionMotion.values.splice(frameIndex, 0, motion.direction);

        if (motion.next <= 0) {
          break;
        }

        var _motion = this._lightFrameHash[motion.next];
        if (!_motion) {
          console.error('error: the light frame index(' + motion.next + ') does not exist.');
        }
        motion = _motion;
      }
    }
  }, {
    key: '_readLightStatus',
    value: function _readLightStatus() {
      // float3 rgb
      // float3 pos
      // byte5 unknown

      // just ignore data
      this.skip(29);
    }

    // MARK: - Accessory Frame

  }, {
    key: '_readAccessories',
    value: function _readAccessories() {
      var _this4 = this;

      this._accessoryCount = this.readUnsignedByte();
      this._accessoryNameArray = [];

      for (var i = 0; i < this._accessoryCount; i++) {
        this._accessoryNameArray.push(this.readString(100));
      }
      for (var index = 0; index < this._accessoryCount; index++) {
        console.log('[' + index + ']: ' + this._accessoryNameArray[index]);
      }

      if (this._modelCount + this._accessoryCount > this._substituteModels.length) {
        var len = this._modelCount + this._accessoryCount - this._substituteModels.length;
        for (var _i8 = 0; _i8 < len; _i8++) {
          this._substituteModels.push(null);
        }
      }

      this._accessoryFrameHash = {};

      var prevPromise = Promise.resolve();

      var _loop2 = function _loop2(_index) {
        prevPromise = prevPromise.then(function () {
          //let accessory = new MMDNode()
          var m = _this4._substituteModels[_this4._modelCount + _index];
          if (m) {
            // just skip accessory data
            _this4.skip(358);

            return m;
          }

          var no = _this4.readUnsignedByte();
          var name = _this4.readString(100);
          var filePath = _this4.readString(256);

          //accessory.name = name

          var paths = filePath.match(_userFilePathPattern);
          if (paths) {
            var replaced = paths[1].replace(/\\/g, '/');
            filePath = _this4.directoryPath + '/' + replaced;
          } else {
            filePath = filePath.replace(/\\/g, '/');
          }

          if (!filePath) {
            var accessory = new _MMDNode2.default();
            accessory.name = name;
            return accessory;
          }

          var accessorySceneSource = _MMDSceneSource2.default.sceneSourceWithURLOptions(filePath);
          return accessorySceneSource.didLoad.then(function () {
            var newAccessory = accessorySceneSource.getModel();
            return newAccessory.didLoad.then(function () {
              return newAccessory;
            }).catch(function (error) {
              console.error('cannot get accessory data: ' + filePath);
              return Promise.reject(error);
            });
          }).catch(function (error) {
            console.error('cannot read file: ' + filePath);
            return Promise.reject(error);
          });
        }).then(function (accessory) {

          // set the default scale for accessory (x10)
          accessory.scale = new _jscenekit.SCNVector3Make(10.0, 10.0, 10.0);

          var accessoryIndex = _this4.readUnsignedByte();
          console.log('accessoryIndex: ' + accessoryIndex);

          _this4._readOneAccessoryFrame(false);

          var accessoryFrameCount = _this4.readUnsignedInt();
          console.log('accessoryFrameCount: ' + accessoryFrameCount);
          for (var _i9 = 0; _i9 < accessoryFrameCount; _i9++) {
            _this4._readOneAccessoryFrame();
          }

          _this4._createAccessoryAnimation();

          _this4._readAccessoryStatus();

          _this4._accessories.push(accessory);
        });
      };

      for (var _index = 0; _index < this._accessoryCount; _index++) {
        _loop2(_index);
      }
      return prevPromise;
    }

    /**
     * @access private
     * @param {boolean} [hasIndex = true] -
     * @returns {void}
     */

  }, {
    key: '_readOneAccessoryFrame',
    value: function _readOneAccessoryFrame() {
      var hasIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var index = 0;
      if (hasIndex) {
        index = this.readUnsignedInt();
      }

      var info = new MMDVMDAccessoryInfo(this);
      if (hasIndex) {
        this._accessoryFrameHash[index] = info;
      } else {
        this._initialAccessoryFrame = info;
      }
    }
  }, {
    key: '_createAccessoryAnimation',
    value: function _createAccessoryAnimation() {
      var animation = new _jscenekit.CAAnimationGroup();
      animation.animations = [];

      var posMotion = new _jscenekit.CAKeyframeAnimation('position');
      var rotMotion = new _jscenekit.CAKeyframeAnimation('transform.quaternion');
      var scaleMotion = new _jscenekit.CAKeyframeAnimation('scale');
      var hiddenMotion = new _jscenekit.CAKeyframeAnimation('hidden');
      var opacityMotion = new _jscenekit.CAKeyframeAnimation('opacity');
      var additiveMotion = new _jscenekit.CAKeyframeAnimation('/Geometry.materials.blendMode');
      var parentMotion = new _jscenekit.CAKeyframeAnimation('parent.motionParentNode');

      posMotion.values = [];
      rotMotion.values = [];
      scaleMotion.values = [];
      hiddenMotion.values = [];
      opacityMotion.values = [];
      additiveMotion.values = [];
      parentMotion.values = [];

      posMotion.keyTimes = [];
      rotMotion.keyTimes = [];
      scaleMotion.keyTimes = [];
      hiddenMotion.keyTimes = [];
      opacityMotion.keyTimes = [];
      additiveMotion.keyTimes = [];
      parentMotion.keyTimes = [];

      this._frameLength = 0;
      this._addAccessoryMotionRecursive(this._initialAccessoryFrame, posMotion, rotMotion, scaleMotion, hiddenMotion, opacityMotion, additiveMotion, parentMotion);

      var duration = this._frameLength / this.fps;

      var _arr3 = [posMotion, rotMotion, scaleMotion, hiddenMotion, opacityMotion, additiveMotion, parentMotion];
      for (var _i10 = 0; _i10 < _arr3.length; _i10++) {
        var motion = _arr3[_i10];
        motion.duration = duration;
        motion.usesSceneTimeBase = false;
        motion.isRemovedOnCompletion = false;
        motion.fillMode = _jscenekit.kCAFillModeForwards;

        for (var _num2 = 0; _num2 < motion.keyTimes.length; _num2++) {
          var _keyTime2 = motion.keyTimes[_num2] / this._frameLength;
          if (this._frameLength <= 0) {
            _keyTime2 = 0.0;
          }
          motion.keyTimes[_num2] = _keyTime2;
        }
      }
      hiddenMotion.calculationMode = _jscenekit.kCAAnimationDiscrete;
      additiveMotion.calculationMode = _jscenekit.kCAAnimationDiscrete;
      parentMotion.calculationMode = _jscenekit.kCAAnimationDiscrete;

      for (var num = 0; num < hiddenMotion.keyTimes.length; num++) {
        var keyTime = hiddenMotion.keyTimes[num];
        var value = hiddenMotion.values[num];
        console.log('isHidden @' + keyTime + ': ' + value);
      }

      animation.animations.push(posMotion);
      animation.animations.push(rotMotion);
      animation.animations.push(scaleMotion);
      animation.animations.push(hiddenMotion);
      animation.animations.push(opacityMotion);
      animation.duration = duration;
      animation.usesScaleTimeBase = false;
      animation.isRemovedOnCompletion = false;
      animation.fillMode = _jscenekit.kCAFillModeForwards;

      var parentEvents = [];
      var prevParent = null;

      var _loop3 = function _loop3(index) {
        var keyTime = parentMotion.keyTimes[index];
        var value = parentMotion.values[index];

        if (value) {
          var mmdParentNode = value;
          // TODO: implement for playingBackward
          var parentEvent = new _jscenekit.SCNAnimationEvent(keyTime, function (_animation, animatedObject, playingBackward) {
            var node = animatedObject;
            if (animatedObject) {
              if (playingBackward) {
                if (parent === prevParent) {
                  parent.addChildNode(node);
                }
              } else {
                value.addChildNode(node);
              }
            }
          });

          parentEvents.push(parentEvent);
          prevParent = mmdParentNode;
        }
      };

      for (var index = 0; index < parentMotion.keyTimes.length; index++) {
        _loop3(index);
      }

      var prevBlendMode = _jscenekit.SCNBlendMode.alpha;

      var _loop4 = function _loop4(index) {
        var keyTime = additiveMotion.keyTimes[index];
        var value = additiveMotion.values[index];

        var additiveEvent = new _jscenekit.SCNAnimationEvent(keyTime, function (_animation, animatedObject, playingBackward) {
          var geometry = animatedObject.childNodeWithNameRecursively('Geometry', true).geometry;
          if (geometry) {
            var blendMode = value;
            if (playingBackward) {
              blendMode = prevBlendMode;
            }
            //if(blendMode === SCNBlendMode.add){
            //  console.log('.add')
            //}else if(blendMode === SCNBlendMode.alpha){
            //  console.log('.alpha')
            //}
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = geometry.materials[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var material = _step7.value;

                material.blendMode = blendMode;
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                  _iterator7.return();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }
          }
        });
        parentEvents.push(additiveEvent);
        prevBlendMode = value;
      };

      for (var index = 0; index < additiveMotion.keyTimes.length; index++) {
        _loop4(index);
      }

      animation.animationEvents = parentEvents;

      this._accessoryMotions.push(animation);
    }

    /**
     * @access private
     * @param {MMDVMDAccessoryInfo} info -
     * @param {CAKeyframeAnimation} posMotion -
     * @param {CAKeyframeAnimation} rotMotion -
     * @param {CAKeyframeAnimation} scaleMotion -
     * @param {CAKeyframeAnimation} hiddenMotion -
     * @param {CAKeyframeAnimation} opacityMotion -
     * @param {CAKeyframeAnimation} additiveMotion -
     * @param {CAKeyframeAnimation} parentMotion -
     * @returns {void}
     */

  }, {
    key: '_addAccessoryMotionRecursive',
    value: function _addAccessoryMotionRecursive(info, posMotion, rotMotion, scaleMotion, hiddenMotion, opacityMotion, additiveMotion, parentMotion) {

      var motion = info;
      while (motion) {
        var frameIndex = posMotion.keyTimes.length - 1;

        // the frame number might not be sorted
        while (frameIndex >= 0) {
          var k = posMotion.keyTimes[frameIndex];
          if (k < motion.frameNo) {
            break;
          }
          frameIndex -= 1;
        }
        frameIndex += 1;

        if (motion.frameNo > this._frameLength) {
          this._frameLength = motion.frameNo;
        }

        posMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        rotMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        scaleMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        hiddenMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        opacityMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        additiveMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);
        parentMotion.keyTimes.splice(frameIndex, 0, motion.frameNo);

        posMotion.values.splice(frameIndex, 0, motion.position);
        rotMotion.values.splice(frameIndex, 0, motion.rotation);
        scaleMotion.values.splice(frameIndex, 0, motion.scale);
        hiddenMotion.values.splice(frameIndex, 0, motion.isHidden);
        opacityMotion.values.splice(frameIndex, 0, motion.opacity);
        additiveMotion.values.splice(frameIndex, 0, motion.additive);
        parentMotion.values.splice(frameIndex, 0, motion.parent);

        if (motion.next <= 0) {
          break;
        }

        var _motion = this._accessoryFrameHash[motion.next];
        if (!_motion) {
          console.error('error: the accessory frame index(' + motion.next + ') does not exist.');
        }
        motion = _motion;
      }
    }
  }, {
    key: '_readAccessoryStatus',
    value: function _readAccessoryStatus() {
      // byte opacity?
      // int modelIndex
      // int boneIndex
      // float3 pos
      // float scale
      // float3 rot
      // byte flag1?
      // byte flat2?

      this.skip(38);
      if (this.version >= 2) {
        this.skip(1);
      }
    }

    // MARK: - other settings

  }, {
    key: '_readSettings',
    value: function _readSettings() {
      var numObjects = this._modelCount + this._accessoryCount;

      var viewFlag = this.readUnsignedByte();

      // wav file
      var usesWav = this.readUnsignedByte();
      var wavPath = this.readString(256);

      // background movie
      var bgMoviePath = this.readString(256);
      var usesMovie = this.readUnsignedByte();

      // background image
      var bgImagePath = this.readString(256);
      var usesImage = this.readUnsignedByte();

      // misc.
      var showInfo = this.readUnsignedByte();
      var showGrid = this.readUnsignedByte();
      var shadow = this.readUnsignedByte();
      this.skip(3); // ?

      var screenCapture = this.readUnsignedByte();
      this.skip(7); // ?

      var shadowColor = this.readFloat(); // ?

      this.skip(numObjects);

      this.skip(4 * this._modelCount);

      this.skip(62); // ?

      var usesPhysics = this.readUnsignedByte();
      var gravity = this.readFloat();
      var noise = 0.0;
      if (this.version === 1) {
        noise = this.readFloat();
      }
      var gravityX = this.readFloat();
      var gravityY = this.readFloat();
      var gravityZ = this.readFloat();

      this.skip(24); // ?

      this.skip(this._modelCount);

      this.skip(5);
    }
  }, {
    key: '_setupScene',
    value: function _setupScene() {
      // camera
      var cameraNode = new _MMDCameraNode2.default();
      cameraNode.prepareAnimationForKey(this._workingCameraAnimationGroup, 'motion');
      cameraNode.playPreparedAnimationForKey('motion');
      cameraNode.getCamera().automaticallyAdjustsZRange = true;

      this._workingScene.rootNode.addChildNode(cameraNode);

      // light
      var lightNode = new _jscenekit.SCNNode();
      lightNode.light = new _jscenekit.SCNLight();
      lightNode.light.type = _jscenekit.SCNLight.LightType.directional;
      lightNode.light.castsShadow = true;
      lightNode.addAnimationForKey(this._workingLightAnimationGroup, 'motion');
      lightNode.name = 'MMDLight';

      this._workingScene.rootNode.addChildNode(lightNode);

      // model and motion
      for (var index = 0; index < this.models.count; index++) {
        var model = this.models[index];
        var motion = this._motions[index];

        model.prepareAnimationForKey(motion, 'motion');
        model.playPreparedAnimationForKey('motion');
        this._workingScene.rootNode.addChildNode(model);
      }

      // accessory
      for (var _index2 = 0; _index2 < this._accessories.length; _index2++) {
        var accessory = this._accessories[_index2];
        var _motion3 = this._accessoryMotions[_index2];

        accessory.prepareAnimationForKey(_motion3, 'motion');
        accessory.playPreparedAnimationForKey('motion');

        this._workingScene.rootNode.addChildNode(accessory);
      }
    }

    /**
     * @access private
     * @returns {string} -
     */

  }, {
    key: '_getPascalString',
    value: function _getPascalString() {
      var strlen = this.readUnsignedByte();
      var str = this.readString(strlen);
      if (str) {
        return str;
      }
      return '';
    }
  }], [{
    key: 'getScene',
    value: function getScene(data, directoryPath) {
      var models = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var motions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var reader = new MMDPMMReader(data, directoryPath);
      var scene = reader.loadPMMFile(models, motions);

      return scene;
    }
  }]);

  return MMDPMMReader;
}(_MMDReader3.default);

exports.default = MMDPMMReader;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MMDNode = __webpack_require__(1);

var _MMDNode2 = _interopRequireDefault(_MMDNode);

var _MMDProgram = __webpack_require__(5);

var _MMDProgram2 = _interopRequireDefault(_MMDProgram);

var _MMDReader2 = __webpack_require__(2);

var _MMDReader3 = _interopRequireDefault(_MMDReader2);

var _MMDIKConstraint = __webpack_require__(4);

var _MMDIKConstraint2 = _interopRequireDefault(_MMDIKConstraint);

var _MMDFragmentShader2 = __webpack_require__(6);

var _MMDFragmentShader3 = _interopRequireDefault(_MMDFragmentShader2);

var _jscenekit = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _BoneNodeTypes = [_MMDNode2.default.Type.rotate, _MMDNode2.default.Type.rotateTranslate, _MMDNode2.default.Type.ik, _MMDNode2.default.Type.unknown, _MMDNode2.default.Type.ikChild, _MMDNode2.default.Type.rotateChild, _MMDNode2.default.Type.hidden, _MMDNode2.default.Type.twist, _MMDNode2.default.Type.roll];

/**
 *
 * @access public
 * @extends {MMDReader}
 */

var MMDPMXReader = function (_MMDReader) {
  _inherits(MMDPMXReader, _MMDReader);

  /**
   *
   * @access public
   * @constructor
   * @param {Buffer} data -
   * @param {string} directoryPath -
   */
  function MMDPMXReader(data, directoryPath) {
    _classCallCheck(this, MMDPMXReader);

    console.log('MMDPMXReader constructor');
    var isBinary = true;
    var isBigEndian = false;
    var encoding = 'sjis';

    // initialize working variables
    var _this = _possibleConstructorReturn(this, (MMDPMXReader.__proto__ || Object.getPrototypeOf(MMDPMXReader)).call(this, data, directoryPath, isBinary, isBigEndian, encoding));

    _this._workingNode = null;

    // header info
    _this._pmxMagic = '';
    _this._version = 0.0;
    _this._encoding = '';

    _this._numUV = 0;
    _this._indexSize = 0;
    _this._textureIndexSize = 0;
    _this._materialIndexSize = 0;
    _this._boneIndexSize = 0;
    _this._morphIndexSize = 0;
    _this._physicsBodyIndexSize = 0;

    _this._modelName = '';
    _this._englishModelName = '';
    _this._comment = '';
    _this._englishComment = '';

    // vertex data
    _this._vertexCount = 0;
    _this._vertexArray = [];
    _this._normalArray = [];
    _this._texcoordArray = [];

    _this._boneIndicesArray = [];
    _this._boneWeightsArray = [];
    _this._edgeArray = [];

    // index data
    _this._indexCount = 0;
    _this._indexArray = [];

    // texture data
    _this._textureCount = 0;
    _this._texturePromiseArray = [];
    _this._textureArray = [];

    // material data
    _this._materialCount = 0;
    _this._materialArray = [];
    _this._materialShapeArray = [];
    _this._materialIndexCountArray = [];
    _this._separatedIndexArray = [];
    _this._shaderModifiers = {};

    // bone data
    _this._boneCount = 0;
    _this._rootBone = new _MMDNode2.default();
    _this._boneArray = [];
    _this._boneInverseMatrixArray = [];

    // morphing data
    _this._faceCount = 0;
    _this._faceNameArray = [];
    _this._faceVertexArray = [];

    // data sources
    _this._vertexSource = null;
    _this._normalSource = null;
    _this._texcoordSource = null;
    _this._elementArray = [];

    // physics body
    _this._physicsBoneArray = [];
    _this._physicsBodyArray = [];
    return _this;
  }

  /**
   * @access public
   * @param {} data -
   * @param {string} directoryPath -
   * @returns {MMDNode} -
   */


  _createClass(MMDPMXReader, [{
    key: '_loadPMXFile',


    /**
     * @access private
     * @returns {MMDNode} -
     */
    value: function _loadPMXFile() {
      this._workingNode = new _MMDNode2.default();

      // read contents of file
      this._readPMXHeader();
      if (this._pmxMagic !== 'PMX ') {
        throw new Error('PMX file magic error: ' + this._pmxMagic);
      }

      // load shader modifiers
      this._shaderModifiers[_jscenekit.SCNShaderModifierEntryPoint.fragment] = _MMDFragmentShader3.default;

      // read basic data
      this._readVertex();
      this._readIndex();
      this._readTexture();
      this._readMaterial();
      this._readBone();
      this._readFace();
      this._readDisplayInfo();

      // create geometry for shader
      this._createGeometry();
      this._createFaceMorph();

      this._readPhysicsBody();
      this._readConstraint();

      if (this._version > 2.0) {
        this._readSoftBody();
      }

      return this._workingNode;
    }

    /**
     * @access private
     * @returns {string} -
     */

  }, {
    key: '_readPascalString',
    value: function _readPascalString() {
      var strlen = this.readUnsignedInt();
      return this.readString(strlen, this._encoding);
    }

    /**
     * read PMX header data
     * @access private
     * @returns {void}
     */

  }, {
    key: '_readPMXHeader',
    value: function _readPMXHeader() {
      this._pmxMagic = this.readString(4);
      this._version = this.readFloat();

      var numData = this.readUnsignedByte();
      if (numData !== 8) {
        throw new Error('unknown header data size: ' + numData);
      }

      var encodingNo = this.readUnsignedByte();
      switch (encodingNo) {
        case 0:
          this._encoding = 'utf16le';
          break;
        case 1:
          this._encoding = 'utf8';
          break;
        default:
          throw new Error('unknown encoding number: ' + encodingNo);
      }

      this._numUV = this.readUnsignedByte();
      this._indexSize = this.readUnsignedByte();
      this._textureIndexSize = this.readUnsignedByte();
      this._materialIndexSize = this.readUnsignedByte();
      this._boneIndexSize = this.readUnsignedByte();
      this._morphIndexSize = this.readUnsignedByte();
      this._physicsBodyIndexSize = this.readUnsignedByte();

      this._modelName = this._readPascalString();
      this._englishModelName = this._readPascalString();
      this._comment = this._readPascalString();
      this._englishComment = this._readPascalString();

      console.log('modelName: ' + this._modelName);
    }

    /**
     * read PMX vertex data
     * @access private
     * @returns {void}
     */

  }, {
    key: '_readVertex',
    value: function _readVertex() {
      var vertexCount = this.readInt();
      this._vertexCount = vertexCount;

      var noBone = 0;
      switch (this._boneIndexSize) {
        case 1:
          noBone = 0xFF;
          break;
        case 2:
          noBone = 0xFFFF;
          break;
        case 4:
          noBone = 0xFFFFFFFF;
          break;
        default:
          throw new Error('unknown bone index size: ' + this._boneIndexSize);
      }

      for (var i = 0; i < vertexCount; i++) {
        this._vertexArray.push(this.readFloat());
        this._vertexArray.push(this.readFloat());
        this._vertexArray.push(-this.readFloat());

        this._normalArray.push(this.readFloat());
        this._normalArray.push(this.readFloat());
        this._normalArray.push(-this.readFloat());

        this._texcoordArray.push(this.readFloat());
        this._texcoordArray.push(this.readFloat());

        for (var j = 0; j < this._numUV; j++) {
          // FIXME: use additional UV
          this.readFloat();
          this.readFloat();
          this.readFloat();
          this.readFloat();
        }

        var weightType = this.readUnsignedByte();
        var weight1 = 0.0;
        var weight2 = 0.0;
        var weight3 = 0.0;
        var weight4 = 0.0;
        var boneNo1 = 0;
        var boneNo2 = 0;
        var boneNo3 = 0;
        var boneNo4 = 0;

        switch (weightType) {
          case 0:
            // BDEF1
            boneNo1 = this.readInteger(this._boneIndexSize);
            weight1 = 1.0;
            break;
          case 1:
            // BDEF2
            boneNo1 = this.readInteger(this._boneIndexSize);
            boneNo2 = this.readInteger(this._boneIndexSize);
            weight1 = this.readFloat();
            weight2 = 1.0 - weight1;
            break;
          case 2:
            // BDEF4
            boneNo1 = this.readInteger(this._boneIndexSize);
            boneNo2 = this.readInteger(this._boneIndexSize);
            boneNo3 = this.readInteger(this._boneIndexSize);
            boneNo4 = this.readInteger(this._boneIndexSize);
            weight1 = this.readFloat();
            weight2 = this.readFloat();
            weight3 = this.readFloat();
            weight4 = this.readFloat();
            break;
          case 3:
            // SDEF
            boneNo1 = this.readInteger(this._boneIndexSize);
            boneNo2 = this.readInteger(this._boneIndexSize);
            weight1 = this.readFloat();
            weight2 = 1.0 - weight1;

            // FIXME: use SDEF-C
            this.readFloat();
            this.readFloat();
            this.readFloat();

            // FIXME: use SDEF-R0
            this.readFloat();
            this.readFloat();
            this.readFloat();

            // FIXME: use SDEF-R1
            this.readFloat();
            this.readFloat();
            this.readFloat();
            break;
          case 4:
            // QDEF
            boneNo1 = this.readInteger(this._boneIndexSize);
            boneNo2 = this.readInteger(this._boneIndexSize);
            boneNo3 = this.readInteger(this._boneIndexSize);
            boneNo4 = this.readInteger(this._boneIndexSize);
            weight1 = this.readFloat();
            weight2 = this.readFloat();
            weight3 = this.readFloat();
            weight4 = this.readFloat();
            break;
          default:
            throw new Error('unknown skin weight type: ' + weightType);
        }

        if (boneNo1 === noBone) {
          boneNo1 = 0;
          weight1 = 0;
        }
        if (boneNo2 === noBone) {
          boneNo2 = 0;
          weight2 = 0;
        }
        if (boneNo3 === noBone) {
          boneNo3 = 0;
          weight3 = 0;
        }
        if (boneNo4 === noBone) {
          boneNo4 = 0;
          weight4 = 0;
        }

        //console.log(`boneIndex ${i} ${boneNo1}:${weight1} ${boneNo2}:${weight2} ${boneNo3}:${weight3} ${boneNo4}:${weight4}`)

        // the first weight must not be 0 in SceneKit...
        if (weight1 === 0.0) {
          if (weight2 !== 0.0) {
            this._boneIndicesArray.push(boneNo2);
            this._boneIndicesArray.push(boneNo1);
            this._boneIndicesArray.push(boneNo3);
            this._boneIndicesArray.push(boneNo4);

            this._boneWeightsArray.push(weight2);
            this._boneWeightsArray.push(weight1);
            this._boneWeightsArray.push(weight3);
            this._boneWeightsArray.push(weight4);
          } else if (weight3 !== 0.0) {
            this._boneIndicesArray.push(boneNo3);
            this._boneIndicesArray.push(boneNo1);
            this._boneIndicesArray.push(boneNo2);
            this._boneIndicesArray.push(boneNo4);

            this._boneWeightsArray.push(weight3);
            this._boneWeightsArray.push(weight1);
            this._boneWeightsArray.push(weight2);
            this._boneWeightsArray.push(weight4);
          } else if (weight4 !== 0.0) {
            this._boneIndicesArray.push(boneNo4);
            this._boneIndicesArray.push(boneNo1);
            this._boneIndicesArray.push(boneNo2);
            this._boneIndicesArray.push(boneNo3);

            this._boneWeightsArray.push(weight4);
            this._boneWeightsArray.push(weight1);
            this._boneWeightsArray.push(weight2);
            this._boneWeightsArray.push(weight3);
          } else {
            throw new Error('bad data definition: all bone weights are 0.');
          }
        } else {
          this._boneIndicesArray.push(boneNo1);
          this._boneIndicesArray.push(boneNo2);
          this._boneIndicesArray.push(boneNo3);
          this._boneIndicesArray.push(boneNo4);

          this._boneWeightsArray.push(weight1);
          this._boneWeightsArray.push(weight2);
          this._boneWeightsArray.push(weight3);
          this._boneWeightsArray.push(weight4);
        }

        this._edgeArray.push(this.readFloat());
      }
    }

    /**
     * read PMX index data
     * @access private
     * @returns {void}
     */

  }, {
    key: '_readIndex',
    value: function _readIndex() {
      var indexCount = this.readUnsignedInt();
      this._indexCount = indexCount;
      console.log('indexCount: ' + indexCount);

      for (var i = 0; i < indexCount; i++) {
        this._indexArray.push(this.readInteger(this._indexSize));
      }
    }

    /**
     * read PMX texture data
     * @access private
     * @returns {void}
     */

  }, {
    key: '_readTexture',
    value: function _readTexture() {
      var _this2 = this;

      var textureCount = this.readUnsignedInt();
      this._textureCount = textureCount;

      var _loop = function _loop(i) {
        var textureFile = _this2._readPascalString();
        var index = _this2._texturePromiseArray.length;
        _this2._texturePromiseArray.push(_this2.loadTexture(textureFile).then(function (texture) {
          _this2._textureArray[index] = texture;
        }));
      };

      for (var i = 0; i < textureCount; i++) {
        _loop(i);
      }
    }

    /**
     * read PMX material data
     * @access private
     * @returns {void}
     */

  }, {
    key: '_readMaterial',
    value: function _readMaterial() {
      var _this3 = this;

      var materialCount = this.readUnsignedInt();
      this._materialCount = materialCount;

      var indexPos = 0;

      var _loop2 = function _loop2(i) {
        var material = new _jscenekit.SCNMaterial();
        material.name = _this3._readPascalString();

        var englishName = _this3._readPascalString();

        material.diffuse.contents = new _jscenekit.SKColor(_this3.readFloat(), _this3.readFloat(), _this3.readFloat(), _this3.readFloat());
        material.specular.contents = new _jscenekit.SKColor(_this3.readFloat(), _this3.readFloat(), _this3.readFloat(), 1.0);
        material.shininess = _this3.readFloat();
        material.ambient.contents = new _jscenekit.SKColor(0, 0, 0, 1);
        material.emission.contents = new _jscenekit.SKColor(_this3.readFloat(), _this3.readFloat(), _this3.readFloat(), 1.0);

        var bitFlag = _this3.readUnsignedByte();
        var edgeColor = new _jscenekit.SKColor(_this3.readFloat(), _this3.readFloat(), _this3.readFloat(), _this3.readFloat());

        var noCulling = (bitFlag & 0x01) !== 0;
        var floorShadow = (bitFlag & 0x02) !== 0;
        var shadowMap = (bitFlag & 0x04) !== 0;
        var selfShadow = (bitFlag & 0x08) !== 0;
        var drawEdge = (bitFlag & 0x10) !== 0;
        var vertexColor = (bitFlag & 0x20) !== 0;
        var drawPoint = (bitFlag & 0x40) !== 0;
        var drawLine = (bitFlag & 0x80) !== 0;

        var edgeSize = _this3.readFloat();
        var textureNo = _this3.readInteger(_this3._textureIndexSize);
        var sphereTextureNo = _this3.readInteger(_this3._textureIndexSize);
        var sphereMode = _this3.readUnsignedByte();
        var toonFlag = _this3.readUnsignedByte();
        var toonTextureNo = 0;

        if (textureNo < _this3._texturePromiseArray.length) {
          material.multiply._loadedPromise = _this3._texturePromiseArray[textureNo].then(function () {
            material.multiply.contents = _this3._textureArray[textureNo];
            material.multiply.wrapS = _jscenekit.SCNWrapMode.repeat;
            material.multiply.wrapT = _jscenekit.SCNWrapMode.repeat;
            console.warn('material.diffuse promise resolve');
          });
          material.setValueForKey(1.0, 'useTexture');
        } else {
          material.setValueForKey(0.0, 'useTexture');
        }

        if (sphereTextureNo < _this3._texturePromiseArray.length) {
          _this3._texturePromiseArray[sphereTextureNo].then(function () {
            var prop = new _jscenekit.SCNMaterialProperty(_this3._textureArray[sphereTextureNo]);
            material.setValueForKey(prop, 'sphereTexture');
          });
        }
        if (sphereMode === 0) {
          // disabled
          material.setValueForKey(0.0, 'useSphereMap');
          material.setValueForKey(0.0, 'spadd');
          material.setValueForKey(0.0, 'useSubtexture');
        } else if (sphereMode === 1) {
          // sph
          material.setValueForKey(1.0, 'useSphereMap');
          material.setValueForKey(0.0, 'spadd');
          material.setValueForKey(0.0, 'useSubtexture');
        } else if (sphereMode === 2) {
          // spa
          material.setValueForKey(1.0, 'useSphereMap');
          material.setValueForKey(1.0, 'spadd');
          material.setValueForKey(0.0, 'useSubtexture');
        } else if (sphereMode === 3) {
          // subtexture
          material.setValueForKey(0.0, 'useSphereMap');
          material.setValueForKey(0.0, 'spadd');
          material.setValueForKey(1.0, 'useSubtexture');
        } else {
          throw new Error('unknown sphereMode: ' + sphereMode);
        }

        if (toonFlag === 0) {
          toonTextureNo = _this3.readInteger(_this3._textureIndexSize);
          if (toonTextureNo < _this3._texturePromiseArray.length) {
            material.transparent._loadedPromise = _this3._texturePromiseArray[toonTextureNo].then(function () {
              material.transparent.contents = _this3._textureArray[toonTextureNo];
            });
            material.setValueForKey(1.0, 'useToon');
          } else {
            material.setValueForKey(0.0, 'useToon');
          }
        } else if (toonFlag === 1) {
          toonTextureNo = _this3.readUnsignedByte();
          material.transparent.contents = _MMDReader3.default.toonTextures[toonTextureNo];
          material.setValueForKey(1.0, 'useToon');
        } else {
          throw new Error('unknown toon flag: ' + toonFlag);
        }

        if (noCulling) {
          material.isDoubleSided = true;
        } else {
          material.isDoubleSided = false;
        }

        // FIXME: use floorShadow, shadowMap property
        // FIXME: use drawEdge property
        // FIXME: use vertexColor

        var shape = _jscenekit.SCNGeometryPrimitiveType.triangles;
        if (drawPoint) {
          shape = _jscenekit.SCNGeometryPrimitiveType.point;
        } else if (drawLine) {
          shape = _jscenekit.SCNGeometryPrimitiveType.line;
        }

        _this3._materialShapeArray.push(shape);

        var text = _this3._readPascalString();
        var materialIndexCount = _this3.readUnsignedInt();

        // create index data
        var orgArray = _this3._indexArray.slice(indexPos, indexPos + materialIndexCount);
        var newArray = [];
        indexPos += materialIndexCount;
        console.log('indexPos: ' + text + ' ' + indexPos);

        var arrayPos = 0;
        var newIndexCount = 0;
        if (shape === _jscenekit.SCNGeometryPrimitiveType.point) {
          while (arrayPos < materialIndexCount) {
            var index1 = orgArray[arrayPos + 0];
            var index2 = orgArray[arrayPos + 1];
            var index3 = orgArray[arrayPos + 2];

            if (index1 === index2 && index2 === index3) {
              newArray.push(index1);
              newIndexCount += 1;
            } else {
              newArray.push(index1);
              newArray.push(index2);
              newArray.push(index3);
              newIndexCount += 3;
            }
            arrayPos += 3;
          }
        } else if (shape === _jscenekit.SCNGeometryPrimitiveType.line) {
          while (arrayPos < materialIndexCount) {
            var _index = orgArray[arrayPos + 0];
            var _index2 = orgArray[arrayPos + 1];
            var _index3 = orgArray[arrayPos + 2];

            if (_index === _index3) {
              newArray.push(_index);
              newArray.push(_index2);
              newIndexCount += 1;
            } else {
              newArray.push(_index);
              newArray.push(_index2);

              newArray.push(_index2);
              newArray.push(_index3);

              newArray.push(_index3);
              newArray.push(_index);

              newIndexCount += 3;
            }
            arrayPos += 3;
          }
        } else if (shape === _jscenekit.SCNGeometryPrimitiveType.triangles) {
          while (arrayPos < materialIndexCount) {
            var _index4 = orgArray[arrayPos + 0];
            var _index5 = orgArray[arrayPos + 1];
            var _index6 = orgArray[arrayPos + 2];

            newArray.push(_index4);
            newArray.push(_index6);
            newArray.push(_index5);

            newIndexCount += 1;
            arrayPos += 3;
          }
        }

        material.shaderModifiers = _this3._shaderModifiers;

        _this3._materialIndexCountArray.push(newIndexCount);
        _this3._materialArray.push(material);
        _this3._separatedIndexArray.push(newArray);
      };

      for (var i = 0; i < materialCount; i++) {
        _loop2(i);
      }
    }

    /**
     * read PMX bone data
     * @access private
     * @returns {void}
     */

  }, {
    key: '_readBone',
    value: function _readBone() {
      var bonePositionArray = [];
      var parentNoArray = [];

      var boneCount = this.readUnsignedInt();
      this._boneCount = boneCount;
      this._rootBone.position = new _jscenekit.SCNVector3(0, 0, 0);
      this._rootBone.name = 'rootBone';

      this._workingNode.ikArray = [];

      for (var i = 0; i < boneCount; i++) {
        var boneNode = new _MMDNode2.default();
        this._boneArray.push(boneNode);
      }

      for (var _i = 0; _i < boneCount; _i++) {
        var _boneNode = this._boneArray[_i];
        _boneNode.name = this._readPascalString();
        var englishName = this._readPascalString();

        if (_boneNode.name.startsWith('右ひざ') || _boneNode.name.startsWith('左ひざ')) {
          _boneNode.isKnee = true;
        }

        var x = this.readFloat();
        var y = this.readFloat();
        var z = -this.readFloat();

        var position = new _jscenekit.SCNVector3(x, y, z);
        bonePositionArray.push(position);

        parentNoArray.push(this.readInteger(this._boneIndexSize));
        var level = this.readInt();
        var flags = this.readUnsignedShort();

        var hasChildBoneIndex = (flags & 0x0001) !== 0;
        var isRotatable = (flags & 0x0002) !== 0;
        var isMovable = (flags & 0x0004) !== 0;
        var isVisible = (flags & 0x0008) !== 0;
        var isControllable = (flags & 0x0010) !== 0;
        var isIKBone = (flags & 0x0020) !== 0;
        // 0x0040: ?
        var isLocalValue = (flags & 0x0080) !== 0;
        var hasRotationValue = (flags & 0x0100) !== 0;
        var hasTranslationValue = (flags & 0x0200) !== 0;
        var hasFixAxis = (flags & 0x0400) !== 0;
        var hasLocalAxis = (flags & 0x0800) !== 0;
        var isDeformable = (flags & 0x1000) !== 0;
        var hasDeformableParent = (flags & 0x2000) !== 0;

        if (hasChildBoneIndex) {
          var childBoneNo = this.readInteger(this._boneIndexSize);
        } else {
          this.readFloat();
          this.readFloat();
          this.readFloat();
        }

        if (hasRotationValue || hasTranslationValue) {
          var boneIndex = this.readInteger(this._boneIndexSize);
          var rate = this.readFloat();
          var bone = this._boneArray[boneIndex];
          console.log('   rotation/translation: [' + boneIndex + '] ' + bone.name + ' ' + rate);

          if (hasRotationValue) {
            _boneNode.rotateEffector = bone;
            _boneNode.rotateEffectRate = rate;
          }
          if (hasTranslationValue) {
            _boneNode.translateEffector = bone;
            _boneNode.translateEffectRate = rate;
          }
        }

        if (hasFixAxis) {
          var _x = this.readFloat();
          var _y = this.readFloat();
          var _z = this.readFloat();
        }

        if (hasLocalAxis) {
          var xAxisX = this.readFloat();
          var xAxisY = this.readFloat();
          var xAxisZ = this.readFloat();

          var zAxisX = this.readFloat();
          var zAxisY = this.readFloat();
          var zAxisZ = this.readFloat();
        }

        if (hasDeformableParent) {
          var parentBoneKey = this.readInt();
        }

        if (isIKBone) {
          var ik = new _MMDIKConstraint2.default();

          var targetBoneNo = this.readInteger(this._boneIndexSize);
          var targetBone = this._boneArray[targetBoneNo];

          var iteration = this.readInt();
          var weight = this.readFloat();
          var numLink = this.readInt();

          ik.ikBone = _boneNode;
          ik.targetBone = targetBone;
          ik.iteration = iteration;
          ik.weight = weight * 0.25 * Math.PI;
          ik.boneArray = [];

          console.log('targetBoneNo: ' + targetBoneNo + ' ' + targetBone.name + ' ikBone: ' + ik.ikBone.name);

          var linkBoneNoArray = [];
          for (var j = 0; j < numLink; j++) {
            var linkNo = this.readUnsignedShort();
            var _bone = this._boneArray[linkNo];

            var limitFlag = this.readUnsignedByte();
            if (limitFlag === 1) {
              // TODO: constraint
              var minX = this.readFloat();
              var minY = this.readFloat();
              var minZ = this.readFloat();
              var maxX = this.readFloat();
              var maxY = this.readFloat();
              var maxZ = this.readFloat();
            }

            ik.boneArray.push(_bone);
          }

          this._workingNode.ikArray.push(ik);
        }
      }

      // set parent node
      var noParent = 0;
      if (this._boneIndexSize === 1) {
        noParent = 0xFF;
      } else if (this._boneIndexSize === 2) {
        noParent = 0xFFFF;
      } else if (this._boneIndexSize === 4) {
        noParent = 0xFFFFFFFF;
      }

      for (var _i2 = 0; _i2 < this._boneCount; _i2++) {
        var _bone2 = this._boneArray[_i2];
        var parentNo = parentNoArray[_i2];
        var bonePos = bonePositionArray[_i2];

        if (parentNo !== noParent) {
          this._boneArray[parentNo].addChildNode(_bone2);

          var parentPos = bonePositionArray[parentNo];
          _bone2._position.x = bonePos.x - parentPos.x;
          _bone2._position.y = bonePos.y - parentPos.y;
          _bone2._position.z = bonePos.z - parentPos.z;
        } else {
          this._rootBone.addChildNode(_bone2);
          _bone2._position = bonePos;
        }
      }

      // calc initial matrix
      for (var _i3 = 0; _i3 < this._boneCount; _i3++) {
        var _bonePos = bonePositionArray[_i3];
        var matrix = _jscenekit.SCNMatrix4.matrixWithTranslation(-_bonePos.x, -_bonePos.y, -_bonePos.z);
        this._boneInverseMatrixArray.push(matrix);
      }

      this._boneArray.push(this._rootBone);
      this._boneInverseMatrixArray.push(_jscenekit.SCNMatrix4.matrixWithTranslation(0, 0, 0));

      this._workingNode.addChildNode(this._rootBone);
    }

    /**
     * read PMX face data
     * @access private
     * @returns {void}
     */

  }, {
    key: '_readFace',
    value: function _readFace() {
      var faceCount = this.readUnsignedInt();
      this._faceCount = faceCount;

      for (var i = 0; i < faceCount; i++) {
        var name = this._readPascalString();
        var englishName = this._readPascalString();
        var panelNo = this.readUnsignedByte();
        var type = this.readUnsignedByte();
        var offsetCount = this.readInt();

        switch (type) {
          case 0:
            // group morph
            this._readGroupMorph(offsetCount);
            break;
          case 1:
            // vertex morph
            this._readVertexMorph(offsetCount);
            this._faceNameArray.push(name);
            break;
          case 2:
            // bone morph
            this._readBoneMorph(offsetCount);
            break;
          case 3:
            // UV morph
            this._readUVMorph(offsetCount, 0);
            break;
          case 4:
            // additional UV - 1
            this._readUVMorph(offsetCount, 1);
            break;
          case 5:
            // additional UV - 2
            this._readUVMorph(offsetCount, 2);
            break;
          case 6:
            // additional UV - 3
            this._readUVMorph(offsetCount, 3);
            break;
          case 7:
            // additional UV - 4
            this._readUVMorph(offsetCount, 4);
            break;
          case 8:
            // material morph
            this._readMaterialMorph(offsetCount);
            break;
          case 9:
            // flip morph
            this._readFlipMorph(offsetCount);
            break;
          case 10:
            // impulse morph
            this._readImpulseMorph(offsetCount);
            break;
          default:
            // unknown type
            throw new Error('unknown face type: ' + type);
        }
      }
    }

    /**
     * read PMX vertex morphing data
     * @access private
     * @param {number} count -
     * @returns {void}
     */

  }, {
    key: '_readVertexMorph',
    value: function _readVertexMorph(count) {
      var faceVertex = [];

      for (var i = 0; i < count; i++) {
        var _index7 = this.readInteger(this._indexSize);
        var vertexIndex = _index7 * 3;

        var x = this.readFloat();
        var y = this.readFloat();
        var z = -this.readFloat();

        faceVertex[vertexIndex + 0] = x;
        faceVertex[vertexIndex + 1] = y;
        faceVertex[vertexIndex + 2] = z;
      }

      this._faceVertexArray.push(faceVertex);
    }

    /**
     * read PMX uv morphing data
     * @access private
     * @param {number} count -
     * @param {number} textureNo -
     * @returns {void}
     */

  }, {
    key: '_readUVMorph',
    value: function _readUVMorph(count, textureNo) {
      for (var i = 0; i < count; i++) {
        var _index8 = this.readInteger(this._indexSize);
        var x = this.readFloat();
        var y = this.readFloat();
        var z = this.readFloat();
        var w = this.readFloat();
      }
    }

    /**
     * read PMX bone morphing data
     * @access private
     * @param {number} count -
     * @returns {void}
     */

  }, {
    key: '_readBoneMorph',
    value: function _readBoneMorph(count) {
      for (var i = 0; i < count; i++) {
        var _index9 = this.readInteger(this._boneIndexSize);
        var posX = this.readFloat();
        var posY = this.readFloat();
        var posZ = -this.readFloat();

        var quatX = this.readFloat();
        var quatY = this.readFloat();
        var quatZ = this.readFloat();
        var quatW = this.readFloat();
      }
    }

    /**
     * read PMX material morphing data
     * @access private
     * @param {number} count -
     * @returns {void}
     */

  }, {
    key: '_readMaterialMorph',
    value: function _readMaterialMorph(count) {
      for (var i = 0; i < count; i++) {
        var _index10 = this.readInteger(this._materialIndexSize);
        var addColor = this.readUnsignedByte();
        var diffuseColor = new _jscenekit.SKColor(this.readFloat(), this.readFloat(), this.readFloat(), this.readFloat());
        var specularColor = new _jscenekit.SKColor(this.readFloat(), this.readFloat(), this.readFloat(), 1.0);
        var shininess = this.readFloat();
        var ambientColor = new _jscenekit.SKColor(this.readFloat(), this.readFloat(), this.readFloat(), 1.0);
        var edgeColor = new _jscenekit.SKColor(this.readFloat(), this.readFloat(), this.readFloat(), this.readFloat());
        var edgeSize = this.readFloat();
        var textureColor = new _jscenekit.SKColor(this.readFloat(), this.readFloat(), this.readFloat(), this.readFloat());
        var sphereColor = new _jscenekit.SKColor(this.readFloat(), this.readFloat(), this.readFloat(), this.readFloat());
        var toonColor = new _jscenekit.SKColor(this.readFloat(), this.readFloat(), this.readFloat(), this.readFloat());
      }
    }

    /** 
     * read PMX group morphing data
     * @access private
     * @param {number} count -
     * @returns {void}
     */

  }, {
    key: '_readGroupMorph',
    value: function _readGroupMorph(count) {
      for (var i = 0; i < count; i++) {
        var morphIndex = this.readInteger(this._morphIndexSize);
        var rate = this.readFloat();
      }
    }

    /**
     * read PMX flip morphing data
     * @access private
     * @param {number} count -
     * @returns {void}
     */

  }, {
    key: '_readFlipMorph',
    value: function _readFlipMorph(count) {
      for (var i = 0; i < count; i++) {
        var morphIndex = this.readInteger(this._morphIndexSize);
        var rate = this.readFloat();
      }
    }

    /**
     * read PMX impulse morphing data
     * @access private
     * @param {number} count -
     * @returns {void}
     */

  }, {
    key: '_readImpulseMorph',
    value: function _readImpulseMorph(count) {
      for (var i = 0; i < count; i++) {
        var morphIndex = this.readInteger(this._morphIndexSize);
        var isLocal = this.readUnsignedByte();

        var vx = this.readFloat();
        var vy = this.readFloat();
        var vz = -this.readFloat();

        var torqueX = this.readFloat();
        var torqueY = this.readFloat();
        var torqueZ = this.readFloat();
      }
    }

    /**
     * read PMX face morphing data
     * @access private
     * @returns {void}
     */

  }, {
    key: '_createFaceMorph',
    value: function _createFaceMorph() {
      var morpher = new _jscenekit.SCNMorpher();
      morpher.calculationMode = _jscenekit.SCNMorpherCalculationMode.additive;

      var count = this._faceVertexArray.length;
      for (var i = 0; i < count; i++) {
        var faceVertexData = this._faceVertexArray[i];
        var faceVertexSource = new _jscenekit.SCNGeometrySource(faceVertexData, // data
        _jscenekit.SCNGeometrySource.Semantic.vertex, // semantic
        this._vertexCount, // vectorCount
        true, // usesFloatComponents
        3, // componentsPerVector
        4, // bytesPerComponent
        0, // dataOffset
        12 // dataStride
        );
        var faceGeometry = new _jscenekit.SCNGeometry([faceVertexSource, this._normalSource], []);
        faceGeometry.name = this._faceNameArray[i];

        morpher.targets.push(faceGeometry);
      }
      var geometryNode = this._workingNode.childNodeWithNameRecursively('Geometry', true);
      geometryNode.morpher = morpher;
      this._workingNode.geometryMorpher = morpher;
    }

    /**
     * read PMX display info
     * @access private
     * @returns {void}
     */

  }, {
    key: '_readDisplayInfo',
    value: function _readDisplayInfo() {
      var displayCount = this.readUnsignedInt();

      for (var i = 0; i < displayCount; i++) {
        var infoName = this._readPascalString();
        var englishInfoName = this._readPascalString();
        var flag = this.readUnsignedByte();
        var infoCount = this.readInt();

        for (var j = 0; j < infoCount; j++) {
          var type = this.readUnsignedByte();

          if (type === 0) {
            var boneIndex = this.readInteger(this._boneIndexSize);
          } else if (type === 1) {
            var morphIndex = this.readInteger(this._morphIndexSize);
          } else {
            throw new Error('unknown display info type: ' + type);
          }
        }
      }
    }

    /**
     * create geometry objects
     * @access private
     * @returns {void}
     */

  }, {
    key: '_createGeometry',
    value: function _createGeometry() {
      var vertexData = this._vertexArray;
      var normalData = this._normalArray;
      var texcoordData = this._texcoordArray;
      var boneWeightsData = this._boneWeightsArray;
      var boneIndicesData = null;
      switch (this._boneIndexSize) {
        case 1:
          {
            //const array = []
            //this._boneIndicesArray.forEach((data) => {
            //  array.push(data)
            //})
            //boneIndicesData = array
            boneIndicesData = this._boneIndicesArray;
            break;
          }
        case 2:
          {
            //const array = []
            //this._boneIndicesArray.forEach((data) => {
            //  array.push(data)
            //})
            //boneIndicesData = array
            boneIndicesData = this._boneIndicesArray;
            break;
          }
        case 4:
          {
            //const array = []
            //this._boneIndicesArray.forEach((data) => {
            //  array.push(data)
            //})
            //boneIndicesData = array
            boneIndicesData = this._boneIndicesArray;
            break;
          }
        default:
          {
            throw new Error('unknown bone indices size: ' + this._boneIndexSize);
          }
      }

      this._vertexSource = new _jscenekit.SCNGeometrySource(vertexData, // data
      _jscenekit.SCNGeometrySource.Semantic.vertex, // semantic
      this._vertexCount, // vectorCount
      true, // usesFloatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // dataOffset
      12 // dataStride
      );
      this._normalSource = new _jscenekit.SCNGeometrySource(normalData, // data
      _jscenekit.SCNGeometrySource.Semantic.normal, // semantic
      this._vertexCount, // vectorCount
      true, // usesFloatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // dataOffset
      12 // dataStride
      );
      this._texcoordSource = new _jscenekit.SCNGeometrySource(texcoordData, // data
      _jscenekit.SCNGeometrySource.Semantic.texcoord, // semantic
      this._vertexCount, // vectorCount
      true, // usesFloatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      0, // dataOffset
      8 // dataStride
      );

      var boneIndicesSource = new _jscenekit.SCNGeometrySource(boneIndicesData, // data
      _jscenekit.SCNGeometrySource.Semantic.boneIndices, // semantic
      this._vertexCount, // vectorCount
      false, // usesFloatComponents
      4, // componentsPerVector
      this._boneIndexSize, // bytesPerComponent
      0, // dataOffset
      4 * this._boneIndexSize // dataStride
      );
      var boneWeightsSource = new _jscenekit.SCNGeometrySource(boneWeightsData, // data
      _jscenekit.SCNGeometrySource.Semantic.boneWeights, // semantic
      this._vertexCount, // vectorCount
      true, // usesFloatComponents
      4, // componentsPerVector
      4, // bytesPerComponent
      0, // dataOffset
      16 // dataStride
      );

      for (var i = 0; i < this._materialCount; i++) {
        var count = this._materialIndexCountArray[i];
        var indexArray = this._separatedIndexArray[i];
        var indexData = null;
        switch (this._indexSize) {
          case 1:
            {
              //const array = []
              //indexArray.forEach((data) => {
              //  array.push(data)
              //})
              //indexData = array
              indexData = indexArray;
              break;
            }
          case 2:
            {
              //const array = []
              //indexArray.forEach((data) => {
              //  array.push(data)
              //})
              //indexData = array
              indexData = indexArray;
              break;
            }
          case 4:
            {
              //const array = []
              //indexArray.forEach((data) => {
              //  array.push(data)
              //})
              //indexData = array
              indexData = indexArray;
              break;
            }
          default:
            {
              throw new Error('unknown vertex indices size: ' + this._boneIndexSize);
            }
        }

        // FIXME: use Point/Line in the A-A-A pattern or the A-B-A pattern

        var primitiveType = this._materialShapeArray[i];
        var element = new _jscenekit.SCNGeometryElement(indexData, // data
        primitiveType, // primitiveType
        count, // primitiveCount
        this._indexSize // bytesPerIndex
        );

        this._elementArray.push(element);
      }

      //const program = new MMDProgram()
      //// TODO: implement MMD renderer
      //this._materialArray.forEach((material) => {
      //  material.program = program
      //})
      var geometry = new _jscenekit.SCNGeometry([this._vertexSource, this._normalSource, this._texcoordSource], this._elementArray);
      geometry.materials = this._materialArray;
      geometry.name = 'Geometry';

      var geometryNode = new _jscenekit.SCNNode(geometry);
      geometryNode.name = 'Geometry';

      var skinner = new _jscenekit.SCNSkinner(geometry, // baseGeometry
      this._boneArray, // bones
      this._boneInverseMatrixArray, // boneInverseBindTransforms
      boneWeightsSource, // boneWeights
      boneIndicesSource // boneIndices
      );

      geometryNode.skinner = skinner;
      geometryNode.skinner.skeleton = this._rootBone;
      geometryNode.castsShadow = true;

      this._workingNode.name = this._modelName;
      this._workingNode.castsShadow = true;
      this._workingNode.addChildNode(geometryNode);

      this._workingNode.vertexArray = this._vertexArray;

      this._workingNode.boneArray = this._boneArray;
      this._workingNode.boneInverseMatrixArray = this._boneInverseMatrixArray;

      this._workingNode.vertexCount = this._vertexCount;
      this._workingNode.vertexArray = this._vertexArray;
      this._workingNode.normalArary = this._normalArray;
      this._workingNode.texcoordArray = this._texcoordArray;

      this._workingNode.boneWeightsArray = this._boneWeight;
      this._workingNode.indexCount = this._indexCount;
      this._workingNode.materialCount = this._materialCount;
      this._workingNode.materialArray = this._materialArray;
      this._workingNode.materialIndexCountArray = this._materialIndexCountArray;
      this._workingNode.rootBone = this._rootBone;
    }

    /**
     * read PMX physics body data
     * @access private
     * @returns {void}
     */

  }, {
    key: '_readPhysicsBody',
    value: function _readPhysicsBody() {
      var _this4 = this;

      var bodyCount = this.readUnsignedInt();

      console.log('readPhysicsBody bodyCount: ' + bodyCount);

      for (var i = 0; i < bodyCount; i++) {
        var name = this._readPascalString();
        console.log('physics body name: ' + name);
        var englishName = this._readPascalString();
        var boneIndex = this.readInteger(this._boneIndexSize);

        var groupIndex = this.readUnsignedByte();
        var groupTarget = this.readUnsignedShort();
        var shapeType = this.readUnsignedByte();
        var dx = this.readFloat();
        var dy = this.readFloat();
        var dz = this.readFloat();
        var posX = this.readFloat();
        var posY = this.readFloat();
        var posZ = -this.readFloat();
        var rotX = -this.readFloat();
        var rotY = -this.readFloat();
        var rotZ = this.readFloat();
        var weight = this.readFloat();
        var positionDim = this.readFloat();
        var rotateDim = this.readFloat();
        var recoil = this.readFloat();
        var friction = this.readFloat();
        var type = this.readUnsignedByte();

        var bodyType = null;
        if (type === 0) {
          bodyType = _jscenekit.SCNPhysicsBodyType.kinematic;
        } else if (type === 1) {
          bodyType = _jscenekit.SCNPhysicsBodyType.dynamic;
        } else if (type === 2) {
          bodyType = _jscenekit.SCNPhysicsBodyType.dynamic;
        }
        bodyType = _jscenekit.SCNPhysicsBodyType.kinematic; // for debug

        var _shape = null;
        if (shapeType === 0) {
          _shape = new _jscenekit.SCNSphere(dx);
        } else if (shapeType === 1) {
          _shape = new _jscenekit.SCNBox(dx, dy, dz, 0.0);
        } else if (shapeType === 2) {
          _shape = new _jscenekit.SCNCapsule(dx, dy);
        } else {
          throw new Error('unknown physics body shape: ' + shapeType);
        }

        var bone = null;
        if (boneIndex !== -1) {
          bone = this._boneArray[boneIndex];
        }
        if (bone === null || typeof bone === 'undefined') {
          bone = this._boneArray[0];
        }

        var worldTransform = (0, _jscenekit.SCNMatrix4MakeTranslation)(posX, posY, posZ);
        worldTransform = worldTransform.rotation(0, 1, 0, rotY);
        worldTransform = worldTransform.rotation(1, 0, 0, rotX);
        worldTransform = worldTransform.rotation(0, 0, 1, rotZ);

        var invBoneTransform = bone.worldTransform.invert();
        var physicsTransform = worldTransform.mult(invBoneTransform);
        var physicsShape = new _jscenekit.SCNPhysicsShape(_shape, null);
        var transformedShape = new _jscenekit.SCNPhysicsShape([physicsShape], [physicsTransform]);

        if (bone.physicsBody !== null) {
          var identity = (0, _jscenekit.SCNMatrix4MakeTranslation)(0, 0, 0);
          transformedShape = new _jscenekit.SCNPhysicsShape([bone.physicsBody.physicsShape, transformedShape], [identity, identity]);
        }
        var body = new _jscenekit.SCNPhysicsBody(bodyType, transformedShape);

        body.isAffectedByGravity = true;
        body.mass = weight;
        body.friction = friction;
        body.rollingFriction = friction;
        body.dumping = positionDim;
        body.angularDamping = rotateDim;
        body.categoryBitMask = 1 << groupIndex;
        body.collisionBitMask = groupTarget;
        body.restitution = recoil;
        body.usesDefaultMomentOfInertia = true;
        body.allowsResting = true;
        body.charge = 0;

        if (boneIndex !== -1) {
          bone.physicsBody = body;
        }

        this._physicsBoneArray.push(bone);
      }

      this._physicsBoneArray.forEach(function (bone) {
        _this4._physicsBodyArray.push(bone.physicsBody);
      });
    }

    /**
     * read PMX constraint data
     * @access private
     * @returns {void}
     */

  }, {
    key: '_readConstraint',
    value: function _readConstraint() {
      var constraintCount = this.readUnsignedInt();
      this._workingNode.joints = [];
      for (var i = 0; i < constraintCount; i++) {
        var name = this._readPascalString();
        console.log('constraint name: ' + name);
        var englishName = this._readPascalString();
        var type = this.readUnsignedByte();

        var bodyANo = this.readInteger(this._physicsBodyIndexSize);
        var bodyBNo = this.readInteger(this._physicsBodyIndexSize);

        var bodyA = this._physicsBodyArray[bodyANo];
        var bodyB = this._physicsBodyArray[bodyBNo];

        var pos = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());
        var rot = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());

        var minPos = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());
        var manPos = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());

        var minRot = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());
        var manRot = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());

        var springPos = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());
        var springRot = new _jscenekit.SCNVector3(this.readFloat(), this.readFloat(), -this.readFloat());

        var boneA = this._physicsBoneArray[bodyANo];
        var boneB = this._physicsBoneArray[bodyBNo];

        var anchorA = new _jscenekit.SCNVector3(pos.x - boneA.worldTransform.m41, pos.y - boneA.worldTransform.m42, pos.z - boneA.worldTransform.m43);
        var anchorB = new _jscenekit.SCNVector3(pos.x - boneB.worldTransform.m41, pos.y - boneB.worldTransform.m42, pos.z - boneB.worldTransform.m43);

        if (boneA === boneB) {
          continue;
        }

        var constraint = new _jscenekit.SCNPhysicsBallSocketJoint(bodyA, anchorA, bodyB, anchorB);
        this._workingNode.joints.push(constraint);
      }
    }

    /**
     * read PMX soft body data
     * @access private
     * @returns {void}
     */

  }, {
    key: '_readSoftBody',
    value: function _readSoftBody() {
      var softBodyCount = this.readUnsignedInt();

      for (var i = 0; i < softBodyCount; i++) {
        var name = this._readPascalString();
        var englishName = this._readPascalString();

        var _shape2 = this.readUnsignedByte();
        if (_shape2 === 0) {
          // TriMesh
        } else if (_shape2 === 1) {
          // Rope
        } else {
          throw new Error('unknown softbody type: ' + _shape2);
        }

        var _index11 = this.readInteger(this._materialIndexSize);
        var groupIndex = this.readUnsignedByte();
        var groupTarget = this.readUnsignedShort();

        var flags = this.readUnsignedByte();
        if (flags & 0x01) {
          // TODO: create B-Link
        }
        if (flags & 0x02) {
          // TODO: create cluster
        }
        if (flags & 0x04) {}
        // TODO: mix links


        /*
          4  : int	| B-Link 作成距離
          4  : int	| クラスタ数
          
          4  : float	| 総質量
          4  : float	| 衝突マージン
          
          4  : int	| AeroModel - 0:V_Point, 1:V_TwoSided, 2:V_OneSided, 3:F_TwoSided, 4:F_OneSided
          
          <config>
          4  : float	| VCF
          4  : float	| DP
          4  : float	| DG
          4  : float	| LF
          4  : float	| PR
          4  : float	| VC
          4  : float	| DF
          4  : float	| MT
          4  : float	| CHR
          4  : float	| KHR
          4  : float	| SHR
          4  : float	| AHR
          
          <cluster>
          4  : float	| SRHR_CL
          4  : float	| SKHR_CL
          4  : float	| SSHR_CL
          4  : float	| SR_SPLT_CL
          4  : float	| SK_SPLT_CL
          4  : float	| SS_SPLT_CL
          
          <iteration>
          4  : int	| V_IT
          4  : int	| P_IT
          4  : int	| D_IT
          4  : int	| C_IT
          
          <material>
          4  : float	| LST
          4  : float	| AST
          4  : float	| VST
          
          4  : int	| アンカー剛体数
          <アンカー剛体>
          n  : 剛体Indexサイズ  | 関連剛体Index
          n  : 頂点Indexサイズ  | 関連頂点Index
          1  : byte	| Near モード  0:OFF 1:ON
          </アンカー剛体>
          * アンカー剛体数
          
          4  : int	| Pin頂点数
          <Pin頂点>
          n  : 頂点Indexサイズ  | 関連頂点Index
          </Pin頂点>
          * Pin頂点数
        */
      }
    }
  }], [{
    key: 'getNode',
    value: function getNode(data, directoryPath) {
      var reader = new MMDPMXReader(data, directoryPath);
      return reader._loadPMXFile();
    }
  }]);

  return MMDPMXReader;
}(_MMDReader3.default);

exports.default = MMDPMXReader;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MMDNode = __webpack_require__(1);

var _MMDNode2 = _interopRequireDefault(_MMDNode);

var _MMDReader2 = __webpack_require__(2);

var _MMDReader3 = _interopRequireDefault(_MMDReader2);

var _MMDSceneSource = __webpack_require__(3);

var _MMDSceneSource2 = _interopRequireDefault(_MMDSceneSource);

var _jscenekit = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 * @access public
 * @extends {MMDReader}
 */
var MMDVACReader = function (_MMDReader) {
  _inherits(MMDVACReader, _MMDReader);

  /**
   * 
   * @access public
   * @constructor
   * @param {Buffer} data -
   * @param {string} directoryPath -
   */
  function MMDVACReader(data, directoryPath) {
    _classCallCheck(this, MMDVACReader);

    var isBinary = false;
    var isBigEndian = false;
    var encoding = 'sjis';
    return _possibleConstructorReturn(this, (MMDVACReader.__proto__ || Object.getPrototypeOf(MMDVACReader)).call(this, data, directoryPath, isBinary, isBigEndian, encoding));
  }

  /**
   * @access public
   * @param {Buffer} data -
   * @param {string} directoryPath -
   * @returns {?MMDNode} -
   */


  _createClass(MMDVACReader, [{
    key: 'loadVACFile',


    /**
     * @access private
     * @returns {?MMDNode} -
     */
    value: function loadVACFile() {
      var _this2 = this;

      var lines = this.binaryData.split('\r\n');
      if (lines.length < 6) {
        return null;
      }
      var name = lines[0];
      var fileName = lines[1];
      var scaleStr = lines[2];
      var positions = lines[3].split(',');
      var rotations = lines[4].split(',');
      var boneName = lines[5];

      var xFilePath = this.directoryPath + '/' + fileName;
      var xNode = new _MMDNode2.default();
      xNode._loadedPromise = new Promise(function (resolve, reject) {
        _this2._resolveFunction = resolve;
        _this2._rejectFunction = reject;
      });

      var source = _MMDSceneSource2.default.sceneSourceWithURLOptions(xFilePath);
      source.didLoad.then(function () {
        //if(!scene){
        //  console.error(`cannot read file: ${xFilePath}`)
        //  return null
        //}

        _this2._model = source.getModel();
        if (!_this2._model) {
          throw new Error('model load error');
        }
        return _this2._model.didLoad;
      }).then(function () {
        _this2._model.name = name;
        var scale = parseFloat(scaleStr);
        if (!isNaN(scale)) {
          var s = scale * 10.0;
          _this2._model.scale = new _jscenekit.SCNVector3(s, s, s);
        } else {
          _this2._model.scale = new _jscenekit.SCNVector3(10.0, 10.0, 10.0);
        }

        if (positions.length >= 3) {
          var posX = parseFloat(positions[0]);
          var posY = parseFloat(positions[1]);
          var posZ = parseFloat(positions[2]);
          if (!isNaN(posX) && !isNaN(posY) && !isNaN(posZ)) {
            _this2._model.position = new _jscenekit.SCNVector3(posX, posY, posZ);
          }
        }

        if (rotations.length >= 3) {
          var rotX = parseFloat(rotations[0]);
          var rotY = parseFloat(rotations[1]);
          var rotZ = parseFloat(rotations[2]);
          if (!isNaN(rotX) && !isNaN(rotY) && !isNaN(rotZ)) {
            // TODO: implement
          }
        }

        xNode.copySCNNodeValues(_this2._model);
        xNode.copyValues(_this2._model);

        _this2._resolveFunction();
      }).catch(function (error) {
        throw new Error('model load error: ' + error);
      });
      return xNode;
    }
  }], [{
    key: 'getNode',
    value: function getNode(data, directoryPath) {
      var reader = new MMDVACReader(data, directoryPath);
      var node = reader.loadVACFile();

      return node;
    }
  }]);

  return MMDVACReader;
}(_MMDReader3.default);

exports.default = MMDVACReader;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MMDNode = __webpack_require__(1);

var _MMDNode2 = _interopRequireDefault(_MMDNode);

var _MMDReader2 = __webpack_require__(2);

var _MMDReader3 = _interopRequireDefault(_MMDReader2);

var _constants = __webpack_require__(26);

var _jscenekit = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _VMDMotionType = {
  model: Symbol(),
  cameraOrLight: Symbol(),
  camera: Symbol(),
  light: Symbol(),
  unknown: Symbol()

  /**
   *
   * @access public
   * @extends {MMDReader}
   */
};
var MMDVMDReader = function (_MMDReader) {
  _inherits(MMDVMDReader, _MMDReader);

  /**
   *
   * @access public
   * @param {Buffer} data -
   * @param {string} directoryPath -
   * @constructor
   */
  function MMDVMDReader(data, directoryPath) {
    _classCallCheck(this, MMDVMDReader);

    var isBinary = true;
    var isBigEndian = false;
    var encoding = 'sjis';

    var _this = _possibleConstructorReturn(this, (MMDVMDReader.__proto__ || Object.getPrototypeOf(MMDVMDReader)).call(this, data, directoryPath, isBinary, isBigEndian, encoding));

    _this._workingAnimationGroup = null;
    _this._animationHash = null;
    _this._faceAnimationHash = null;

    _this.fps = 30.0;

    // header
    _this._vmdMagic = '';
    _this._motionName = '';
    _this._motionType = _VMDMotionType.unknown;

    // frame
    _this._frameCount = 0;
    _this._frameLength = 0;
    return _this;
  }

  /**
   * @access public
   * @param {Buffer} data -
   * @param {string} directoryPath -
   * @returns {CAAnimationGroup} -
   */


  _createClass(MMDVMDReader, [{
    key: '_loadVMDFile',


    /**
     * @access private
     * @returns {CAAnimationGroup} -
     */
    value: function _loadVMDFile() {
      this._workingAnimationGroup = new _jscenekit.CAAnimationGroup();
      this._workingAnimationGroup.animations = [];

      this._animationHash = new Map();
      this._faceAnimationHash = new Map();

      this._readVMDHeader();
      this._readFrame();
      this._readFaceMotion();
      this._createAnimations();

      if (this.pos >= this.length) {
        return this._workingAnimationGroup;
      }

      this._readCameraMotion();
      this._readLightMotion();

      //console.log(`pos: ${this.pos}, length: ${this.length}`)
      if (this.pos >= this.length) {
        return this._workingAnimationGroup;
      }

      this._readShadow();

      if (this.pos >= this.length) {
        return this._workingAnimationGroup;
      }

      this._readVisibilityAndIK();

      return this._workingAnimationGroup;
    }
  }, {
    key: '_readVMDHeader',
    value: function _readVMDHeader() {
      this._vmdMagic = this.readString(30);
      this._motionName = this.readString(20);

      if (this._motionName === 'カメラ・照明') {
        this._motionType = _VMDMotionType.cameraOrLight;
      } else {
        this._motionType = _VMDMotionType.model;
      }
    }
  }, {
    key: '_readFrame',
    value: function _readFrame() {
      var frameCount = this.readUnsignedInt();
      this._frameCount = frameCount;
      this._frameLength = 0;
      var bytesPerFrame = 111;

      console.log('readFrame: frameCount: ' + frameCount);

      if (this._motionType === _VMDMotionType.cameraOrLight && frameCount > 0) {
        console.warn('MMDVMDReader: not model motion data has bone motion data');
        this.skip(bytesPerFrame * frameCount, true);
        return;
      }

      for (var i = 0; i < frameCount; i++) {
        var boneName = this.readString(15);
        //console.log(`boneName: ${boneName}`)
        if (boneName === null) {
          console.warn('motion(' + i + '): skip because of broken bone name');
          this.skip(96);
          continue;
        }
        var posXMotion = this._animationHash.get('posX:' + boneName);
        var posYMotion = this._animationHash.get('posY:' + boneName);
        var posZMotion = this._animationHash.get('posZ:' + boneName);
        var rotMotion = this._animationHash.get('rot:' + boneName);

        if (typeof posXMotion === 'undefined') {
          posXMotion = new _jscenekit.CAKeyframeAnimation('/' + boneName + '.transform.translation.x');
          posYMotion = new _jscenekit.CAKeyframeAnimation('/' + boneName + '.transform.translation.y');
          posZMotion = new _jscenekit.CAKeyframeAnimation('/' + boneName + '.transform.translation.z');
          rotMotion = new _jscenekit.CAKeyframeAnimation('/' + boneName + '.transform.quaternion');

          posXMotion.values = [];
          posYMotion.values = [];
          posZMotion.values = [];
          rotMotion.values = [];

          posXMotion.keyTimes = [];
          posYMotion.keyTimes = [];
          posZMotion.keyTimes = [];
          rotMotion.keyTimes = [];

          posXMotion.timingFunctions = [];
          posYMotion.timingFunctions = [];
          posZMotion.timingFunctions = [];
          rotMotion.timingFunctions = [];

          this._animationHash.set('posX:' + boneName, posXMotion);
          this._animationHash.set('posY:' + boneName, posYMotion);
          this._animationHash.set('posZ:' + boneName, posZMotion);
          this._animationHash.set('rot:' + boneName, rotMotion);
        }

        var frameIndex = posXMotion.keyTimes.length - 1;
        var frameNo = this.readUnsignedInt();
        //console.log(`frameNo: ${frameNo}`)

        while (frameIndex >= 0) {
          var k = posXMotion.keyTimes[frameIndex];
          if (k < frameNo) {
            break;
          }
          frameIndex -= 1;
        }
        frameIndex += 1;

        // insert frameNo at frameIndex
        posXMotion.keyTimes.splice(frameIndex, 0, frameNo);
        posYMotion.keyTimes.splice(frameIndex, 0, frameNo);
        posZMotion.keyTimes.splice(frameIndex, 0, frameNo);
        rotMotion.keyTimes.splice(frameIndex, 0, frameNo);

        if (frameNo > this._frameLength) {
          this._frameLength = frameNo;
        }

        var posX = this.readFloat();
        var posY = this.readFloat();
        var posZ = this.readFloat();
        var rotate = new _jscenekit.SCNQuaternion(-this.readFloat(), -this.readFloat(), this.readFloat(), this.readFloat()).normalize();
        //console.log(`pos: ${posX}, ${posY}, ${posZ}`)

        var interpolation = [];
        for (var j = 0; j < 64; j++) {
          interpolation.push(this.readUnsignedByte() / 127.0);
        }

        var timingX = new _jscenekit.CAMediaTimingFunction(interpolation[0], interpolation[4], interpolation[8], interpolation[12]);
        posXMotion.timingFunctions.splice(frameIndex, 0, timingX);

        var timingY = new _jscenekit.CAMediaTimingFunction(interpolation[1], interpolation[5], interpolation[9], interpolation[13]);
        posYMotion.timingFunctions.splice(frameIndex, 0, timingY);

        var timingZ = new _jscenekit.CAMediaTimingFunction(interpolation[2], interpolation[6], interpolation[10], interpolation[14]);
        posZMotion.timingFunctions.splice(frameIndex, 0, timingZ);

        var timingRot = new _jscenekit.CAMediaTimingFunction(interpolation[3], interpolation[7], interpolation[11], interpolation[15]);
        rotMotion.timingFunctions.splice(frameIndex, 0, timingRot);

        posXMotion.values.splice(frameIndex, 0, posX);
        posYMotion.values.splice(frameIndex, 0, posY);
        posZMotion.values.splice(frameIndex, 0, posZ);
        rotMotion.values.splice(frameIndex, 0, rotate);
      }
    }
  }, {
    key: '_readFaceMotion',
    value: function _readFaceMotion() {
      var faceFrameCount = this.readUnsignedInt();
      var timingFunc = _jscenekit.CAMediaTimingFunction.functionWithName(_jscenekit.kCAMediaTimingFunctionLinear);
      var bytesPerFrame = 23;

      console.log('readFaceMotion: faceFrameCount: ' + faceFrameCount);

      if (this._motionType === _VMDMotionType.cameraOrLight && faceFrameCount > 0) {
        console.warn('not model motion data has face motion data');
        this.skip(bytesPerFrame * faceFrameCount, true);
        return;
      }

      for (var i = 0; i < faceFrameCount; i++) {
        var name = this.readString(15);
        var frameNo = this.readUnsignedInt();
        var factor = this.readFloat();

        //console.log(`faceName: ${name}`)

        var keyPath = 'morpher.weights.' + name;
        var animation = this._faceAnimationHash.get(name);

        if (typeof animation === 'undefined') {
          animation = new _jscenekit.CAKeyframeAnimation(keyPath);
          animation.values = [];
          animation.keyTimes = [];
          animation.timingFunctions = [];
          this._faceAnimationHash.set(name, animation);
        }

        var frameIndex = animation.keyTimes.length - 1;
        while (frameIndex >= 0) {
          var k = animation.keyTimes[frameIndex];
          if (k < frameNo) {
            break;
          }
          frameIndex -= 1;
        }
        frameIndex += 1;

        // insert frameNo at frameIndex
        animation.keyTimes.splice(frameIndex, 0, frameNo);
        animation.values.splice(frameIndex, 0, factor);
        animation.timingFunctions.splice(frameIndex, 0, timingFunc);
      }
    }
  }, {
    key: '_createAnimations',
    value: function _createAnimations() {
      var _this2 = this;

      var duration = this._frameLength / this.fps;

      //console.log('_createAnimations')
      this._animationHash.forEach(function (motion, key) {
        // normalize keyTimes
        var motionLength = motion.keyTimes[motion.keyTimes.length - 1];
        for (var num = 0; num < motion.keyTimes.length; num++) {
          var keyTime = motion.keyTimes[num] / motionLength;
          motion.keyTimes[num] = keyTime;
        }

        motion.duration = motionLength / _this2.fps;
        motion.usesSceneTimeBase = false;
        motion.isRemovedOnCompletion = false;
        motion.fillMode = _jscenekit.kCAFillModeForwards;

        //console.log('animations.push ' + key)
        _this2._workingAnimationGroup.animations.push(motion);
      });

      this._faceAnimationHash.forEach(function (motion, key) {
        // normalize keyTimes
        var motionLength = motion.keyTimes[motion.keyTimes.length - 1];
        for (var num = 0; num < motion.keyTimes.length; num++) {
          var keyTime = motion.keyTimes[num] / motionLength;
          motion.keyTimes[num] = keyTime;
        }

        motion.duration = motionLength / _this2.fps;
        motion.usesSceneTimeBase = false;
        motion.isRemovedOnCompletion = false;
        motion.fillMode = _jscenekit.kCAFillModeForwards;

        _this2._workingAnimationGroup.animations.push(motion);
      });

      this._workingAnimationGroup.duration = duration;
      this._workingAnimationGroup.usesSceneTimeBase = false;
      this._workingAnimationGroup.isRemovedOnCompletion = false;
      this._workingAnimationGroup.fillMode = _jscenekit.kCAFillModeForwards;
    }
  }, {
    key: '_readCameraMotion',
    value: function _readCameraMotion() {
      var _this3 = this;

      var cameraFrameCount = this.readUnsignedInt();
      var bytesPerFrame = 61;

      console.log('readCameraMotion: cameraFrameCount: ' + cameraFrameCount);

      if (cameraFrameCount === 0) {
        return;
      }

      if (this._motionType !== _VMDMotionType.cameraOrLight) {
        console.warn('not camera motion has motion data');
        this.skip(bytesPerFrame * cameraFrameCount, true);
        return;
      }
      this._motionType = _VMDMotionType.camera;

      // init values
      this._frameCount = cameraFrameCount;
      this._frameLength = 0;

      var distanceMotion = new _jscenekit.CAKeyframeAnimation('/' + _constants.MMD_CAMERA_NODE_NAME + '.translation.z');
      var posXMotion = new _jscenekit.CAKeyframeAnimation('transform.translation.x');
      var posYMotion = new _jscenekit.CAKeyframeAnimation('transform.translation.y');
      var posZMotion = new _jscenekit.CAKeyframeAnimation('transform.translation.z');
      var rotZMotion = new _jscenekit.CAKeyframeAnimation('/' + _constants.MMD_CAMERA_ROTZ_NODE_NAME + '.eulerAngles.z');
      var rotXMotion = new _jscenekit.CAKeyframeAnimation('/' + _constants.MMD_CAMERA_ROTX_NODE_NAME + '.eulerAngles.x');
      var rotYMotion = new _jscenekit.CAKeyframeAnimation('/' + _constants.MMD_CAMERA_ROTY_NODE_NAME + '.eulerAngles.y');
      var angleMotion = new _jscenekit.CAKeyframeAnimation('/' + _constants.MMD_CAMERA_NODE_NAME + '.camera.yFov');
      var persMotion = new _jscenekit.CAKeyframeAnimation('/' + _constants.MMD_CAMERA_NODE_NAME + '.camera.usesOrthographicProjection');

      distanceMotion.values = [];
      posXMotion.values = [];
      posYMotion.values = [];
      posZMotion.values = [];
      rotXMotion.values = [];
      rotYMotion.values = [];
      rotZMotion.values = [];
      angleMotion.values = [];
      persMotion.values = [];

      distanceMotion.timingFunctions = [];
      posXMotion.timingFunctions = [];
      posYMotion.timingFunctions = [];
      posZMotion.timingFunctions = [];
      rotXMotion.timingFunctions = [];
      rotYMotion.timingFunctions = [];
      rotZMotion.timingFunctions = [];
      angleMotion.timingFunctions = [];
      persMotion.timingFunctions = [];

      for (var i = 0; i < cameraFrameCount; i++) {
        var frameIndex = distanceMotion.keyTimes.length - 1;
        var frameNo = this.readUnsignedInt();

        while (frameIndex >= 0) {
          var k = distanceMotion.keyTimes[frameIndex];
          if (k < frameNo) {
            break;
          }
          frameIndex -= 1;
        }
        frameIndex += 1;

        distanceMotion.keyTimes.splice(frameIndex, 0, frameNo);
        posXMotion.keyTimes.splice(frameIndex, 0, frameNo);
        posYMotion.keyTimes.splice(frameIndex, 0, frameNo);
        posZMotion.keyTimes.splice(frameIndex, 0, frameNo);
        rotXMotion.keyTimes.splice(frameIndex, 0, frameNo);
        rotYMotion.keyTimes.splice(frameIndex, 0, frameNo);
        rotZMotion.keyTimes.splice(frameIndex, 0, frameNo);
        angleMotion.keyTimes.splice(frameIndex, 0, frameNo);
        persMotion.keyTimes.splice(frameIndex, 0, frameNo);

        if (frameNo > this._frameLength) {
          this._frameLength = frameNo;
        }

        var distance = -this.readFloat();
        var posX = this.readFloat();
        var posY = this.readFloat();
        var posZ = -this.readFloat();

        var rotX = this.readFloat();
        var rotY = this.readFloat();
        var rotZ = -this.readFloat();

        var interpolation = [];
        for (var j = 0; j < 24; i++) {
          interpolation.push(this.readUnsignedByte() / 127.0);
        }

        var angle = this.readInt();
        var perspective = this.readUnsignedByte();
        var useOrtho = perspective !== 0;

        var timingX = new _jscenekit.CAMediaTimingFunction(interpolation[0], interpolation[2], interpolation[1], interpolation[3]);
        posXMotion.timingFunctions.splice(frameIndex, 0, timingX);

        var timingY = new _jscenekit.CAMediaTimingFunction(interpolation[4], interpolation[6], interpolation[5], interpolation[7]);
        posYMotion.timingFunctions.splice(frameIndex, 0, timingY);

        var timingZ = new _jscenekit.CAMediaTimingFunction(interpolation[8], interpolation[10], interpolation[9], interpolation[11]);
        posZMotion.timingFunctions.splice(frameIndex, 0, timingZ);

        var timingRot = new _jscenekit.CAMediaTimingFunction(interpolation[12], interpolation[14], interpolation[13], interpolation[15]);
        rotXMotion.timingFunctions.splice(frameIndex, 0, timingRot);
        rotYMotion.timingFunctions.splice(frameIndex, 0, timingRot);
        rotZMotion.timingFunctions.splice(frameIndex, 0, timingRot);

        var timingDistance = new _jscenekit.CAMediaTimingFunction(interpolation[16], interpolation[18], interpolation[17], interpolation[19]);
        distanceMotion.timingFunctions.splice(frameIndex, 0, timingDistance);

        var timingAngle = new _jscenekit.CAMediaTimingFunction(interpolation[20], interpolation[22], interpolation[21], interpolation[23]);
        angleMotion.timingFunctions.splice(frameIndex, 0, timingAngle);

        distanceMotion.values.splice(frameIndex, 0, distance);
        posXMotion.values.splice(frameIndex, 0, posX);
        posYMotion.values.splice(frameIndex, 0, posY);
        posZMotion.values.splice(frameIndex, 0, posZ);
        rotXMotion.values.splice(frameIndex, 0, rotX);
        rotYMotion.values.splice(frameIndex, 0, rotY);
        rotZMotion.values.splice(frameIndex, 0, rotZ);
        angleMotion.values.splice(frameIndex, 0, angle);
        persMotion.values.splice(frameIndex, 0, useOrtho);
      }

      var duration = this._frameLength / this.fps;

      var motions = [distanceMotion, posXMotion, posYMotion, posZMotion, rotXMotion, rotYMotion, rotZMotion, angleMotion, persMotion];
      motions.forEach(function (motion) {
        var motionLength = motion.keyTimes[motion.keyTimes.length - 1];
        motion.duration = motionLength / _this3.fps;
        motion.usesSceneTimeBase = false;
        motion.isRemovedOnCompletion = false;
        motion.fillMode = _jscenekit.kCAFillModeForwards;

        var len = motion.keyTimes.length;
        for (var num = 0; num < len; num++) {
          var keyTime = motion.keyTimes[num] / motionLength;
          motion.keyTimes[num] = keyTime;
        }
        _this3._workingAnimationGroup.animations.push(motion);
      });

      this._workingAnimationGroup.duration = duration;
      this._workingAnimationGroup.usesSceneTimeBase = false;
      this._workingAnimationGroup.isRemovedOnCompletion = false;
      this._workingAnimationGroup.fillMode = _jscenekit.kCAFillModeForwards;
    }
  }, {
    key: '_readLightMotion',
    value: function _readLightMotion() {
      var _this4 = this;

      var lightFrameCount = this.readUnsignedInt();
      var bytesPerFrame = 28;

      console.log('readLightMotion: lightFrameCount: ' + lightFrameCount);

      if (lightFrameCount === 0) {
        return;
      }

      if (this._motionType !== _VMDMotionType.cameraOrLight) {
        console.warn('not light motion has light motion data');
        this.skip(bytesPerFrame * lightFrameCount, true);
        return;
      }
      this._motionType = _VMDMotionType.light;

      this._frameCount = lightFrameCount;
      this._frameLength = 0;

      var colorMotion = new _jscenekit.CAKeyframeAnimation('light.color');
      var directionMotion = new _jscenekit.CAKeyframeAnimation('transform.quaternion');

      colorMotion.values = [];
      directionMotion.values = [];

      colorMotion.keyTimes = [];
      directionMotion.keyTimes = [];

      for (var i = 0; i < lightFrameCount; i++) {
        var frameIndex = colorMotion.keyTimes.length - 1;
        var frameNo = this.readUnsignedInt();

        while (frameIndex >= 0) {
          var k = colorMotion.keyTimes[frameIndex];
          if (k < frameNo) {
            break;
          }
          frameIndex -= 1;
        }
        frameIndex += 1;

        colorMotion.keyTimes.splice(frameIndex, 0, frameNo);
        directionMotion.keyTimes.splice(frameIndex, 0, frameNo);

        if (frameNo > this._frameLength) {
          this._frameLength = frameNo;
        }

        var color = (0, _jscenekit.SKColor)(this.readFloat(), this.readFloat(), this.readFloat(), 1.0);
        colorMotion.values.splice(frameIndex, 0, color);

        var rotX = this.readFloat();
        var rotY = this.readFloat();
        var rotZ = this.readFloat();

        var cosX = Math.cos(rotX * 0.5);
        var cosY = Math.cos(rotY * 0.5);
        var cosZ = Math.cos(rotZ * 0.5);
        var sinX = Math.sin(rotX * 0.5);
        var sinY = Math.sin(rotY * 0.5);
        var sinZ = Math.sin(rotZ * 0.5);

        var quat = new _jscenekit.SCNQuaternion();
        quat.x = sinX * cosY * cosZ + cosX * sinY * sinZ;
        quat.y = cosX * sinY * cosZ - cosX * cosY * sinZ;
        quat.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
        quat.w = cosX * cosY * cosZ + sinX * sinY * sinZ;

        var direction = quat.normalize();
        directionMotion.values.splice(frameIndex, 0, direction);
      }

      var duration = this._frameLength / this.fps;
      var motions = [colorMotion, directionMotion];

      motions.forEach(function (motion) {
        var motionLength = motion.keyTimes[motion.keyTimes.length - 1];
        motion.duration = motionLength / _this4.fps;
        motion.usesSceneTimeBase = false;
        motion.isRemovedOnCompletion = false;
        motion.fillMode = _jscenekit.kCAFillModeForwards;

        var len = motion.keyTImes.length;
        for (var num = 0; num < len; num++) {
          var keyTime = motion.keyTimes[num] / motionLength;
          motion.keyTimes[num] = keyTime;
        }

        _this4._workingAnimationGroup.animations.push(motion);
      });

      this._workingAnimationGroup.duration = duration;
      this._workingAnimationGroup.usesSceneTimeBase = false;
      this._workingAnimationGroup.isRemovedOnCompletion = false;
      this._workingAnimationGroup.fillMode = _jscenekit.kCAFillModeForwards;
    }
  }, {
    key: '_readShadow',
    value: function _readShadow() {
      var shadowFrameCount = this.readUnsignedInt();
      var shadowArray = [];
      var bytesPerFrame = 9;

      console.log('readShadow: shadowFrameCount: ' + shadowFrameCount);
      if (shadowFrameCount === 0) {
        return;
      }

      var dataLength = bytesPerFrame * shadowFrameCount;
      if (this._motionType !== _VMDMotionType.model) {
        console.warn('not model motion has shadow motion data');
        this.skip(dataLength, true);
        return;
      }

      if (this.getAvailableDataLength() < dataLength) {
        console.warn('this file doesn\'t have shadow data');
        this.skip(dataLength, true);
        return;
      }

      var shadowFrameLength = 0;
      var shadowMotion = new _jscenekit.CAKeyframeAnimation('????'); // FIXME: set appropriate keyPath

      shadowMotion.values = [];
      shadowMotion.keyTimes = [];

      for (var i = 0; i < shadowFrameCount; i++) {
        var frameIndex = shadowMotion.keyTimes.length - 1;
        var frameNo = this.readUnsignedInt();

        while (frameIndex >= 0) {
          var k = shadowMotion.keyTimes[frameIndex];
          if (k < frameNo) {
            break;
          }
          frameIndex -= 1;
        }
        frameIndex += 1;

        shadowMotion.keyTimes.splice(frameIndex, 0, frameNo);

        if (frameNo > this._frameLength) {
          this._frameLength = frameNo;
        }

        var mode = this.readUnsignedByte();
        var distance = this.readFloat();
      }

      //const duration = shadowFrameLength / this.fps

      var motionLength = shadowMotion.keyTimes[shadowMotion.keyTimes.length - 1];
      shadowMotion.duration = motionLength / this.fps;
      shadowMotion.usesSceneTimeBase = false;
      shadowMotion.isRemovedOnCompletion = false;
      shadowMotion.fillMode = _jscenekit.kCAFillModeForwards;

      var len = shadowMotion.keyTimes.length;
      for (var num = 0; num < len; num++) {
        var keyTime = shadowMotion.keyTimes[num] / motionLength;
        shadowMotion.keyTimes[num] = keyTime;
      }

      this._workingAnimationGroup.animations.push(shadowMotion);
    }
  }, {
    key: '_readVisibilityAndIK',
    value: function _readVisibilityAndIK() {
      var _this5 = this;

      var ikFrameCount = this.readUnsignedInt();
      var ikArray = [];
      var bytesPerFrame = 9;

      console.log('readVisibilityAndIK: ikFrameCount: ' + ikFrameCount);

      if (ikFrameCount === 0) {
        return;
      }

      var dataLength = bytesPerFrame * ikFrameCount;
      if (this._motionType !== _VMDMotionType.model) {
        console.warn('not model motion has IK motion data');
        this.skip(dataLength, true);
        return;
      }

      if (this.getAvailableDataLength() < dataLength) {
        console.warn('this file doesn\'t have IK data');
        this.skip(dataLength, true);
        return;
      }

      var ikFrameLength = 0;
      var ikMotion = new _jscenekit.CAKeyframeAnimation('????'); // FIXME: set appropriate keyPath
      var hiddenMotion = new _jscenekit.CAKeyframeAnimation('hidden');

      ikMotion.values = [];
      hiddenMotion.values = [];

      ikMotion.keyTimes = [];
      hiddenMotion.keyTimes = [];

      for (var i = 0; i < ikFrameCount; i++) {
        var frameIndex = ikMotion.keyTimes.length - 1;
        var frameNo = this.readUnsignedInt();

        while (frameIndex >= 0) {
          var k = ikMotion.keyTimes[frameIndex];
          if (k < frameNo) {
            break;
          }
          frameIndex -= 1;
        }
        frameIndex += 1;

        ikMotion.keyTimes.splice(frameIndex, 0, frameNo);
        hiddenMotion.keyTimes.splice(frameIndex, 0, frameNo);

        if (frameNo > this._frameLength) {
          this._frameLength = frameNo;
        }

        var visible = this.readUnsignedByte();
        var hidden = visible === 0;
        var ikNum = this.readUnsignedInt();

        for (var num = 0; num < ikNum; num++) {
          var boneName = this.readString(20);
          var ikOn = this.readUnsignedByte();
        }
      }
      var duration = ikFrameLength / this.fps;

      var motions = [ikMotion, hiddenMotion];
      motions.forEach(function (motion) {
        var motionLength = motion.keyTimes[motion.keyTimes.length - 1];
        motion.duration = motionLength / _this5.fps;
        motion.usesSceneTimeBase = false;
        motion.isRemovedOnCompletion = false;
        motion.fillMode = _jscenekit.kCAFillModeForwards;

        var len = motion.keyTimes.length;
        for (var _num = 0; _num < len; _num++) {
          var keyTime = motion.keyTimes[_num] / motionLength;
          motion.keyTimes[_num] = keyTime;
        }
        _this5._workingAnimationGroup.animations.push(motion);
      });

      this._workingAnimationGroup.duration = duration;
    }
  }], [{
    key: 'getMotion',
    value: function getMotion(data, directoryPath) {
      var reader = new MMDVMDReader(data, directoryPath);
      return reader._loadVMDFile();
    }
  }, {
    key: 'Type',
    get: function get() {
      return _VMDMotionType;
    }
  }]);

  return MMDVMDReader;
}(_MMDReader3.default);

exports.default = MMDVMDReader;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MMDReader2 = __webpack_require__(2);

var _MMDReader3 = _interopRequireDefault(_MMDReader2);

var _jscenekit = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 * @access public
 * @extends {MMDReader}
 */
var MMDVPDReader = function (_MMDReader) {
  _inherits(MMDVPDReader, _MMDReader);

  /**
   * 
   * @access public
   * @constructor
   * @param {Buffer} data -
   * @param {string} directoryPath -
   */
  function MMDVPDReader(data, directoryPath) {
    _classCallCheck(this, MMDVPDReader);

    var isBinary = false;
    var isBigEndian = false;
    var encoding = 'sjis';

    /**
     * @access private
     * @type {CAAnimationGroup}
     */
    var _this = _possibleConstructorReturn(this, (MMDVPDReader.__proto__ || Object.getPrototypeOf(MMDVPDReader)).call(this, data, directoryPath, isBinary, isBigEndian, encoding));

    _this.workingAnimationGroup = null;
    return _this;
  }

  /**
   * @access public
   * @param {Buffer} data -
   * @param {string} [directoryPath = ''] -
   * @returns {?CAAnimationGroup} -
   */


  _createClass(MMDVPDReader, [{
    key: 'loadVPDFile',


    /**
     * @access private
     * @returns {?CAAnimationGroup} -
     */
    value: function loadVPDFile() {
      var lines = this.binaryData.split('\r\n');

      this.workingAnimationGroup = new _jscenekit.CAAnimationGroup();
      this.workingAnimationGroup.animations = [];

      var magic = lines[0];
      if (magic !== 'Vocaloid Pose Data file') {
        console.error('Unknown file format: ' + magic);
        return null;
      }

      var modelName = lines[2].split(';')[0];
      var numBonesText = lines[3].split(';')[0];
      var numBones = parseInt(numBonesText);
      if (isNaN(numBones)) {
        return null;
      }

      var line = 5;
      for (var boneNo = 0; boneNo < numBones; boneNo++) {
        var boneName = lines[line + 0].split('{')[1];
        var posText = lines[line + 1].split(';')[0].split(',');
        var rotText = lines[line + 2].split(';')[0].split(',');

        var posX = this.getFloatFromText(posText[0]);
        var posY = this.getFloatFromText(posText[1]);
        var posZ = this.getFloatFromText(posText[2]);
        var pos = new _jscenekit.SCNVector3(posX, posY, posZ);

        var rotX = this.getFloatFromText(rotText[0]);
        var rotY = this.getFloatFromText(rotText[1]);
        var rotZ = this.getFloatFromText(rotText[2]);
        var rotW = this.getFloatFromText(rotText[3]);
        var rot = new _jscenekit.SCNVector4(-rotX, -rotY, rotZ, rotW);

        var posMotion = new _jscenekit.CAKeyframeAnimation('/' + boneName + '.transform.translation');
        var rotMotion = new _jscenekit.CAKeyframeAnimation('/' + boneName + '.transform.quaternion');

        posMotion.values = [pos];
        rotMotion.values = [rot];

        posMotion.keyTimes = [0.0];
        rotMotion.keyTimes = [0.0];

        this.workingAnimationGroup.animations.push(posMotion);
        this.workingANimationGroup.animations.push(rotMotion);

        line += 5;
      }

      this.workingAnimationGroup.duration = 0;
      this.workingAnimationGroup.usesSceneTimeBase = false;
      this.workingAnimationGroup.isRemovedOnCompletion = false;
      this.workingAnimationGroup.fillMode = _jscenekit.kCAFillModeForwards;

      return this.workingAnimationGroup;
    }

    /**
     * @access private
     * @param {string} text -
     * @returns {Float} -
     */

  }, {
    key: 'getFloatFromText',
    value: function getFloatFromText(text) {
      var value = parseFloat(text);
      if (!isNaN(value)) {
        return value;
      }
      return 0;
    }
  }], [{
    key: 'getAnimation',
    value: function getAnimation(data) {
      var directoryPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var reader = new MMDVPDReader(data, directoryPath);
      var animation = reader.loadVPDFile();

      return animation;
    }
  }]);

  return MMDVPDReader;
}(_MMDReader3.default);

exports.default = MMDVPDReader;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MMDNode = __webpack_require__(1);

var _MMDNode2 = _interopRequireDefault(_MMDNode);

var _MMDReader2 = __webpack_require__(2);

var _MMDReader3 = _interopRequireDefault(_MMDReader2);

var _jscenekit = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _headerPattern = new RegExp(/^xof (\d\d\d\d)([ \w][ \w][ \w][ \w])(\d\d\d\d)/);
var _commaOrSemicolonPattern = new RegExp(/^,|;/);
var _uuidPattern = new RegExp(/^<[\w-]+>/);
var _leftBracePattern = new RegExp(/^{/);
var _rightBracePattern = new RegExp(/^}/);
var _memberPattern = new RegExp(/^((array\s+\w+\s+\w+\[(\d+|\w+)\]|\w+\s+\w+)\s*;|\[[\w.]+\])/);
var _filenamePattern = new RegExp(/^"(.*)";?/);

/**
 *
 * @access public
 * @extends {MMDReader}
 */

var MMDXReader = function (_MMDReader) {
  _inherits(MMDXReader, _MMDReader);

  /**
   *
   * @access public
   * @constructor
   * @param {Buffer} data -
   * @param {string} directoryPath -
   */
  function MMDXReader(data, directoryPath) {
    _classCallCheck(this, MMDXReader);

    // TODO: implement binary x file reader
    var isBinary = false;
    var isBigEndian = false;
    var encoding = 'sjis';

    var _this = _possibleConstructorReturn(this, (MMDXReader.__proto__ || Object.getPrototypeOf(MMDXReader)).call(this, data, directoryPath, isBinary, isBigEndian, encoding));

    _this._workingNode = null;
    _this._workingGeometry = null;
    _this._workingGeometryNode = null;

    // header info
    _this._version = '';
    _this._format = '';
    _this._floatSize = '';

    // vertex
    _this._vertexCount = 0;
    _this._rawVertexArray = [];
    _this._vertexArray = [];

    // face
    _this._indexCount = 0;
    _this._rawVertexIndexArray = [];
    _this._indexArray = [];

    // material
    _this._rawMaterialIndexArray = [];
    _this._materialArray = [];

    // normal
    _this._rawNormalArray = [];
    _this._rawNormalIndexArray = [];
    _this._vertexNormalMap = [];
    _this._normalMap = [];
    _this._rawSortedNormalArray = [];
    _this._normalArray = [];

    // texcoord
    _this._rawTexcoordArray = [];
    _this._texcoordArray = [];

    _this._elementArray = [];
    return _this;
  }

  _createClass(MMDXReader, [{
    key: '_loadXFile',


    /**
     * @access private
     * @returns {MMDNode} -
     */
    value: function _loadXFile() {
      this._workingNode = new _MMDNode2.default();

      if (!this._XFileHeader()) {
        throw new Error('MMDXReader: header format error');
      }

      var end = false;
      while (!end) {
        var result = this._XObjectLong();

        if (result === null) {
          end = true;
        } else {
          end = !result;
        }
      }

      this._splitFaceNormals();

      this._workingNode.name = 'rootNode';

      this._workingGeometry = this._createGeometry();
      this._workingGeometryNode = new _jscenekit.SCNNode(this._workingGeometry);
      this._workingGeometryNode.name = 'Geometry';
      this._workingGeometryNode.castsShadow = true;

      this._workingNode.addChildNode(this._workingGeometryNode);
      this._workingNode.castsShadow = true;

      return this._workingNode;
    }
  }, {
    key: '_commaOrSemicolon',
    value: function _commaOrSemicolon() {
      // FIXME: don't access private property and method
      //return this._reader.readPattern(_commaOrSemicolonPattern)
      var code = this._reader._partialText.charCodeAt(0);
      if (code === 44 || code === 59) {
        this._reader._moveIndex(1);
      }
    }
  }, {
    key: '_UUID',
    value: function _UUID() {
      return this._reader.readPattern(_uuidPattern);
    }
  }, {
    key: '_leftBrace',
    value: function _leftBrace() {
      return this._reader.readPattern(_leftBracePattern);
    }
  }, {
    key: '_rightBrace',
    value: function _rightBrace() {
      return this._reader.readPattern(_rightBracePattern);
    }
  }, {
    key: '_member',
    value: function _member() {
      return this._reader.readPattern(_memberPattern);
    }
  }, {
    key: '_filename',
    value: function _filename() {
      var str = this._reader.readPattern(_filenamePattern);
      return str[1];
    }
  }, {
    key: '_integerArray',
    value: function _integerArray() {
      var n = this._reader.readInteger();
      var arr = [];
      for (var i = 0; i < n; i++) {
        arr.push(this._reader.readInteger());
        this._commaOrSemicolon();
      }
      return arr;
    }
  }, {
    key: '_floatArray',
    value: function _floatArray() {
      var n = this._reader.readInteger();
      var arr = [];
      for (var i = 0; i < n; i++) {
        arr.push(this._reader.readFloat());
        this._commaOrSemicolon();
      }
      return arr;
    }
  }, {
    key: '_vector3',
    value: function _vector3() {
      var invertZSign = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var v = new _jscenekit.SCNVector3();
      v.x = this._reader.readFloat();
      v.y = this._reader.readFloat();
      v.z = this._reader.readFloat();

      if (invertZSign) {
        v.z = -v.z;
      }

      this._commaOrSemicolon();

      return v;
    }
  }, {
    key: '_vector4',
    value: function _vector4() {
      var v = new _jscenekit.SCNVector4();
      v.x = this._reader.readFloat();
      v.y = this._reader.readFloat();
      v.z = this._reader.readFloat();
      v.w = this._reader.readFloat();
      this._commaOrSemicolon();

      return v;
    }
  }, {
    key: '_splitFaceNormals',
    value: function _splitFaceNormals() {
      var numFaces = this._rawVertexIndexArray.length;

      // set texcoord
      if (this._rawTexcoordArray.length === 0) {
        for (var i = 0; i < numFaces; i++) {
          this._rawTexcoordArray.push([0, 0]);
        }
      }

      // create normal
      if (this._rawNormalArray.length === 0) {
        for (var _i = 0; _i < numFaces; _i++) {
          var vertexIndex = this._rawVertexIndexArray[_i];
          var angles = vertexIndex.length;
          var normal = this._calcNormal(this._rawVertexArray[vertexIndex[0]], this._rawVertexArray[vertexIndex[1]], this._rawVertexArray[vertexIndex[angles - 1]]);
          this._rawNormalArray.splice(_i, 0, normal);

          var normalIndex = [];
          this._rawNormalIndexArray.splice(_i, 0, normalIndex);
        }
      }

      // flatten arrays
      var flatVertexIndexArray = [];
      var flatNormalIndexArray = [];
      var flatMaterialIndexArray = [];

      this._vertexCount = 0;
      this._indexCount = 0;

      for (var _i2 = 0; _i2 < numFaces; _i2++) {
        var _vertexIndex = this._rawVertexIndexArray[_i2];
        var _normalIndex = this._rawNormalIndexArray[_i2];
        var materialIndex = this._rawMaterialIndexArray[_i2];

        var _angles = _vertexIndex.length;

        for (var j = 2; j < _angles; j++) {
          flatVertexIndexArray.push(_vertexIndex[0]);
          flatVertexIndexArray.push(_vertexIndex[j]);
          flatVertexIndexArray.push(_vertexIndex[j - 1]);

          flatNormalIndexArray.push(_normalIndex[0]);
          flatNormalIndexArray.push(_normalIndex[j]);
          flatNormalIndexArray.push(_normalIndex[j - 1]);

          flatMaterialIndexArray.push(materialIndex);
          flatMaterialIndexArray.push(materialIndex);
          flatMaterialIndexArray.push(materialIndex);

          this._indexCount += 1;
        }
      }

      // make map of vertex to normal
      var vertexCount = this._rawVertexArray.length;

      var flatArrayCount = flatVertexIndexArray.length;
      for (var _i3 = 0; _i3 < flatArrayCount; _i3++) {
        var _vertexIndex2 = flatVertexIndexArray[_i3];
        var _normalIndex2 = flatNormalIndexArray[_i3];
        var _materialIndex = flatMaterialIndexArray[_i3];

        var vertexToNormal = this._vertexNormalMap[_vertexIndex2];
        var newVertexIndex = typeof vertexToNormal === 'undefined' ? null : vertexToNormal[_normalIndex2];

        if (typeof vertexToNormal === 'undefined') {
          // new
          this._vertexNormalMap[_vertexIndex2] = [];
          this._vertexNormalMap[_vertexIndex2][_normalIndex2] = _vertexIndex2;
          this._normalMap[_vertexIndex2] = _normalIndex2;
        } else if (typeof newVertexIndex === 'undefined' || newVertexIndex === null) {
          // conflict: add vertex data at index(vertexCount)
          this._rawVertexArray.push(this._rawVertexArray[_vertexIndex2]);
          this._rawTexcoordArray.push(this._rawTexcoordArray[_vertexIndex2]);
          this._vertexNormalMap[_vertexIndex2][_normalIndex2] = vertexCount;
          this._normalMap[vertexCount] = _normalIndex2;
          flatVertexIndexArray[_i3] = vertexCount;
          vertexCount += 1;
        } else {
          // reuse
          flatVertexIndexArray[_i3] = newVertexIndex;
        }
      }

      // create normal data
      for (var _i4 = 0; _i4 < vertexCount; _i4++) {
        var _normalIndex3 = this._normalMap[_i4];
        if (typeof _normalIndex3 === 'undefined') {
          _normalIndex3 = 0;
        }

        this._rawSortedNormalArray.push(this._rawNormalArray[_normalIndex3]);
      }

      // create vertex data
      this._vertexCount = this._rawVertexArray.length;
      this._vertexArray = [];
      for (var _i5 = 0; _i5 < this._vertexCount; _i5++) {
        this._vertexArray.push(this._rawVertexArray[_i5].x);
        this._vertexArray.push(this._rawVertexArray[_i5].y);
        this._vertexArray.push(this._rawVertexArray[_i5].z);
      }

      this._normalArray = [];
      for (var _i6 = 0; _i6 < this._vertexCount; _i6++) {
        this._normalArray.push(this._rawSortedNormalArray[_i6].x);
        this._normalArray.push(this._rawSortedNormalArray[_i6].y);
        this._normalArray.push(this._rawSortedNormalArray[_i6].z);
      }

      this._texcoordArray = [];
      var texCount = this._rawTexcoordArray.length;
      for (var _i7 = 0; _i7 < texCount; _i7++) {
        this._texcoordArray.push(this._rawTexcoordArray[_i7][0]);
        this._texcoordArray.push(this._rawTexcoordArray[_i7][1]);
      }

      // create index data
      this._indexArray = [];
      var materialCount = this._materialArray.length;
      for (var _i8 = 0; _i8 < materialCount; _i8++) {
        this._indexArray.push([]);
      }
      var materialIndexCount = flatMaterialIndexArray.length;
      for (var _i9 = 0; _i9 < materialIndexCount; _i9++) {
        var _materialIndex2 = flatMaterialIndexArray[_i9];
        var _vertexIndex3 = flatVertexIndexArray[_i9];

        this._indexArray[_materialIndex2].push(_vertexIndex3);
      }
    }
  }, {
    key: '_createGeometry',
    value: function _createGeometry() {
      var vertexSource = new _jscenekit.SCNGeometrySource(this._vertexArray, // data
      _jscenekit.SCNGeometrySource.Semantic.vertex, // semantic
      this._vertexCount, // vectorCount
      true, // usesFloatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // dataOffset
      12 // dataStride
      );

      var normalSource = new _jscenekit.SCNGeometrySource(this._normalArray, // data
      _jscenekit.SCNGeometrySource.Semantic.normal, // semantic
      this._vertexCount, // vectorCount
      true, // usesFloatComponents
      3, // componentsPerVector
      4, // bytesPerComponent
      0, // dataOffset
      12 // dataStride
      );

      var texcoordSource = new _jscenekit.SCNGeometrySource(this._texcoordArray, // data
      _jscenekit.SCNGeometrySource.Semantic.texcoord, // semantic
      this._vertexCount, // vectorCount
      true, // usesFloatComponents
      2, // componentsPerVector
      4, // bytesPerComponent
      0, // dataOffset
      8 // dataStride
      );

      this._elementArray = [];
      var newMaterialArray = [];
      var materialCount = this._materialArray.length;
      console.log('materialCount: ' + materialCount);
      for (var i = 0; i < materialCount; i++) {
        var indexArray = this._indexArray[i];
        var indexCount = indexArray.length / 3;
        console.log('indexCount: ' + indexCount);

        if (indexCount > 0) {
          var indices = [];
          var element = new _jscenekit.SCNGeometryElement(indexArray, // data
          _jscenekit.SCNGeometryPrimitiveType.triangles, // primitiveType
          indexCount, // primitiveCount
          4 // bytesPerIndex
          );
          this._elementArray.push(element);
          newMaterialArray.push(this._materialArray[i]);
        }
      }

      var geometry = new _jscenekit.SCNGeometry([vertexSource, normalSource, texcoordSource], this._elementArray);
      geometry.materials = newMaterialArray;
      geometry.name = 'Geometry';

      return geometry;
    }
  }, {
    key: '_calcNormal',
    value: function _calcNormal(v1, v2, v3) {
      var a = v3.sub(v1);
      var b = v2.sub(v1);
      var n = a.cross(b).normalize();
      return n;
    }

    /**
     * @access private
     * @returns {boolean} - returns true if it's a valid header.
     */

  }, {
    key: '_XFileHeader',
    value: function _XFileHeader() {
      var str = this._reader.readPattern(_headerPattern);
      this._version = str[1];
      this._format = str[2];
      this._floatSize = str[3];
      //console.log(`version ${this.version} format ${this.format} floatSize ${this.floatSize}`)
      return true;
    }

    /**
     * @access private
     * @returns {?Object} -
     */

  }, {
    key: '_XObjectLong',
    value: function _XObjectLong() {
      var id = this._reader.readWord();

      if (id === null) {
        return null;
      }
      console.log('********** id: ' + id + ' **********');

      switch (id) {
        case 'template':
          return this._Template();
        case 'Header':
          return this._Header();
        case 'Mesh':
          return this._Mesh();
        case 'MeshMaterialList':
          return this._MeshMaterialList();
        case 'MeshNormals':
          return this._MeshNormals();
        case 'MeshTextureCoords':
          return this._MeshTextureCoords();
        case 'MeshVertexColors':
          return this._MeshVertexColors();
        default:
          throw new Error('MMDXReader: unknown type: ' + id);
      }
    }
  }, {
    key: '_ColorRGB',
    value: function _ColorRGB() {
      var color = new _jscenekit.SKColor();
      color.red = this._reader.readFloat();
      color.green = this._reader.readFloat();
      color.blue = this._reader.readFloat();
      color.alpha = 1.0;
      this._commaOrSemicolon();

      return color;
    }
  }, {
    key: '_ColorRGBA',
    value: function _ColorRGBA() {
      var color = new _jscenekit.SKColor();
      color.red = this._reader.readFloat();
      color.green = this._reader.readFloat();
      color.blue = this._reader.readFloat();
      color.alpha = this._reader.readFloat();
      this._commaOrSemicolon();

      return color;
    }
  }, {
    key: '_IndexedColor',
    value: function _IndexedColor() {
      var index = this._reader.readInteger();
      var color = this._ColorRGBA();
      // TODO: retain index info
      // color.index = index
      return color;
    }
  }, {
    key: '_Coords2d',
    value: function _Coords2d() {
      var v = [];
      v.push(this._reader.readFloat());
      v.push(this._reader.readFloat());
      this._commaOrSemicolon();

      return v;
    }
  }, {
    key: '_Template',
    value: function _Template() {
      this._reader.readWord();
      this._leftBrace();
      this._UUID();
      var member = null;
      do {
        member = this._member();
        //console.log(`member: ${member}`)
      } while (member !== null);
      this._rightBrace();

      return true;
    }
  }, {
    key: '_Header',
    value: function _Header() {
      this._leftBrace();
      this._reader.readInteger(); // major
      this._reader.readInteger(); // minor
      this._reader.readInteger(); // flags
      this._rightBrace();
      return true;
    }
  }, {
    key: '_Material',
    value: function _Material() {
      var material = new _jscenekit.SCNMaterial();

      this._leftBrace();

      material.diffuse.contents = this._ColorRGBA();
      material.ambient.contents = material.diffuse.contents;
      material.shininess = this._reader.readFloat();
      material.specular.contents = this._ColorRGB();
      material.emission.contents = this._ColorRGB();

      var name = this._reader.readWord();
      if (name === 'TextureFilename') {
        var textureFilePath = this._TextureFilename();
        if (textureFilePath !== null) {
          /*
          const texture = this._loadTexture(textureFilePath)
          if(texture !== null){
            // FIXME: use mmd shader
            material.emission.contents = texture
            material.emission.wrapS = SCNWrapMode.repeat
            material.emission.wrapT = SCNWrapMode.repeat
            material.diffuse.contents = texture
            material.diffuse.wrapS = SCNWrapMode.repeat
            material.diffuse.wrapT = SCNWrapMode.repeat
             // DEBUG
            //material.diffuse.contents = new SKColor(0, 0.5, 0, 1.0)
          }
          */
          this.loadTexture(textureFilePath).then(function (texture) {
            material.emission.contents = texture;
            material.emission.wrapS = _jscenekit.SCNWrapMode.repeat;
            material.emission.wrapT = _jscenekit.SCNWrapMode.repeat;
            material.diffuse.contents = texture;
            material.diffuse.wrapS = _jscenekit.SCNWrapMode.repeat;
            material.diffuse.wrapT = _jscenekit.SCNWrapMode.repeat;
          });
        }
      }

      this._rightBrace();

      return material;
    }
  }, {
    key: '_Mesh',
    value: function _Mesh() {
      this._leftBrace();

      // vertices
      var rawVertexCount = this._reader.readInteger();
      console.log('vertexCount: ' + rawVertexCount);

      for (var i = 0; i < rawVertexCount; i++) {
        var pos = this._vector3(true);
        this._rawVertexArray.push(pos);
        this._commaOrSemicolon();
      }

      // faces
      this._indexCount = 0;
      var nFaces = this._reader.readInteger();
      console.log('num faces: ' + nFaces);

      for (var _i10 = 0; _i10 < nFaces; _i10++) {
        var face = this._integerArray();
        this._rawVertexIndexArray.push(face);
      }

      this._rightBrace();

      return true;
    }
  }, {
    key: '_MeshMaterialList',
    value: function _MeshMaterialList() {
      this._leftBrace();

      // materials
      var nMaterials = this._reader.readInteger();
      console.log('materials: ' + nMaterials);

      // face materials
      var nFaceIndices = this._reader.readInteger();
      console.log('face indices: ' + nFaceIndices);

      for (var i = 0; i < nFaceIndices; i++) {
        var materialNo = this._reader.readInteger();
        this._commaOrSemicolon();
        this._rawMaterialIndexArray.push(materialNo);
      }

      // materials
      var name = this._reader.readWord();
      while (name === 'Material') {
        var material = this._Material();
        this._materialArray.push(material);
        name = this._reader.readWord();
      }

      this._rightBrace();

      return true;
    }
  }, {
    key: '_MeshNormals',
    value: function _MeshNormals() {
      this._leftBrace();

      var nNormals = this._reader.readInteger();
      console.log('mesh normals: ' + nNormals);

      for (var i = 0; i < nNormals; i++) {
        var normal = this._vector3(true);
        this._rawNormalArray.push(normal);
      }

      var nFaceNormals = this._reader.readInteger();
      console.log('normal indices: ' + nFaceNormals);

      for (var _i11 = 0; _i11 < nFaceNormals; _i11++) {
        var faceNormals = this._integerArray();
        this._rawNormalIndexArray.push(faceNormals);
      }

      this._rightBrace();

      return true;
    }
  }, {
    key: '_MeshTextureCoords',
    value: function _MeshTextureCoords() {
      this._leftBrace();

      // suppose to be the same number as vertexCount
      var nTextureCoords = this._reader.readInteger();
      console.log('textureCoords: ' + nTextureCoords);

      for (var i = 0; i < nTextureCoords; i++) {
        var texcoord = this._Coords2d();
        this._rawTexcoordArray.push(texcoord);
      }

      this._rightBrace();

      return true;
    }
  }, {
    key: '_MeshVertexColors',
    value: function _MeshVertexColors() {
      this._leftBrace();

      var nVertexColors = this._reader.readInteger();
      for (var i = 0; i < nVertexColors; i++) {
        var v = this._IndexedColor();
        // TODO: implement
      }

      this._rightBrace();

      return true;
    }
  }, {
    key: '_TextureFilename',
    value: function _TextureFilename() {
      this._leftBrace();

      var name = this._filename();
      var filePath = name.replace('\\\\', '/');
      console.log('filePath: ' + filePath);

      this._rightBrace();

      return filePath;
    }

    /*
      _loadTexture(path) {
        const promise = new Promise((resolve, reject) => {
          console.error('TODO: implement _loadTexture')
          const fileName = this.directoryPath + path
          const image = new Image()
          image.onload = () => {
            resolve(image)
          }
          image.src = fileName
        })
        return promise
      }
    */

  }], [{
    key: 'getNode',
    value: function getNode(data, directoryPath) {
      var reader = new MMDXReader(data, directoryPath);
      return reader._loadXFile();
    }
  }]);

  return MMDXReader;
}(_MMDReader3.default);

exports.default = MMDXReader;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _MMDFragmentShader2 = __webpack_require__(6);

var _MMDFragmentShader3 = _interopRequireDefault(_MMDFragmentShader2);

var _ToonImages2 = __webpack_require__(7);

var _ToonImages3 = _interopRequireDefault(_ToonImages2);

var _MMDCameraNode = __webpack_require__(8);

var _MMDCameraNode2 = _interopRequireDefault(_MMDCameraNode);

var _MMDIKConstraint = __webpack_require__(4);

var _MMDIKConstraint2 = _interopRequireDefault(_MMDIKConstraint);

var _MMDIKController = __webpack_require__(19);

var _MMDIKController2 = _interopRequireDefault(_MMDIKController);

var _MMDNode = __webpack_require__(1);

var _MMDNode2 = _interopRequireDefault(_MMDNode);

var _MMDPMDReader = __webpack_require__(9);

var _MMDPMDReader2 = _interopRequireDefault(_MMDPMDReader);

var _MMDPMMReader = __webpack_require__(12);

var _MMDPMMReader2 = _interopRequireDefault(_MMDPMMReader);

var _MMDPMXReader = __webpack_require__(13);

var _MMDPMXReader2 = _interopRequireDefault(_MMDPMXReader);

var _MMDProgram = __webpack_require__(5);

var _MMDProgram2 = _interopRequireDefault(_MMDProgram);

var _MMDReader = __webpack_require__(2);

var _MMDReader2 = _interopRequireDefault(_MMDReader);

var _MMDScene = __webpack_require__(27);

var _MMDScene2 = _interopRequireDefault(_MMDScene);

var _MMDSceneSource = __webpack_require__(3);

var _MMDSceneSource2 = _interopRequireDefault(_MMDSceneSource);

var _MMDVACReader = __webpack_require__(14);

var _MMDVACReader2 = _interopRequireDefault(_MMDVACReader);

var _MMDVMDReader = __webpack_require__(15);

var _MMDVMDReader2 = _interopRequireDefault(_MMDVMDReader);

var _MMDVPDReader = __webpack_require__(16);

var _MMDVPDReader2 = _interopRequireDefault(_MMDVPDReader);

var _MMDXReader = __webpack_require__(17);

var _MMDXReader2 = _interopRequireDefault(_MMDXReader);

var _BinaryParser = __webpack_require__(28);

var _BinaryParser2 = _interopRequireDefault(_BinaryParser);

var _ecl = __webpack_require__(11);

var _ecl2 = _interopRequireDefault(_ecl);

var _TextReader2 = __webpack_require__(10);

var _TextReader3 = _interopRequireDefault(_TextReader2);

var _TextRequest2 = __webpack_require__(29);

var _TextRequest3 = _interopRequireDefault(_TextRequest2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*global exports*/
exports._MMDFragmentShader = _MMDFragmentShader3.default;
exports._ToonImages = _ToonImages3.default;
exports.MMDCameraNode = _MMDCameraNode2.default;
exports.MMDIKConstraint = _MMDIKConstraint2.default;
exports.MMDIKController = _MMDIKController2.default;
exports.MMDNode = _MMDNode2.default;
exports.MMDPMDReader = _MMDPMDReader2.default;
exports.MMDPMMReader = _MMDPMMReader2.default;
exports.MMDPMXReader = _MMDPMXReader2.default;
exports.MMDProgram = _MMDProgram2.default;
exports.MMDReader = _MMDReader2.default;
exports.MMDScene = _MMDScene2.default;
exports.MMDSceneSource = _MMDSceneSource2.default;
exports.MMDVACReader = _MMDVACReader2.default;
exports.MMDVMDReader = _MMDVMDReader2.default;
exports.MMDVPDReader = _MMDVPDReader2.default;
exports.MMDXReader = _MMDXReader2.default;
exports.BinaryParser = _BinaryParser2.default;
exports.ecl = _ecl2.default;
exports._TextReader = _TextReader3.default;
exports._TextRequest = _TextRequest3.default;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MMDNode = __webpack_require__(1);

var _MMDNode2 = _interopRequireDefault(_MMDNode);

__webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _sharedController = null;

/**
 *
 * @access public
 * @implements {SCNSceneRendererDelegate}
 */

var MMDIKController = function () {
  _createClass(MMDIKController, null, [{
    key: 'sharedController',
    get: function get() {
      if (_sharedController === null) {
        _sharedController = new MMDIKController();
      }
      return _sharedController;
    }

    /**
     *
     * @access private
     * @constructor
     */

  }]);

  function MMDIKController() {
    _classCallCheck(this, MMDIKController);
  }

  /**
   * update IK constraint for the given renderer
   * @access public
   * @param {SCNSceneRenderer} renderer -
   * @returns {void}
   */


  _createClass(MMDIKController, [{
    key: 'rendererDidApplyAnimationsAtTime',


    /**
     * apply IK constraint after animations are applied
     * @access public
     * @param {SCNSceneRenderer} renderer -
     * @param {TimeInterval} time -
     */
    value: function rendererDidApplyAnimationsAtTime(renderer, time) {
      MMDIKController.updateIK(renderer);
    }
  }], [{
    key: 'updateIK',
    value: function updateIK(renderer) {
      if (renderer.scene) {
        MMDIKController.applyIKRecursive(renderer.scene.rootNode);
      }
    }

    /**
     * apply IK constraint recursively
     * @access public
     * @param {SCNNode} node -
     * @returns {void}
     */

  }, {
    key: 'applyIKRecursive',
    value: function applyIKRecursive(node) {
      if (node instanceof _MMDNode2.default) {
        node.updateIK();
      }

      node.childNodes.forEach(function (childNode) {
        MMDIKController.applyIKRecursive(childNode);
      });
    }
  }]);

  return MMDIKController;
}();

exports.default = MMDIKController;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	/*global Buffer*/

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _ImageType = {
	  noImage: 0,
	  colorMapped: 1,
	  RGB: 2,
	  blackAndWhite: 3,
	  runlengthColorMapped: 9,
	  runlengthRGB: 10,
	  compressedBlackAndWhite: 11,
	  compressedColorMapped: 32,
	  compressed4PassQTColorMapped: 33
	};

	var _headerLength = 18;

	var TGAImage = function () {
	  /**
	   * constructor
	   * @param {Buffer|ArrayBuffer} data -
	   * @constructor
	   */
	  function TGAImage(data) {
	    var _this = this;

	    _classCallCheck(this, TGAImage);

	    if (data instanceof Buffer) {
	      this._buffer = data;
	    } else if (typeof data === 'string') {
	      this._buffer = Buffer.from(data, 'binary');
	    } else if (data) {
	      this._buffer = Buffer.from(data);
	    } else {
	      this._buffer = null;
	    }

	    // Header
	    this._idLength = 0;
	    this._colorMapType = 0;
	    this._imageType = 0;
	    this._colorMapOrigin = 0;
	    this._colorMapLength = 0;
	    this._colorMapDepth = 0;
	    this._imageXOrigin = 0;
	    this._imageYOrigin = 0;
	    this._imageWidth = 0;
	    this._imageHeight = 0;
	    this._imageDepth = 0;
	    this._alphaDepth = 0;
	    this._leftToRight = true;
	    this._topToBottom = false;
	    this._interleave = false;
	    this._hasAlpha = false;

	    // Image Identification Field
	    this._imageID = null;

	    // Image Data
	    this._canvas = null;
	    this._context = null;
	    this._imageData = null;
	    this._image = null;

	    // for HTML Image tag compatibility
	    this._src = null;
	    this.onload = null;
	    this.onerror = null;

	    this._resolveFunc = null;
	    this._rejectFunc = null;
	    this._didLoad = new Promise(function (resolve, reject) {
	      _this._resolveFunc = resolve;
	      _this._rejectFunc = reject;
	    });

	    if (data) {
	      this._parseData();
	    }
	  }

	  _createClass(TGAImage, [{
	    key: '_loadURL',
	    value: function _loadURL(url) {
	      var _this2 = this;

	      this._src = url;
	      this._requestBinaryFile(url).then(function (data) {
	        _this2._buffer = Buffer.from(data);
	        _this2._parseData();
	      }).catch(function (error) {
	        _this2._reject(error);
	      });
	    }
	  }, {
	    key: '_requestBinaryFile',
	    value: function _requestBinaryFile(url) {
	      return new Promise(function (resolve, reject) {
	        var request = new XMLHttpRequest();
	        request.open('GET', url);
	        request.responseType = 'arraybuffer';
	        request.onload = function (ev) {
	          if (request.response) {
	            resolve(request.response);
	          } else {
	            reject(request);
	          }
	        };
	        request.onerror = function (ev) {
	          reject(ev);
	        };
	        request.send(null);
	      });
	    }
	  }, {
	    key: '_parseData',
	    value: function _parseData() {
	      this._readHeader();
	      this._readImageID();
	      this._initImage();

	      var data = this._getImageData();

	      switch (this._imageType) {
	        case _ImageType.noImage:
	          {
	            // nothing to do
	            break;
	          }
	        case _ImageType.colorMapped:
	          {
	            this._parseColorMapData(data);
	            break;
	          }
	        case _ImageType.RGB:
	          {
	            this._parseRGBData(data);
	            break;
	          }
	        case _ImageType.blackAndWhite:
	          {
	            this._parseBlackAndWhiteData(data);
	            break;
	          }
	        case _ImageType.runlengthColorMapped:
	          {
	            this._parseColorMapData(data);
	            break;
	          }
	        case _ImageType.runlengthRGB:
	          {
	            this._parseRGBData(data);
	            break;
	          }
	        case _ImageType.compressedBlackAndWhite:
	          {
	            this._parseBlackAndWhiteData(data);
	            break;
	          }
	        case _ImageType.compressedColorMapped:
	          {
	            console.error('parser for compressed TGA is not implemeneted');
	            break;
	          }
	        case _ImageType.compressed4PassQTColorMapped:
	          {
	            console.error('parser for compressed TGA is not implemeneted');
	            break;
	          }
	        default:
	          {
	            throw new Error('unknown imageType: ' + this._imageType);
	          }
	      }

	      this._setImage();
	      this._deleteBuffer();

	      this._resolve();
	    }
	  }, {
	    key: '_readHeader',
	    value: function _readHeader() {
	      this._idLength = this._buffer.readUIntLE(0, 1);
	      this._colorMapType = this._buffer.readUIntLE(1, 1);
	      this._imageType = this._buffer.readUIntLE(2, 1);
	      this._colorMapOrigin = this._buffer.readUIntLE(3, 2);
	      this._colorMapLength = this._buffer.readUIntLE(5, 2);
	      this._colorMapDepth = this._buffer.readUIntLE(7, 1);
	      this._imageXOrigin = this._buffer.readUIntLE(8, 2);
	      this._imageYOrigin = this._buffer.readUIntLE(10, 2);
	      this._imageWidth = this._buffer.readUIntLE(12, 2);
	      this._imageHeight = this._buffer.readUIntLE(14, 2);
	      this._imageDepth = this._buffer.readUIntLE(16, 1);

	      var descriptor = this._buffer.readUIntLE(17, 1);
	      this._alphaDepth = descriptor & 0x0F;
	      this._leftToRight = (descriptor & 0x10) === 0;
	      this._topToBottom = (descriptor & 0x20) > 0;
	      this._interleave = descriptor & 0xC0;
	    }
	  }, {
	    key: '_readImageID',
	    value: function _readImageID() {
	      if (this._idLength > 0) {
	        this._imageID = this._buffer.subarray(_headerLength, this._idLength);
	      }
	    }
	  }, {
	    key: '_initImage',
	    value: function _initImage() {
	      if (this._imageType === _ImageType.noImage) {
	        return;
	      }
	      if (this._imageWidth <= 0 || this._imageHeight <= 0) {
	        return;
	      }
	      this._canvas = document.createElement('canvas');
	      this._canvas.width = this._imageWidth;
	      this._canvas.height = this._imageHeight;
	      this._context = this._canvas.getContext('2d');
	      this._imageData = this._context.createImageData(this._imageWidth, this._imageHeight);
	    }
	  }, {
	    key: '_setImage',
	    value: function _setImage() {
	      this._context.putImageData(this._imageData, 0, 0);
	      this._image = new Image();
	      this._image.width = this._imageWidth;
	      this._image.height = this._imageHeight;
	      this._image.src = this._canvas.toDataURL();
	    }
	  }, {
	    key: '_deleteBuffer',
	    value: function _deleteBuffer() {
	      if (this._buffer) {
	        delete this._buffer;
	        this._buffer = null;
	      }
	      if (this._imageData) {
	        delete this._imageData;
	        this._imageData = null;
	      }
	    }
	  }, {
	    key: '_parseColorMapData',
	    value: function _parseColorMapData(buf) {
	      if (this._colorMapDepth === 24 || this._colorMapDepth === 16 || this._colorMapDepth === 15) {
	        this._hasAlpha = false;
	      } else if (this._colorMapDepth === 32) {
	        this._hasAlpha = true;
	      } else {
	        throw new Error('unknown colorMapDepth: ' + this._colorMapDepth);
	      }

	      var colorMapDataPos = _headerLength + this._idLength;
	      var colorMapDataSize = Math.ceil(this._colorMapDepth / 8);
	      var colorMapDataLen = colorMapDataSize * this._colorMapLength;

	      var imageDataSize = 1;

	      var colorMap = [];
	      var pos = colorMapDataPos;
	      for (var i = 0; i < this._colorMapLength; i++) {
	        var rgba = this._getRGBA(this._buffer, pos, this._colorMapDepth);
	        colorMap.push(rgba);
	        pos += colorMapDataSize;
	      }

	      var data = this._imageData.data;
	      var initX = 0;
	      var initY = 0;
	      var xStep = 1;
	      var yStep = 1;
	      if (!this._leftToRight) {
	        initX = this._imageWidth - 1;
	        xStep = -1;
	      }
	      if (!this._topToBottom) {
	        initY = this._imageHeight - 1;
	        yStep = -1;
	      }

	      pos = 0;
	      var y = initY;
	      var defaultColor = [0xFF, 0xFF, 0xFF, 0xFF];
	      for (var iy = 0; iy < this._imageHeight; iy++) {
	        var x = initX;
	        for (var ix = 0; ix < this._imageWidth; ix++) {
	          var index = (y * this._imageWidth + x) * 4;
	          var color = defaultColor;
	          var mapNo = buf[pos] - this._colorMapOrigin;
	          if (mapNo >= 0) {
	            color = colorMap[mapNo];
	          }
	          data[index] = color[0];
	          data[index + 1] = color[1];
	          data[index + 2] = color[2];
	          data[index + 3] = color[3];

	          x += xStep;
	          pos += imageDataSize;
	        }
	        y += yStep;
	      }
	    }
	  }, {
	    key: '_parseRGBData',
	    value: function _parseRGBData(buf) {
	      if (this._imageDepth === 24 || this._imageDepth === 16 || this._imageDepth === 15) {
	        this._hasAlpha = false;
	      } else if (this._imageDepth === 32) {
	        this._hasAlpha = true;
	      } else {
	        throw new Error('unknown imageDepth: ' + this._imageDepth);
	      }

	      var imageDataSize = Math.ceil(this._imageDepth / 8);

	      var data = this._imageData.data;
	      var initX = 0;
	      var initY = 0;
	      var xStep = 1;
	      var yStep = 1;
	      if (!this._leftToRight) {
	        initX = this._imageWidth - 1;
	        xStep = -1;
	      }
	      if (!this._topToBottom) {
	        initY = this._imageHeight - 1;
	        yStep = -1;
	      }

	      var pos = 0;
	      var y = initY;
	      for (var iy = 0; iy < this._imageHeight; iy++) {
	        var x = initX;
	        for (var ix = 0; ix < this._imageWidth; ix++) {
	          var index = (y * this._imageWidth + x) * 4;
	          var rgba = this._getRGBA(buf, pos, this._imageDepth);
	          data[index] = rgba[0];
	          data[index + 1] = rgba[1];
	          data[index + 2] = rgba[2];
	          data[index + 3] = rgba[3];

	          x += xStep;
	          pos += imageDataSize;
	        }
	        y += yStep;
	      }
	    }
	  }, {
	    key: '_getRGBA',
	    value: function _getRGBA(buf, offset, depth) {
	      if (depth === 15) {
	        var r = (buf[offset + 1] & 0x7c) << 1;
	        var g = (buf[offset + 1] & 0x03) << 6 | (buf[offset] & 0xe0) >> 2;
	        var b = (buf[offset] & 0x1f) << 3;
	        //const a = (buf[offset+1] & 0x80) > 0 ? 255 : 0
	        var a = 255;
	        return [r, g, b, a];
	      } else if (depth === 16) {
	        var _r = (buf[offset + 1] & 0x7c) << 1;
	        var _g = (buf[offset + 1] & 0x03) << 6 | (buf[offset] & 0xe0) >> 2;
	        var _b = (buf[offset] & 0x1f) << 3;
	        var _a = 255;
	        return [_r, _g, _b, _a];
	      } else if (depth === 24) {
	        return [buf[offset + 2], buf[offset + 1], buf[offset], 255];
	      } else if (depth === 32) {
	        return [buf[offset + 2], buf[offset + 1], buf[offset], buf[offset + 3]];
	      }
	      throw new Error('unsupported imageDepth: ' + depth);
	    }
	  }, {
	    key: '_parseBlackAndWhiteData',
	    value: function _parseBlackAndWhiteData(buf) {
	      if (this._imageDepth == 8) {
	        this._hasAlpha = false;
	      } else if (this._imageDepth == 16) {
	        this._hasAlpha = true;
	      } else {
	        throw new Error('unknown imageDepth: ' + this._imageDepth);
	      }

	      var imageDataSize = this._imageDepth / 8;

	      var data = this._imageData.data;
	      var initX = 0;
	      var initY = 0;
	      var xStep = 1;
	      var yStep = 1;
	      if (!this._leftToRight) {
	        initX = this._imageWidth - 1;
	        xStep = -1;
	      }
	      if (!this._topToBottom) {
	        initY = this._imageHeight - 1;
	        yStep = -1;
	      }

	      var pos = 0;
	      if (this._hasAlpha) {
	        var y = initY;
	        for (var iy = 0; iy < this._imageHeight; iy++) {
	          var x = initX;
	          for (var ix = 0; ix < this._imageWidth; ix++) {
	            var index = (y * this._imageWidth + x) * 4;
	            var c = buf[pos];
	            var a = buf[pos + 1];
	            data[index] = c;
	            data[index + 1] = c;
	            data[index + 2] = c;
	            data[index + 3] = a;

	            x += xStep;
	            pos += imageDataSize;
	          }
	          y += yStep;
	        }
	      } else {
	        var _y = initY;
	        for (var _iy = 0; _iy < this._imageHeight; _iy++) {
	          var _x = initX;
	          for (var _ix = 0; _ix < this._imageWidth; _ix++) {
	            var _index = (_y * this._imageWidth + _x) * 4;
	            var _c = buf[pos];
	            var _a2 = 255;
	            data[_index] = _c;
	            data[_index + 1] = _c;
	            data[_index + 2] = _c;
	            data[_index + 3] = _a2;

	            _x += xStep;
	            pos += imageDataSize;
	          }
	          _y += yStep;
	        }
	      }
	    }
	  }, {
	    key: '_getImageData',
	    value: function _getImageData() {
	      var data = null;
	      if (this._imageType !== _ImageType.none) {
	        var colorMapDataLen = Math.ceil(this._colorMapDepth / 8) * this._colorMapLength;
	        var start = _headerLength + this._idLength + colorMapDataLen;
	        data = this._buffer.subarray(start);
	      }

	      if (this._imageType === _ImageType.runlengthColorMapped || this._imageType === _ImageType.runlengthRGB) {
	        data = this._decompressRunlengthData(data);
	      } else if (this._imageType === _ImageType.compressedBlackAndWhite) {
	        data = this._decompressRunlengthData(data);
	      } else if (this._imageType === _ImageType.compressedColorMapped) {
	        // TODO: implement
	        console.error('Compressed Color Mapped TGA Image data is not supported');
	      } else if (this._imageType === _ImageType.compressed4PassQTColorMapped) {
	        // TODO: implement
	        console.error('Compressed Color Mapped TGA Image data is not supported');
	      }
	      return data;
	    }
	  }, {
	    key: '_decompressRunlengthData',
	    value: function _decompressRunlengthData(data) {
	      var d = [];
	      var elementCount = Math.ceil(this._imageDepth / 8);
	      var dataLength = elementCount * this._imageWidth * this._imageHeight;
	      var pos = 0;

	      while (d.length < dataLength) {
	        var packet = data[pos];
	        pos += 1;
	        if ((packet & 0x80) !== 0) {
	          // RLE
	          var elements = data.slice(pos, pos + elementCount);
	          pos += elementCount;

	          var count = (packet & 0x7F) + 1;
	          for (var i = 0; i < count; i++) {
	            d.push.apply(d, _toConsumableArray(elements));
	          }
	        } else {
	          // RAW
	          var len = (packet + 1) * elementCount;
	          d.push.apply(d, _toConsumableArray(data.slice(pos, pos + len)));
	          pos += len;
	        }
	      }
	      return d;
	    }
	  }, {
	    key: '_resolve',
	    value: function _resolve(e) {
	      if (this.onload) {
	        this.onload(e);
	      }
	      this._resolveFunc(e);
	    }
	  }, {
	    key: '_reject',
	    value: function _reject(e) {
	      if (this.onerror) {
	        this.onerror(e);
	      }
	      this._rejectFunc(e);
	    }
	  }, {
	    key: 'image',
	    get: function get() {
	      return this._image;
	    }
	  }, {
	    key: 'canvas',
	    get: function get() {
	      return this._canvas;
	    }
	  }, {
	    key: 'didLoad',
	    get: function get() {
	      return this._didLoad;
	    }
	  }, {
	    key: 'src',
	    get: function get() {
	      return this._src;
	    },
	    set: function set(newValue) {
	      this._loadURL(newValue);
	    }
	  }], [{
	    key: 'imageWithData',
	    value: function imageWithData(data) {
	      return new TGAImage(data);
	    }
	  }, {
	    key: 'imageWithURL',
	    value: function imageWithURL(url) {
	      var image = new TGAImage();
	      image._loadURL(url);
	      return image;
	    }
	  }]);

	  return TGAImage;
	}();

	module.exports = TGAImage;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(2)
	var ieee754 = __webpack_require__(3)
	var isArray = __webpack_require__(4)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()

	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192 // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}

	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)

	  var actual = that.write(string, encoding)

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len)
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}

	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8'

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true

	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0

	  if (this === target) return 0

	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)

	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }

	  return len
	}

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0

	  if (!val) val = 0

	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }

	  return this
	}

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	'use strict'

	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray

	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}

	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63

	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}

	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return (b64.length * 3 / 4) - placeHoldersCount(b64)
	}

	function toByteArray (b64) {
	  var i, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)

	  arr = new Arr((len * 3 / 4) - placeHolders)

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len

	  var L = 0

	  for (i = 0; i < l; i += 4) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }

	  parts.push(output)

	  return parts.join('')
	}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ })
/******/ ]);

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(23)
var ieee754 = __webpack_require__(24)
var isArray = __webpack_require__(25)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))

/***/ }),
/* 22 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 24 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 25 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*global exports*/
exports.MMD_CAMERA_NODE_NAME = 'MMD_CAMERA_NODE';
exports.MMD_CAMERA_ROTX_NODE_NAME = 'MMD_CAMERA_ROTX_NODE';
exports.MMD_CAMERA_ROTY_NODE_NAME = 'MMD_CAMERA_ROTY_NODE';
exports.MMD_CAMERA_ROTZ_NODE_NAME = 'MMD_CAMERA_ROTZ_NODE';

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jscenekit = __webpack_require__(0);

var _MMDSceneSource = __webpack_require__(3);

var _MMDSceneSource2 = _interopRequireDefault(_MMDSceneSource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _mmdFileExtensions = ['pmm', 'pmd', 'vmd', 'vpd', 'x', 'vac', 'pmx'];

/**
 *
 * @access public
 * @extends {MMDScene}
 */

var MMDScene = function (_SCNScene) {
  _inherits(MMDScene, _SCNScene);

  /**
   * Loads a MMD scene from the specified URL.
   * @access public
   * @constructor
   * @param {string} url - The URL to the scene file to load.
   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
   * @param {function} onload -
   * @param {function} onerror -
   * @throws {Error}
   */
  function MMDScene(url) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var onload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var onerror = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, MMDScene);

    return _possibleConstructorReturn(this, (MMDScene.__proto__ || Object.getPrototypeOf(MMDScene)).call(this, url, options, onload, onerror));
  }

  /**
   * Overrided function of SCNSceneSource
   * @access private
   * @param {Blob} data -
   * @param {Object} options -
   * @returns {MMDScene} -
   */


  _createClass(MMDScene, [{
    key: '_loadSceneWithData',
    value: function _loadSceneWithData(data, options) {
      var source = new _MMDSceneSource2.default(data, options);
      return source.scene();
    }

    /**
     * Loads a MMD scene from the specified URL.
     * @access public
     * @param {string} url -
     * @param {Object} options -
     * @returns {MMDScene} -
     */

  }], [{
    key: 'scene',
    value: function scene(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      return new MMDScene(url, options);
    }
  }]);

  return MMDScene;
}(_jscenekit.SCNScene);

exports.default = MMDScene;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
//+ Jonas Raoni Soares Silva
//@ http://jsfromhell.com/classes/binary-parser [rev. #1]

var BinaryParser = function BinaryParser(bigEndian, allowExceptions) {
	this.bigEndian = bigEndian, this.allowExceptions = allowExceptions;
};
exports.default = BinaryParser;


var p = BinaryParser.prototype;

p.encodeFloat = function (number, precisionBits, exponentBits) {
	var bias = Math.pow(2, exponentBits - 1) - 1,
	    minExp = -bias + 1,
	    maxExp = bias,
	    minUnnormExp = minExp - precisionBits,
	    status = isNaN(n = parseFloat(number)) || n == -Infinity || n == +Infinity ? n : 0,
	    exp = 0,
	    len = 2 * bias + 1 + precisionBits + 3,
	    bin = new Array(len),
	    signal = (n = status !== 0 ? 0 : n) < 0,
	    n = Math.abs(n),
	    intPart = Math.floor(n),
	    floatPart = n - intPart,
	    i,
	    lastBit,
	    rounded,
	    j,
	    result;
	for (i = len; i; bin[--i] = 0) {}
	for (i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2)) {}
	for (i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2) >= 1) - 0) && --floatPart) {}
	for (i = -1; ++i < len && !bin[i];) {}
	if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1]) {
		if (!(rounded = bin[lastBit])) for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]) {}
		for (j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0) && (rounded = 0)) {}
	}
	for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];) {}

	(exp = bias + 1 - i) >= minExp && exp <= maxExp ? ++i : exp < minExp && (exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow"), i = bias + 1 - (exp = minExp - 1));
	(intPart || status !== 0) && (this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status), exp = maxExp + 1, i = bias + 2, status == -Infinity ? signal = 1 : isNaN(status) && (bin[i] = 1));
	for (n = Math.abs(exp + bias), j = exponentBits + 1, result = ""; --j; result = n % 2 + result, n = n >>= 1) {}
	for (n = 0, j = 0, i = (result = (signal ? "1" : "0") + result + bin.slice(i, i + precisionBits).join("")).length, r = []; i; n += (1 << j) * result.charAt(--i), j == 7 && (r[r.length] = String.fromCharCode(n), n = 0), j = (j + 1) % 8) {}
	r[r.length] = n ? String.fromCharCode(n) : "";
	return (this.bigEndian ? r.reverse() : r).join("");
};
p.encodeInt = function (number, bits, signed) {
	var max = Math.pow(2, bits),
	    r = [];
	(number >= max || number < -(max >> 1)) && this.warn("encodeInt::overflow") && (number = 0);
	number < 0 && (number += max);
	for (; number; r[r.length] = String.fromCharCode(number % 256), number = Math.floor(number / 256)) {}
	for (bits = -(-bits >> 3) - r.length; bits--; r[r.length] = "\0") {}
	return (this.bigEndian ? r.reverse() : r).join("");
};
p.decodeFloat = function (data, precisionBits, exponentBits) {
	var b = ((b = new this.Buffer(this.bigEndian, data)).checkBuffer(precisionBits + exponentBits + 1), b),
	    bias = Math.pow(2, exponentBits - 1) - 1,
	    signal = b.readBits(precisionBits + exponentBits, 1),
	    exponent = b.readBits(precisionBits, exponentBits),
	    significand = 0,
	    divisor = 2,
	    curByte = b.buffer.length + (-precisionBits >> 3) - 1,
	    byteValue,
	    startBit,
	    mask;
	do {
		for (byteValue = b.buffer[++curByte], startBit = precisionBits % 8 || 8, mask = 1 << startBit; mask >>= 1; byteValue & mask && (significand += 1 / divisor), divisor *= 2) {}
	} while (precisionBits -= startBit);
	return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0);
};
p.decodeInt = function (data, bits, signed) {
	var b = new this.Buffer(this.bigEndian, data),
	    x = b.readBits(0, bits),
	    max = Math.pow(2, bits);
	return signed && x >= max / 2 ? x - max : x;
};

var p2 = (p.Buffer = function (bigEndian, buffer) {
	this.bigEndian = bigEndian || 0, this.buffer = [], this.setBuffer(buffer);
}).prototype;

p2.readBits = function (start, length) {
	//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)
	function shl(a, b) {
		for (++b; --b; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1) {}
		return a;
	}
	if (start < 0 || length <= 0) return 0;
	this.checkBuffer(start + length);
	for (var offsetLeft, offsetRight = start % 8, curByte = this.buffer.length - (start >> 3) - 1, lastByte = this.buffer.length + (-(start + length) >> 3), diff = curByte - lastByte, sum = (this.buffer[curByte] >> offsetRight & (1 << (diff ? 8 - offsetRight : length)) - 1) + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & (1 << offsetLeft) - 1) << (diff-- << 3) - offsetRight : 0); diff; sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight)) {}
	return sum;
};
p2.setBuffer = function (data) {
	if (data) {
		for (var l, i = l = data.length, b = this.buffer = new Array(l); i; b[l - i] = data.charCodeAt(--i)) {}
		this.bigEndian && b.reverse();
	}
};
p2.hasNeededBits = function (neededBits) {
	return this.buffer.length >= -(-neededBits >> 3);
};
p2.checkBuffer = function (neededBits) {
	if (!this.hasNeededBits(neededBits)) throw new Error("checkBuffer::missing bytes");
};

p.warn = function (msg) {
	if (this.allowExceptions) throw new Error(msg);
	return 1;
};
p.toSmall = function (data) {
	return this.decodeInt(data, 8, true);
};
p.fromSmall = function (number) {
	return this.encodeInt(number, 8, true);
};
p.toByte = function (data) {
	return this.decodeInt(data, 8, false);
};
p.fromByte = function (number) {
	return this.encodeInt(number, 8, false);
};
p.toShort = function (data) {
	return this.decodeInt(data, 16, true);
};
p.fromShort = function (number) {
	return this.encodeInt(number, 16, true);
};
p.toWord = function (data) {
	return this.decodeInt(data, 16, false);
};
p.fromWord = function (number) {
	return this.encodeInt(number, 16, false);
};
p.toInt = function (data) {
	return this.decodeInt(data, 32, true);
};
p.fromInt = function (number) {
	return this.encodeInt(number, 32, true);
};
p.toDWord = function (data) {
	return this.decodeInt(data, 32, false);
};
p.fromDWord = function (number) {
	return this.encodeInt(number, 32, false);
};
p.toFloat = function (data) {
	return this.decodeFloat(data, 23, 8);
};
p.fromFloat = function (number) {
	return this.encodeFloat(number, 23, 8);
};
p.toDouble = function (data) {
	return this.decodeFloat(data, 52, 11);
};
p.fromDouble = function (number) {
	return this.encodeFloat(number, 52, 11);
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextRequest = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jscenekit = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * TextRequest class
 * @access public
 */
var TextRequest = exports.TextRequest = function (_AjaxRequest$construc) {
  _inherits(TextRequest, _AjaxRequest$construc);

  /**
   * constructor
   * @access public
   * @constructor
   */
  function TextRequest() {
    _classCallCheck(this, TextRequest);

    var _this = _possibleConstructorReturn(this, (TextRequest.__proto__ || Object.getPrototypeOf(TextRequest)).call(this));

    _this.defaultOptions.mimeType = 'text/plain; charset=utf-8';
    return _this;
  }

  _createClass(TextRequest, [{
    key: 'getWithCharset',
    value: function getWithCharset(url, charset) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      options.mimeType = 'text/plain; charset=' + charset;
      return this.get(url, options);
    }
  }, {
    key: 'postWithCharset',
    value: function postWithCharset(url, charset) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      options.mimeType = 'text/plain; charset=' + charset;
      return this.post(url, options);
    }
  }]);

  return TextRequest;
}(_jscenekit._AjaxRequest.constructor);

exports.default = new TextRequest();

/***/ })
/******/ ]);